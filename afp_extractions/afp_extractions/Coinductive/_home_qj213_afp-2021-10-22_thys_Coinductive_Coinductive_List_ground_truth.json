{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Coinductive_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma funpow_Suc_conv [simp]: \"(Suc ^^ n) m = m + n\"", "lemma wlog_linorder_le [consumes 0, case_names le symmetry]:\n  assumes le: \"\\<And>a b :: 'a :: linorder. a \\<le> b \\<Longrightarrow> P a b\"\n  and sym: \"P b a \\<Longrightarrow> P a b\"\n  shows \"P a b\"", "lemma corec_llist_never_stop: \"corec_llist IS_LNIL LHD (\\<lambda>_. False) MORE LTL x = unfold_llist IS_LNIL LHD LTL x\"", "lemma eq_LConsD: \"xs = LCons y ys \\<Longrightarrow> xs \\<noteq> LNil \\<and> lhd xs = y \\<and> ltl xs = ys\"", "lemma\n  shows LNil_eq_lmap: \"LNil = lmap f xs \\<longleftrightarrow> xs = LNil\"\n  and lmap_eq_LNil: \"lmap f xs = LNil \\<longleftrightarrow> xs = LNil\"", "lemma ltl_lmap[simp]: \"ltl (lmap f xs) = lmap f (ltl xs)\"", "lemma lmap_eq_LCons_conv:\n  \"lmap f xs = LCons y ys \\<longleftrightarrow>\n  (\\<exists>x xs'. xs = LCons x xs' \\<and> y = f x \\<and> ys = lmap f xs')\"", "lemma lmap_conv_unfold_llist:\n  \"lmap f = unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl\" (is \"?lhs = ?rhs\")", "lemma lmap_unfold_llist:\n  \"lmap f (unfold_llist IS_LNIL LHD LTL b) = unfold_llist IS_LNIL (f \\<circ> LHD) LTL b\"", "lemma lmap_corec_llist:\n  \"lmap f (corec_llist IS_LNIL LHD endORmore TTL_end TTL_more b) =\n   corec_llist IS_LNIL (f \\<circ> LHD) endORmore (lmap f \\<circ> TTL_end) TTL_more b\"", "lemma unfold_llist_ltl_unroll:\n  \"unfold_llist IS_LNIL LHD LTL (LTL b) = unfold_llist (IS_LNIL \\<circ> LTL) (LHD \\<circ> LTL) LTL b\"", "lemma ltl_unfold_llist:\n  \"ltl (unfold_llist IS_LNIL LHD LTL a) =\n  (if IS_LNIL a then LNil else unfold_llist IS_LNIL LHD LTL (LTL a))\"", "lemma unfold_llist_eq_LCons [simp]:\n  \"unfold_llist IS_LNIL LHD LTL b = LCons x xs \\<longleftrightarrow>\n  \\<not> IS_LNIL b \\<and> x = LHD b \\<and> xs = unfold_llist IS_LNIL LHD LTL (LTL b)\"", "lemma unfold_llist_id [simp]: \"unfold_llist lnull lhd ltl xs = xs\"", "lemma lset_eq_empty [simp]: \"lset xs = {} \\<longleftrightarrow> lnull xs\"", "lemma lset_ltl: \"lset (ltl xs) \\<subseteq> lset xs\"", "lemma in_lset_ltlD: \"x \\<in> lset (ltl xs) \\<Longrightarrow> x \\<in> lset xs\"", "theorem llist_set_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> lset xs\" and \"\\<And>xs. \\<not> lnull xs \\<Longrightarrow> P (lhd xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> lnull xs; y \\<in> lset (ltl xs); P y (ltl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\"", "lemma \"\\<And>xs. xs = LNil\"", "lemma \"LCons x xs = LCons x xs\"", "lemmas lhd_LCons = llist.sel(1)", "lemmas ltl_simps = llist.sel(2,3)", "lemmas lhd_LCons_ltl = llist.collapse(2)", "lemma lnull_ltlI [simp]: \"lnull xs \\<Longrightarrow> lnull (ltl xs)\"", "lemma neq_LNil_conv: \"xs \\<noteq> LNil \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs')\"", "lemma not_lnull_conv: \"\\<not> lnull xs \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs')\"", "lemma lset_LCons:\n  \"lset (LCons x xs) = insert x (lset xs)\"", "lemma lset_intros:\n  \"x \\<in> lset (LCons x xs)\"\n  \"x \\<in> lset xs \\<Longrightarrow> x \\<in> lset (LCons x' xs)\"", "lemma lset_cases [elim?]:\n  assumes \"x \\<in> lset xs\"\n  obtains xs' where \"xs = LCons x xs'\"\n  | x' xs' where \"xs = LCons x' xs'\" \"x \\<in> lset xs'\"", "lemma lset_induct' [consumes 1, case_names find step]:\n  assumes major: \"x \\<in> lset xs\"\n  and 1: \"\\<And>xs. P (LCons x xs)\"\n  and 2: \"\\<And>x' xs. \\<lbrakk> x \\<in> lset xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x' xs)\"\n  shows \"P xs\"", "lemma lset_induct [consumes 1, case_names find step, induct set: lset]:\n  assumes major: \"x \\<in> lset xs\"\n  and find: \"\\<And>xs. P (LCons x xs)\"\n  and step: \"\\<And>x' xs. \\<lbrakk> x \\<in> lset xs; x \\<noteq> x'; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x' xs)\"\n  shows \"P xs\"", "lemmas lset_LNil = llist.set(1)", "lemma lset_lnull: \"lnull xs \\<Longrightarrow> lset xs = {}\"", "lemma lset_into_lsetp:\n  \"x \\<in> lset xs \\<Longrightarrow> lsetp xs x\"", "lemma lsetp_into_lset:\n  \"lsetp xs x \\<Longrightarrow> x \\<in> lset xs\"", "lemma lset_eq_lsetp [nitpick_unfold]:\n  \"lset xs = {x. lsetp xs x}\"", "lemma gen_lset_code [code]:\n  \"gen_lset A LNil = A\"\n  \"gen_lset A (LCons x xs) = gen_lset (insert x A) xs\"", "lemma lset_code [code]:\n  \"lset = gen_lset {}\"", "lemma lmember_code [code]:\n  \"lmember x LNil \\<longleftrightarrow> False\"\n  \"lmember x (LCons y ys) \\<longleftrightarrow> x = y \\<or> lmember x ys\"", "lemma lset_lmember [code_unfold]:\n  \"x \\<in> lset xs \\<longleftrightarrow> lmember x xs\"", "lemmas lset_lmap [simp] = llist.set_map", "lemma lnull_imp_lfinite [simp]: \"lnull xs \\<Longrightarrow> lfinite xs\"", "lemma lfinite_LCons [simp]: \"lfinite (LCons x xs) = lfinite xs\"", "lemma lfinite_ltl [simp]: \"lfinite (ltl xs) = lfinite xs\"", "lemma lfinite_code [code]:\n  \"lfinite LNil = True\"\n  \"lfinite (LCons x xs) = lfinite xs\"", "lemma lfinite_induct [consumes 1, case_names LNil LCons]:\n  assumes lfinite: \"lfinite xs\"\n  and LNil: \"\\<And>xs. lnull xs \\<Longrightarrow> P xs\"\n  and LCons: \"\\<And>xs. \\<lbrakk> lfinite xs; \\<not> lnull xs; P (ltl xs) \\<rbrakk> \\<Longrightarrow> P xs\"\n  shows \"P xs\"", "lemma lfinite_imp_finite_lset:\n  assumes \"lfinite xs\"\n  shows \"finite (lset xs)\"", "lemmas lappend_LNil_LNil = lappend_code(1)[where ys = LNil]", "lemma lappend_simps [simp]:\n  shows lhd_lappend: \"lhd (lappend xs ys) = (if lnull xs then lhd ys else lhd xs)\"\n  and ltl_lappend: \"ltl (lappend xs ys) = (if lnull xs then ltl ys else lappend (ltl xs) ys)\"", "lemma lnull_lappend [simp]:\n  \"lnull (lappend xs ys) \\<longleftrightarrow> lnull xs \\<and> lnull ys\"", "lemma lappend_eq_LNil_iff:\n  \"lappend xs ys = LNil \\<longleftrightarrow> xs = LNil \\<and> ys = LNil\"", "lemma LNil_eq_lappend_iff:\n  \"LNil = lappend xs ys \\<longleftrightarrow> xs = LNil \\<and> ys = LNil\"", "lemma lappend_LNil2 [simp]: \"lappend xs LNil = xs\"", "lemma shows lappend_lnull1: \"lnull xs \\<Longrightarrow> lappend xs ys = ys\"\n  and lappend_lnull2: \"lnull ys \\<Longrightarrow> lappend xs ys = xs\"", "lemma lappend_assoc: \"lappend (lappend xs ys) zs = lappend xs (lappend ys zs)\"", "lemma lmap_lappend_distrib:\n  \"lmap f (lappend xs ys) = lappend (lmap f xs) (lmap f ys)\"", "lemma lappend_snocL1_conv_LCons2:\n  \"lappend (lappend xs (LCons y LNil)) ys = lappend xs (LCons y ys)\"", "lemma lappend_ltl: \"\\<not> lnull xs \\<Longrightarrow> lappend (ltl xs) ys = ltl (lappend xs ys)\"", "lemma lfinite_lappend [simp]:\n  \"lfinite (lappend xs ys) \\<longleftrightarrow> lfinite xs \\<and> lfinite ys\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lappend_inf: \"\\<not> lfinite xs \\<Longrightarrow> lappend xs ys = xs\"", "lemma lfinite_lmap [simp]:\n  \"lfinite (lmap f xs) = lfinite xs\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lset_lappend_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> lset (lappend xs ys) = lset xs \\<union> lset ys\"", "lemma lset_lappend: \"lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\"", "lemma lset_lappend1: \"lset xs \\<subseteq> lset (lappend xs ys)\"", "lemma lset_lappend_conv: \"lset (lappend xs ys) = (if lfinite xs then lset xs \\<union> lset ys else lset xs)\"", "lemma in_lset_lappend_iff: \"x \\<in> lset (lappend xs ys) \\<longleftrightarrow> x \\<in> lset xs \\<or> lfinite xs \\<and> x \\<in> lset ys\"", "lemma split_llist_first:\n  assumes \"x \\<in> lset xs\"\n  shows \"\\<exists>ys zs. xs = lappend ys (LCons x zs) \\<and> lfinite ys \\<and> x \\<notin> lset ys\"", "lemma split_llist: \"x \\<in> lset xs \\<Longrightarrow> \\<exists>ys zs. xs = lappend ys (LCons x zs) \\<and> lfinite ys\"", "lemma lprefixI [consumes 1, case_names lprefix,\n                case_conclusion lprefix LeLNil LeLCons]:\n  assumes major: \"(xs, ys) \\<in> X\"\n  and step:\n      \"\\<And>xs ys. (xs, ys) \\<in> X\n       \\<Longrightarrow> lnull xs \\<or> (\\<exists>x xs' ys'. xs = LCons x xs' \\<and> ys = LCons x ys' \\<and>\n                                   ((xs', ys') \\<in> X \\<or> xs' \\<sqsubseteq> ys'))\"\n  shows \"xs \\<sqsubseteq> ys\"", "lemma lprefix_coinduct [consumes 1, case_names lprefix, case_conclusion lprefix LNil LCons, coinduct pred: lprefix]:\n  assumes major: \"P xs ys\"\n  and step: \"\\<And>xs ys. P xs ys\n    \\<Longrightarrow> (lnull ys \\<longrightarrow> lnull xs) \\<and>\n       (\\<not> lnull xs \\<longrightarrow> \\<not> lnull ys \\<longrightarrow> lhd xs = lhd ys \\<and> (P (ltl xs) (ltl ys) \\<or> ltl xs \\<sqsubseteq> ltl ys))\"\n  shows \"xs \\<sqsubseteq> ys\"", "lemma lprefix_refl [intro, simp]: \"xs \\<sqsubseteq> xs\"", "lemma lprefix_LNil [simp]: \"xs \\<sqsubseteq> LNil \\<longleftrightarrow> lnull xs\"", "lemma lprefix_lnull: \"lnull ys \\<Longrightarrow> xs \\<sqsubseteq> ys \\<longleftrightarrow> lnull xs\"", "lemma lnull_lprefix: \"lnull xs \\<Longrightarrow> lprefix xs ys\"", "lemma lprefix_LCons_conv:\n  \"xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow>\n   xs = LNil \\<or> (\\<exists>xs'. xs = LCons y xs' \\<and> xs' \\<sqsubseteq> ys)\"", "lemma LCons_lprefix_LCons [simp]:\n  \"LCons x xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow> x = y \\<and> xs \\<sqsubseteq> ys\"", "lemma LCons_lprefix_conv:\n  \"LCons x xs \\<sqsubseteq> ys \\<longleftrightarrow> (\\<exists>ys'. ys = LCons x ys' \\<and> xs \\<sqsubseteq> ys')\"", "lemma lprefix_ltlI: \"xs \\<sqsubseteq> ys \\<Longrightarrow> ltl xs \\<sqsubseteq> ltl ys\"", "lemma lprefix_code [code]:\n  \"LNil \\<sqsubseteq> ys \\<longleftrightarrow> True\"\n  \"LCons x xs \\<sqsubseteq> LNil \\<longleftrightarrow> False\"\n  \"LCons x xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow> x = y \\<and> xs \\<sqsubseteq> ys\"", "lemma lprefix_lhdD: \"\\<lbrakk> xs \\<sqsubseteq> ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd xs = lhd ys\"", "lemma lprefix_lnullD: \"\\<lbrakk> xs \\<sqsubseteq> ys; lnull ys \\<rbrakk> \\<Longrightarrow> lnull xs\"", "lemma lprefix_not_lnullD: \"\\<lbrakk> xs \\<sqsubseteq> ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> \\<not> lnull ys\"", "lemma lprefix_expand:\n  \"(\\<not> lnull xs \\<Longrightarrow> \\<not> lnull ys \\<and> lhd xs = lhd ys \\<and> ltl xs \\<sqsubseteq> ltl ys) \\<Longrightarrow> xs \\<sqsubseteq> ys\"", "lemma lprefix_antisym:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; ys \\<sqsubseteq> xs \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma lprefix_trans [trans]:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; ys \\<sqsubseteq> zs \\<rbrakk> \\<Longrightarrow> xs \\<sqsubseteq> zs\"", "lemma preorder_lprefix [cont_intro]:\n  \"class.preorder (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\"", "lemma lprefix_lsetD:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"lset xs \\<subseteq> lset ys\"", "lemma lprefix_lappend_sameI:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"lappend zs xs \\<sqsubseteq> lappend zs ys\"", "lemma not_lfinite_lprefix_conv_eq:\n  assumes nfin: \"\\<not> lfinite xs\"\n  shows \"xs \\<sqsubseteq> ys \\<longleftrightarrow> xs = ys\"", "lemma lprefix_lappend: \"xs \\<sqsubseteq> lappend xs ys\"", "lemma lprefix_down_linear:\n  assumes \"xs \\<sqsubseteq> zs\" \"ys \\<sqsubseteq> zs\"\n  shows \"xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs\"", "lemma lprefix_lappend_same [simp]:\n  \"lappend xs ys \\<sqsubseteq> lappend xs zs \\<longleftrightarrow> (lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lnull_lSup [simp]: \"lnull (lSup A) \\<longleftrightarrow> (\\<forall>x\\<in>A. lnull x)\"", "lemma lhd_lSup [simp]: \"\\<exists>x\\<in>A. \\<not> lnull x \\<Longrightarrow> lhd (lSup A) = (THE x. x \\<in> lhd ` (A \\<inter> {xs. \\<not> lnull xs}))\"", "lemma ltl_lSup [simp]: \"ltl (lSup A) = lSup (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))\"", "lemma lhd_lSup_eq:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y\"\n  shows \"\\<lbrakk> xs \\<in> Y; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd (lSup Y) = lhd xs\"", "lemma lSup_empty [simp]: \"lSup {} = LNil\"", "lemma lSup_singleton [simp]: \"lSup {xs} = xs\"", "lemma LCons_image_Int_not_lnull: \"(LCons x ` A \\<inter> {xs. \\<not> lnull xs}) = LCons x ` A\"", "lemma lSup_LCons: \"A \\<noteq> {} \\<Longrightarrow> lSup (LCons x ` A) = LCons x (lSup A)\"", "lemma lSup_eq_LCons_iff:\n  \"lSup Y = LCons x xs \\<longleftrightarrow> (\\<exists>x\\<in>Y. \\<not> lnull x) \\<and> x = (THE x. x \\<in> lhd ` (Y \\<inter> {xs. \\<not> lnull xs})) \\<and> xs = lSup (ltl ` (Y \\<inter> {xs. \\<not> lnull xs}))\"", "lemma lSup_insert_LNil: \"lSup (insert LNil Y) = lSup Y\"", "lemma lSup_minus_LNil: \"lSup (Y - {LNil}) = lSup Y\"", "lemma chain_lprefix_ltl:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) A\"\n  shows \"Complete_Partial_Order.chain (\\<sqsubseteq>) (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))\"", "lemma lSup_finite_prefixes: \"lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} = xs\" (is \"lSup (?C xs) = _\")", "lemma lSup_finite_gen_prefixes:\n  assumes \"zs \\<sqsubseteq> xs\" \"lfinite zs\"\n  shows \"lSup {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} = xs\"", "lemma lSup_strict_prefixes:\n  \"\\<not> lfinite xs \\<Longrightarrow> lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs\"\n  (is \"_ \\<Longrightarrow> lSup (?C xs) = _\")", "lemma chain_lprefix_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) A; xs \\<in> A \\<rbrakk>\n  \\<Longrightarrow> xs \\<sqsubseteq> lSup A\"", "lemma chain_lSup_lprefix:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) A; \\<And>xs. xs \\<in> A \\<Longrightarrow> xs \\<sqsubseteq> zs \\<rbrakk>\n  \\<Longrightarrow> lSup A \\<sqsubseteq> zs\"", "lemma llist_ccpo [simp, cont_intro]: \"class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\"", "lemmas [cont_intro] = ccpo.admissible_leI[OF llist_ccpo]", "lemma llist_partial_function_definitions:\n  \"partial_function_definitions (\\<sqsubseteq>) lSup\"", "lemma lprefixes_chain:\n  \"Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. lprefix ys xs}\"", "lemma llist_gen_induct:\n  assumes adm: \"ccpo.admissible lSup (\\<sqsubseteq>) P\"\n  and step: \"\\<exists>zs. zs \\<sqsubseteq> xs \\<and> lfinite zs \\<and> (\\<forall>ys. zs \\<sqsubseteq> ys \\<longrightarrow> ys \\<sqsubseteq> xs \\<longrightarrow> lfinite ys \\<longrightarrow> P ys)\"\n  shows \"P xs\"", "lemma llist_induct [case_names adm LNil LCons, induct type: llist]:\n  assumes adm: \"ccpo.admissible lSup (\\<sqsubseteq>) P\"\n  and LNil: \"P LNil\"\n  and LCons: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x xs)\"\n  shows \"P xs\"", "lemma LCons_mono [partial_function_mono, cont_intro]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. LCons x (A f))\"", "lemma mono2mono_LCons [THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_LCons: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (LCons x)\"", "lemma mcont2mcont_LCons [THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_LCons: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (LCons x)\"", "lemma mono2mono_ltl[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_ltl: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) ltl\"", "lemma cont_ltl: \"cont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl\"", "lemma mcont2mcont_ltl [THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_ltl: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl\"", "lemma llist_case_mono [partial_function_mono, cont_intro]:\n  assumes lnil: \"monotone orda ordb lnil\"\n  and lcons: \"\\<And>x xs. monotone orda ordb (\\<lambda>f. lcons f x xs)\"\n  shows \"monotone orda ordb (\\<lambda>f. case_llist (lnil f) (lcons f) x)\"", "lemma mcont_llist_case [cont_intro, simp]:\n  \"\\<lbrakk> mcont luba orda lubb ordb (\\<lambda>x. f x); \\<And>x xs. mcont luba orda lubb ordb (\\<lambda>y. g x xs y) \\<rbrakk>\n  \\<Longrightarrow> mcont luba orda lubb ordb (\\<lambda>y. case xs of LNil \\<Rightarrow> f y | LCons x xs' \\<Rightarrow> g x xs' y)\"", "lemma monotone_lprefix_case [cont_intro, simp]:\n  assumes mono: \"\\<And>x. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> f x xs' xs)\"", "lemma mcont_lprefix_case_aux:\n  fixes f bot\n  defines \"g \\<equiv> \\<lambda>xs. f (lhd xs) (ltl xs) (LCons (lhd xs) (ltl xs))\"\n  assumes mcont: \"\\<And>x. mcont lSup (\\<sqsubseteq>) lub ord (\\<lambda>xs. f x xs (LCons x xs))\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord bot x\"\n  shows \"mcont lSup (\\<sqsubseteq>) lub ord (\\<lambda>xs. case xs of LNil \\<Rightarrow> bot | LCons x xs' \\<Rightarrow> f x xs' xs)\"", "lemma mcont_lprefix_case [cont_intro, simp]:\n  assumes \"\\<And>x. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> f x xs' xs)\"", "lemma monotone_lprefix_case_lfp [cont_intro, simp]:\n  fixes f :: \"_ \\<Rightarrow> _ :: order_bot\"\n  assumes mono: \"\\<And>x. monotone (\\<sqsubseteq>) (\\<le>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"monotone (\\<sqsubseteq>) (\\<le>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<bottom> | LCons x xs \\<Rightarrow> f x xs (LCons x xs))\"", "lemma mcont_lprefix_case_lfp [cont_intro, simp]:\n  fixes f :: \"_ => _ :: complete_lattice\"\n  assumes \"\\<And>x. mcont lSup (\\<sqsubseteq>) Sup (\\<le>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"mcont lSup (\\<sqsubseteq>) Sup (\\<le>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<bottom> | LCons x xs \\<Rightarrow> f x xs (LCons x xs))\"", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>lmap xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> LCons (f x) (lmap xs)\"\n  shows lmap_conv_fixp: \"lmap f \\<equiv> ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) F\" (is \"?lhs \\<equiv> ?rhs\")\n  and lmap_mono: \"\\<And>xs. mono_llist (\\<lambda>lmap. F lmap xs)\" (is \"PROP ?mono\")", "lemma mono2mono_lmap[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lmap: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lmap f)\"", "lemma mcont2mcont_lmap[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lmap: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lmap f)\"", "lemma [partial_function_mono]: \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. lmap g (F f))\"", "lemma mono_llist_lappend2 [partial_function_mono]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lappend xs (A f))\"", "lemma mono2mono_lappend2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lappend2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lappend xs)\"", "lemma mcont2mcont_lappend2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lappend2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\"", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>lset xs. case xs of LNil \\<Rightarrow> {} | LCons x xs \\<Rightarrow> insert x (lset xs)\"\n  shows lset_conv_fixp: \"lset \\<equiv> ccpo.fixp (fun_lub Union) (fun_ord (\\<subseteq>)) F\" (is \"_ \\<equiv> ?fixp\")\n  and lset_mono: \"\\<And>x. monotone (fun_ord (\\<subseteq>)) (\\<subseteq>) (\\<lambda>f. F f x)\" (is \"PROP ?mono\")", "lemma mono2mono_lset [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_lset: \"monotone (\\<sqsubseteq>) (\\<subseteq>) lset\"", "lemma mcont2mcont_lset[THEN mcont2mcont, cont_intro, simp]:\n  shows mcont_lset: \"mcont lSup (\\<sqsubseteq>) Union (\\<subseteq>) lset\"", "lemma lset_lSup: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<Longrightarrow> lset (lSup Y) = \\<Union>(lset ` Y)\"", "lemma lfinite_lSupD: \"lfinite (lSup A) \\<Longrightarrow> \\<forall>xs \\<in> A. lfinite xs\"", "lemma monotone_enat_le_lprefix_case [cont_intro, simp]:\n  \"monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>x. f x (eSuc x)) \\<Longrightarrow> monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>x. case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)\"", "lemma mcont_enat_le_lprefix_case [cont_intro, simp]:\n  assumes \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>x. f x (eSuc x))\"\n  shows \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>x. case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)\"", "lemma compact_LConsI:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) xs\"\n  shows \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)\"", "lemma compact_LConsD:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)\"\n  shows \"ccpo.compact lSup (\\<sqsubseteq>) xs\"", "lemma compact_LCons_iff [simp]:\n  \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs) \\<longleftrightarrow> ccpo.compact lSup (\\<sqsubseteq>) xs\"", "lemma compact_lfiniteI:\n  \"lfinite xs \\<Longrightarrow> ccpo.compact lSup (\\<sqsubseteq>) xs\"", "lemma compact_lfiniteD:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) xs\"\n  shows \"lfinite xs\"", "lemma compact_eq_lfinite [simp]: \"ccpo.compact lSup (\\<sqsubseteq>) = lfinite\"", "lemma lhd'_simps[simp]:\n  \"lhd' LNil = None\"\n  \"lhd' (LCons x xs) = Some x\"", "lemma ltl'_simps[simp]:\n  \"ltl' LNil = None\"\n  \"ltl' (LCons x xs) = Some xs\"", "lemma lhd_llist_of [simp]: \"lhd (llist_of xs) = hd xs\"", "lemma ltl_llist_of [simp]: \"ltl (llist_of xs) = llist_of (tl xs)\"", "lemma lfinite_llist_of [simp]: \"lfinite (llist_of xs)\"", "lemma lfinite_eq_range_llist_of: \"lfinite xs \\<longleftrightarrow> xs \\<in> range llist_of\"", "lemma lnull_llist_of [simp]: \"lnull (llist_of xs) \\<longleftrightarrow> xs = []\"", "lemma llist_of_eq_LNil_conv:\n  \"llist_of xs = LNil \\<longleftrightarrow> xs = []\"", "lemma llist_of_eq_LCons_conv:\n  \"llist_of xs = LCons y ys \\<longleftrightarrow> (\\<exists>xs'. xs = y # xs' \\<and> ys = llist_of xs')\"", "lemma lappend_llist_of_llist_of:\n  \"lappend (llist_of xs) (llist_of ys) = llist_of (xs @ ys)\"", "lemma lfinite_rev_induct [consumes 1, case_names Nil snoc]:\n  assumes fin: \"lfinite xs\"\n  and Nil: \"P LNil\"\n  and snoc: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (lappend xs (LCons x LNil))\"\n  shows \"P xs\"", "lemma lappend_llist_of_LCons:\n  \"lappend (llist_of xs) (LCons y ys) = lappend (llist_of (xs @ [y])) ys\"", "lemma lmap_llist_of [simp]:\n  \"lmap f (llist_of xs) = llist_of (map f xs)\"", "lemma lset_llist_of [simp]: \"lset (llist_of xs) = set xs\"", "lemma llist_of_inject [simp]: \"llist_of xs = llist_of ys \\<longleftrightarrow> xs = ys\"", "lemma inj_llist_of [simp]: \"inj llist_of\"", "lemma list_of_llist_of [simp]: \"list_of (llist_of xs) = xs\"", "lemma llist_of_list_of [simp]: \"lfinite xs \\<Longrightarrow> llist_of (list_of xs) = xs\"", "lemma list_of_LNil [simp, nitpick_simp]: \"list_of LNil = []\"", "lemma list_of_LCons [simp]: \"lfinite xs \\<Longrightarrow> list_of (LCons x xs) = x # list_of xs\"", "lemma list_of_LCons_conv [nitpick_simp]:\n  \"list_of (LCons x xs) = (if lfinite xs then x # list_of xs else undefined)\"", "lemma list_of_lappend:\n  assumes \"lfinite xs\" \"lfinite ys\"\n  shows \"list_of (lappend xs ys) = list_of xs @ list_of ys\"", "lemma list_of_lmap [simp]:\n  assumes \"lfinite xs\"\n  shows \"list_of (lmap f xs) = map f (list_of xs)\"", "lemma set_list_of [simp]:\n  assumes \"lfinite xs\"\n  shows \"set (list_of xs) = lset xs\"", "lemma hd_list_of [simp]: \"lfinite xs \\<Longrightarrow> hd (list_of xs) = lhd xs\"", "lemma tl_list_of: \"lfinite xs \\<Longrightarrow> tl (list_of xs) = list_of (ltl xs)\"", "lemma list_of_code [code]: \"list_of = list_of_aux []\"", "lemma list_of_aux_code [code]:\n  \"list_of_aux xs LNil = rev xs\"\n  \"list_of_aux xs (LCons y ys) = list_of_aux (y # xs) ys\"", "lemma [simp, nitpick_simp]:\n  shows llength_LNil: \"llength LNil = 0\"\n  and llength_LCons: \"llength (LCons x xs) = eSuc (llength xs)\"", "lemma llength_eq_0 [simp]: \"llength xs = 0 \\<longleftrightarrow> lnull xs\"", "lemma llength_lnull [simp]: \"lnull xs \\<Longrightarrow> llength xs = 0\"", "lemma epred_llength:\n  \"epred (llength xs) = llength (ltl xs)\"", "lemmas llength_ltl = epred_llength[symmetric]", "lemma llength_lmap [simp]: \"llength (lmap f xs) = llength xs\"", "lemma llength_lappend [simp]: \"llength (lappend xs ys) = llength xs + llength ys\"", "lemma llength_llist_of [simp]:\n  \"llength (llist_of xs) = enat (length xs)\"", "lemma length_list_of:\n  \"lfinite xs \\<Longrightarrow> enat (length (list_of xs)) = llength xs\"", "lemma length_list_of_conv_the_enat:\n  \"lfinite xs \\<Longrightarrow> length (list_of xs) = the_enat (llength xs)\"", "lemma llength_eq_enat_lfiniteD: \"llength xs = enat n \\<Longrightarrow> lfinite xs\"", "lemma lfinite_llength_enat:\n  assumes \"lfinite xs\"\n  shows \"\\<exists>n. llength xs = enat n\"", "lemma lfinite_conv_llength_enat:\n  \"lfinite xs \\<longleftrightarrow> (\\<exists>n. llength xs = enat n)\"", "lemma not_lfinite_llength:\n  \"\\<not> lfinite xs \\<Longrightarrow> llength xs = \\<infinity>\"", "lemma llength_eq_infty_conv_lfinite:\n  \"llength xs = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs\"", "lemma lfinite_finite_index: \"lfinite xs \\<Longrightarrow> finite {n. enat n < llength xs}\"", "lemma gen_llength_code [code]:\n  \"gen_llength n LNil = enat n\"\n  \"gen_llength n (LCons x xs) = gen_llength (n + 1) xs\"", "lemma llength_code [code]: \"llength = gen_llength 0\"", "lemma fixes F\n  defines \"F \\<equiv> \\<lambda>llength xs. case xs of LNil \\<Rightarrow> 0 | LCons x xs \\<Rightarrow> eSuc (llength xs)\"\n  shows llength_conv_fixp: \"llength \\<equiv> ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) F\" (is \"_ \\<equiv> ?fixp\")\n  and llength_mono: \"\\<And>xs. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>llength. F llength xs)\" (is \"PROP ?mono\")", "lemma mono2mono_llength[THEN lfp.mono2mono, simp, cont_intro]:\n  shows monotone_llength: \"monotone (\\<sqsubseteq>) (\\<le>) llength\"", "lemma mcont2mcont_llength[THEN lfp.mcont2mcont, simp, cont_intro]:\n  shows mcont_llength: \"mcont lSup (\\<sqsubseteq>) Sup (\\<le>) llength\"", "lemma ltake_LNil [simp, code, nitpick_simp]: \"ltake n LNil = LNil\"", "lemma ltake_0 [simp]: \"ltake 0 xs = LNil\"", "lemma ltake_eSuc_LCons [simp]:\n  \"ltake (eSuc n) (LCons x xs) = LCons x (ltake n xs)\"", "lemma ltake_eSuc:\n  \"ltake (eSuc n) xs =\n  (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> LCons x (ltake n xs'))\"", "lemma lnull_ltake [simp]: \"lnull (ltake n xs) \\<longleftrightarrow> lnull xs \\<or> n = 0\"", "lemma ltake_eq_LNil_iff: \"ltake n xs = LNil \\<longleftrightarrow> xs = LNil \\<or> n = 0\"", "lemma LNil_eq_ltake_iff [simp]: \"LNil = ltake n xs \\<longleftrightarrow> xs = LNil \\<or> n = 0\"", "lemma ltake_LCons [code, nitpick_simp]:\n  \"ltake n (LCons x xs) =\n  (case n of 0 \\<Rightarrow> LNil | eSuc n' \\<Rightarrow> LCons x (ltake n' xs))\"", "lemma lhd_ltake [simp]: \"n \\<noteq> 0 \\<Longrightarrow> lhd (ltake n xs) = lhd xs\"", "lemma ltl_ltake: \"ltl (ltake n xs) = ltake (epred n) (ltl xs)\"", "lemmas ltake_epred_ltl = ltl_ltake [symmetric]", "lemma ltake_ltl: \"ltake n (ltl xs) = ltl (ltake (eSuc n) xs)\"", "lemma llength_ltake [simp]: \"llength (ltake n xs) = min n (llength xs)\"", "lemma ltake_lmap [simp]: \"ltake n (lmap f xs) = lmap f (ltake n xs)\"", "lemma ltake_ltake [simp]: \"ltake n (ltake m xs) = ltake (min n m) xs\"", "lemma lset_ltake: \"lset (ltake n xs) \\<subseteq> lset xs\"", "lemma ltake_all: \"llength xs \\<le> m \\<Longrightarrow> ltake m xs = xs\"", "lemma ltake_llist_of [simp]:\n  \"ltake (enat n) (llist_of xs) = llist_of (take n xs)\"", "lemma lfinite_ltake [simp]:\n  \"lfinite (ltake n xs) \\<longleftrightarrow> lfinite xs \\<or> n < \\<infinity>\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma ltake_lappend1:  \"n \\<le> llength xs \\<Longrightarrow> ltake n (lappend xs ys) = ltake n xs\"", "lemma ltake_lappend2:\n  \"llength xs \\<le> n \\<Longrightarrow> ltake n (lappend xs ys) = lappend xs (ltake (n - llength xs) ys)\"", "lemma ltake_lappend:\n  \"ltake n (lappend xs ys) = lappend (ltake n xs) (ltake (n - llength xs) ys)\"", "lemma take_list_of:\n  assumes \"lfinite xs\"\n  shows \"take n (list_of xs) = list_of (ltake (enat n) xs)\"", "lemma ltake_eq_ltake_antimono:\n  \"\\<lbrakk> ltake n xs = ltake n ys; m \\<le> n \\<rbrakk> \\<Longrightarrow> ltake m xs = ltake m ys\"", "lemma ltake_is_lprefix [simp, intro]: \"ltake n xs \\<sqsubseteq> xs\"", "lemma lprefix_ltake_same [simp]:\n  \"ltake n xs \\<sqsubseteq> ltake m xs \\<longleftrightarrow> n \\<le> m \\<or> llength xs \\<le> m\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>ltake n xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> case n of 0 \\<Rightarrow> LNil | eSuc n \\<Rightarrow> LCons x (ltake n xs)\"\n  shows ltake_conv_fixp: \"ltake \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) (\\<lambda>ltake. case_prod (F (curry ltake))))\" (is \"?lhs \\<equiv> ?rhs\")\n  and ltake_mono: \"\\<And>nxs. mono_llist (\\<lambda>ltake. case nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs)\" (is \"PROP ?mono\")", "lemma monotone_ltake: \"monotone (rel_prod (\\<le>) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod ltake)\"", "lemma mono2mono_ltake1[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltake1: \"monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)\"", "lemma mono2mono_ltake2[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltake2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ltake n)\"", "lemma mcont_ltake: \"mcont (prod_lub Sup lSup) (rel_prod (\\<le>) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod ltake)\"", "lemma mcont2mcont_ltake1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltake1: \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)\"", "lemma mcont2mcont_ltake2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltake2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ltake n)\"", "lemma [partial_function_mono]: \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. ltake n (F f))\"", "lemma llist_induct2:\n  assumes adm: \"ccpo.admissible (prod_lub lSup lSup) (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) (\\<lambda>x. P (fst x) (snd x))\"\n  and LNil: \"P LNil LNil\"\n  and LCons1: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs LNil \\<rbrakk> \\<Longrightarrow> P (LCons x xs) LNil\"\n  and LCons2: \"\\<And>y ys. \\<lbrakk> lfinite ys; P LNil ys \\<rbrakk> \\<Longrightarrow> P LNil (LCons y ys)\"\n  and LCons: \"\\<And>x xs y ys. \\<lbrakk> lfinite xs; lfinite ys; P xs ys \\<rbrakk> \\<Longrightarrow> P (LCons x xs) (LCons y ys)\"\n  shows \"P xs ys\"", "lemma ldropn_0 [simp]: \"ldropn 0 xs = xs\"", "lemma ldropn_LNil [code, simp]: \"ldropn n LNil = LNil\"", "lemma ldropn_lnull: \"lnull xs \\<Longrightarrow> ldropn n xs = LNil\"", "lemma ldropn_LCons [code]:\n  \"ldropn n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | Suc n' \\<Rightarrow> ldropn n' xs)\"", "lemma ldropn_Suc: \"ldropn (Suc n) xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> ldropn n xs')\"", "lemma ldropn_Suc_LCons [simp]: \"ldropn (Suc n) (LCons x xs) = ldropn n xs\"", "lemma ltl_ldropn: \"ltl (ldropn n xs) = ldropn n (ltl xs)\"", "lemma ldrop_simps [simp]:\n  shows ldrop_LNil: \"ldrop n LNil = LNil\"\n  and ldrop_0: \"ldrop 0 xs = xs\"\n  and ldrop_eSuc_LCons: \"ldrop (eSuc n) (LCons x xs) = ldrop n xs\"", "lemma ldrop_lnull: \"lnull xs \\<Longrightarrow> ldrop n xs = LNil\"", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>ldropn xs. case xs of LNil \\<Rightarrow> \\<lambda>_. LNil | LCons x xs \\<Rightarrow> \\<lambda>n. if n = 0 then LCons x xs else ldropn xs (n - 1)\"\n  shows ldrop_conv_fixp: \"(\\<lambda>xs n. ldropn n xs) \\<equiv> ccpo.fixp (fun_lub (fun_lub lSup)) (fun_ord (fun_ord lprefix)) (\\<lambda>ldrop. F ldrop)\" (is \"?lhs \\<equiv> ?rhs\")\n  and ldrop_mono: \"\\<And>xs. mono_llist_lift (\\<lambda>ldrop. F ldrop xs)\" (is \"PROP ?mono\")", "lemma ldropn_fixp_case_conv:\n  \"(\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<lambda>_. LNil | LCons x xs \\<Rightarrow> \\<lambda>n. if n = 0 then LCons x xs else f xs (n - 1)) =\n   (\\<lambda>xs n. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> if n = 0 then LCons x xs else f xs (n - 1))\"", "lemma monotone_ldropn_aux: \"monotone lprefix (fun_ord lprefix) (\\<lambda>xs n. ldropn n xs)\"", "lemma mono2mono_ldropn[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldropn': \"monotone lprefix lprefix (\\<lambda>xs. ldropn n xs)\"", "lemma mcont_ldropn_aux: \"mcont lSup lprefix (fun_lub lSup) (fun_ord lprefix) (\\<lambda>xs n. ldropn n xs)\"", "lemma mcont2mcont_ldropn [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldropn: \"mcont lSup lprefix lSup lprefix (ldropn n)\"", "lemma monotone_enat_cocase [cont_intro, simp]:\n  \"\\<lbrakk> \\<And>n. monotone (\\<le>) ord (\\<lambda>n. f n (eSuc n));\n    \\<And>n. ord a (f n (eSuc n)); ord a a \\<rbrakk>\n  \\<Longrightarrow> monotone (\\<le>) ord (\\<lambda>n. case n of 0 \\<Rightarrow> a | eSuc n' \\<Rightarrow> f n' n)\"", "lemma monotone_ldrop: \"monotone (rel_prod (=) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod ldrop)\"", "lemma mono2mono_ldrop2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldrop2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldrop n)\"", "lemma mcont_ldrop: \"mcont (prod_lub the_Sup lSup) (rel_prod (=) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod ldrop)\"", "lemma mcont2monct_ldrop2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldrop2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldrop n)\"", "lemma ldrop_eSuc_conv_ltl: \"ldrop (eSuc n) xs = ltl (ldrop n xs)\"", "lemma ldrop_ltl: \"ldrop n (ltl xs) = ldrop (eSuc n) xs\"", "lemma lnull_ldropn [simp]: \"lnull (ldropn n xs) \\<longleftrightarrow> llength xs \\<le> enat n\"", "lemma ldrop_eq_LNil [simp]: \"ldrop n xs = LNil \\<longleftrightarrow> llength xs \\<le> n\"", "lemma lnull_ldrop [simp]: \"lnull (ldrop n xs) \\<longleftrightarrow> llength xs \\<le> n\"", "lemma ldropn_eq_LNil: \"(ldropn n xs = LNil) = (llength xs \\<le> enat n)\"", "lemma ldropn_all: \"llength xs \\<le> enat m \\<Longrightarrow> ldropn m xs = LNil\"", "lemma ldrop_all: \"llength xs \\<le> m \\<Longrightarrow> ldrop m xs = LNil\"", "lemma ltl_ldrop: \"ltl (ldrop n xs) = ldrop n (ltl xs)\"", "lemma ldrop_eSuc:\n  \"ldrop (eSuc n) xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> ldrop n xs')\"", "lemma ldrop_LCons:\n  \"ldrop n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | eSuc n' \\<Rightarrow> ldrop n' xs)\"", "lemma ldrop_inf [code, simp]: \"ldrop \\<infinity> xs = LNil\"", "lemma ldrop_enat [code]: \"ldrop (enat n) xs = ldropn n xs\"", "lemma lfinite_ldropn [simp]: \"lfinite (ldropn n xs) = lfinite xs\"", "lemma lfinite_ldrop [simp]:\n  \"lfinite (ldrop n xs) \\<longleftrightarrow> lfinite xs \\<or> n = \\<infinity>\"", "lemma ldropn_ltl: \"ldropn n (ltl xs) = ldropn (Suc n) xs\"", "lemmas ldrop_eSuc_ltl = ldropn_ltl[symmetric]", "lemma lset_ldropn_subset: \"lset (ldropn n xs) \\<subseteq> lset xs\"", "lemma in_lset_ldropnD: \"x \\<in> lset (ldropn n xs) \\<Longrightarrow> x \\<in> lset xs\"", "lemma lset_ldrop_subset: \"lset (ldrop n xs) \\<subseteq> lset xs\"", "lemma in_lset_ldropD: \"x \\<in> lset (ldrop n xs) \\<Longrightarrow> x \\<in> lset xs\"", "lemma lappend_ltake_ldrop: \"lappend (ltake n xs) (ldrop n xs) = xs\"", "lemma ldropn_lappend:\n  \"ldropn n (lappend xs ys) =\n  (if enat n < llength xs then lappend (ldropn n xs) ys\n   else ldropn (n - the_enat (llength xs)) ys)\"", "lemma ldropn_lappend2:\n  \"llength xs \\<le> enat n \\<Longrightarrow> ldropn n (lappend xs ys) = ldropn (n - the_enat (llength xs)) ys\"", "lemma lappend_ltake_enat_ldropn [simp]: \"lappend (ltake (enat n) xs) (ldropn n xs) = xs\"", "lemma ldrop_lappend:\n  \"ldrop n (lappend xs ys) =\n  (if n < llength xs then lappend (ldrop n xs) ys\n   else ldrop (n - llength xs) ys)\"\n  \\<comment> \\<open>cannot prove this directly using fixpoint induction,\n     because @{term \"(-) :: enat \\<Rightarrow> enat \\<Rightarrow> enat\"} is not a least fixpoint\\<close>", "lemma ltake_plus_conv_lappend:\n  \"ltake (n + m) xs = lappend (ltake n xs) (ltake m (ldrop n xs))\"", "lemma ldropn_eq_LConsD:\n  \"ldropn n xs = LCons y ys \\<Longrightarrow> enat n < llength xs\"", "lemma ldrop_eq_LConsD:\n  \"ldrop n xs = LCons y ys \\<Longrightarrow> n < llength xs\"", "lemma ldropn_lmap [simp]: \"ldropn n (lmap f xs) = lmap f (ldropn n xs)\"", "lemma ldrop_lmap [simp]: \"ldrop n (lmap f xs) = lmap f (ldrop n xs)\"", "lemma ldropn_ldropn [simp]:\n  \"ldropn n (ldropn m xs) = ldropn (n + m) xs\"", "lemma ldrop_ldrop [simp]:\n  \"ldrop n (ldrop m xs) = ldrop (n + m) xs\"", "lemma llength_ldropn [simp]: \"llength (ldropn n xs) = llength xs - enat n\"", "lemma enat_llength_ldropn:\n  \"enat n \\<le> llength xs \\<Longrightarrow> enat (n - m) \\<le> llength (ldropn m xs)\"", "lemma ldropn_llist_of [simp]: \"ldropn n (llist_of xs) = llist_of (drop n xs)\"", "lemma ldrop_llist_of: \"ldrop (enat n) (llist_of xs) = llist_of (drop n xs)\"", "lemma drop_list_of:\n  \"lfinite xs \\<Longrightarrow> drop n (list_of xs) = list_of (ldropn n xs)\"", "lemma llength_ldrop: \"llength (ldrop n xs) = (if n = \\<infinity> then 0 else llength xs - n)\"", "lemma ltake_ldropn: \"ltake n (ldropn m xs) = ldropn m (ltake (n + enat m) xs)\"", "lemma ldropn_ltake: \"ldropn n (ltake m xs) = ltake (m - enat n) (ldropn n xs)\"", "lemma ltake_ldrop: \"ltake n (ldrop m xs) = ldrop m (ltake (n + m) xs)\"", "lemma ldrop_ltake: \"ldrop n (ltake m xs) = ltake (m - n) (ldrop n xs)\"", "lemma lnth_LNil:\n  \"lnth LNil n = undefined n\"", "lemma lnth_0 [simp]:\n  \"lnth (LCons x xs) 0 = x\"", "lemma lnth_Suc_LCons [simp]:\n  \"lnth (LCons x xs) (Suc n) = lnth xs n\"", "lemma lnth_LCons:\n  \"lnth (LCons x xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> lnth xs n')\"", "lemma lnth_LCons': \"lnth (LCons x xs) n = (if n = 0 then x else lnth xs (n - 1))\"", "lemma lhd_conv_lnth:\n  \"\\<not> lnull xs \\<Longrightarrow> lhd xs = lnth xs 0\"", "lemmas lnth_0_conv_lhd = lhd_conv_lnth[symmetric]", "lemma lnth_ltl: \"\\<not> lnull xs \\<Longrightarrow> lnth (ltl xs) n = lnth xs (Suc n)\"", "lemma lhd_ldropn:\n  \"enat n < llength xs \\<Longrightarrow> lhd (ldropn n xs) = lnth xs n\"", "lemma lhd_ldrop:\n  assumes \"n < llength xs\"\n  shows \"lhd (ldrop n xs) = lnth xs (the_enat n)\"", "lemma lnth_beyond:\n  \"llength xs \\<le> enat n \\<Longrightarrow> lnth xs n = undefined (n - (case llength xs of enat m \\<Rightarrow> m))\"", "lemma lnth_lmap [simp]:\n  \"enat n < llength xs \\<Longrightarrow> lnth (lmap f xs) n = f (lnth xs n)\"", "lemma lnth_ldropn [simp]:\n  \"enat (n + m) < llength xs \\<Longrightarrow> lnth (ldropn n xs) m = lnth xs (m + n)\"", "lemma lnth_ldrop [simp]:\n  \"n + enat m < llength xs \\<Longrightarrow> lnth (ldrop n xs) m = lnth xs (m + the_enat n)\"", "lemma in_lset_conv_lnth:\n  \"x \\<in> lset xs \\<longleftrightarrow> (\\<exists>n. enat n < llength xs \\<and> lnth xs n = x)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lset_conv_lnth: \"lset xs = {lnth xs n|n. enat n < llength xs}\"", "lemma lnth_llist_of [simp]: \"lnth (llist_of xs) = nth xs\"", "lemma nth_list_of [simp]:\n  assumes \"lfinite xs\"\n  shows \"nth (list_of xs) = lnth xs\"", "lemma lnth_lappend1:\n  \"enat n < llength xs \\<Longrightarrow> lnth (lappend xs ys) n = lnth xs n\"", "lemma lnth_lappend_llist_of:\n  \"lnth (lappend (llist_of xs) ys) n =\n  (if n < length xs then xs ! n else lnth ys (n - length xs))\"", "lemma lnth_lappend2:\n  \"\\<lbrakk> llength xs = enat k; k \\<le> n \\<rbrakk> \\<Longrightarrow> lnth (lappend xs ys) n = lnth ys (n - k)\"", "lemma lnth_lappend:\n  \"lnth (lappend xs ys) n = (if enat n < llength xs then lnth xs n else lnth ys (n - the_enat (llength xs)))\"", "lemma lnth_ltake:\n  \"enat m < n \\<Longrightarrow> lnth (ltake n xs) m = lnth xs m\"", "lemma ldropn_Suc_conv_ldropn:\n  \"enat n < llength xs \\<Longrightarrow> LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs\"", "lemma ltake_Suc_conv_snoc_lnth:\n  \"enat m < llength xs \\<Longrightarrow> ltake (enat (Suc m)) xs = lappend (ltake (enat m) xs) (LCons (lnth xs m) LNil)\"", "lemma lappend_eq_lappend_conv:\n  assumes len: \"llength xs = llength us\"\n  shows \"lappend xs ys = lappend us vs \\<longleftrightarrow>\n         xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemmas iterates [code, nitpick_simp] = iterates.ctr\n  and lnull_iterates = iterates.simps(1)\n  and lhd_iterates = iterates.simps(2)\n  and ltl_iterates = iterates.simps(3)", "lemma lfinite_iterates [iff]: \"\\<not> lfinite (iterates f x)\"", "lemma lmap_iterates: \"lmap f (iterates f x) = iterates f (f x)\"", "lemma iterates_lmap: \"iterates f x = LCons x (lmap f (iterates f x))\"", "lemma lappend_iterates: \"lappend (iterates f x) xs = iterates f x\"", "lemma [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  shows lnull_funpow_lmap: \"lnull ((lmap f ^^ n) xs) \\<longleftrightarrow> lnull xs\"\n  and lhd_funpow_lmap: \"\\<not> lnull xs \\<Longrightarrow> lhd ((lmap f ^^ n) xs) = (f ^^ n) (lhd xs)\"\n  and ltl_funpow_lmap: \"\\<not> lnull xs \\<Longrightarrow> ltl ((lmap f ^^ n) xs) = (lmap f ^^ n) (ltl xs)\"", "lemma iterates_equality:\n  assumes h: \"\\<And>x. h x = LCons x (lmap f (h x))\"\n  shows \"h = iterates f\"", "lemma llength_iterates [simp]: \"llength (iterates f x) = \\<infinity>\"", "lemma ldropn_iterates: \"ldropn n (iterates f x) = iterates f ((f ^^ n) x)\"", "lemma ldrop_iterates: \"ldrop (enat n) (iterates f x) = iterates f ((f ^^ n) x)\"", "lemma lnth_iterates [simp]: \"lnth (iterates f x) n = (f ^^ n) x\"", "lemma lset_iterates:\n  \"lset (iterates f x) = {(f ^^ n) x|n. True}\"", "lemma lset_repeat [simp]: \"lset (repeat x) = {x}\"", "lemma lstrict_prefix_code [code, simp]:\n  \"lstrict_prefix LNil LNil \\<longleftrightarrow> False\"\n  \"lstrict_prefix LNil (LCons y ys) \\<longleftrightarrow> True\"\n  \"lstrict_prefix (LCons x xs) LNil \\<longleftrightarrow> False\"\n  \"lstrict_prefix (LCons x xs) (LCons y ys) \\<longleftrightarrow> x = y \\<and> lstrict_prefix xs ys\"", "lemma lmap_lprefix: \"xs \\<sqsubseteq> ys \\<Longrightarrow> lmap f xs \\<sqsubseteq> lmap f ys\"", "lemma lprefix_llength_eq_imp_eq:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; llength xs = llength ys \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma lprefix_llength_le: \"xs \\<sqsubseteq> ys \\<Longrightarrow> llength xs \\<le> llength ys\"", "lemma lstrict_prefix_llength_less:\n  assumes \"lstrict_prefix xs ys\"\n  shows \"llength xs < llength ys\"", "lemma lstrict_prefix_lfinite1: \"lstrict_prefix xs ys \\<Longrightarrow> lfinite xs\"", "lemma wfP_lstrict_prefix: \"wfP lstrict_prefix\"", "lemma llist_less_induct[case_names less]:\n  \"(\\<And>xs. (\\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys) \\<Longrightarrow> P xs) \\<Longrightarrow> P xs\"", "lemma ltake_enat_eq_imp_eq: \"(\\<And>n. ltake (enat n) xs = ltake (enat n) ys) \\<Longrightarrow> xs = ys\"", "lemma ltake_enat_lprefix_imp_lprefix:\n  assumes \"\\<And>n. lprefix (ltake (enat n) xs) (ltake (enat n) ys)\"\n  shows \"lprefix xs ys\"", "lemma lprefix_conv_lappend: \"xs \\<sqsubseteq> ys \\<longleftrightarrow> (\\<exists>zs. ys = lappend xs zs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lappend_lprefixE:\n  assumes \"lappend xs ys \\<sqsubseteq> zs\"\n  obtains zs' where \"zs = lappend xs zs'\"", "lemma lprefix_lfiniteD:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; lfinite ys \\<rbrakk> \\<Longrightarrow> lfinite xs\"", "lemma lprefix_lappendD:\n  assumes \"xs \\<sqsubseteq> lappend ys zs\"\n  shows \"xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs\"", "lemma lstrict_prefix_lappend_conv:\n  \"lstrict_prefix xs (lappend xs ys) \\<longleftrightarrow> lfinite xs \\<and> \\<not> lnull ys\"", "lemma lprefix_llist_ofI:\n  \"\\<exists>zs. ys = xs @ zs \\<Longrightarrow> llist_of xs \\<sqsubseteq> llist_of ys\"", "lemma lprefix_llist_of [simp]: \"llist_of xs \\<sqsubseteq> llist_of ys \\<longleftrightarrow> prefix xs ys\"", "lemma llimit_induct [case_names LNil LCons limit]:\n  \\<comment> \\<open>The limit case is just an instance of admissibility\\<close>\n  assumes LNil: \"P LNil\"\n  and LCons: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x xs)\"\n  and limit: \"(\\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys) \\<Longrightarrow> P xs\"\n  shows \"P xs\"", "lemma lmap_lstrict_prefix:\n  \"lstrict_prefix xs ys \\<Longrightarrow> lstrict_prefix (lmap f xs) (lmap f ys)\"", "lemma lprefix_lnthD:\n  assumes \"xs \\<sqsubseteq> ys\" and \"enat n < llength xs\"\n  shows \"lnth xs n = lnth ys n\"", "lemma lfinite_lSup_chain:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) A\"\n  shows \"lfinite (lSup A) \\<longleftrightarrow> finite A \\<and> (\\<forall>xs \\<in> A. lfinite xs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma finite_lprefix_nitpick_simps [nitpick_simp]:\n  \"finite_lprefix xs LNil \\<longleftrightarrow> xs = LNil\"\n  \"finite_lprefix LNil xs \\<longleftrightarrow> True\"\n  \"finite_lprefix xs (LCons y ys) \\<longleftrightarrow>\n   xs = LNil \\<or> (\\<exists>xs'. xs = LCons y xs' \\<and> finite_lprefix xs' ys)\"", "lemma lprefix_nitpick_simps [nitpick_simp]:\n  \"xs \\<sqsubseteq> ys = (if lfinite xs then finite_lprefix xs ys else xs = ys)\"", "lemma llcp_simps [simp, code, nitpick_simp]:\n  shows llcp_LNil1: \"llcp LNil ys = 0\"\n  and llcp_LNil2: \"llcp xs LNil = 0\"\n  and llcp_LCons: \"llcp (LCons x xs) (LCons y ys) = (if x = y then eSuc (llcp xs ys) else 0)\"", "lemma llcp_eq_0_iff:\n  \"llcp xs ys = 0 \\<longleftrightarrow> lnull xs \\<or> lnull ys \\<or> lhd xs \\<noteq> lhd ys\"", "lemma epred_llcp:\n  \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys; lhd xs = lhd ys \\<rbrakk>\n  \\<Longrightarrow>  epred (llcp xs ys) = llcp (ltl xs) (ltl ys)\"", "lemma llcp_commute: \"llcp xs ys = llcp ys xs\"", "lemma llcp_same_conv_length [simp]: \"llcp xs xs = llength xs\"", "lemma llcp_lappend_same [simp]:\n  \"llcp (lappend xs ys) (lappend xs zs) = llength xs + llcp ys zs\"", "lemma llcp_lprefix1 [simp]: \"xs \\<sqsubseteq> ys \\<Longrightarrow> llcp xs ys = llength xs\"", "lemma llcp_lprefix2 [simp]: \"ys \\<sqsubseteq> xs \\<Longrightarrow> llcp xs ys = llength ys\"", "lemma llcp_le_length: \"llcp xs ys \\<le> min (llength xs) (llength ys)\"", "lemma llcp_ltake1: \"llcp (ltake n xs) ys = min n (llcp xs ys)\"", "lemma llcp_ltake2: \"llcp xs (ltake n ys) = min n (llcp xs ys)\"", "lemma llcp_ltake [simp]: \"llcp (ltake n xs) (ltake m ys) = min (min n m) (llcp xs ys)\"", "lemma lzip_simps [simp, code, nitpick_simp]:\n  \"lzip LNil ys = LNil\"\n  \"lzip xs LNil = LNil\"\n  \"lzip (LCons x xs) (LCons y ys) = LCons (x, y) (lzip xs ys)\"", "lemma lnull_lzip [simp]: \"lnull (lzip xs ys) \\<longleftrightarrow> lnull xs \\<or> lnull ys\"", "lemma lzip_eq_LNil_conv: \"lzip xs ys = LNil \\<longleftrightarrow> xs = LNil \\<or> ys = LNil\"", "lemmas lhd_lzip = lzip.sel(1)\n  and ltl_lzip = lzip.sel(2)", "lemma lzip_eq_LCons_conv:\n  \"lzip xs ys = LCons z zs \\<longleftrightarrow>\n   (\\<exists>x xs' y ys'. xs = LCons x xs' \\<and> ys = LCons y ys' \\<and> z = (x, y) \\<and> zs = lzip xs' ys')\"", "lemma lzip_lappend:\n  \"llength xs = llength us\n  \\<Longrightarrow> lzip (lappend xs ys) (lappend us vs) = lappend (lzip xs us) (lzip ys vs)\"", "lemma llength_lzip [simp]:\n  \"llength (lzip xs ys) = min (llength xs) (llength ys)\"", "lemma ltake_lzip: \"ltake n (lzip xs ys) = lzip (ltake n xs) (ltake n ys)\"", "lemma ldropn_lzip [simp]:\n  \"ldropn n (lzip xs ys) = lzip (ldropn n xs) (ldropn n ys)\"", "lemma\n  fixes F\n  defines \"F \\<equiv> \\<lambda>lzip (xs, ys). case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> case ys of LNil \\<Rightarrow> LNil | LCons y ys' \\<Rightarrow> LCons (x, y) (curry lzip xs' ys')\"\n  shows lzip_conv_fixp: \"lzip \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) F)\" (is \"?lhs \\<equiv> ?rhs\")\n  and lzip_mono: \"mono_llist (\\<lambda>lzip. F lzip xs)\" (is \"?mono xs\")", "lemma monotone_lzip: \"monotone (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod lzip)\"", "lemma mono2mono_lzip1 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lzip1: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. lzip xs ys)\"", "lemma mono2mono_lzip2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lzip2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>ys. lzip xs ys)\"", "lemma mcont_lzip: \"mcont (prod_lub lSup lSup) (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod lzip)\"", "lemma mcont2mcont_lzip1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lzip1: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. lzip xs ys)\"", "lemma mcont2mcont_lzip2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lzip2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>ys. lzip xs ys)\"", "lemma ldrop_lzip [simp]: \"ldrop n (lzip xs ys) = lzip (ldrop n xs) (ldrop n ys)\"", "lemma lzip_iterates:\n  \"lzip (iterates f x) (iterates g y) = iterates (\\<lambda>(x, y). (f x, g y)) (x, y)\"", "lemma lzip_llist_of [simp]:\n  \"lzip (llist_of xs) (llist_of ys) = llist_of (zip xs ys)\"", "lemma lnth_lzip:\n  \"\\<lbrakk> enat n < llength xs; enat n < llength ys \\<rbrakk>\n  \\<Longrightarrow> lnth (lzip xs ys) n = (lnth xs n, lnth ys n)\"", "lemma lset_lzip:\n  \"lset (lzip xs ys) =\n   {(lnth xs n, lnth ys n)|n. enat n < min (llength xs) (llength ys)}\"", "lemma lset_lzipD1: \"(x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> x \\<in> lset xs\"", "lemma lset_lzipD2: \"(x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> y \\<in> lset ys\"", "lemma lset_lzip_same [simp]: \"lset (lzip xs xs) = (\\<lambda>x. (x, x)) ` lset xs\"", "lemma lfinite_lzip [simp]:\n  \"lfinite (lzip xs ys) \\<longleftrightarrow> lfinite xs \\<or> lfinite ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lzip_eq_lappend_conv:\n  assumes eq: \"lzip xs ys = lappend us vs\"\n  shows \"\\<exists>xs' xs'' ys' ys''. xs = lappend xs' xs'' \\<and> ys = lappend ys' ys'' \\<and>\n                             llength xs' = llength ys' \\<and> us = lzip xs' ys' \\<and>\n                             vs = lzip xs'' ys''\"", "lemma lzip_lmap [simp]:\n  \"lzip (lmap f xs) (lmap g ys) = lmap (\\<lambda>(x, y). (f x, g y)) (lzip xs ys)\"", "lemma lzip_lmap1:\n  \"lzip (lmap f xs) ys = lmap (\\<lambda>(x, y). (f x, y)) (lzip xs ys)\"", "lemma lzip_lmap2:\n  \"lzip xs (lmap f ys) = lmap (\\<lambda>(x, y). (x, f y)) (lzip xs ys)\"", "lemma lmap_fst_lzip_conv_ltake:\n  \"lmap fst (lzip xs ys) = ltake (min (llength xs) (llength ys)) xs\"", "lemma lmap_snd_lzip_conv_ltake:\n  \"lmap snd (lzip xs ys) = ltake (min (llength xs) (llength ys)) ys\"", "lemma lzip_conv_lzip_ltake_min_llength:\n  \"lzip xs ys =\n  lzip (ltake (min (llength xs) (llength ys)) xs)\n       (ltake (min (llength xs) (llength ys)) ys)\"", "lemma ltakeWhile_simps [simp, code, nitpick_simp]:\n  shows ltakeWhile_LNil: \"ltakeWhile P LNil = LNil\"\n  and ltakeWhile_LCons: \"ltakeWhile P (LCons x xs) = (if P x then LCons x (ltakeWhile P xs) else LNil)\"", "lemma ldropWhile_simps [simp, code]:\n  shows ldropWhile_LNil: \"ldropWhile P LNil = LNil\"\n  and ldropWhile_LCons: \"ldropWhile P (LCons x xs) = (if P x then ldropWhile P xs else LCons x xs)\"", "lemma fixes f F P\n  defines \"F \\<equiv> \\<lambda>ltakeWhile xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> if P x then LCons x (ltakeWhile xs) else LNil\"\n  shows ltakeWhile_conv_fixp: \"ltakeWhile P \\<equiv> ccpo.fixp (fun_lub lSup) (fun_ord lprefix) F\" (is \"?lhs \\<equiv> ?rhs\")\n  and ltakeWhile_mono: \"\\<And>xs. mono_llist (\\<lambda>ltakeWhile. F ltakeWhile xs)\" (is \"PROP ?mono\")", "lemma mono2mono_ltakeWhile[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltakeWhile: \"monotone lprefix lprefix (ltakeWhile P)\"", "lemma mcont2mcont_ltakeWhile [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltakeWhile: \"mcont lSup lprefix lSup lprefix (ltakeWhile P)\"", "lemma mono_llist_ltakeWhile [partial_function_mono]:\n  \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. ltakeWhile P (F f))\"", "lemma mono2mono_ldropWhile [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldropWhile: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldropWhile P)\"", "lemma mcont2mcont_ldropWhile [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldropWhile: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldropWhile P)\"", "lemma lnull_ltakeWhile [simp]: \"lnull (ltakeWhile P xs) \\<longleftrightarrow> (\\<not> lnull xs \\<longrightarrow> \\<not> P (lhd xs))\"", "lemma ltakeWhile_eq_LNil_iff: \"ltakeWhile P xs = LNil \\<longleftrightarrow> (xs \\<noteq> LNil \\<longrightarrow> \\<not> P (lhd xs))\"", "lemmas lhd_ltakeWhile = ltakeWhile.sel(1)", "lemma ltl_ltakeWhile:\n  \"ltl (ltakeWhile P xs) = (if P (lhd xs) then ltakeWhile P (ltl xs) else LNil)\"", "lemma lprefix_ltakeWhile: \"ltakeWhile P xs \\<sqsubseteq> xs\"", "lemma llength_ltakeWhile_le: \"llength (ltakeWhile P xs) \\<le> llength xs\"", "lemma ltakeWhile_nth: \"enat i < llength (ltakeWhile P xs) \\<Longrightarrow> lnth (ltakeWhile P xs) i = lnth xs i\"", "lemma ltakeWhile_all: \"\\<forall>x\\<in>lset xs. P x \\<Longrightarrow> ltakeWhile P xs = xs\"", "lemma lset_ltakeWhileD:\n  assumes \"x \\<in> lset (ltakeWhile P xs)\"\n  shows \"x \\<in> lset xs \\<and> P x\"", "lemma lset_ltakeWhile_subset:\n  \"lset (ltakeWhile P xs) \\<subseteq> lset xs \\<inter> {x. P x}\"", "lemma ltakeWhile_all_conv: \"ltakeWhile P xs = xs \\<longleftrightarrow> lset xs \\<subseteq> {x. P x}\"", "lemma llength_ltakeWhile_all: \"llength (ltakeWhile P xs) = llength xs \\<longleftrightarrow> ltakeWhile P xs = xs\"", "lemma ldropWhile_eq_LNil_iff: \"ldropWhile P xs = LNil \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\"", "lemma lnull_ldropWhile [simp]:\n  \"lnull (ldropWhile P xs) \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lset_ldropWhile_subset:\n  \"lset (ldropWhile P xs) \\<subseteq> lset xs\"", "lemma in_lset_ldropWhileD: \"x \\<in> lset (ldropWhile P xs) \\<Longrightarrow> x \\<in> lset xs\"", "lemma ltakeWhile_lmap: \"ltakeWhile P (lmap f xs) = lmap f (ltakeWhile (P \\<circ> f) xs)\"", "lemma ldropWhile_lmap: \"ldropWhile P (lmap f xs) = lmap f (ldropWhile (P \\<circ> f) xs)\"", "lemma llength_ltakeWhile_lt_iff: \"llength (ltakeWhile P xs) < llength xs \\<longleftrightarrow> (\\<exists>x\\<in>lset xs. \\<not> P x)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma ltakeWhile_K_False [simp]: \"ltakeWhile (\\<lambda>_. False) xs = LNil\"", "lemma ltakeWhile_K_True [simp]: \"ltakeWhile (\\<lambda>_. True) xs = xs\"", "lemma ldropWhile_K_False [simp]: \"ldropWhile (\\<lambda>_. False) = id\"", "lemma ldropWhile_K_True [simp]: \"ldropWhile (\\<lambda>_. True) xs = LNil\"", "lemma lappend_ltakeWhile_ldropWhile [simp]:\n  \"lappend (ltakeWhile P xs) (ldropWhile P xs) = xs\"", "lemma ltakeWhile_lappend:\n  \"ltakeWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n   else lappend xs (ltakeWhile P ys))\"", "lemma ldropWhile_lappend:\n  \"ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\"", "lemma lfinite_ltakeWhile:\n  \"lfinite (ltakeWhile P xs) \\<longleftrightarrow> lfinite xs \\<or> (\\<exists>x \\<in> lset xs. \\<not> P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma llength_ltakeWhile_eq_infinity:\n  \"llength (ltakeWhile P xs) = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs \\<and> ltakeWhile P xs = xs\"", "lemma llength_ltakeWhile_eq_infinity':\n  \"llength (ltakeWhile P xs) = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs \\<and> (\\<forall>x\\<in>lset xs. P x)\"", "lemma lzip_ltakeWhile_fst: \"lzip (ltakeWhile P xs) ys = ltakeWhile (P \\<circ> fst) (lzip xs ys)\"", "lemma lzip_ltakeWhile_snd: \"lzip xs (ltakeWhile P ys) = ltakeWhile (P \\<circ> snd) (lzip xs ys)\"", "lemma ltakeWhile_lappend1:\n  \"\\<lbrakk> x \\<in> lset xs; \\<not> P x \\<rbrakk> \\<Longrightarrow> ltakeWhile P (lappend xs ys) = ltakeWhile P xs\"", "lemma ltakeWhile_lappend2:\n  \"lset xs \\<subseteq> {x. P x}\n  \\<Longrightarrow> ltakeWhile P (lappend xs ys) = lappend xs (ltakeWhile P ys)\"", "lemma ltakeWhile_cong [cong, fundef_cong]:\n  assumes xs: \"xs = ys\"\n  and PQ: \"\\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x\"\n  shows \"ltakeWhile P xs = ltakeWhile Q ys\"", "lemma lnth_llength_ltakeWhile:\n  assumes len: \"llength (ltakeWhile P xs) < llength xs\"\n  shows \"\\<not> P (lnth xs (the_enat (llength (ltakeWhile P xs))))\"", "lemma assumes \"\\<exists>x\\<in>lset xs. \\<not> P x\"\n  shows lhd_ldropWhile: \"\\<not> P (lhd (ldropWhile P xs))\" (is ?thesis1)\n  and lhd_ldropWhile_in_lset: \"lhd (ldropWhile P xs) \\<in> lset xs\" (is ?thesis2)", "lemma ldropWhile_eq_ldrop:\n  \"ldropWhile P xs = ldrop (llength (ltakeWhile P xs)) xs\"\n  (is \"?lhs = ?rhs\")", "lemma ldropWhile_cong [cong]:\n  \"\\<lbrakk> xs = ys; \\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x \\<rbrakk> \\<Longrightarrow> ldropWhile P xs = ldropWhile Q ys\"", "lemma ltakeWhile_repeat:\n  \"ltakeWhile P (repeat x) = (if P x then repeat x else LNil)\"", "lemma ldropWhile_repeat: \"ldropWhile P (repeat x) = (if P x then LNil else repeat x)\"", "lemma lfinite_ldropWhile: \"lfinite (ldropWhile P xs) \\<longleftrightarrow> (\\<exists>x \\<in> lset xs. \\<not> P x) \\<longrightarrow> lfinite xs\"", "lemma llength_ldropWhile:\n  \"llength (ldropWhile P xs) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then llength xs - llength (ltakeWhile P xs) else 0)\"", "lemma lhd_ldropWhile_conv_lnth:\n  \"\\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lhd (ldropWhile P xs) = lnth xs (the_enat (llength (ltakeWhile P xs)))\"", "lemmas llist_all2_LNil_LNil = llist.rel_inject(1)", "lemmas llist_all2_LNil_LCons = llist.rel_distinct(1)", "lemmas llist_all2_LCons_LNil = llist.rel_distinct(2)", "lemmas llist_all2_LCons_LCons = llist.rel_inject(2)", "lemma llist_all2_LNil1 [simp]: \"llist_all2 P LNil xs \\<longleftrightarrow> xs = LNil\"", "lemma llist_all2_LNil2 [simp]: \"llist_all2 P xs LNil \\<longleftrightarrow> xs = LNil\"", "lemma llist_all2_LCons1:\n  \"llist_all2 P (LCons x xs) ys \\<longleftrightarrow> (\\<exists>y ys'. ys = LCons y ys' \\<and> P x y \\<and> llist_all2 P xs ys')\"", "lemma llist_all2_LCons2:\n  \"llist_all2 P xs (LCons y ys) \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs' \\<and> P x y \\<and> llist_all2 P xs' ys)\"", "lemma llist_all2_llist_of [simp]:\n  \"llist_all2 P (llist_of xs) (llist_of ys) = list_all2 P xs ys\"", "lemma llist_all2_conv_lzip:\n  \"llist_all2 P xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>(x, y) \\<in> lset (lzip xs ys). P x y)\"", "lemma llist_all2_llengthD:\n  \"llist_all2 P xs ys \\<Longrightarrow> llength xs = llength ys\"", "lemma llist_all2_lnullD: \"llist_all2 P xs ys \\<Longrightarrow> lnull xs \\<longleftrightarrow> lnull ys\"", "lemma llist_all2_all_lnthI:\n  \"\\<lbrakk> llength xs = llength ys;\n     \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n) \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs ys\"", "lemma llist_all2_lnthD:\n  \"\\<lbrakk> llist_all2 P xs ys; enat n < llength xs \\<rbrakk> \\<Longrightarrow> P (lnth xs n) (lnth ys n)\"", "lemma llist_all2_lnthD2:\n  \"\\<lbrakk> llist_all2 P xs ys; enat n < llength ys \\<rbrakk> \\<Longrightarrow> P (lnth xs n) (lnth ys n)\"", "lemma llist_all2_conv_all_lnth:\n  \"llist_all2 P xs ys \\<longleftrightarrow>\n   llength xs = llength ys \\<and>\n   (\\<forall>n. enat n < llength ys \\<longrightarrow> P (lnth xs n) (lnth ys n))\"", "lemma llist_all2_True [simp]: \"llist_all2 (\\<lambda>_ _. True) xs ys \\<longleftrightarrow> llength xs = llength ys\"", "lemma llist_all2_reflI:\n  \"(\\<And>x. x \\<in> lset xs \\<Longrightarrow> P x x) \\<Longrightarrow> llist_all2 P xs xs\"", "lemma llist_all2_lmap1:\n  \"llist_all2 P (lmap f xs) ys \\<longleftrightarrow> llist_all2 (\\<lambda>x. P (f x)) xs ys\"", "lemma llist_all2_lmap2:\n  \"llist_all2 P xs (lmap g ys) \\<longleftrightarrow> llist_all2 (\\<lambda>x y. P x (g y)) xs ys\"", "lemma llist_all2_lfiniteD:\n  \"llist_all2 P xs ys \\<Longrightarrow> lfinite xs \\<longleftrightarrow> lfinite ys\"", "lemma llist_all2_coinduct[consumes 1, case_names LNil LCons, case_conclusion LCons lhd ltl, coinduct pred]:\n  assumes major: \"X xs ys\"\n  and step:\n  \"\\<And>xs ys. X xs ys \\<Longrightarrow> lnull xs \\<longleftrightarrow> lnull ys\"\n  \"\\<And>xs ys. \\<lbrakk> X xs ys; \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and> (X (ltl xs) (ltl ys) \\<or> llist_all2 P (ltl xs) (ltl ys))\"\n  shows \"llist_all2 P xs ys\"", "lemma llist_all2_cases[consumes 1, case_names LNil LCons, cases pred]:\n  assumes \"llist_all2 P xs ys\"\n  obtains (LNil) \"xs = LNil\" \"ys = LNil\"\n  | (LCons) x xs' y ys'\n    where \"xs = LCons x xs'\" and \"ys = LCons y ys'\"\n    and \"P x y\" and \"llist_all2 P xs' ys'\"", "lemma llist_all2_mono:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<And>x y. P x y \\<Longrightarrow> P' x y \\<rbrakk> \\<Longrightarrow> llist_all2 P' xs ys\"", "lemma llist_all2_left: \"llist_all2 (\\<lambda>x _. P x) xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>x\\<in>lset xs. P x)\"", "lemma llist_all2_right: \"llist_all2 (\\<lambda>_. P) xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>x\\<in>lset ys. P x)\"", "lemma llist_all2_lsetD1: \"\\<lbrakk> llist_all2 P xs ys; x \\<in> lset xs \\<rbrakk> \\<Longrightarrow> \\<exists>y\\<in>lset ys. P x y\"", "lemma llist_all2_lsetD2: \"\\<lbrakk> llist_all2 P xs ys; y \\<in> lset ys \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>lset xs. P x y\"", "lemma llist_all2_conj:\n  \"llist_all2 (\\<lambda>x y. P x y \\<and> Q x y) xs ys \\<longleftrightarrow> llist_all2 P xs ys \\<and> llist_all2 Q xs ys\"", "lemma llist_all2_lhdD:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys)\"", "lemma llist_all2_lhdD2:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys)\"", "lemma llist_all2_ltlI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ltl xs) (ltl ys)\"", "lemma llist_all2_lappendI:\n  assumes 1: \"llist_all2 P xs ys\"\n  and 2: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> llist_all2 P xs' ys'\"\n  shows \"llist_all2 P (lappend xs xs') (lappend ys ys')\"", "lemma llist_all2_lappend1D:\n  assumes \"llist_all2 P (lappend xs xs') ys\"\n  shows \"llist_all2 P xs (ltake (llength xs) ys)\"\n  and \"lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)\"", "lemma lmap_eq_lmap_conv_llist_all2:\n  \"lmap f xs = lmap g ys \\<longleftrightarrow> llist_all2 (\\<lambda>x y. f x = g y) xs ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma llist_all2_expand:\n  \"\\<lbrakk> lnull xs \\<longleftrightarrow> lnull ys;\n     \\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and> llist_all2 P (ltl xs) (ltl ys) \\<rbrakk>\n   \\<Longrightarrow> llist_all2 P xs ys\"", "lemma llist_all2_llength_ltakeWhileD:\n  assumes major: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llength (ltakeWhile Q1 xs) = llength (ltakeWhile Q2 ys)\"", "lemma llist_all2_lzipI:\n  \"\\<lbrakk> llist_all2 P xs ys; llist_all2 P' xs' ys' \\<rbrakk>\n  \\<Longrightarrow> llist_all2 (rel_prod P P') (lzip xs xs') (lzip ys ys')\"", "lemma llist_all2_ltakeI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ltake n xs) (ltake n ys)\"", "lemma llist_all2_ldropnI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ldropn n xs) (ldropn n ys)\"", "lemma llist_all2_ldropI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ldrop n xs) (ldrop n ys)\"", "lemma llist_all2_lSupI:\n  assumes \"Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\" \"\\<forall>(xs, ys)\\<in>Y. llist_all2 P xs ys\"\n  shows \"llist_all2 P (lSup (fst ` Y)) (lSup (snd ` Y))\"", "lemma admissible_llist_all2 [cont_intro, simp]:\n  assumes f: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  and g: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. g x)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. llist_all2 P (f x) (g x))\"", "lemmas [cont_intro] =\n  ccpo.mcont2mcont[OF llist_ccpo _ mcont_fst]\n  ccpo.mcont2mcont[OF llist_ccpo _ mcont_snd]", "lemmas ldropWhile_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    ldropWhile.mono ldropWhile.mono ldropWhile_def ldropWhile_def, case_names adm LNil step]", "lemma llist_all2_ldropWhileI:\n  assumes *: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llist_all2 P (ldropWhile Q1 xs) (ldropWhile Q2 ys)\"\n\\<comment> \\<open>cannot prove this with parallel induction over @{term xs} and @{term ys}\n  because @{term \"\\<lambda>x. \\<not> llist_all2 P (f x) (g x)\"} is not admissible.\\<close>", "lemma llist_all2_same [simp]: \"llist_all2 P xs xs \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. P x x)\"", "lemma llist_all2_trans:\n  \"\\<lbrakk> llist_all2 P xs ys; llist_all2 P ys zs; transp P \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs zs\"", "lemma llast_LNil: \"llast LNil = undefined\"", "lemma llast_LCons: \"llast (LCons x xs) = (if lnull xs then x else llast xs)\"", "lemma llast_linfinite: \"\\<not> lfinite xs \\<Longrightarrow> llast xs = undefined\"", "lemma [simp, code]:\n  shows llast_singleton: \"llast (LCons x LNil) = x\"\n  and llast_LCons2: \"llast (LCons x (LCons y xs)) = llast (LCons y xs)\"", "lemma llast_lappend:\n  \"llast (lappend xs ys) = (if lnull ys then llast xs else if lfinite xs then llast ys else undefined)\"", "lemma llast_lappend_LCons [simp]:\n  \"lfinite xs \\<Longrightarrow> llast (lappend xs (LCons y ys)) = llast (LCons y ys)\"", "lemma llast_ldropn: \"enat n < llength xs \\<Longrightarrow> llast (ldropn n xs) = llast xs\"", "lemma llast_ldrop:\n  assumes \"n < llength xs\"\n  shows \"llast (ldrop n xs) = llast xs\"", "lemma llast_llist_of [simp]: \"llast (llist_of xs) = last xs\"", "lemma llast_conv_lnth: \"llength xs = eSuc (enat n) \\<Longrightarrow> llast xs = lnth xs n\"", "lemma llast_lmap:\n  assumes \"lfinite xs\" \"\\<not> lnull xs\"\n  shows \"llast (lmap f xs) = f (llast xs)\"", "lemma ldistinct_LNil_code [code]:\n  \"ldistinct LNil = True\"", "lemma ldistinct_llist_of [simp]:\n  \"ldistinct (llist_of xs) \\<longleftrightarrow> distinct xs\"", "lemma ldistinct_coinduct [consumes 1, case_names ldistinct, case_conclusion ldistinct lhd ltl, coinduct pred: ldistinct]:\n  assumes \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs \\<rbrakk>\n    \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and> (X (ltl xs) \\<or> ldistinct (ltl xs))\"\n  shows \"ldistinct xs\"", "lemma ldistinct_lhdD:\n  \"\\<lbrakk> ldistinct xs; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs)\"", "lemma ldistinct_ltlI:\n  \"ldistinct xs \\<Longrightarrow> ldistinct (ltl xs)\"", "lemma ldistinct_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) Y; \\<forall>xs\\<in>Y. ldistinct xs \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lSup Y)\"", "lemma admissible_ldistinct [cont_intro, simp]:\n  assumes mcont: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. ldistinct (f x))\"", "lemma ldistinct_lappend:\n  \"ldistinct (lappend xs ys) \\<longleftrightarrow> ldistinct xs \\<and> (lfinite xs \\<longrightarrow> ldistinct ys \\<and> lset xs \\<inter> lset ys = {})\"\n  (is \"?lhs = ?rhs\")", "lemma ldistinct_lprefix:\n  \"\\<lbrakk> ldistinct xs; ys \\<sqsubseteq> xs \\<rbrakk> \\<Longrightarrow> ldistinct ys\"", "lemma admissible_not_ldistinct[THEN admissible_subst, cont_intro, simp]:\n  \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>x. \\<not> ldistinct x)\"", "lemma ldistinct_ltake: \"ldistinct xs \\<Longrightarrow> ldistinct (ltake n xs)\"", "lemma ldistinct_ldropn:\n  \"ldistinct xs \\<Longrightarrow> ldistinct (ldropn n xs)\"", "lemma ldistinct_ldrop: \"ldistinct xs \\<Longrightarrow> ldistinct (ldrop n xs)\"", "lemma ldistinct_conv_lnth:\n  \"ldistinct xs \\<longleftrightarrow> (\\<forall>i j. enat i < llength xs \\<longrightarrow> enat j < llength xs \\<longrightarrow> i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma ldistinct_lmap [simp]:\n  \"ldistinct (lmap f xs) \\<longleftrightarrow> ldistinct xs \\<and> inj_on f (lset xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma ldistinct_lzipI1: \"ldistinct xs \\<Longrightarrow> ldistinct (lzip xs ys)\"", "lemma ldistinct_lzipI2: \"ldistinct ys \\<Longrightarrow> ldistinct (lzip xs ys)\"", "lemma lsorted_coinduct' [consumes 1, case_names lsorted, case_conclusion lsorted lhd ltl, coinduct pred: lsorted]:\n  assumes major: \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs; \\<not> lnull (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> lhd (ltl xs) \\<and> (X (ltl xs) \\<or> lsorted (ltl xs))\"\n  shows \"lsorted xs\"", "lemma lsorted_ltlI: \"lsorted xs \\<Longrightarrow> lsorted (ltl xs)\"", "lemma lsorted_lhdD:\n  \"\\<lbrakk> lsorted xs; \\<not> lnull xs; \\<not> lnull (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> lhd (ltl xs)\"", "lemma lsorted_LCons':\n  \"lsorted (LCons x xs) \\<longleftrightarrow> (\\<not> lnull xs \\<longrightarrow> x \\<le> lhd xs \\<and> lsorted xs)\"", "lemma lsorted_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) Y; \\<forall>xs \\<in> Y. lsorted xs \\<rbrakk>\n  \\<Longrightarrow> lsorted (lSup Y)\"", "lemma lsorted_lprefixD:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; lsorted ys \\<rbrakk> \\<Longrightarrow> lsorted xs\"", "lemma admissible_lsorted [cont_intro, simp]:\n  assumes mcont: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. lsorted (f x))\"", "lemma admissible_not_lsorted[THEN admissible_subst, cont_intro, simp]:\n  \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>xs. \\<not> lsorted xs)\"", "lemma lsorted_ltake [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ltake n xs)\"", "lemma lsorted_ldropn [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ldropn n xs)\"", "lemma lsorted_ldrop [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ldrop n xs)\"", "lemma lsorted_LCons:\n  \"lsorted (LCons x xs) \\<longleftrightarrow> lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lsorted_coinduct [consumes 1, case_names lsorted, case_conclusion lsorted lhd ltl, coinduct pred: lsorted]:\n  assumes major: \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> (\\<forall>x \\<in> lset (ltl xs). lhd xs \\<le> x) \\<and> (X (ltl xs) \\<or> lsorted (ltl xs))\"\n  shows \"lsorted xs\"", "lemma lsortedD: \"\\<lbrakk> lsorted xs; \\<not> lnull xs; y \\<in> lset (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> y\"", "lemma lsorted_lmap':\n  assumes \"ord.lsorted orda xs\" \"monotone orda ordb f\"\n  shows \"ord.lsorted ordb (lmap f xs)\"", "lemma lsorted_lmap:\n  assumes \"lsorted xs\" \"monotone (\\<le>) (\\<le>) f\"\n  shows \"lsorted (lmap f xs)\"", "lemma lsorted_ldistinct_lset_unique:\n  \"\\<lbrakk> lsorted xs; ldistinct xs; lsorted ys; ldistinct ys; lset xs = lset ys \\<rbrakk>\n  \\<Longrightarrow> xs = ys\"", "lemma lsorted_llist_of[simp]: \"lsorted (llist_of xs) \\<longleftrightarrow> sorted xs\"", "lemma llexord_coinduct [consumes 1, case_names llexord, coinduct pred: llexord]:\n  assumes X: \"X xs ys\"\n  and step: \"\\<And>xs ys. \\<lbrakk> X xs ys; \\<not> lnull xs \\<rbrakk>\n    \\<Longrightarrow> \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow> r (lhd xs) (lhd ys) \\<or>\n                     lhd xs = lhd ys \\<and> (X (ltl xs) (ltl ys) \\<or> llexord r (ltl xs) (ltl ys)))\"\n  shows \"llexord r xs ys\"", "lemma llexord_refl [simp, intro!]:\n  \"llexord r xs xs\"", "lemma llexord_LCons_LCons [simp]:\n  \"llexord r (LCons x xs) (LCons y ys) \\<longleftrightarrow> (x = y \\<and> llexord r xs ys \\<or> r x y)\"", "lemma lnull_llexord [simp]: \"lnull xs \\<Longrightarrow> llexord r xs ys\"", "lemma llexord_LNil_right [simp]:\n  \"lnull ys \\<Longrightarrow> llexord r xs ys \\<longleftrightarrow> lnull xs\"", "lemma llexord_LCons_left:\n  \"llexord r (LCons x xs) ys \\<longleftrightarrow>\n   (\\<exists>y ys'. ys = LCons y ys' \\<and> (x = y \\<and> llexord r xs ys' \\<or> r x y))\"", "lemma lprefix_imp_llexord:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"llexord r xs ys\"", "lemma llexord_empty:\n  \"llexord (\\<lambda>x y. False) xs ys = xs \\<sqsubseteq> ys\"", "lemma llexord_append_right:\n  \"llexord r xs (lappend xs ys)\"", "lemma llexord_lappend_leftI:\n  assumes \"llexord r ys zs\"\n  shows \"llexord r (lappend xs ys) (lappend xs zs)\"", "lemma llexord_lappend_leftD:\n  assumes lex: \"llexord r (lappend xs ys) (lappend xs zs)\"\n  and fin: \"lfinite xs\"\n  and irrefl: \"!!x. x \\<in> lset xs \\<Longrightarrow> \\<not> r x x\"\n  shows \"llexord r ys zs\"", "lemma llexord_lappend_left:\n  \"\\<lbrakk> lfinite xs; !!x. x \\<in> lset xs \\<Longrightarrow> \\<not> r x x \\<rbrakk>\n  \\<Longrightarrow> llexord r (lappend xs ys) (lappend xs zs) \\<longleftrightarrow> llexord r ys zs\"", "lemma antisym_llexord:\n  assumes r: \"antisymp r\"\n  and irrefl: \"\\<And>x. \\<not> r x x\"\n  shows \"antisymp (llexord r)\"", "lemma llexord_antisym:\n  \"\\<lbrakk> llexord r xs ys; llexord r ys xs;\n    !!a b. \\<lbrakk> r a b; r b a \\<rbrakk> \\<Longrightarrow> False \\<rbrakk>\n  \\<Longrightarrow> xs = ys\"", "lemma llexord_trans:\n  assumes 1: \"llexord r xs ys\"\n  and 2: \"llexord r ys zs\"\n  and trans: \"!!a b c. \\<lbrakk> r a b; r b c \\<rbrakk> \\<Longrightarrow> r a c\"\n  shows \"llexord r xs zs\"", "lemma trans_llexord:\n  \"transp r \\<Longrightarrow> transp (llexord r)\"", "lemma llexord_linear:\n  assumes linear: \"!!x y. r x y \\<or> x = y \\<or> r y x\"\n  shows \"llexord r xs ys \\<or> llexord r ys xs\"", "lemma llexord_code [code]:\n  \"llexord r LNil ys = True\"\n  \"llexord r (LCons x xs) LNil = False\"\n  \"llexord r (LCons x xs) (LCons y ys) = (r x y \\<or> x = y \\<and> llexord r xs ys)\"", "lemma llexord_conv:\n \"llexord r xs ys \\<longleftrightarrow>\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'. lfinite zs \\<and> xs = lappend zs xs' \\<and> ys = lappend zs (LCons y ys') \\<and>\n                  (xs' = LNil \\<or> r (lhd xs') y))\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma llexord_conv_ltake_index:\n  \"llexord r xs ys \\<longleftrightarrow>\n   (llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs) \\<or>\n   (\\<exists>n. enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n))\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma llexord_llist_of:\n  \"llexord r (llist_of xs) (llist_of ys) \\<longleftrightarrow>\n   xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lfilter_code [simp, code]:\n  shows lfilter_LNil: \"lfilter P LNil = LNil\"\n  and lfilter_LCons: \"lfilter P (LCons x xs) = (if P x then LCons x (lfilter P xs) else lfilter P xs)\"", "lemma mono2mono_lfilter[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lfilter: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lfilter P)\"", "lemma mcont2mcont_lfilter[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lfilter: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lfilter P)\"", "lemma lfilter_mono [partial_function_mono]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lfilter P (A f))\"", "lemma lfilter_LCons_seek: \"~ (p x) ==> lfilter p (LCons x l) = lfilter p l\"", "lemma lfilter_LCons_found:\n  \"P x \\<Longrightarrow> lfilter P (LCons x xs) = LCons x (lfilter P xs)\"", "lemma lfilter_eq_LNil: \"lfilter P xs = LNil \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. \\<not> P x)\"", "lemma diverge_lfilter_LNil [simp]: \"\\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil\"", "lemmas lfilter_False = diverge_lfilter_LNil", "lemma lnull_lfilter [simp]: \"lnull (lfilter P xs) \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. \\<not> P x)\"", "lemmas lfilter_empty_conv = lfilter_eq_LNil", "lemma lhd_lfilter [simp]: \"lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\"", "lemma ltl_lfilter: \"ltl (lfilter P xs) = lfilter P (ltl (ldropWhile (Not \\<circ> P) xs))\"", "lemma lfilter_eq_LCons:\n  \"lfilter P xs = LCons x xs' \\<Longrightarrow>\n   \\<exists>xs''. xs' = lfilter P xs'' \\<and> ldropWhile (Not \\<circ> P) xs = LCons x xs''\"", "lemma lfilter_K_True [simp]: \"lfilter (%_. True) xs = xs\"", "lemma lfitler_K_False [simp]: \"lfilter (\\<lambda>_. False) xs = LNil\"", "lemma lfilter_lappend_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> lfilter P (lappend xs ys) = lappend (lfilter P xs) (lfilter P ys)\"", "lemma lfinite_lfilterI [simp]: \"lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\"", "lemma lset_lfilter [simp]: \"lset (lfilter P xs) = {x \\<in> lset xs. P x}\"", "lemma lfilter_lfilter: \"lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs\"", "lemma lfilter_idem [simp]: \"lfilter P (lfilter P xs) = lfilter P xs\"", "lemma lfilter_lmap: \"lfilter P (lmap f xs) = lmap f (lfilter (P o f) xs)\"", "lemma lfilter_llist_of [simp]:\n  \"lfilter P (llist_of xs) = llist_of (filter P xs)\"", "lemma lfilter_cong [cong]:\n  assumes xsys: \"xs = ys\"\n  and set: \"\\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x\"\n  shows \"lfilter P xs = lfilter Q ys\"", "lemma llength_lfilter_ile:\n  \"llength (lfilter P xs) \\<le> llength xs\"", "lemma lfinite_lfilter:\n  \"lfinite (lfilter P xs) \\<longleftrightarrow>\n   lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\"", "lemma lfilter_eq_LConsD:\n  assumes \"lfilter P ys = LCons x xs\"\n  shows \"\\<exists>us vs. ys = lappend us (LCons x vs) \\<and> lfinite us \\<and>\n                      (\\<forall>u\\<in>lset us. \\<not> P u) \\<and> P x \\<and> xs = lfilter P vs\"", "lemma lfilter_eq_lappend_lfiniteD:\n  assumes \"lfilter P xs = lappend ys zs\" and \"lfinite ys\"\n  shows \"\\<exists>us vs. xs = lappend us vs \\<and> lfinite us \\<and>\n                      ys = lfilter P us \\<and> zs = lfilter P vs\"", "lemma ldistinct_lfilterI: \"ldistinct xs \\<Longrightarrow> ldistinct (lfilter P xs)\"", "lemma ldistinct_lfilterD:\n  \"\\<lbrakk> ldistinct (lfilter P xs); enat n < llength xs; enat m < llength xs; P a; lnth xs n = a; lnth xs m = a \\<rbrakk> \\<Longrightarrow> m = n\"", "lemmas lfilter_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    lfilter.mono lfilter.mono lfilter_def lfilter_def, case_names adm LNil step]", "lemma llist_all2_lfilterI:\n  assumes *: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llist_all2 P (lfilter Q1 xs) (lfilter Q2 ys)\"", "lemma distinct_filterD:\n  \"\\<lbrakk> distinct (filter P xs); n < length xs; m < length xs; P x; xs ! n = x; xs ! m = x \\<rbrakk> \\<Longrightarrow> m = n\"", "lemma lprefix_lfilterI:\n  \"xs \\<sqsubseteq> ys \\<Longrightarrow> lfilter P xs \\<sqsubseteq> lfilter P ys\"", "lemma lsorted_lfilterI:\n  \"lsorted xs \\<Longrightarrow> lsorted (lfilter P xs)\"", "lemma lsorted_lfilter_same:\n  \"lsorted (lfilter (\\<lambda>x. x = c) xs)\"", "lemma lfilter_id_conv: \"lfilter P xs = xs \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lfilter_repeat [simp]: \"lfilter P (repeat x) = (if P x then repeat x else LNil)\"", "lemma lconcat_simps [simp, code]:\n  shows lconcat_LNil: \"lconcat LNil = LNil\"\n  and lconcat_LCons: \"lconcat (LCons xs xss) = lappend xs (lconcat xss)\"", "lemma mono2mono_lconcat[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lconcat: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) lconcat\"", "lemma mcont2mcont_lconcat[THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lconcat: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) lconcat\"", "lemma lconcat_eq_LNil: \"lconcat xss = LNil \\<longleftrightarrow> lset xss \\<subseteq> {LNil}\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma lnull_lconcat [simp]: \"lnull (lconcat xss) \\<longleftrightarrow> lset xss \\<subseteq> {xs. lnull xs}\"", "lemma lconcat_llist_of:\n  \"lconcat (llist_of (map llist_of xs)) = llist_of (concat xs)\"", "lemma lhd_lconcat [simp]:\n  \"\\<lbrakk> \\<not> lnull xss; \\<not> lnull (lhd xss) \\<rbrakk> \\<Longrightarrow> lhd (lconcat xss) = lhd (lhd xss)\"", "lemma ltl_lconcat [simp]:\n  \"\\<lbrakk> \\<not> lnull xss; \\<not> lnull (lhd xss) \\<rbrakk> \\<Longrightarrow> ltl (lconcat xss) = lappend (ltl (lhd xss)) (lconcat (ltl xss))\"", "lemma lmap_lconcat:\n  \"lmap f (lconcat xss) = lconcat (lmap (lmap f) xss)\"", "lemma lconcat_lappend [simp]:\n  assumes \"lfinite xss\"\n  shows \"lconcat (lappend xss yss) = lappend (lconcat xss) (lconcat yss)\"", "lemma lconcat_eq_LCons_conv:\n  \"lconcat xss = LCons x xs \\<longleftrightarrow>\n  (\\<exists>xs' xss' xss''. xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n                    xs = lappend xs' (lconcat xss'') \\<and> set xss' \\<subseteq> {xs. lnull xs})\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma llength_lconcat_lfinite_conv_sum:\n  assumes \"lfinite xss\"\n  shows \"llength (lconcat xss) = (\\<Sum>i | enat i < llength xss. llength (lnth xss i))\"", "lemma lconcat_lfilter_neq_LNil:\n  \"lconcat (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) = lconcat xss\"", "lemmas lconcat_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    lconcat.mono lconcat.mono lconcat_def lconcat_def, case_names adm LNil step]", "lemma llist_all2_lconcatI:\n  \"llist_all2 (llist_all2 A) xss yss\n  \\<Longrightarrow> llist_all2 A (lconcat xss) (lconcat yss)\"", "lemma llength_lconcat_eqI:\n  fixes xss :: \"'a llist llist\" and yss :: \"'b llist llist\"\n  assumes \"llist_all2 (\\<lambda>xs ys. llength xs = llength ys) xss yss\"\n  shows \"llength (lconcat xss) = llength (lconcat yss)\"", "lemma lset_lconcat_lfinite:\n  \"\\<forall>xs \\<in> lset xss. lfinite xs \\<Longrightarrow> lset (lconcat xss) = (\\<Union>xs\\<in>lset xss. lset xs)\"", "lemma lconcat_ltake:\n  \"lconcat (ltake (enat n) xss) = ltake (\\<Sum>i<n. llength (lnth xss i)) (lconcat xss)\"", "lemma lnth_lconcat_conv:\n  assumes \"enat n < llength (lconcat xss)\"\n  shows \"\\<exists>m n'. lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and> enat n' < llength (lnth xss m) \\<and>\n                enat m < llength xss \\<and> enat n = (\\<Sum>i<m . llength (lnth xss i)) + enat n'\"", "lemma lprefix_lconcatI:\n  \"xss \\<sqsubseteq> yss \\<Longrightarrow> lconcat xss \\<sqsubseteq> lconcat yss\"", "lemma lnth_lconcat_ltake:\n  assumes \"enat w < llength (lconcat (ltake (enat n) xss))\"\n  shows \"lnth (lconcat (ltake (enat n) xss)) w = lnth (lconcat xss) w\"", "lemma lfinite_lconcat [simp]:\n  \"lfinite (lconcat xss) \\<longleftrightarrow> lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and> (\\<forall>xs \\<in> lset xss. lfinite xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma list_of_lconcat:\n  assumes \"lfinite xss\"\n  and \"\\<forall>xs \\<in> lset xss. lfinite xs\"\n  shows \"list_of (lconcat xss) = concat (list_of (lmap list_of xss))\"", "lemma lfilter_lconcat_lfinite:\n  \"\\<forall>xs\\<in>lset xss. lfinite xs\n  \\<Longrightarrow> lfilter P (lconcat xss) = lconcat (lmap (lfilter P) xss)\"", "lemma lconcat_repeat_LNil [simp]: \"lconcat (repeat LNil) = LNil\"", "lemma lconcat_lmap_singleton [simp]: \"lconcat (lmap (\\<lambda>x. LCons (f x) LNil) xs) = lmap f xs\"", "lemma lset_lconcat_subset: \"lset (lconcat xss) \\<subseteq> (\\<Union>xs\\<in>lset xss. lset xs)\"", "lemma ldistinct_lconcat:\n  \"\\<lbrakk> ldistinct xss; \\<And>ys. ys \\<in> lset xss \\<Longrightarrow> ldistinct ys;\n     \\<And>ys zs. \\<lbrakk> ys \\<in> lset xss; zs \\<in> lset xss; ys \\<noteq> zs \\<rbrakk> \\<Longrightarrow> lset ys \\<inter> lset zs = {} \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lconcat xss)\"", "lemma lnths_empty [simp]: \"lnths xs {} = LNil\"", "lemma lnths_LNil [simp]: \"lnths LNil A = LNil\"", "lemma lnths_LCons:\n  \"lnths (LCons x xs) A =\n  (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A}) else lnths xs {n. Suc n \\<in> A})\"", "lemma lset_lnths:\n  \"lset (lnths xs I) = {lnth xs i|i. enat i<llength xs \\<and> i \\<in> I}\"", "lemma lset_lnths_subset: \"lset (lnths xs I) \\<subseteq> lset xs\"", "lemma lnths_singleton [simp]:\n  \"lnths (LCons x LNil) A = (if 0 : A then LCons x LNil else LNil)\"", "lemma lnths_upt_eq_ltake [simp]:\n  \"lnths xs {..<n} = ltake (enat n) xs\"", "lemma lnths_llist_of [simp]:\n  \"lnths (llist_of xs) A = llist_of (nths xs A)\"", "lemma llength_lnths_ile: \"llength (lnths xs A) \\<le> llength xs\"", "lemma lnths_lmap [simp]:\n  \"lnths (lmap f xs) A = lmap f (lnths xs A)\"", "lemma lfilter_conv_lnths:\n  \"lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}\"", "lemma ltake_iterates_Suc:\n  \"ltake (enat n) (iterates Suc m) = llist_of [m..<n + m]\"", "lemma lnths_lappend_lfinite:\n  assumes len: \"llength xs = enat k\"\n  shows \"lnths (lappend xs ys) A =\n         lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})\"", "lemma lnths_split:\n  \"lnths xs A =\n   lappend (lnths (ltake (enat n) xs) A) (lnths (ldropn n xs) {m. n + m \\<in> A})\"", "lemma lnths_cong:\n  assumes \"xs = ys\" and A: \"\\<And>n. enat n < llength ys \\<Longrightarrow> n \\<in> A \\<longleftrightarrow> n \\<in> B\"\n  shows \"lnths xs A = lnths ys B\"", "lemma lnths_insert:\n  assumes n: \"enat n < llength xs\"\n  shows \"lnths xs (insert n A) =\n         lappend (lnths (ltake (enat n) xs) A) (LCons (lnth xs n)\n                 (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))\"", "lemma lfinite_lnths [simp]:\n  \"lfinite (lnths xs A) \\<longleftrightarrow> lfinite xs \\<or> finite A\"", "lemma lsum_list_0 [simp]: \"lsum_list (lmap (\\<lambda>_. 0) xs) = 0\"", "lemma lsum_list_llist_of [simp]: \"lsum_list (llist_of xs) = sum_list xs\"", "lemma lsum_list_lappend: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> lsum_list (lappend xs ys) = lsum_list xs + lsum_list ys\"", "lemma lsum_list_LNil [simp]: \"lsum_list LNil = 0\"", "lemma lsum_list_LCons [simp]: \"lfinite xs \\<Longrightarrow> lsum_list (LCons x xs) = x + lsum_list xs\"", "lemma lsum_list_inf [simp]: \"\\<not> lfinite xs \\<Longrightarrow> lsum_list xs = 0\"", "lemma lsum_list_mono:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {monoid_add, ordered_ab_semigroup_add}\"\n  assumes \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> f x \\<le> g x\"\n  shows \"lsum_list (lmap f xs) \\<le> lsum_list (lmap g xs)\"", "lemma lnull_inf_llist [simp]: \"\\<not> lnull (inf_llist f)\"", "lemma inf_llist_neq_LNil: \"inf_llist f \\<noteq> LNil\"", "lemmas LNil_neq_inf_llist = inf_llist_neq_LNil[symmetric]", "lemma lhd_inf_llist [simp]: \"lhd (inf_llist f) = f 0\"", "lemma ltl_inf_llist [simp]: \"ltl (inf_llist f) = inf_llist (\\<lambda>n. f (Suc n))\"", "lemma inf_llist_rec [code, nitpick_simp]:\n  \"inf_llist f = LCons (f 0) (inf_llist (\\<lambda>n. f (Suc n)))\"", "lemma lfinite_inf_llist [iff]: \"\\<not> lfinite (inf_llist f)\"", "lemma iterates_conv_inf_llist:\n  \"iterates f a = inf_llist (\\<lambda>n. (f ^^ n) a)\"", "lemma inf_llist_neq_llist_of [simp]:\n  \"llist_of xs \\<noteq> inf_llist f\"\n   \"inf_llist f \\<noteq> llist_of xs\"", "lemma lnth_inf_llist [simp]: \"lnth (inf_llist f) n = f n\"", "lemma inf_llist_lprefix [simp]: \"inf_llist f \\<sqsubseteq> xs \\<longleftrightarrow> xs = inf_llist f\"", "lemma llength_inf_llist [simp]: \"llength (inf_llist f) = \\<infinity>\"", "lemma lset_inf_llist [simp]: \"lset (inf_llist f) = range f\"", "lemma inf_llist_inj [simp]:\n  \"inf_llist f = inf_llist g \\<longleftrightarrow> f = g\"", "lemma inf_llist_lnth [simp]: \"\\<not> lfinite xs \\<Longrightarrow> inf_llist (lnth xs) = xs\"", "lemma llist_exhaust:\n  obtains (llist_of) ys where \"xs = llist_of ys\"\n       | (inf_llist) f where \"xs = inf_llist f\"", "lemma lappend_inf_llist [simp]: \"lappend (inf_llist f) xs = inf_llist f\"", "lemma lmap_inf_llist [simp]:\n  \"lmap f (inf_llist g) = inf_llist (f o g)\"", "lemma ltake_enat_inf_llist [simp]:\n  \"ltake (enat n) (inf_llist f) = llist_of (map f [0..<n])\"", "lemma ldropn_inf_llist [simp]:\n  \"ldropn n (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))\"", "lemma ldrop_enat_inf_llist:\n  \"ldrop (enat n) (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))\"", "lemma lzip_inf_llist_inf_llist [simp]:\n  \"lzip (inf_llist f) (inf_llist g) = inf_llist (\\<lambda>n. (f n, g n))\"", "lemma lzip_llist_of_inf_llist [simp]:\n  \"lzip (llist_of xs) (inf_llist f) = llist_of (zip xs (map f [0..<length xs]))\"", "lemma lzip_inf_llist_llist_of [simp]:\n  \"lzip (inf_llist f) (llist_of xs) = llist_of (zip (map f [0..<length xs]) xs)\"", "lemma llist_all2_inf_llist [simp]:\n  \"llist_all2 P (inf_llist f) (inf_llist g) \\<longleftrightarrow> (\\<forall>n. P (f n) (g n))\"", "lemma llist_all2_llist_of_inf_llist [simp]:\n  \"\\<not> llist_all2 P (llist_of xs) (inf_llist f)\"", "lemma llist_all2_inf_llist_llist_of [simp]:\n  \"\\<not> llist_all2 P (inf_llist f) (llist_of xs)\"", "lemma (in monoid_add) lsum_list_infllist: \"lsum_list (inf_llist f) = 0\"", "lemma set1_pre_llist_transfer [transfer_rule]:\n  \"(rel_pre_llist A B ===> rel_set A) set1_pre_llist set1_pre_llist\"", "lemma set2_pre_llist_transfer [transfer_rule]:\n  \"(rel_pre_llist A B ===> rel_set B) set2_pre_llist set2_pre_llist\"", "lemma LNil_transfer [transfer_rule]: \"llist_all2 P LNil LNil\"", "lemma LCons_transfer [transfer_rule]:\n  \"(A ===> llist_all2 A ===> llist_all2 A) LCons LCons\"", "lemma case_llist_transfer [transfer_rule]:\n  \"(B ===> (A ===> llist_all2 A ===> B) ===> llist_all2 A ===> B)\n    case_llist case_llist\"", "lemma unfold_llist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> A) ===> A ===> llist_all2 B) unfold_llist unfold_llist\"", "lemma llist_corec_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> (=)) ===> (A ===> llist_all2 B) ===> (A ===> A) ===> A ===> llist_all2 B) corec_llist corec_llist\"", "lemma ltl_transfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 A) ltl ltl\"", "lemma lset_transfer [transfer_rule]:\n  \"(llist_all2 A ===> rel_set A) lset lset\"", "lemma lmap_transfer [transfer_rule]:\n  \"((A ===> B) ===> llist_all2 A ===> llist_all2 B) lmap lmap\"", "lemma lappend_transfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 A ===> llist_all2 A) lappend lappend\"", "lemma iterates_transfer [transfer_rule]:\n  \"((A ===> A) ===> A ===> llist_all2 A) iterates iterates\"", "lemma lfinite_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=)) lfinite lfinite\"", "lemma llist_of_transfer [transfer_rule]:\n  \"(list_all2 A ===> llist_all2 A) llist_of llist_of\"", "lemma llength_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=)) llength llength\"", "lemma ltake_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ltake ltake\"", "lemma ldropn_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ldropn ldropn\"", "lemma ldrop_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ldrop ldrop\"", "lemma ltakeWhile_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ltakeWhile ltakeWhile\"", "lemma ldropWhile_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ldropWhile ldropWhile\"", "lemma lzip_ltransfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 B ===> llist_all2 (rel_prod A B)) lzip lzip\"", "lemma inf_llist_transfer [transfer_rule]:\n  \"(((=) ===> A) ===> llist_all2 A) inf_llist inf_llist\"", "lemma lfilter_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) lfilter lfilter\"", "lemma lconcat_transfer [transfer_rule]:\n  \"(llist_all2 (llist_all2 A) ===> llist_all2 A) lconcat lconcat\"", "lemma lnths_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=) ===> llist_all2 A) lnths lnths\"", "lemma llist_all_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> (=)) llist_all llist_all\"", "lemma llist_all2_rsp:\n  assumes r: \"\\<forall>x y. R x y \\<longrightarrow> (\\<forall>a b. R a b \\<longrightarrow> S x a = T y b)\"\n  and l1: \"llist_all2 R x y\"\n  and l2: \"llist_all2 R a b\"\n  shows \"llist_all2 S x a = llist_all2 T y b\"", "lemma llist_all2_transfer [transfer_rule]:\n  \"((R ===> R ===> (=)) ===> llist_all2 R ===> llist_all2 R ===> (=)) llist_all2 llist_all2\""], "translations": [["", "lemma funpow_Suc_conv [simp]: \"(Suc ^^ n) m = m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc ^^ n) m = m + n", "by(induct n arbitrary: m) simp_all"], ["", "lemma wlog_linorder_le [consumes 0, case_names le symmetry]:\n  assumes le: \"\\<And>a b :: 'a :: linorder. a \\<le> b \\<Longrightarrow> P a b\"\n  and sym: \"P b a \\<Longrightarrow> P a b\"\n  shows \"P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a b", "proof(cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> P a b\n 2. \\<not> a \\<le> b \\<Longrightarrow> P a b", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> P a b\n 2. \\<not> a \\<le> b \\<Longrightarrow> P a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. P a b", "by(rule le)"], ["proof (state)\nthis:\n  P a b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> P a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> P a b", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> P a b", "hence \"b \\<le> a\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. b \\<le> a", "by simp"], ["proof (state)\nthis:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> P a b", "hence \"P b a\""], ["proof (prove)\nusing this:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. P b a", "by(rule le)"], ["proof (state)\nthis:\n  P b a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> P a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  P b a\n\ngoal (1 subgoal):\n 1. P a b", "by(rule sym)"], ["proof (state)\nthis:\n  P a b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Type definition\\<close>"], ["", "codatatype (lset: 'a) llist =\n    lnull: LNil\n  | LCons (lhd: 'a) (ltl: \"'a llist\")\nfor\n  map: lmap\n  rel: llist_all2\nwhere\n  \"lhd LNil = undefined\"\n| \"ltl LNil = LNil\""], ["", "text \\<open>\n  Coiterator setup.\n\\<close>"], ["", "primcorec unfold_llist :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'b llist\" where\n  \"p a \\<Longrightarrow> unfold_llist p g21 g22 a = LNil\" |\n  \"_ \\<Longrightarrow> unfold_llist p g21 g22 a = LCons (g21 a) (unfold_llist p g21 g22 (g22 a))\""], ["", "declare\n  unfold_llist.ctr(1) [simp]\n  llist.corec(1) [simp]"], ["", "text \\<open>\n  The following setup should be done by the BNF package.\n\\<close>"], ["", "text \\<open>congruence rule\\<close>"], ["", "declare llist.map_cong [cong]"], ["", "text \\<open>Code generator setup\\<close>"], ["", "lemma corec_llist_never_stop: \"corec_llist IS_LNIL LHD (\\<lambda>_. False) MORE LTL x = unfold_llist IS_LNIL LHD LTL x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_llist IS_LNIL LHD (\\<lambda>_. False) MORE LTL x =\n    unfold_llist IS_LNIL LHD LTL x", "by(coinduction arbitrary: x) auto"], ["", "text \\<open>lemmas about generated constants\\<close>"], ["", "lemma eq_LConsD: \"xs = LCons y ys \\<Longrightarrow> xs \\<noteq> LNil \\<and> lhd xs = y \\<and> ltl xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LCons y ys \\<Longrightarrow>\n    xs \\<noteq> LNil \\<and> lhd xs = y \\<and> ltl xs = ys", "by auto"], ["", "lemma\n  shows LNil_eq_lmap: \"LNil = lmap f xs \\<longleftrightarrow> xs = LNil\"\n  and lmap_eq_LNil: \"lmap f xs = LNil \\<longleftrightarrow> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LNil = lmap f xs) = (xs = LNil) &&& (lmap f xs = LNil) = (xs = LNil)", "by(cases xs,simp_all)+"], ["", "declare llist.map_sel(1)[simp]"], ["", "lemma ltl_lmap[simp]: \"ltl (lmap f xs) = lmap f (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lmap f xs) = lmap f (ltl xs)", "by(cases xs, simp_all)"], ["", "declare llist.map_ident[simp]"], ["", "lemma lmap_eq_LCons_conv:\n  \"lmap f xs = LCons y ys \\<longleftrightarrow>\n  (\\<exists>x xs'. xs = LCons x xs' \\<and> y = f x \\<and> ys = lmap f xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmap f xs = LCons y ys) =\n    (\\<exists>x xs'. xs = LCons x xs' \\<and> y = f x \\<and> ys = lmap f xs')", "by(cases xs)(auto)"], ["", "lemma lmap_conv_unfold_llist:\n  \"lmap f = unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f = unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lmap f x =\n       unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lmap f x =\n       unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl x", "show \"?lhs x = ?rhs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f x = unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl x", "by(coinduction arbitrary: x) auto"], ["proof (state)\nthis:\n  lmap f x = unfold_llist (\\<lambda>xs. xs = LNil) (f \\<circ> lhd) ltl x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmap_unfold_llist:\n  \"lmap f (unfold_llist IS_LNIL LHD LTL b) = unfold_llist IS_LNIL (f \\<circ> LHD) LTL b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (unfold_llist IS_LNIL LHD LTL b) =\n    unfold_llist IS_LNIL (f \\<circ> LHD) LTL b", "by(coinduction arbitrary: b) auto"], ["", "lemma lmap_corec_llist:\n  \"lmap f (corec_llist IS_LNIL LHD endORmore TTL_end TTL_more b) =\n   corec_llist IS_LNIL (f \\<circ> LHD) endORmore (lmap f \\<circ> TTL_end) TTL_more b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (corec_llist IS_LNIL LHD endORmore TTL_end TTL_more b) =\n    corec_llist IS_LNIL (f \\<circ> LHD) endORmore (lmap f \\<circ> TTL_end)\n     TTL_more b", "by(coinduction arbitrary: b rule: llist.coinduct_strong) auto"], ["", "lemma unfold_llist_ltl_unroll:\n  \"unfold_llist IS_LNIL LHD LTL (LTL b) = unfold_llist (IS_LNIL \\<circ> LTL) (LHD \\<circ> LTL) LTL b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_llist IS_LNIL LHD LTL (LTL b) =\n    unfold_llist (IS_LNIL \\<circ> LTL) (LHD \\<circ> LTL) LTL b", "by(coinduction arbitrary: b) auto"], ["", "lemma ltl_unfold_llist:\n  \"ltl (unfold_llist IS_LNIL LHD LTL a) =\n  (if IS_LNIL a then LNil else unfold_llist IS_LNIL LHD LTL (LTL a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (unfold_llist IS_LNIL LHD LTL a) =\n    (if IS_LNIL a then LNil else unfold_llist IS_LNIL LHD LTL (LTL a))", "by(simp)"], ["", "lemma unfold_llist_eq_LCons [simp]:\n  \"unfold_llist IS_LNIL LHD LTL b = LCons x xs \\<longleftrightarrow>\n  \\<not> IS_LNIL b \\<and> x = LHD b \\<and> xs = unfold_llist IS_LNIL LHD LTL (LTL b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unfold_llist IS_LNIL LHD LTL b = LCons x xs) =\n    (\\<not> IS_LNIL b \\<and>\n     x = LHD b \\<and> xs = unfold_llist IS_LNIL LHD LTL (LTL b))", "by(subst unfold_llist.code) auto"], ["", "lemma unfold_llist_id [simp]: \"unfold_llist lnull lhd ltl xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_llist lnull lhd ltl xs = xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma lset_eq_empty [simp]: \"lset xs = {} \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lset xs = {}) = lnull xs", "by(cases xs) simp_all"], ["", "declare llist.set_sel(1)[simp]"], ["", "lemma lset_ltl: \"lset (ltl xs) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ltl xs) \\<subseteq> lset xs", "by(cases xs) auto"], ["", "lemma in_lset_ltlD: \"x \\<in> lset (ltl xs) \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (ltl xs) \\<Longrightarrow> x \\<in> lset xs", "using lset_ltl[of xs]"], ["proof (prove)\nusing this:\n  lset (ltl xs) \\<subseteq> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (ltl xs) \\<Longrightarrow> x \\<in> lset xs", "by auto"], ["", "text \\<open>induction rules\\<close>"], ["", "theorem llist_set_induct[consumes 1, case_names find step]:\n  assumes \"x \\<in> lset xs\" and \"\\<And>xs. \\<not> lnull xs \\<Longrightarrow> P (lhd xs) xs\"\n  and \"\\<And>xs y. \\<lbrakk>\\<not> lnull xs; y \\<in> lset (ltl xs); P y (ltl xs)\\<rbrakk> \\<Longrightarrow> P y xs\"\n  shows \"P x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  \\<not> lnull ?xs \\<Longrightarrow> P (lhd ?xs) ?xs\n  \\<lbrakk>\\<not> lnull ?xs; ?y \\<in> lset (ltl ?xs);\n   P ?y (ltl ?xs)\\<rbrakk>\n  \\<Longrightarrow> P ?y ?xs\n\ngoal (1 subgoal):\n 1. P x xs", "by(induct)(fastforce simp del: llist.disc(2) iff: llist.disc(2), auto)"], ["", "text \\<open>Test quickcheck setup\\<close>"], ["", "lemma \"\\<And>xs. xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs = LNil", "quickcheck[random, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs = LNil", "quickcheck[exhaustive, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs = LNil", "oops"], ["", "lemma \"LCons x xs = LCons x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x xs = LCons x xs", "quickcheck[narrowing, expect=no_counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x xs = LCons x xs", "oops"], ["", "subsection \\<open>Properties of predefined functions\\<close>"], ["", "lemmas lhd_LCons = llist.sel(1)"], ["", "lemmas ltl_simps = llist.sel(2,3)"], ["", "lemmas lhd_LCons_ltl = llist.collapse(2)"], ["", "lemma lnull_ltlI [simp]: \"lnull xs \\<Longrightarrow> lnull (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> lnull (ltl xs)", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow> ltl xs = LNil", "by simp"], ["", "lemma neq_LNil_conv: \"xs \\<noteq> LNil \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> LNil) = (\\<exists>x xs'. xs = LCons x xs')", "by(cases xs) auto"], ["", "lemma not_lnull_conv: \"\\<not> lnull xs \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> lnull xs) = (\\<exists>x xs'. xs = LCons x xs')", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> LNil) = (\\<exists>x xs'. xs = LCons x xs')", "by(simp add: neq_LNil_conv)"], ["", "lemma lset_LCons:\n  \"lset (LCons x xs) = insert x (lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (LCons x xs) = insert x (lset xs)", "by simp"], ["", "lemma lset_intros:\n  \"x \\<in> lset (LCons x xs)\"\n  \"x \\<in> lset xs \\<Longrightarrow> x \\<in> lset (LCons x' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (LCons x xs) &&&\n    (x \\<in> lset xs \\<Longrightarrow> x \\<in> lset (LCons x' xs))", "by simp_all"], ["", "lemma lset_cases [elim?]:\n  assumes \"x \\<in> lset xs\"\n  obtains xs' where \"xs = LCons x xs'\"\n  | x' xs' where \"xs = LCons x' xs'\" \"x \\<in> lset xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'. xs = LCons x xs' \\<Longrightarrow> thesis;\n     \\<And>x' xs'.\n        \\<lbrakk>xs = LCons x' xs'; x \\<in> lset xs'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'. xs = LCons x xs' \\<Longrightarrow> thesis;\n     \\<And>x' xs'.\n        \\<lbrakk>xs = LCons x' xs'; x \\<in> lset xs'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases xs) auto"], ["", "lemma lset_induct' [consumes 1, case_names find step]:\n  assumes major: \"x \\<in> lset xs\"\n  and 1: \"\\<And>xs. P (LCons x xs)\"\n  and 2: \"\\<And>x' xs. \\<lbrakk> x \\<in> lset xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x' xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using major"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. P xs", "apply(induct y\\<equiv>\"x\" xs rule: llist_set_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs; lhd xs = x\\<rbrakk> \\<Longrightarrow> P xs\n 2. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs; x \\<in> lset (ltl xs); P (ltl xs)\\<rbrakk>\n       \\<Longrightarrow> P xs", "using 1 2"], ["proof (prove)\nusing this:\n  P (LCons x ?xs)\n  \\<lbrakk>x \\<in> lset ?xs; P ?xs\\<rbrakk>\n  \\<Longrightarrow> P (LCons ?x' ?xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs; lhd xs = x\\<rbrakk> \\<Longrightarrow> P xs\n 2. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs; x \\<in> lset (ltl xs); P (ltl xs)\\<rbrakk>\n       \\<Longrightarrow> P xs", "by(auto simp add: not_lnull_conv)"], ["", "lemma lset_induct [consumes 1, case_names find step, induct set: lset]:\n  assumes major: \"x \\<in> lset xs\"\n  and find: \"\\<And>xs. P (LCons x xs)\"\n  and step: \"\\<And>x' xs. \\<lbrakk> x \\<in> lset xs; x \\<noteq> x'; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x' xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using major"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. P xs", "apply(induct rule: lset_induct')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs. P (LCons x xs)\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; P xs\\<rbrakk>\n       \\<Longrightarrow> P (LCons x' xs)", "apply(rule find)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; P xs\\<rbrakk>\n       \\<Longrightarrow> P (LCons x' xs)", "apply(case_tac \"x'=x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; P xs; x' = x\\<rbrakk>\n       \\<Longrightarrow> P (LCons x' xs)\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; P xs; x' \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> P (LCons x' xs)", "apply(simp_all add: find step)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas lset_LNil = llist.set(1)"], ["", "lemma lset_lnull: \"lnull xs \\<Longrightarrow> lset xs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> lset xs = {}", "by(auto dest: llist.collapse)"], ["", "text \\<open>Alternative definition of @{term lset} for nitpick\\<close>"], ["", "inductive lsetp :: \"'a llist \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere\n  \"lsetp (LCons x xs) x\"\n| \"lsetp xs x \\<Longrightarrow> lsetp (LCons x' xs) x\""], ["", "lemma lset_into_lsetp:\n  \"x \\<in> lset xs \\<Longrightarrow> lsetp xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<Longrightarrow> lsetp xs x", "by(induct rule: lset_induct)(blast intro: lsetp.intros)+"], ["", "lemma lsetp_into_lset:\n  \"lsetp xs x \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsetp xs x \\<Longrightarrow> x \\<in> lset xs", "by(induct rule: lsetp.induct)(blast intro: lset_intros)+"], ["", "lemma lset_eq_lsetp [nitpick_unfold]:\n  \"lset xs = {x. lsetp xs x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs = {x. lsetp xs x}", "by(auto intro: lset_into_lsetp dest: lsetp_into_lset)"], ["", "hide_const (open) lsetp"], ["", "hide_fact (open) lsetp.intros lsetp.cases lsetp.induct lset_into_lsetp lset_eq_lsetp"], ["", "text \\<open>code setup for @{term lset}\\<close>"], ["", "definition gen_lset :: \"'a set \\<Rightarrow> 'a llist \\<Rightarrow> 'a set\"\nwhere \"gen_lset A xs = A \\<union> lset xs\""], ["", "lemma gen_lset_code [code]:\n  \"gen_lset A LNil = A\"\n  \"gen_lset A (LCons x xs) = gen_lset (insert x A) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lset A LNil = A &&&\n    gen_lset A (LCons x xs) = gen_lset (insert x A) xs", "by(auto simp add: gen_lset_def)"], ["", "lemma lset_code [code]:\n  \"lset = gen_lset {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset = gen_lset {}", "by(simp add: gen_lset_def fun_eq_iff)"], ["", "definition lmember :: \"'a \\<Rightarrow> 'a llist \\<Rightarrow> bool\"\nwhere \"lmember x xs \\<longleftrightarrow> x \\<in> lset xs\""], ["", "lemma lmember_code [code]:\n  \"lmember x LNil \\<longleftrightarrow> False\"\n  \"lmember x (LCons y ys) \\<longleftrightarrow> x = y \\<or> lmember x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmember x LNil = False &&&\n    lmember x (LCons y ys) = (x = y \\<or> lmember x ys)", "by(simp_all add: lmember_def)"], ["", "lemma lset_lmember [code_unfold]:\n  \"x \\<in> lset xs \\<longleftrightarrow> lmember x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> lset xs) = lmember x xs", "by(simp add: lmember_def)"], ["", "lemmas lset_lmap [simp] = llist.set_map"], ["", "subsection \\<open>The subset of finite lazy lists @{term \"lfinite\"}\\<close>"], ["", "inductive lfinite :: \"'a llist \\<Rightarrow> bool\"\nwhere\n  lfinite_LNil:  \"lfinite LNil\"\n| lfinite_LConsI: \"lfinite xs \\<Longrightarrow> lfinite (LCons x xs)\""], ["", "declare lfinite_LNil [iff]"], ["", "lemma lnull_imp_lfinite [simp]: \"lnull xs \\<Longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> lfinite xs", "by(auto dest: llist.collapse)"], ["", "lemma lfinite_LCons [simp]: \"lfinite (LCons x xs) = lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (LCons x xs) = lfinite xs", "by(auto elim: lfinite.cases intro: lfinite_LConsI)"], ["", "lemma lfinite_ltl [simp]: \"lfinite (ltl xs) = lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltl xs) = lfinite xs", "by(cases xs) simp_all"], ["", "lemma lfinite_code [code]:\n  \"lfinite LNil = True\"\n  \"lfinite (LCons x xs) = lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite LNil = True &&& lfinite (LCons x xs) = lfinite xs", "by simp_all"], ["", "lemma lfinite_induct [consumes 1, case_names LNil LCons]:\n  assumes lfinite: \"lfinite xs\"\n  and LNil: \"\\<And>xs. lnull xs \\<Longrightarrow> P xs\"\n  and LCons: \"\\<And>xs. \\<lbrakk> lfinite xs; \\<not> lnull xs; P (ltl xs) \\<rbrakk> \\<Longrightarrow> P xs\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using lfinite"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs", "by(induct)(auto intro: LCons LNil)"], ["", "lemma lfinite_imp_finite_lset:\n  assumes \"lfinite xs\"\n  shows \"finite (lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lset xs)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. finite (lset xs)", "by induct auto"], ["", "subsection \\<open>Concatenating two lists: @{term \"lappend\"}\\<close>"], ["", "primcorec lappend :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere\n  \"lappend xs ys = (case xs of LNil \\<Rightarrow> ys | LCons x xs' \\<Rightarrow> LCons x (lappend xs' ys))\""], ["", "simps_of_case lappend_code [code, simp, nitpick_simp]: lappend.code"], ["", "lemmas lappend_LNil_LNil = lappend_code(1)[where ys = LNil]"], ["", "lemma lappend_simps [simp]:\n  shows lhd_lappend: \"lhd (lappend xs ys) = (if lnull xs then lhd ys else lhd xs)\"\n  and ltl_lappend: \"ltl (lappend xs ys) = (if lnull xs then ltl ys else lappend (ltl xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lappend xs ys) = (if lnull xs then lhd ys else lhd xs) &&&\n    ltl (lappend xs ys) = (if lnull xs then ltl ys else lappend (ltl xs) ys)", "by(case_tac [!] xs) simp_all"], ["", "lemma lnull_lappend [simp]:\n  \"lnull (lappend xs ys) \\<longleftrightarrow> lnull xs \\<and> lnull ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lappend xs ys) = (lnull xs \\<and> lnull ys)", "by(auto simp add: lappend_def)"], ["", "lemma lappend_eq_LNil_iff:\n  \"lappend xs ys = LNil \\<longleftrightarrow> xs = LNil \\<and> ys = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lappend xs ys = LNil) = (xs = LNil \\<and> ys = LNil)", "using lnull_lappend"], ["proof (prove)\nusing this:\n  lnull (lappend ?xs ?ys) = (lnull ?xs \\<and> lnull ?ys)\n\ngoal (1 subgoal):\n 1. (lappend xs ys = LNil) = (xs = LNil \\<and> ys = LNil)", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (lappend ?xs ?ys = LNil) = (?xs = LNil \\<and> ?ys = LNil)\n\ngoal (1 subgoal):\n 1. (lappend xs ys = LNil) = (xs = LNil \\<and> ys = LNil)", "."], ["", "lemma LNil_eq_lappend_iff:\n  \"LNil = lappend xs ys \\<longleftrightarrow> xs = LNil \\<and> ys = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LNil = lappend xs ys) = (xs = LNil \\<and> ys = LNil)", "by(auto dest: sym simp add: lappend_eq_LNil_iff)"], ["", "lemma lappend_LNil2 [simp]: \"lappend xs LNil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend xs LNil = xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma shows lappend_lnull1: \"lnull xs \\<Longrightarrow> lappend xs ys = ys\"\n  and lappend_lnull2: \"lnull ys \\<Longrightarrow> lappend xs ys = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lnull xs \\<Longrightarrow> lappend xs ys = ys) &&&\n    (lnull ys \\<Longrightarrow> lappend xs ys = xs)", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = LNil \\<Longrightarrow> lappend xs ys = ys) &&&\n    (ys = LNil \\<Longrightarrow> lappend xs ys = xs)", "by simp_all"], ["", "lemma lappend_assoc: \"lappend (lappend xs ys) zs = lappend xs (lappend ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (lappend xs ys) zs = lappend xs (lappend ys zs)", "by(coinduction arbitrary: xs rule: llist.coinduct_strong) auto"], ["", "lemma lmap_lappend_distrib:\n  \"lmap f (lappend xs ys) = lappend (lmap f xs) (lmap f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (lappend xs ys) = lappend (lmap f xs) (lmap f ys)", "by(coinduction arbitrary: xs rule: llist.coinduct_strong) auto"], ["", "lemma lappend_snocL1_conv_LCons2:\n  \"lappend (lappend xs (LCons y LNil)) ys = lappend xs (LCons y ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (lappend xs (LCons y LNil)) ys = lappend xs (LCons y ys)", "by(simp add: lappend_assoc)"], ["", "lemma lappend_ltl: \"\\<not> lnull xs \\<Longrightarrow> lappend (ltl xs) ys = ltl (lappend xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<Longrightarrow>\n    lappend (ltl xs) ys = ltl (lappend xs ys)", "by simp"], ["", "lemma lfinite_lappend [simp]:\n  \"lfinite (lappend xs ys) \\<longleftrightarrow> lfinite xs \\<and> lfinite ys\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lappend xs ys) = (lfinite xs \\<and> lfinite ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lappend xs ys) \\<Longrightarrow> lfinite xs \\<and> lfinite ys\n 2. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (lappend xs ys)\n\ngoal (2 subgoals):\n 1. lfinite (lappend xs ys) \\<Longrightarrow> lfinite xs \\<and> lfinite ys\n 2. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (lappend xs ys)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys", "proof(induct zs\\<equiv>\"lappend xs ys\" arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       LNil = lappend xs ys \\<Longrightarrow> lfinite xs \\<and> lfinite ys\n 2. \\<And>xs x xsa ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa ys.\n           xs = lappend xsa ys \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite ys;\n        LCons x xs = lappend xsa ys\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa \\<and> lfinite ys", "case lfinite_LNil"], ["proof (state)\nthis:\n  LNil = lappend xs ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       LNil = lappend xs ys \\<Longrightarrow> lfinite xs \\<and> lfinite ys\n 2. \\<And>xs x xsa ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa ys.\n           xs = lappend xsa ys \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite ys;\n        LCons x xs = lappend xsa ys\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa \\<and> lfinite ys", "thus ?case"], ["proof (prove)\nusing this:\n  LNil = lappend xs ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys", "by(simp add: LNil_eq_lappend_iff)"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite ys\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa ys.\n           xs = lappend xsa ys \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite ys;\n        LCons x xs = lappend xsa ys\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa \\<and> lfinite ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xsa ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa ys.\n           xs = lappend xsa ys \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite ys;\n        LCons x xs = lappend xsa ys\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa \\<and> lfinite ys", "case (lfinite_LConsI zs z)"], ["proof (state)\nthis:\n  lfinite zs\n  zs = lappend ?xs ?ys \\<Longrightarrow> lfinite ?xs \\<and> lfinite ?ys\n  LCons z zs = lappend xs ys\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa ys.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa ys.\n           xs = lappend xsa ys \\<Longrightarrow>\n           lfinite xsa \\<and> lfinite ys;\n        LCons x xs = lappend xsa ys\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa \\<and> lfinite ys", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite zs\n  zs = lappend ?xs ?ys \\<Longrightarrow> lfinite ?xs \\<and> lfinite ?ys\n  LCons z zs = lappend xs ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys", "by(cases xs)(cases ys, simp_all)"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "assume ?rhs (is \"?xs \\<and> ?ys\")"], ["proof (state)\nthis:\n  lfinite xs \\<and> lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "then"], ["proof (chain)\npicking this:\n  lfinite xs \\<and> lfinite ys", "obtain ?xs ?ys"], ["proof (prove)\nusing this:\n  lfinite xs \\<and> lfinite ys\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite xs; lfinite ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  lfinite xs\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<and> lfinite ys \\<Longrightarrow> lfinite (lappend xs ys)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite (lappend xs ys)", "by induct simp_all"], ["proof (state)\nthis:\n  lfinite (lappend xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_inf: \"\\<not> lfinite xs \\<Longrightarrow> lappend xs ys = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lappend xs ys = xs", "by(coinduction arbitrary: xs) auto"], ["", "lemma lfinite_lmap [simp]:\n  \"lfinite (lmap f xs) = lfinite xs\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lmap f xs) = lfinite xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lmap f xs) \\<Longrightarrow> lfinite xs\n 2. lfinite xs \\<Longrightarrow> lfinite (lmap f xs)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (lmap f xs)\n\ngoal (2 subgoals):\n 1. lfinite (lmap f xs) \\<Longrightarrow> lfinite xs\n 2. lfinite xs \\<Longrightarrow> lfinite (lmap f xs)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (lmap f xs)\n\ngoal (1 subgoal):\n 1. lfinite xs", "by(induct zs\\<equiv>\"lmap f xs\" arbitrary: xs rule: lfinite_induct) fastforce+"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lfinite (lmap f xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lfinite (lmap f xs)", "assume ?rhs"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lfinite (lmap f xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lmap f xs)", "by(induct) simp_all"], ["proof (state)\nthis:\n  lfinite (lmap f xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lappend_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> lset (lappend xs ys) = lset xs \\<union> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) = lset xs \\<union> lset ys", "by(induct rule: lfinite.induct) auto"], ["", "lemma lset_lappend: \"lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "by simp"], ["proof (state)\nthis:\n  lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys", "by(auto simp add: lappend_inf)"], ["proof (state)\nthis:\n  lset (lappend xs ys) \\<subseteq> lset xs \\<union> lset ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lappend1: \"lset xs \\<subseteq> lset (lappend xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs \\<subseteq> lset (lappend xs ys)", "by(rule subsetI)(erule lset_induct, simp_all)"], ["", "lemma lset_lappend_conv: \"lset (lappend xs ys) = (if lfinite xs then lset xs \\<union> lset ys else lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lappend xs ys) =\n    (if lfinite xs then lset xs \\<union> lset ys else lset xs)", "by(simp add: lappend_inf)"], ["", "lemma in_lset_lappend_iff: \"x \\<in> lset (lappend xs ys) \\<longleftrightarrow> x \\<in> lset xs \\<or> lfinite xs \\<and> x \\<in> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> lset (lappend xs ys)) =\n    (x \\<in> lset xs \\<or> lfinite xs \\<and> x \\<in> lset ys)", "by(simp add: lset_lappend_conv)"], ["", "lemma split_llist_first:\n  assumes \"x \\<in> lset xs\"\n  shows \"\\<exists>ys zs. xs = lappend ys (LCons x zs) \\<and> lfinite ys \\<and> x \\<notin> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs = lappend ys (LCons x zs) \\<and>\n       lfinite ys \\<and> x \\<notin> lset ys", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs = lappend ys (LCons x zs) \\<and>\n       lfinite ys \\<and> x \\<notin> lset ys", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>ys zs.\n          LCons x xs = lappend ys (LCons x zs) \\<and>\n          lfinite ys \\<and> x \\<notin> lset ys\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>ys zs.\n           xs = lappend ys (LCons x zs) \\<and>\n           lfinite ys \\<and> x \\<notin> lset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            LCons x' xs = lappend ys (LCons x zs) \\<and>\n                            lfinite ys \\<and> x \\<notin> lset ys", "case find"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>ys zs.\n          LCons x xs = lappend ys (LCons x zs) \\<and>\n          lfinite ys \\<and> x \\<notin> lset ys\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>ys zs.\n           xs = lappend ys (LCons x zs) \\<and>\n           lfinite ys \\<and> x \\<notin> lset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            LCons x' xs = lappend ys (LCons x zs) \\<and>\n                            lfinite ys \\<and> x \\<notin> lset ys", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       LCons x xs_ = lappend ys (LCons x zs) \\<and>\n       lfinite ys \\<and> x \\<notin> lset ys", "by(auto intro: exI[where x=LNil])"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     LCons x xs_ = lappend ys (LCons x zs) \\<and>\n     lfinite ys \\<and> x \\<notin> lset ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>ys zs.\n           xs = lappend ys (LCons x zs) \\<and>\n           lfinite ys \\<and> x \\<notin> lset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            LCons x' xs = lappend ys (LCons x zs) \\<and>\n                            lfinite ys \\<and> x \\<notin> lset ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>ys zs.\n           xs = lappend ys (LCons x zs) \\<and>\n           lfinite ys \\<and> x \\<notin> lset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            LCons x' xs = lappend ys (LCons x zs) \\<and>\n                            lfinite ys \\<and> x \\<notin> lset ys", "case step"], ["proof (state)\nthis:\n  x \\<in> lset xs_\n  x \\<noteq> x'_\n  \\<exists>ys zs.\n     xs_ = lappend ys (LCons x zs) \\<and>\n     lfinite ys \\<and> x \\<notin> lset ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>ys zs.\n           xs = lappend ys (LCons x zs) \\<and>\n           lfinite ys \\<and> x \\<notin> lset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            LCons x' xs = lappend ys (LCons x zs) \\<and>\n                            lfinite ys \\<and> x \\<notin> lset ys", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> lset xs_\n  x \\<noteq> x'_\n  \\<exists>ys zs.\n     xs_ = lappend ys (LCons x zs) \\<and>\n     lfinite ys \\<and> x \\<notin> lset ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       LCons x'_ xs_ = lappend ys (LCons x zs) \\<and>\n       lfinite ys \\<and> x \\<notin> lset ys", "by(fastforce intro: exI[where x=\"LCons a b\" for a b])"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     LCons x'_ xs_ = lappend ys (LCons x zs) \\<and>\n     lfinite ys \\<and> x \\<notin> lset ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_llist: \"x \\<in> lset xs \\<Longrightarrow> \\<exists>ys zs. xs = lappend ys (LCons x zs) \\<and> lfinite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>ys zs. xs = lappend ys (LCons x zs) \\<and> lfinite ys", "by(blast dest: split_llist_first)"], ["", "subsection \\<open>The prefix ordering on lazy lists: @{term \"lprefix\"}\\<close>"], ["", "coinductive lprefix :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\" 65)\nwhere\n  LNil_lprefix [simp, intro!]: \"LNil \\<sqsubseteq> xs\"\n| Le_LCons: \"xs \\<sqsubseteq> ys \\<Longrightarrow> LCons x xs \\<sqsubseteq> LCons x ys\""], ["", "lemma lprefixI [consumes 1, case_names lprefix,\n                case_conclusion lprefix LeLNil LeLCons]:\n  assumes major: \"(xs, ys) \\<in> X\"\n  and step:\n      \"\\<And>xs ys. (xs, ys) \\<in> X\n       \\<Longrightarrow> lnull xs \\<or> (\\<exists>x xs' ys'. xs = LCons x xs' \\<and> ys = LCons x ys' \\<and>\n                                   ((xs', ys') \\<in> X \\<or> xs' \\<sqsubseteq> ys'))\"\n  shows \"xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "using major"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> X\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(rule lprefix.coinduct)(auto dest: step)"], ["", "lemma lprefix_coinduct [consumes 1, case_names lprefix, case_conclusion lprefix LNil LCons, coinduct pred: lprefix]:\n  assumes major: \"P xs ys\"\n  and step: \"\\<And>xs ys. P xs ys\n    \\<Longrightarrow> (lnull ys \\<longrightarrow> lnull xs) \\<and>\n       (\\<not> lnull xs \\<longrightarrow> \\<not> lnull ys \\<longrightarrow> lhd xs = lhd ys \\<and> (P (ltl xs) (ltl ys) \\<or> ltl xs \\<sqsubseteq> ltl ys))\"\n  shows \"xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "from major"], ["proof (chain)\npicking this:\n  P xs ys", "have \"(xs, ys) \\<in> {(xs, ys). P xs ys}\""], ["proof (prove)\nusing this:\n  P xs ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> {(xs, ys). P xs ys}", "by simp"], ["proof (state)\nthis:\n  (xs, ys) \\<in> {(xs, ys). P xs ys}\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> {(xs, ys). P xs ys}\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "proof(coinduct rule: lprefixI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (xs, ys) \\<in> {(xs, ys). P xs ys} \\<Longrightarrow>\n       lnull xs \\<or>\n       (\\<exists>x xs' ys'.\n           xs = LCons x xs' \\<and>\n           ys = LCons x ys' \\<and>\n           ((xs', ys') \\<in> {(xs, ys). P xs ys} \\<or>\n            xs' \\<sqsubseteq> ys'))", "case (lprefix xs ys)"], ["proof (state)\nthis:\n  (xs, ys) \\<in> {(xs, ys). P xs ys}\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (xs, ys) \\<in> {(xs, ys). P xs ys} \\<Longrightarrow>\n       lnull xs \\<or>\n       (\\<exists>x xs' ys'.\n           xs = LCons x xs' \\<and>\n           ys = LCons x ys' \\<and>\n           ((xs', ys') \\<in> {(xs, ys). P xs ys} \\<or>\n            xs' \\<sqsubseteq> ys'))", "hence \"P xs ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> {(xs, ys). P xs ys}\n\ngoal (1 subgoal):\n 1. P xs ys", "by simp"], ["proof (state)\nthis:\n  P xs ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       (xs, ys) \\<in> {(xs, ys). P xs ys} \\<Longrightarrow>\n       lnull xs \\<or>\n       (\\<exists>x xs' ys'.\n           xs = LCons x xs' \\<and>\n           ys = LCons x ys' \\<and>\n           ((xs', ys') \\<in> {(xs, ys). P xs ys} \\<or>\n            xs' \\<sqsubseteq> ys'))", "from step[OF this]"], ["proof (chain)\npicking this:\n  (lnull ys \\<longrightarrow> lnull xs) \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (P (ltl xs) (ltl ys) \\<or> ltl xs \\<sqsubseteq> ltl ys))", "show ?case"], ["proof (prove)\nusing this:\n  (lnull ys \\<longrightarrow> lnull xs) \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (P (ltl xs) (ltl ys) \\<or> ltl xs \\<sqsubseteq> ltl ys))\n\ngoal (1 subgoal):\n 1. lnull xs \\<or>\n    (\\<exists>x xs' ys'.\n        xs = LCons x xs' \\<and>\n        ys = LCons x ys' \\<and>\n        ((xs', ys') \\<in> {(xs, ys). P xs ys} \\<or> xs' \\<sqsubseteq> ys'))", "by(cases xs)(auto simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  lnull xs \\<or>\n  (\\<exists>x xs' ys'.\n      xs = LCons x xs' \\<and>\n      ys = LCons x ys' \\<and>\n      ((xs', ys') \\<in> {(xs, ys). P xs ys} \\<or> xs' \\<sqsubseteq> ys'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_refl [intro, simp]: \"xs \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma lprefix_LNil [simp]: \"xs \\<sqsubseteq> LNil \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> LNil = lnull xs", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> LNil = (xs = LNil)", "by(subst lprefix.simps)simp"], ["", "lemma lprefix_lnull: \"lnull ys \\<Longrightarrow> xs \\<sqsubseteq> ys \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull ys \\<Longrightarrow> xs \\<sqsubseteq> ys = lnull xs", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = LNil \\<Longrightarrow> xs \\<sqsubseteq> ys = (xs = LNil)", "by auto"], ["", "lemma lnull_lprefix: \"lnull xs \\<Longrightarrow> lprefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> xs \\<sqsubseteq> ys", "by(simp add: lnull_def)"], ["", "lemma lprefix_LCons_conv:\n  \"xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow>\n   xs = LNil \\<or> (\\<exists>xs'. xs = LCons y xs' \\<and> xs' \\<sqsubseteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> LCons y ys =\n    (xs = LNil \\<or>\n     (\\<exists>xs'. xs = LCons y xs' \\<and> xs' \\<sqsubseteq> ys))", "by(subst lprefix.simps) simp"], ["", "lemma LCons_lprefix_LCons [simp]:\n  \"LCons x xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow> x = y \\<and> xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x xs \\<sqsubseteq> LCons y ys = (x = y \\<and> xs \\<sqsubseteq> ys)", "by(simp add: lprefix_LCons_conv)"], ["", "lemma LCons_lprefix_conv:\n  \"LCons x xs \\<sqsubseteq> ys \\<longleftrightarrow> (\\<exists>ys'. ys = LCons x ys' \\<and> xs \\<sqsubseteq> ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x xs \\<sqsubseteq> ys =\n    (\\<exists>ys'. ys = LCons x ys' \\<and> xs \\<sqsubseteq> ys')", "by(cases ys)(auto)"], ["", "lemma lprefix_ltlI: \"xs \\<sqsubseteq> ys \\<Longrightarrow> ltl xs \\<sqsubseteq> ltl ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> ltl xs \\<sqsubseteq> ltl ys", "by(cases ys)(auto simp add: lprefix_LCons_conv)"], ["", "lemma lprefix_code [code]:\n  \"LNil \\<sqsubseteq> ys \\<longleftrightarrow> True\"\n  \"LCons x xs \\<sqsubseteq> LNil \\<longleftrightarrow> False\"\n  \"LCons x xs \\<sqsubseteq> LCons y ys \\<longleftrightarrow> x = y \\<and> xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LNil \\<sqsubseteq> ys = True &&&\n    LCons x xs \\<sqsubseteq> LNil = False &&&\n    LCons x xs \\<sqsubseteq> LCons y ys = (x = y \\<and> xs \\<sqsubseteq> ys)", "by simp_all"], ["", "lemma lprefix_lhdD: \"\\<lbrakk> xs \\<sqsubseteq> ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd xs = lhd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd xs = lhd ys", "by(clarsimp simp add: not_lnull_conv LCons_lprefix_conv)"], ["", "lemma lprefix_lnullD: \"\\<lbrakk> xs \\<sqsubseteq> ys; lnull ys \\<rbrakk> \\<Longrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; lnull ys\\<rbrakk>\n    \\<Longrightarrow> lnull xs", "by(auto elim: lprefix.cases)"], ["", "lemma lprefix_not_lnullD: \"\\<lbrakk> xs \\<sqsubseteq> ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> \\<not> lnull ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> \\<not> lnull ys", "by(auto elim: lprefix.cases)"], ["", "lemma lprefix_expand:\n  \"(\\<not> lnull xs \\<Longrightarrow> \\<not> lnull ys \\<and> lhd xs = lhd ys \\<and> ltl xs \\<sqsubseteq> ltl ys) \\<Longrightarrow> xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> lnull xs \\<Longrightarrow>\n     \\<not> lnull ys \\<and>\n     lhd xs = lhd ys \\<and> ltl xs \\<sqsubseteq> ltl ys) \\<Longrightarrow>\n    xs \\<sqsubseteq> ys", "by(cases xs ys rule: llist.exhaust[case_product llist.exhaust])(simp_all)"], ["", "lemma lprefix_antisym:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; ys \\<sqsubseteq> xs \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; ys \\<sqsubseteq> xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by(coinduction arbitrary: xs ys)(auto simp add: not_lnull_conv lprefix_lnull)"], ["", "lemma lprefix_trans [trans]:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; ys \\<sqsubseteq> zs \\<rbrakk> \\<Longrightarrow> xs \\<sqsubseteq> zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; ys \\<sqsubseteq> zs\\<rbrakk>\n    \\<Longrightarrow> xs \\<sqsubseteq> zs", "by(coinduction arbitrary: xs ys zs)(auto 4 3 dest: lprefix_lnullD lprefix_lhdD intro: lprefix_ltlI)"], ["", "lemma preorder_lprefix [cont_intro]:\n  \"class.preorder (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.preorder (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))", "by(unfold_locales)(auto simp add: mk_less_def intro: lprefix_trans)"], ["", "lemma lprefix_lsetD:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"lset xs \\<subseteq> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs \\<subseteq> lset ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset xs \\<Longrightarrow> x \\<in> lset ys", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset xs \\<Longrightarrow> x \\<in> lset ys", "assume \"x \\<in> lset xs\""], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset xs \\<Longrightarrow> x \\<in> lset ys", "thus \"x \\<in> lset ys\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset ys", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. x \\<in> lset ys", "by(induct arbitrary: ys)(auto simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  x \\<in> lset ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_lappend_sameI:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"lappend zs xs \\<sqsubseteq> lappend zs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend zs xs \\<sqsubseteq> lappend zs ys", "proof(cases \"lfinite zs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite zs \\<Longrightarrow> lappend zs xs \\<sqsubseteq> lappend zs ys\n 2. \\<not> lfinite zs \\<Longrightarrow>\n    lappend zs xs \\<sqsubseteq> lappend zs ys", "case True"], ["proof (state)\nthis:\n  lfinite zs\n\ngoal (2 subgoals):\n 1. lfinite zs \\<Longrightarrow> lappend zs xs \\<sqsubseteq> lappend zs ys\n 2. \\<not> lfinite zs \\<Longrightarrow>\n    lappend zs xs \\<sqsubseteq> lappend zs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite zs\n\ngoal (1 subgoal):\n 1. lappend zs xs \\<sqsubseteq> lappend zs ys", "using assms"], ["proof (prove)\nusing this:\n  lfinite zs\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. lappend zs xs \\<sqsubseteq> lappend zs ys", "by induct auto"], ["proof (state)\nthis:\n  lappend zs xs \\<sqsubseteq> lappend zs ys\n\ngoal (1 subgoal):\n 1. \\<not> lfinite zs \\<Longrightarrow>\n    lappend zs xs \\<sqsubseteq> lappend zs ys", "qed(simp add: lappend_inf)"], ["", "lemma not_lfinite_lprefix_conv_eq:\n  assumes nfin: \"\\<not> lfinite xs\"\n  shows \"xs \\<sqsubseteq> ys \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys = (xs = ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> xs \\<sqsubseteq> ys", "assume \"xs \\<sqsubseteq> ys\""], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> xs \\<sqsubseteq> ys", "with nfin"], ["proof (chain)\npicking this:\n  \\<not> lfinite xs\n  xs \\<sqsubseteq> ys", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by(coinduction arbitrary: xs ys)(auto dest: lprefix_lnullD lprefix_lhdD intro: lprefix_ltlI)"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> xs \\<sqsubseteq> ys", "qed simp"], ["", "lemma lprefix_lappend: \"xs \\<sqsubseteq> lappend xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> lappend xs ys", "by(coinduction arbitrary: xs) auto"], ["", "lemma lprefix_down_linear:\n  assumes \"xs \\<sqsubseteq> zs\" \"ys \\<sqsubseteq> zs\"\n  shows \"xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs", "proof(rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ys \\<sqsubseteq> xs \\<Longrightarrow> xs \\<sqsubseteq> ys", "assume \"\\<not> ys \\<sqsubseteq> xs\""], ["proof (state)\nthis:\n  \\<not> ys \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. \\<not> ys \\<sqsubseteq> xs \\<Longrightarrow> xs \\<sqsubseteq> ys", "with assms"], ["proof (chain)\npicking this:\n  xs \\<sqsubseteq> zs\n  ys \\<sqsubseteq> zs\n  \\<not> ys \\<sqsubseteq> xs", "show \"xs \\<sqsubseteq> ys\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> zs\n  ys \\<sqsubseteq> zs\n  \\<not> ys \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(coinduction arbitrary: xs ys zs)(auto simp add: not_lnull_conv LCons_lprefix_conv, simp add: lnull_def)"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_lappend_same [simp]:\n  \"lappend xs ys \\<sqsubseteq> lappend xs zs \\<longleftrightarrow> (lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs =\n    (lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs \\<Longrightarrow>\n    lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs\n 2. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "assume \"?lhs\""], ["proof (state)\nthis:\n  lappend xs ys \\<sqsubseteq> lappend xs zs\n\ngoal (2 subgoals):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs \\<Longrightarrow>\n    lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs\n 2. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "show \"?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys \\<sqsubseteq> zs", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys \\<sqsubseteq> zs", "thus \"ys \\<sqsubseteq> zs\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. ys \\<sqsubseteq> zs", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  lfinite xs\n  lappend xs ys \\<sqsubseteq> lappend xs zs\n\ngoal (1 subgoal):\n 1. ys \\<sqsubseteq> zs", "by(induct) simp_all"], ["proof (state)\nthis:\n  ys \\<sqsubseteq> zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "assume \"?rhs\""], ["proof (state)\nthis:\n  lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<longrightarrow> ys \\<sqsubseteq> zs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lappend xs ys \\<sqsubseteq> lappend xs zs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lappend xs ys \\<sqsubseteq> lappend xs zs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "hence yszs: \"ys \\<sqsubseteq> zs\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. ys \\<sqsubseteq> zs", "by(rule \\<open>?rhs\\<close>[rule_format])"], ["proof (state)\nthis:\n  ys \\<sqsubseteq> zs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lappend xs ys \\<sqsubseteq> lappend xs zs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "from True"], ["proof (chain)\npicking this:\n  lfinite xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs", "by induct (simp_all add: yszs)"], ["proof (state)\nthis:\n  lappend xs ys \\<sqsubseteq> lappend xs zs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lappend xs ys \\<sqsubseteq> lappend xs zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lappend xs ys \\<sqsubseteq> lappend xs zs", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  lappend xs ys \\<sqsubseteq> lappend xs zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lappend xs ys \\<sqsubseteq> lappend xs zs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Setup for partial\\_function\\<close>"], ["", "primcorec lSup :: \"'a llist set \\<Rightarrow> 'a llist\"\nwhere\n  \"lSup A =\n  (if \\<forall>x\\<in>A. lnull x then LNil\n   else LCons (THE x. x \\<in> lhd ` (A \\<inter> {xs. \\<not> lnull xs})) (lSup (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))))\""], ["", "declare lSup.simps[simp del]"], ["", "lemma lnull_lSup [simp]: \"lnull (lSup A) \\<longleftrightarrow> (\\<forall>x\\<in>A. lnull x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lSup A) = (\\<forall>x\\<in>A. lnull x)", "by(simp add: lSup_def)"], ["", "lemma lhd_lSup [simp]: \"\\<exists>x\\<in>A. \\<not> lnull x \\<Longrightarrow> lhd (lSup A) = (THE x. x \\<in> lhd ` (A \\<inter> {xs. \\<not> lnull xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A. \\<not> lnull x \\<Longrightarrow>\n    lhd (lSup A) = (THE x. x \\<in> lhd ` (A \\<inter> {xs. \\<not> lnull xs}))", "by(auto simp add: lSup_def)"], ["", "lemma ltl_lSup [simp]: \"ltl (lSup A) = lSup (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lSup A) = lSup (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))", "by(cases \"\\<forall>xs\\<in>A. lnull xs\")(auto 4 3 simp add: lSup_def intro: llist.expand)"], ["", "lemma lhd_lSup_eq:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y\"\n  shows \"\\<lbrakk> xs \\<in> Y; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd (lSup Y) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> Y; \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup Y) = lhd xs", "by(subst lhd_lSup)(auto 4 3 dest: chainD[OF chain] lprefix_lhdD intro!: the_equality)"], ["", "lemma lSup_empty [simp]: \"lSup {} = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {} = LNil", "by(simp add: lSup_def)"], ["", "lemma lSup_singleton [simp]: \"lSup {xs} = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {xs} = xs", "by(coinduction arbitrary: xs) simp_all"], ["", "lemma LCons_image_Int_not_lnull: \"(LCons x ` A \\<inter> {xs. \\<not> lnull xs}) = LCons x ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x ` A \\<inter> {xs. \\<not> lnull xs} = LCons x ` A", "by auto"], ["", "lemma lSup_LCons: \"A \\<noteq> {} \\<Longrightarrow> lSup (LCons x ` A) = LCons x (lSup A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> lSup (LCons x ` A) = LCons x (lSup A)", "by(rule llist.expand)(auto simp add: image_image lhd_lSup exI LCons_image_Int_not_lnull intro!: the_equality)"], ["", "lemma lSup_eq_LCons_iff:\n  \"lSup Y = LCons x xs \\<longleftrightarrow> (\\<exists>x\\<in>Y. \\<not> lnull x) \\<and> x = (THE x. x \\<in> lhd ` (Y \\<inter> {xs. \\<not> lnull xs})) \\<and> xs = lSup (ltl ` (Y \\<inter> {xs. \\<not> lnull xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lSup Y = LCons x xs) =\n    ((\\<exists>x\\<in>Y. \\<not> lnull x) \\<and>\n     x = (THE x. x \\<in> lhd ` (Y \\<inter> {xs. \\<not> lnull xs})) \\<and>\n     xs = lSup (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})))", "by(auto dest: eq_LConsD simp add: lnull_def[symmetric] intro: llist.expand)"], ["", "lemma lSup_insert_LNil: \"lSup (insert LNil Y) = lSup Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup (insert LNil Y) = lSup Y", "by(rule llist.expand) simp_all"], ["", "lemma lSup_minus_LNil: \"lSup (Y - {LNil}) = lSup Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup (Y - {LNil}) = lSup Y", "using lSup_insert_LNil[where Y=\"Y - {LNil}\", symmetric]"], ["proof (prove)\nusing this:\n  lSup (Y - {LNil}) = lSup (insert LNil (Y - {LNil}))\n\ngoal (1 subgoal):\n 1. lSup (Y - {LNil}) = lSup Y", "by(cases \"LNil \\<in> Y\")(simp_all add: insert_absorb)"], ["", "lemma chain_lprefix_ltl:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) A\"\n  shows \"Complete_Partial_Order.chain (\\<sqsubseteq>) (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>)\n     (ltl ` (A \\<inter> {xs. \\<not> lnull xs}))", "by(auto intro!: chainI dest: chainD[OF chain] intro: lprefix_ltlI)"], ["", "lemma lSup_finite_prefixes: \"lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} = xs\" (is \"lSup (?C xs) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} = xs", "proof(coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "case (Eq_llist xs)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "have ?lnull"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs", "by(cases xs)(auto simp add: lprefix_LCons_conv)"], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "moreover"], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "have \"\\<not> lnull xs \\<Longrightarrow> ltl ` ({ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<inter> {xs. \\<not> lnull xs}) = {ys. ys \\<sqsubseteq> ltl xs \\<and> lfinite ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<Longrightarrow>\n    ltl `\n    ({ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<inter>\n     {xs. \\<not> lnull xs}) =\n    {ys. ys \\<sqsubseteq> ltl xs \\<and> lfinite ys}", "by(auto 4 4 intro!: rev_image_eqI[where x=\"LCons (lhd xs) ys\" for ys] intro: llist.expand lprefix_ltlI simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  \\<not> lnull xs \\<Longrightarrow>\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "hence ?LCons"], ["proof (prove)\nusing this:\n  \\<not> lnull xs \\<Longrightarrow>\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. \\<not> lnull\n            (lSup\n              {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n    \\<not> lnull xs \\<longrightarrow>\n    lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n    (\\<exists>xs.\n        ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n        ltl xs = xs)", "by(auto 4 3 intro!: the_equality dest: lprefix_lhdD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  \\<not> lnull\n          (lSup\n            {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n  \\<not> lnull xs \\<longrightarrow>\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n  (\\<exists>xs.\n      ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n      lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n      ltl xs = xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> lfinite ys} \\<and>\n            ltl xs = xsa))", "ultimately"], ["proof (chain)\npicking this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs\n  \\<not> lnull\n          (lSup\n            {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n  \\<not> lnull xs \\<longrightarrow>\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n  (\\<exists>xs.\n      ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n      lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n      ltl xs = xs)", "show ?case"], ["proof (prove)\nusing this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs\n  \\<not> lnull\n          (lSup\n            {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n  \\<not> lnull xs \\<longrightarrow>\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n  (\\<exists>xs.\n      ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n      lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n      ltl xs = xs)\n\ngoal (1 subgoal):\n 1. lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n    lnull xs \\<and>\n    (\\<not> lnull\n             (lSup\n               {ys.\n                ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n     \\<not> lnull xs \\<longrightarrow>\n     lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n     (\\<exists>xs.\n         ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n         lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n         ltl xs = xs))", ".."], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lnull xs \\<and>\n  (\\<not> lnull\n           (lSup\n             {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) \\<longrightarrow>\n   \\<not> lnull xs \\<longrightarrow>\n   lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) = lhd xs \\<and>\n   (\\<exists>xs.\n       ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys}) =\n       lSup {ys. ys \\<sqsubseteq> xs \\<and> lfinite ys} \\<and>\n       ltl xs = xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lSup_finite_gen_prefixes:\n  assumes \"zs \\<sqsubseteq> xs\" \"lfinite zs\"\n  shows \"lSup {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "using \\<open>lfinite zs\\<close> \\<open>zs \\<sqsubseteq> xs\\<close>"], ["proof (prove)\nusing this:\n  lfinite zs\n  zs \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "proof(induction arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       LNil \\<sqsubseteq> xs \\<Longrightarrow>\n       lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LNil \\<sqsubseteq> ys \\<and> lfinite ys} =\n       xs\n 2. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "case lfinite_LNil"], ["proof (state)\nthis:\n  LNil \\<sqsubseteq> xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       LNil \\<sqsubseteq> xs \\<Longrightarrow>\n       lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LNil \\<sqsubseteq> ys \\<and> lfinite ys} =\n       xs\n 2. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "thus ?case"], ["proof (prove)\nusing this:\n  LNil \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and> LNil \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "by(simp add: lSup_finite_prefixes)"], ["proof (state)\nthis:\n  lSup\n   {ys.\n    ys \\<sqsubseteq> xs \\<and> LNil \\<sqsubseteq> ys \\<and> lfinite ys} =\n  xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "case (lfinite_LConsI zs z)"], ["proof (state)\nthis:\n  lfinite zs\n  zs \\<sqsubseteq> ?xs \\<Longrightarrow>\n  lSup\n   {ys. ys \\<sqsubseteq> ?xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  ?xs\n  LCons z zs \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "from \\<open>LCons z zs \\<sqsubseteq> xs\\<close>"], ["proof (chain)\npicking this:\n  LCons z zs \\<sqsubseteq> xs", "obtain xs' where xs: \"xs = LCons z xs'\"\n    and \"zs \\<sqsubseteq> xs'\""], ["proof (prove)\nusing this:\n  LCons z zs \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>xs = LCons z xs'; zs \\<sqsubseteq> xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  xs = LCons z xs'\n  zs \\<sqsubseteq> xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa.\n           xs \\<sqsubseteq> xsa \\<Longrightarrow>\n           lSup\n            {ys.\n             ys \\<sqsubseteq> xsa \\<and>\n             xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n           xsa;\n        LCons x xs \\<sqsubseteq> xsa\\<rbrakk>\n       \\<Longrightarrow> lSup\n                          {ys.\n                           ys \\<sqsubseteq> xsa \\<and>\n                           LCons x xs \\<sqsubseteq> ys \\<and> lfinite ys} =\n                         xsa", "show ?case (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and>\n      LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "proof(rule llist.expand)"], ["proof (state)\ngoal (2 subgoals):\n 1. lnull\n     (lSup\n       {ys.\n        ys \\<sqsubseteq> xs \\<and>\n        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lnull xs\n 2. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "show \"lnull ?lhs = lnull ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull\n     (lSup\n       {ys.\n        ys \\<sqsubseteq> xs \\<and>\n        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lnull xs", "using xs lfinite_LConsI"], ["proof (prove)\nusing this:\n  xs = LCons z xs'\n  lfinite zs\n  zs \\<sqsubseteq> ?xs \\<Longrightarrow>\n  lSup\n   {ys. ys \\<sqsubseteq> ?xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  ?xs\n  LCons z zs \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. lnull\n     (lSup\n       {ys.\n        ys \\<sqsubseteq> xs \\<and>\n        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lnull xs", "by(auto 4 3 simp add: lprefix_LCons_conv del: disjCI intro: disjI2)"], ["proof (state)\nthis:\n  lnull\n   (lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and>\n      LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lnull xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "assume lnull: \"\\<not> lnull ?lhs\" \"\\<not> lnull ?rhs\""], ["proof (state)\nthis:\n  \\<not> lnull\n          (lSup\n            {ys.\n             ys \\<sqsubseteq> xs \\<and>\n             LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys})\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "have \"lhd ?lhs = lhd ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lhd xs", "using lnull xs"], ["proof (prove)\nusing this:\n  \\<not> lnull\n          (lSup\n            {ys.\n             ys \\<sqsubseteq> xs \\<and>\n             LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys})\n  \\<not> lnull xs\n  xs = LCons z xs'\n\ngoal (1 subgoal):\n 1. lhd (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lhd xs", "by(auto intro!: rev_image_eqI simp add: LCons_lprefix_conv)"], ["proof (state)\nthis:\n  lhd (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lhd xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "moreover"], ["proof (state)\nthis:\n  lhd (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lhd xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "have \"ltl ` ({ys. ys \\<sqsubseteq> xs \\<and> LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter> {xs. \\<not> lnull xs}) =\n          {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl `\n    ({ys.\n      ys \\<sqsubseteq> xs \\<and>\n      LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter>\n     {xs. \\<not> lnull xs}) =\n    {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}", "using xs \\<open>\\<not> lnull ?rhs\\<close>"], ["proof (prove)\nusing this:\n  xs = LCons z xs'\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. ltl `\n    ({ys.\n      ys \\<sqsubseteq> xs \\<and>\n      LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter>\n     {xs. \\<not> lnull xs}) =\n    {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}", "by(auto 4 3 simp add: lprefix_LCons_conv intro: rev_image_eqI del: disjCI intro: disjI2)"], ["proof (state)\nthis:\n  ltl `\n  ({ys.\n    ys \\<sqsubseteq> xs \\<and>\n    LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "hence \"ltl ?lhs = ltl ?rhs\""], ["proof (prove)\nusing this:\n  ltl `\n  ({ys.\n    ys \\<sqsubseteq> xs \\<and>\n    LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. ltl (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    ltl xs", "using lfinite_LConsI.IH[OF \\<open>zs \\<sqsubseteq> xs'\\<close>] xs"], ["proof (prove)\nusing this:\n  ltl `\n  ({ys.\n    ys \\<sqsubseteq> xs \\<and>\n    LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\n  lSup\n   {ys. ys \\<sqsubseteq> xs' \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  xs'\n  xs = LCons z xs'\n\ngoal (1 subgoal):\n 1. ltl (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    ltl xs", "by simp"], ["proof (state)\nthis:\n  ltl (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  ltl xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull\n                     (lSup\n                       {ys.\n                        ys \\<sqsubseteq> xs \\<and>\n                        LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys});\n     \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      lhd xs \\<and>\n                      ltl (lSup\n                            {ys.\n                             ys \\<sqsubseteq> xs \\<and>\n                             LCons z zs \\<sqsubseteq> ys \\<and>\n                             lfinite ys}) =\n                      ltl xs", "ultimately"], ["proof (chain)\npicking this:\n  lhd (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lhd xs\n  ltl (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  ltl xs", "show \"lhd ?lhs = lhd ?rhs \\<and> ltl ?lhs = ltl ?rhs\""], ["proof (prove)\nusing this:\n  lhd (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lhd xs\n  ltl (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  ltl xs\n\ngoal (1 subgoal):\n 1. lhd (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    lhd xs \\<and>\n    ltl (lSup\n          {ys.\n           ys \\<sqsubseteq> xs \\<and>\n           LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n    ltl xs", ".."], ["proof (state)\nthis:\n  lhd (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  lhd xs \\<and>\n  ltl (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and>\n         LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys}) =\n  ltl xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lSup\n   {ys.\n    ys \\<sqsubseteq> xs \\<and>\n    LCons z zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lSup_strict_prefixes:\n  \"\\<not> lfinite xs \\<Longrightarrow> lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs\"\n  (is \"_ \\<Longrightarrow> lSup (?C xs) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs", "proof(coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "case (Eq_llist xs)"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "then"], ["proof (chain)\npicking this:\n  \\<not> lfinite xs", "obtain x x' xs' where xs: \"xs = LCons x (LCons x' xs')\" \"\\<not> lfinite xs'\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. (\\<And>x x' xs'.\n        \\<lbrakk>xs = LCons x (LCons x' xs'); \\<not> lfinite xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs)(simp, rename_tac xs', case_tac xs', auto)"], ["proof (state)\nthis:\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "hence ?lnull"], ["proof (prove)\nusing this:\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'\n\ngoal (1 subgoal):\n 1. lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs", "by(auto intro: exI[where x=\"LCons x (LCons x' LNil)\"])"], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "moreover"], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "hence \"\\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})\""], ["proof (prove)\nusing this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})", "using xs"], ["proof (prove)\nusing this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "hence \"lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})\n\ngoal (1 subgoal):\n 1. lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs", "using xs"], ["proof (prove)\nusing this:\n  \\<not> lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs})\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'\n\ngoal (1 subgoal):\n 1. lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs", "by(auto 4 3 intro!: the_equality intro: rev_image_eqI dest: lprefix_lhdD)"], ["proof (state)\nthis:\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "moreover"], ["proof (state)\nthis:\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "from xs"], ["proof (chain)\npicking this:\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'", "have \"ltl ` ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter> {xs. \\<not> lnull xs}) = {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}\""], ["proof (prove)\nusing this:\n  xs = LCons x (LCons x' xs')\n  \\<not> lfinite xs'\n\ngoal (1 subgoal):\n 1. ltl `\n    ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter>\n     {xs. \\<not> lnull xs}) =\n    {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}", "by(auto simp add: lprefix_LCons_conv intro: image_eqI[where x=\"LCons x (LCons x' ys)\" for ys] image_eqI[where x=\"LCons x LNil\"])"], ["proof (state)\nthis:\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<not> lfinite xs \\<Longrightarrow>\n       lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lnull xs \\<and>\n       (\\<not> lnull\n                (lSup\n                  {ys.\n                   ys \\<sqsubseteq> xs \\<and>\n                   ys \\<noteq> xs}) \\<longrightarrow>\n        \\<not> lnull xs \\<longrightarrow>\n        lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n        lhd xs \\<and>\n        (\\<exists>xsa.\n            ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n            lSup {ys. ys \\<sqsubseteq> xsa \\<and> ys \\<noteq> xsa} \\<and>\n            ltl xs = xsa \\<and> \\<not> lfinite xsa))", "ultimately"], ["proof (chain)\npicking this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}", "show ?case"], ["proof (prove)\nusing this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}\n\ngoal (1 subgoal):\n 1. lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n    lnull xs \\<and>\n    (\\<not> lnull\n             (lSup\n               {ys.\n                ys \\<sqsubseteq> xs \\<and>\n                ys \\<noteq> xs}) \\<longrightarrow>\n     \\<not> lnull xs \\<longrightarrow>\n     lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n     lhd xs \\<and>\n     (\\<exists>xs.\n         ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n         lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<and>\n         ltl xs = xs \\<and> \\<not> lfinite xs))", "using Eq_llist"], ["proof (prove)\nusing this:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lnull xs\n  lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) = lhd xs\n  ltl `\n  ({ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<inter>\n   {xs. \\<not> lnull xs}) =\n  {ys. ys \\<sqsubseteq> ltl xs \\<and> ys \\<noteq> ltl xs}\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n    lnull xs \\<and>\n    (\\<not> lnull\n             (lSup\n               {ys.\n                ys \\<sqsubseteq> xs \\<and>\n                ys \\<noteq> xs}) \\<longrightarrow>\n     \\<not> lnull xs \\<longrightarrow>\n     lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n     lhd xs \\<and>\n     (\\<exists>xs.\n         ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n         lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<and>\n         ltl xs = xs \\<and> \\<not> lfinite xs))", "by clarsimp"], ["proof (state)\nthis:\n  lnull (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n  lnull xs \\<and>\n  (\\<not> lnull\n           (lSup\n             {ys.\n              ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) \\<longrightarrow>\n   \\<not> lnull xs \\<longrightarrow>\n   lhd (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n   lhd xs \\<and>\n   (\\<exists>xs.\n       ltl (lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}) =\n       lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<and>\n       ltl xs = xs \\<and> \\<not> lfinite xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_lprefix_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) A; xs \\<in> A \\<rbrakk>\n  \\<Longrightarrow> xs \\<sqsubseteq> lSup A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n     xs \\<in> A\\<rbrakk>\n    \\<Longrightarrow> xs \\<sqsubseteq> lSup A", "proof(coinduction arbitrary: xs A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        xsa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (lnull (lSup A) \\<longrightarrow> lnull xsa) \\<and>\n                         (\\<not> lnull xsa \\<longrightarrow>\n                          \\<not> lnull (lSup A) \\<longrightarrow>\n                          lhd xsa = lhd (lSup A) \\<and>\n                          ((\\<exists>xs Aa.\n                               ltl xsa = xs \\<and>\n                               ltl (lSup A) = lSup Aa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               xs \\<in> Aa) \\<or>\n                           ltl xsa \\<sqsubseteq> ltl (lSup A)))", "case (lprefix xs A)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n  xs \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>xsa A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        xsa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (lnull (lSup A) \\<longrightarrow> lnull xsa) \\<and>\n                         (\\<not> lnull xsa \\<longrightarrow>\n                          \\<not> lnull (lSup A) \\<longrightarrow>\n                          lhd xsa = lhd (lSup A) \\<and>\n                          ((\\<exists>xs Aa.\n                               ltl xsa = xs \\<and>\n                               ltl (lSup A) = lSup Aa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               xs \\<in> Aa) \\<or>\n                           ltl xsa \\<sqsubseteq> ltl (lSup A)))", "note chain = \\<open>Complete_Partial_Order.chain (\\<sqsubseteq>) A\\<close>"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n\ngoal (1 subgoal):\n 1. \\<And>xsa A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        xsa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (lnull (lSup A) \\<longrightarrow> lnull xsa) \\<and>\n                         (\\<not> lnull xsa \\<longrightarrow>\n                          \\<not> lnull (lSup A) \\<longrightarrow>\n                          lhd xsa = lhd (lSup A) \\<and>\n                          ((\\<exists>xs Aa.\n                               ltl xsa = xs \\<and>\n                               ltl (lSup A) = lSup Aa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               xs \\<in> Aa) \\<or>\n                           ltl xsa \\<sqsubseteq> ltl (lSup A)))", "from \\<open>xs \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> A", "show ?case"], ["proof (prove)\nusing this:\n  xs \\<in> A\n\ngoal (1 subgoal):\n 1. (lnull (lSup A) \\<longrightarrow> lnull xs) \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull (lSup A) \\<longrightarrow>\n     lhd xs = lhd (lSup A) \\<and>\n     ((\\<exists>xs A.\n          ltl xs = xs \\<and>\n          ltl (lSup A) = lSup A \\<and>\n          Complete_Partial_Order.chain (\\<sqsubseteq>) A \\<and>\n          xs \\<in> A) \\<or>\n      ltl xs \\<sqsubseteq> ltl (lSup A)))", "by(auto 4 3 dest: chainD[OF chain] lprefix_lhdD intro: chain_lprefix_ltl[OF chain] intro!: the_equality[symmetric])"], ["proof (state)\nthis:\n  (lnull (lSup A) \\<longrightarrow> lnull xs) \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull (lSup A) \\<longrightarrow>\n   lhd xs = lhd (lSup A) \\<and>\n   ((\\<exists>xs A.\n        ltl xs = xs \\<and>\n        ltl (lSup A) = lSup A \\<and>\n        Complete_Partial_Order.chain (\\<sqsubseteq>) A \\<and>\n        xs \\<in> A) \\<or>\n    ltl xs \\<sqsubseteq> ltl (lSup A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_lSup_lprefix:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) A; \\<And>xs. xs \\<in> A \\<Longrightarrow> xs \\<sqsubseteq> zs \\<rbrakk>\n  \\<Longrightarrow> lSup A \\<sqsubseteq> zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n     \\<And>xs. xs \\<in> A \\<Longrightarrow> xs \\<sqsubseteq> zs\\<rbrakk>\n    \\<Longrightarrow> lSup A \\<sqsubseteq> zs", "proof(coinduction arbitrary: A zs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A zs.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        \\<forall>xs.\n           xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\\<rbrakk>\n       \\<Longrightarrow> (lnull zs \\<longrightarrow> lnull (lSup A)) \\<and>\n                         (\\<not> lnull (lSup A) \\<longrightarrow>\n                          \\<not> lnull zs \\<longrightarrow>\n                          lhd (lSup A) = lhd zs \\<and>\n                          ((\\<exists>Aa zsa.\n                               ltl (lSup A) = lSup Aa \\<and>\n                               ltl zs = zsa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               (\\<forall>xs.\n                                   xs \\<in> Aa \\<longrightarrow>\n                                   xs \\<sqsubseteq> zsa)) \\<or>\n                           ltl (lSup A) \\<sqsubseteq> ltl zs))", "case (lprefix A zs)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n  \\<forall>xs. xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\n\ngoal (1 subgoal):\n 1. \\<And>A zs.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        \\<forall>xs.\n           xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\\<rbrakk>\n       \\<Longrightarrow> (lnull zs \\<longrightarrow> lnull (lSup A)) \\<and>\n                         (\\<not> lnull (lSup A) \\<longrightarrow>\n                          \\<not> lnull zs \\<longrightarrow>\n                          lhd (lSup A) = lhd zs \\<and>\n                          ((\\<exists>Aa zsa.\n                               ltl (lSup A) = lSup Aa \\<and>\n                               ltl zs = zsa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               (\\<forall>xs.\n                                   xs \\<in> Aa \\<longrightarrow>\n                                   xs \\<sqsubseteq> zsa)) \\<or>\n                           ltl (lSup A) \\<sqsubseteq> ltl zs))", "note chain = \\<open>Complete_Partial_Order.chain (\\<sqsubseteq>) A\\<close>"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n\ngoal (1 subgoal):\n 1. \\<And>A zs.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        \\<forall>xs.\n           xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\\<rbrakk>\n       \\<Longrightarrow> (lnull zs \\<longrightarrow> lnull (lSup A)) \\<and>\n                         (\\<not> lnull (lSup A) \\<longrightarrow>\n                          \\<not> lnull zs \\<longrightarrow>\n                          lhd (lSup A) = lhd zs \\<and>\n                          ((\\<exists>Aa zsa.\n                               ltl (lSup A) = lSup Aa \\<and>\n                               ltl zs = zsa \\<and>\n                               Complete_Partial_Order.chain (\\<sqsubseteq>)\n                                Aa \\<and>\n                               (\\<forall>xs.\n                                   xs \\<in> Aa \\<longrightarrow>\n                                   xs \\<sqsubseteq> zsa)) \\<or>\n                           ltl (lSup A) \\<sqsubseteq> ltl zs))", "from \\<open>\\<forall>xs. xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs. xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>xs. xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs\n\ngoal (1 subgoal):\n 1. (lnull zs \\<longrightarrow> lnull (lSup A)) \\<and>\n    (\\<not> lnull (lSup A) \\<longrightarrow>\n     \\<not> lnull zs \\<longrightarrow>\n     lhd (lSup A) = lhd zs \\<and>\n     ((\\<exists>A zs.\n          ltl (lSup A) = lSup A \\<and>\n          ltl zs = zs \\<and>\n          Complete_Partial_Order.chain (\\<sqsubseteq>) A \\<and>\n          (\\<forall>xs.\n              xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs)) \\<or>\n      ltl (lSup A) \\<sqsubseteq> ltl zs))", "by(auto 4 4 dest: lprefix_lnullD lprefix_lhdD intro: chain_lprefix_ltl[OF chain] lprefix_ltlI rev_image_eqI intro!: the_equality)"], ["proof (state)\nthis:\n  (lnull zs \\<longrightarrow> lnull (lSup A)) \\<and>\n  (\\<not> lnull (lSup A) \\<longrightarrow>\n   \\<not> lnull zs \\<longrightarrow>\n   lhd (lSup A) = lhd zs \\<and>\n   ((\\<exists>A zs.\n        ltl (lSup A) = lSup A \\<and>\n        ltl zs = zs \\<and>\n        Complete_Partial_Order.chain (\\<sqsubseteq>) A \\<and>\n        (\\<forall>xs.\n            xs \\<in> A \\<longrightarrow> xs \\<sqsubseteq> zs)) \\<or>\n    ltl (lSup A) \\<sqsubseteq> ltl zs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_ccpo [simp, cont_intro]: \"class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))", "by(unfold_locales)(auto dest: lprefix_antisym intro: lprefix_trans chain_lprefix_lSup chain_lSup_lprefix simp add: mk_less_def)"], ["", "lemmas [cont_intro] = ccpo.admissible_leI[OF llist_ccpo]"], ["", "lemma llist_partial_function_definitions:\n  \"partial_function_definitions (\\<sqsubseteq>) lSup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<sqsubseteq>) lSup", "by(unfold_locales)(auto dest: lprefix_antisym intro: lprefix_trans chain_lprefix_lSup chain_lSup_lprefix)"], ["", "interpretation llist: partial_function_definitions \"(\\<sqsubseteq>)\" lSup\n  rewrites \"lSup {} \\<equiv> LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions (\\<sqsubseteq>) lSup &&&\n    lSup {} \\<equiv> LNil", "by(rule llist_partial_function_definitions)(simp)"], ["", "abbreviation \"mono_llist \\<equiv> monotone (fun_ord (\\<sqsubseteq>)) (\\<sqsubseteq>)\""], ["", "interpretation llist_lift: partial_function_definitions \"fun_ord lprefix\" \"fun_lub lSup\"\n  rewrites \"fun_lub lSup {} \\<equiv> \\<lambda>_. LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_function_definitions llist.le_fun llist.lub_fun &&&\n    llist.lub_fun {} \\<equiv> \\<lambda>_. LNil", "by(rule llist_partial_function_definitions[THEN partial_function_lift])(simp)"], ["", "abbreviation \"mono_llist_lift \\<equiv> monotone (fun_ord (fun_ord lprefix)) (fun_ord lprefix)\""], ["", "lemma lprefixes_chain:\n  \"Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. lprefix ys xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. ys \\<sqsubseteq> xs}", "by(rule chainI)(auto dest: lprefix_down_linear)"], ["", "lemma llist_gen_induct:\n  assumes adm: \"ccpo.admissible lSup (\\<sqsubseteq>) P\"\n  and step: \"\\<exists>zs. zs \\<sqsubseteq> xs \\<and> lfinite zs \\<and> (\\<forall>ys. zs \\<sqsubseteq> ys \\<longrightarrow> ys \\<sqsubseteq> xs \\<longrightarrow> lfinite ys \\<longrightarrow> P ys)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "from step"], ["proof (chain)\npicking this:\n  \\<exists>zs.\n     zs \\<sqsubseteq> xs \\<and>\n     lfinite zs \\<and>\n     (\\<forall>ys.\n         zs \\<sqsubseteq> ys \\<longrightarrow>\n         ys \\<sqsubseteq> xs \\<longrightarrow>\n         lfinite ys \\<longrightarrow> P ys)", "obtain zs\n    where zs: \"zs \\<sqsubseteq> xs\" \"lfinite zs\"\n    and ys: \"\\<And>ys. \\<lbrakk> zs \\<sqsubseteq> ys; ys \\<sqsubseteq> xs; lfinite ys \\<rbrakk> \\<Longrightarrow> P ys\""], ["proof (prove)\nusing this:\n  \\<exists>zs.\n     zs \\<sqsubseteq> xs \\<and>\n     lfinite zs \\<and>\n     (\\<forall>ys.\n         zs \\<sqsubseteq> ys \\<longrightarrow>\n         ys \\<sqsubseteq> xs \\<longrightarrow>\n         lfinite ys \\<longrightarrow> P ys)\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>zs \\<sqsubseteq> xs; lfinite zs;\n         \\<And>ys.\n            \\<lbrakk>zs \\<sqsubseteq> ys; ys \\<sqsubseteq> xs;\n             lfinite ys\\<rbrakk>\n            \\<Longrightarrow> P ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zs \\<sqsubseteq> xs\n  lfinite zs\n  \\<lbrakk>zs \\<sqsubseteq> ?ys; ?ys \\<sqsubseteq> xs; lfinite ?ys\\<rbrakk>\n  \\<Longrightarrow> P ?ys\n\ngoal (1 subgoal):\n 1. P xs", "let ?C = \"{ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "from lprefixes_chain[of xs]"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. ys \\<sqsubseteq> xs}", "have \"Complete_Partial_Order.chain (\\<sqsubseteq>) ?C\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. ys \\<sqsubseteq> xs}\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>)\n     {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}", "by(auto dest: chain_compr)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. P xs", "with adm"], ["proof (chain)\npicking this:\n  ccpo.admissible lSup (\\<sqsubseteq>) P\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}", "have \"P (lSup ?C)\""], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>) P\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys}\n\ngoal (1 subgoal):\n 1. P (lSup\n        {ys.\n         ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys})", "by(rule ccpo.admissibleD)(auto intro: ys zs)"], ["proof (state)\nthis:\n  P (lSup\n      {ys.\n       ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys})\n\ngoal (1 subgoal):\n 1. P xs", "also"], ["proof (state)\nthis:\n  P (lSup\n      {ys.\n       ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys})\n\ngoal (1 subgoal):\n 1. P xs", "have \"lSup ?C  = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "using lSup_finite_gen_prefixes[OF zs]"], ["proof (prove)\nusing this:\n  lSup\n   {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  xs\n\ngoal (1 subgoal):\n 1. lSup\n     {ys.\n      ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n    xs", "by simp"], ["proof (state)\nthis:\n  lSup\n   {ys. ys \\<sqsubseteq> xs \\<and> zs \\<sqsubseteq> ys \\<and> lfinite ys} =\n  xs\n\ngoal (1 subgoal):\n 1. P xs", "finally"], ["proof (chain)\npicking this:\n  P xs", "show ?thesis"], ["proof (prove)\nusing this:\n  P xs\n\ngoal (1 subgoal):\n 1. P xs", "."], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_induct [case_names adm LNil LCons, induct type: llist]:\n  assumes adm: \"ccpo.admissible lSup (\\<sqsubseteq>) P\"\n  and LNil: \"P LNil\"\n  and LCons: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "fix ys :: \"'a llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "assume \"lfinite ys\""], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. P xs", "hence \"P ys\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. P ys", "by(induct)(simp_all add: LNil LCons)"], ["proof (state)\nthis:\n  P ys\n\ngoal (1 subgoal):\n 1. P xs", "}"], ["proof (state)\nthis:\n  lfinite ?ys2 \\<Longrightarrow> P ?ys2\n\ngoal (1 subgoal):\n 1. P xs", "note [intro] = this"], ["proof (state)\nthis:\n  lfinite ?ys2 \\<Longrightarrow> P ?ys2\n\ngoal (1 subgoal):\n 1. P xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using adm"], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>) P\n\ngoal (1 subgoal):\n 1. P xs", "by(rule llist_gen_induct)(auto intro: exI[where x=LNil])"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LCons_mono [partial_function_mono, cont_intro]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. LCons x (A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. LCons x (A f))", "by(rule monotoneI)(auto dest: monotoneD)"], ["", "lemma mono2mono_LCons [THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_LCons: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (LCons x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (LCons x)", "by(auto intro: monotoneI)"], ["", "lemma mcont2mcont_LCons [THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_LCons: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (LCons x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (LCons x)", "by(simp add: mcont_def monotone_LCons lSup_LCons[symmetric] contI)"], ["", "lemma mono2mono_ltl[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_ltl: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) ltl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) ltl", "by(auto intro: monotoneI lprefix_ltlI)"], ["", "lemma cont_ltl: \"cont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl", "proof(rule contI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "fix Y :: \"'a llist set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "assume \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "have \"ltl (lSup Y) = lSup (insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lSup Y) =\n    lSup (insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})))", "by(simp add: lSup_insert_LNil)"], ["proof (state)\nthis:\n  ltl (lSup Y) =\n  lSup (insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "also"], ["proof (state)\nthis:\n  ltl (lSup Y) =\n  lSup (insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "have \"insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})) = insert LNil (ltl ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})) =\n    insert LNil (ltl ` Y)", "by auto"], ["proof (state)\nthis:\n  insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})) =\n  insert LNil (ltl ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "also"], ["proof (state)\nthis:\n  insert LNil (ltl ` (Y \\<inter> {xs. \\<not> lnull xs})) =\n  insert LNil (ltl ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "have \"lSup \\<dots> = lSup (ltl ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup (insert LNil (ltl ` Y)) = lSup (ltl ` Y)", "by(simp add: lSup_insert_LNil)"], ["proof (state)\nthis:\n  lSup (insert LNil (ltl ` Y)) = lSup (ltl ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ltl (lSup Y) = lSup (ltl ` Y)", "finally"], ["proof (chain)\npicking this:\n  ltl (lSup Y) = lSup (ltl ` Y)", "show \"ltl (lSup Y) = lSup (ltl ` Y)\""], ["proof (prove)\nusing this:\n  ltl (lSup Y) = lSup (ltl ` Y)\n\ngoal (1 subgoal):\n 1. ltl (lSup Y) = lSup (ltl ` Y)", "."], ["proof (state)\nthis:\n  ltl (lSup Y) = lSup (ltl ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mcont2mcont_ltl [THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_ltl: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl", "by(simp add: mcont_def monotone_ltl cont_ltl)"], ["", "lemma llist_case_mono [partial_function_mono, cont_intro]:\n  assumes lnil: \"monotone orda ordb lnil\"\n  and lcons: \"\\<And>x xs. monotone orda ordb (\\<lambda>f. lcons f x xs)\"\n  shows \"monotone orda ordb (\\<lambda>f. case_llist (lnil f) (lcons f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone orda ordb\n     (\\<lambda>f.\n         case x of LNil \\<Rightarrow> lnil f\n         | LCons x xa \\<Rightarrow> lcons f x xa)", "by(rule monotoneI)(auto split: llist.split dest: monotoneD[OF lnil] monotoneD[OF lcons])"], ["", "lemma mcont_llist_case [cont_intro, simp]:\n  \"\\<lbrakk> mcont luba orda lubb ordb (\\<lambda>x. f x); \\<And>x xs. mcont luba orda lubb ordb (\\<lambda>y. g x xs y) \\<rbrakk>\n  \\<Longrightarrow> mcont luba orda lubb ordb (\\<lambda>y. case xs of LNil \\<Rightarrow> f y | LCons x xs' \\<Rightarrow> g x xs' y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mcont luba orda lubb ordb f;\n     \\<And>x xs. mcont luba orda lubb ordb (g x xs)\\<rbrakk>\n    \\<Longrightarrow> mcont luba orda lubb ordb\n                       (\\<lambda>y.\n                           case xs of LNil \\<Rightarrow> f y\n                           | LCons x xs' \\<Rightarrow> g x xs' y)", "by(cases xs) simp_all"], ["", "lemma monotone_lprefix_case [cont_intro, simp]:\n  assumes mono: \"\\<And>x. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> f x xs' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> LNil\n         | LCons x xs' \\<Rightarrow> f x xs' xs)", "by(rule llist.monotone_if_bot[where f=\"\\<lambda>xs. f (lhd xs) (ltl xs) xs\" and bound=LNil])(auto 4 3 split: llist.split simp add: not_lnull_conv LCons_lprefix_conv dest: monotoneD[OF mono])"], ["", "lemma mcont_lprefix_case_aux:\n  fixes f bot\n  defines \"g \\<equiv> \\<lambda>xs. f (lhd xs) (ltl xs) (LCons (lhd xs) (ltl xs))\"\n  assumes mcont: \"\\<And>x. mcont lSup (\\<sqsubseteq>) lub ord (\\<lambda>xs. f x xs (LCons x xs))\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  and bot: \"\\<And>x. ord bot x\"\n  shows \"mcont lSup (\\<sqsubseteq>) lub ord (\\<lambda>xs. case xs of LNil \\<Rightarrow> bot | LCons x xs' \\<Rightarrow> f x xs' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lub ord\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> bot\n         | LCons x xs' \\<Rightarrow> f x xs' xs)", "proof(rule llist.mcont_if_bot[where f=g and bound=LNil and bot=bot, OF ccpo bot])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "fix Y :: \"'a llist set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "assume chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y\"\n    and Y: \"Y \\<noteq> {}\" \"\\<And>x. x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "from Y"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil", "have Y': \"Y \\<inter> {xs. \\<not> lnull xs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil\n\ngoal (1 subgoal):\n 1. Y \\<inter> {xs. \\<not> lnull xs} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Y \\<inter> {xs. \\<not> lnull xs} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "from Y"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil", "obtain x xs where \"LCons x xs \\<in> Y\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        LCons x xs \\<in> Y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  LCons x xs \\<in> Y\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "with Y(2)"], ["proof (chain)\npicking this:\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil\n  LCons x xs \\<in> Y", "have eq: \"Y = LCons x ` (ltl ` (Y \\<inter> {xs. \\<not> lnull xs}))\""], ["proof (prove)\nusing this:\n  ?x \\<in> Y \\<Longrightarrow> \\<not> ?x \\<sqsubseteq> LNil\n  LCons x xs \\<in> Y\n\ngoal (1 subgoal):\n 1. Y = LCons x ` ltl ` (Y \\<inter> {xs. \\<not> lnull xs})", "by(force dest: chainD[OF chain] simp add: LCons_lprefix_conv lprefix_LCons_conv intro: imageI rev_image_eqI)"], ["proof (state)\nthis:\n  Y = LCons x ` ltl ` (Y \\<inter> {xs. \\<not> lnull xs})\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)\n 3. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        Y \\<noteq> {};\n        \\<And>x.\n           x \\<in> Y \\<Longrightarrow> \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> g (lSup Y) = lub (g ` Y)", "show \"g (lSup Y) = lub (g ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (lSup Y) = lub (g ` Y)", "by(subst (1 2) eq)(simp add: lSup_LCons Y' g_def mcont_contD[OF mcont] chain chain_lprefix_ltl, simp add: image_image)"], ["proof (state)\nthis:\n  g (lSup Y) = lub (g ` Y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (case x of LNil \\<Rightarrow> bot\n        | LCons xa xs' \\<Rightarrow> f xa xs' x) =\n       (if x \\<sqsubseteq> LNil then bot else g x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; \\<not> x \\<sqsubseteq> LNil\\<rbrakk>\n       \\<Longrightarrow> ord (g x) (g y)", "qed(auto 4 3 split: llist.split simp add: not_lnull_conv LCons_lprefix_conv g_def intro: mcont_monoD[OF mcont])"], ["", "lemma mcont_lprefix_case [cont_intro, simp]:\n  assumes \"\\<And>x. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> f x xs' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> LNil\n         | LCons x xs' \\<Rightarrow> f x xs' xs)", "using assms"], ["proof (prove)\nusing this:\n  mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>)\n   (\\<lambda>xs. f ?x xs (LCons ?x xs))\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> LNil\n         | LCons x xs' \\<Rightarrow> f x xs' xs)", "by(rule mcont_lprefix_case_aux)(simp_all add: llist_ccpo)"], ["", "lemma monotone_lprefix_case_lfp [cont_intro, simp]:\n  fixes f :: \"_ \\<Rightarrow> _ :: order_bot\"\n  assumes mono: \"\\<And>x. monotone (\\<sqsubseteq>) (\\<le>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"monotone (\\<sqsubseteq>) (\\<le>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<bottom> | LCons x xs \\<Rightarrow> f x xs (LCons x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<le>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> \\<bottom>\n         | LCons x xs \\<Rightarrow> f x xs (LCons x xs))", "by(rule llist.monotone_if_bot[where bound=LNil and bot=\\<bottom> and f=\"\\<lambda>xs. f (lhd xs) (ltl xs) xs\"])(auto 4 3 simp add: not_lnull_conv LCons_lprefix_conv dest: monotoneD[OF mono] split: llist.split)"], ["", "lemma mcont_lprefix_case_lfp [cont_intro, simp]:\n  fixes f :: \"_ => _ :: complete_lattice\"\n  assumes \"\\<And>x. mcont lSup (\\<sqsubseteq>) Sup (\\<le>) (\\<lambda>xs. f x xs (LCons x xs))\"\n  shows \"mcont lSup (\\<sqsubseteq>) Sup (\\<le>) (\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<bottom> | LCons x xs \\<Rightarrow> f x xs (LCons x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) Sup (\\<le>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> \\<bottom>\n         | LCons x xs \\<Rightarrow> f x xs (LCons x xs))", "using assms"], ["proof (prove)\nusing this:\n  mcont lSup (\\<sqsubseteq>) Sup (\\<le>)\n   (\\<lambda>xs. f ?x xs (LCons ?x xs))\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) Sup (\\<le>)\n     (\\<lambda>xs.\n         case xs of LNil \\<Rightarrow> \\<bottom>\n         | LCons x xs \\<Rightarrow> f x xs (LCons x xs))", "by(rule mcont_lprefix_case_aux)(rule complete_lattice_ccpo', simp)"], ["", "declaration \\<open>Partial_Function.init \"llist\" @{term llist.fixp_fun}\n  @{term llist.mono_body} @{thm llist.fixp_rule_uc} @{thm llist.fixp_strong_induct_uc} NONE\\<close>"], ["", "subsection \\<open>Monotonicity and continuity of already defined functions\\<close>"], ["", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>lmap xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> LCons (f x) (lmap xs)\"\n  shows lmap_conv_fixp: \"lmap f \\<equiv> ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) F\" (is \"?lhs \\<equiv> ?rhs\")\n  and lmap_mono: \"\\<And>xs. mono_llist (\\<lambda>lmap. F lmap xs)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmap f \\<equiv> llist.fixp_fun F) &&&\n    (\\<And>xs. mono_llist (\\<lambda>lmap. F lmap xs))", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. lmap f x = llist.fixp_fun F x\n 2. \\<And>xs. mono_llist (\\<lambda>lmap. F lmap xs)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. mono_llist (\\<lambda>lmap. F lmap xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mono_llist\n        (\\<lambda>lmap.\n            case xs of LNil \\<Rightarrow> LNil\n            | LCons x xs \\<Rightarrow> LCons (f x) (lmap xs))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist (\\<lambda>lmap. F lmap ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. lmap f x = llist.fixp_fun F x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lmap f x = llist.fixp_fun F x", "show \"?lhs xs = ?rhs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f xs = llist.fixp_fun F xs", "proof(coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lmap f xs) = lnull (llist.fixp_fun F xs) \\<and>\n       (\\<not> lnull (lmap f xs) \\<longrightarrow>\n        \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n        lhd (lmap f xs) = lhd (llist.fixp_fun F xs) \\<and>\n        (\\<exists>xsa.\n            ltl (lmap f xs) = lmap f xsa \\<and>\n            ltl (llist.fixp_fun F xs) = llist.fixp_fun F xsa))", "case Eq_llist"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (lmap f xs) = lnull (llist.fixp_fun F xs) \\<and>\n       (\\<not> lnull (lmap f xs) \\<longrightarrow>\n        \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n        lhd (lmap f xs) = lhd (llist.fixp_fun F xs) \\<and>\n        (\\<exists>xsa.\n            ltl (lmap f xs) = lmap f xsa \\<and>\n            ltl (llist.fixp_fun F xs) = llist.fixp_fun F xsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lmap f xs) = lnull (llist.fixp_fun F xs) \\<and>\n    (\\<not> lnull (lmap f xs) \\<longrightarrow>\n     \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n     lhd (lmap f xs) = lhd (llist.fixp_fun F xs) \\<and>\n     (\\<exists>xs.\n         ltl (lmap f xs) = lmap f xs \\<and>\n         ltl (llist.fixp_fun F xs) = llist.fixp_fun F xs))", "by(subst (1 3 4) llist.mono_body_fixp[OF mono])(auto simp add: F_def split: llist.split)"], ["proof (state)\nthis:\n  lnull (lmap f xs) = lnull (llist.fixp_fun F xs) \\<and>\n  (\\<not> lnull (lmap f xs) \\<longrightarrow>\n   \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n   lhd (lmap f xs) = lhd (llist.fixp_fun F xs) \\<and>\n   (\\<exists>xs.\n       ltl (lmap f xs) = lmap f xs \\<and>\n       ltl (llist.fixp_fun F xs) = llist.fixp_fun F xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lmap f xs = llist.fixp_fun F xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono2mono_lmap[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lmap: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lmap f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lmap f)", "by(rule llist.fixp_preserves_mono1[OF lmap_mono lmap_conv_fixp]) simp"], ["", "lemma mcont2mcont_lmap[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lmap: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lmap f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lmap f)", "by(rule llist.fixp_preserves_mcont1[OF lmap_mono lmap_conv_fixp]) simp"], ["", "lemma [partial_function_mono]: \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. lmap g (F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. lmap g (F f))", "by(rule mono2mono_lmap)"], ["", "lemma mono_llist_lappend2 [partial_function_mono]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lappend xs (A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lappend xs (A f))", "by(auto intro!: monotoneI lprefix_lappend_sameI simp add: fun_ord_def dest: monotoneD)"], ["", "lemma mono2mono_lappend2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lappend2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lappend xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lappend xs)", "by(rule monotoneI)(rule lprefix_lappend_sameI)"], ["", "lemma mcont2mcont_lappend2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lappend2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "by induct(simp_all add: monotone_lappend2)"], ["proof (state)\nthis:\n  mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "hence \"lappend xs = (\\<lambda>_. xs)\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lappend xs = (\\<lambda>_. xs)", "by(simp add: fun_eq_iff lappend_inf)"], ["proof (state)\nthis:\n  lappend xs = (\\<lambda>_. xs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lappend xs = (\\<lambda>_. xs)\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)", "by(simp add: ccpo.cont_const[OF llist_ccpo])"], ["proof (state)\nthis:\n  mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lappend xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>lset xs. case xs of LNil \\<Rightarrow> {} | LCons x xs \\<Rightarrow> insert x (lset xs)\"\n  shows lset_conv_fixp: \"lset \\<equiv> ccpo.fixp (fun_lub Union) (fun_ord (\\<subseteq>)) F\" (is \"_ \\<equiv> ?fixp\")\n  and lset_mono: \"\\<And>x. monotone (fun_ord (\\<subseteq>)) (\\<subseteq>) (\\<lambda>f. F f x)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lset \\<equiv> lfp.fixp_fun F) &&&\n    (\\<And>x. lfp.mono_body (\\<lambda>f. F f x))", "proof(rule eq_reflection ext antisym subsetI)+"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa. xa \\<in> lset x \\<Longrightarrow> xa \\<in> lfp.fixp_fun F x\n 2. \\<And>x. lfp.fixp_fun F x \\<subseteq> lset x\n 3. \\<And>x. lfp.mono_body (\\<lambda>f. F f x)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. lfp.mono_body (\\<lambda>f. F f x)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       lfp.mono_body\n        (\\<lambda>f.\n            case x of LNil \\<Rightarrow> {}\n            | LCons x xs \\<Rightarrow> insert x (f xs))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  lfp.mono_body (\\<lambda>f. F f ?x)\n\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> lset x \\<Longrightarrow> xa \\<in> lfp.fixp_fun F x\n 2. \\<And>x. lfp.fixp_fun F x \\<subseteq> lset x", "fix x xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> lset x \\<Longrightarrow> xa \\<in> lfp.fixp_fun F x\n 2. \\<And>x. lfp.fixp_fun F x \\<subseteq> lset x", "show \"?fixp xs \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.fixp_fun F xs \\<subseteq> lset xs", "by(induct arbitrary: xs rule: lfp.fixp_induct_uc[of \"\\<lambda>x. x\" F \"\\<lambda>x. x\", OF mono reflexive refl])(auto simp add: F_def split: llist.split)"], ["proof (state)\nthis:\n  lfp.fixp_fun F xs \\<subseteq> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> lset x \\<Longrightarrow> xa \\<in> lfp.fixp_fun F x", "assume \"x \\<in> lset xs\""], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> lset x \\<Longrightarrow> xa \\<in> lfp.fixp_fun F x", "thus \"x \\<in> ?fixp xs\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lfp.fixp_fun F xs", "by induct(subst lfp.mono_body_fixp[OF mono], simp add: F_def)+"], ["proof (state)\nthis:\n  x \\<in> lfp.fixp_fun F xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono2mono_lset [THEN lfp.mono2mono, cont_intro, simp]:\n  shows monotone_lset: \"monotone (\\<sqsubseteq>) (\\<subseteq>) lset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<subseteq>) lset", "by(rule lfp.fixp_preserves_mono1[OF lset_mono lset_conv_fixp]) simp"], ["", "lemma mcont2mcont_lset[THEN mcont2mcont, cont_intro, simp]:\n  shows mcont_lset: \"mcont lSup (\\<sqsubseteq>) Union (\\<subseteq>) lset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) \\<Union> (\\<subseteq>) lset", "by(rule lfp.fixp_preserves_mcont1[OF lset_mono lset_conv_fixp]) simp"], ["", "lemma lset_lSup: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<Longrightarrow> lset (lSup Y) = \\<Union>(lset ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<Longrightarrow>\n    lset (lSup Y) = \\<Union> (lset ` Y)", "by(cases \"Y = {}\")(simp_all add: mcont_lset[THEN mcont_contD])"], ["", "lemma lfinite_lSupD: \"lfinite (lSup A) \\<Longrightarrow> \\<forall>xs \\<in> A. lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs", "by(induct ys\\<equiv>\"lSup A\" arbitrary: A rule: lfinite_induct) fastforce+"], ["", "lemma monotone_enat_le_lprefix_case [cont_intro, simp]:\n  \"monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>x. f x (eSuc x)) \\<Longrightarrow> monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>x. case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<sqsubseteq>)\n     (\\<lambda>x. f x (eSuc x)) \\<Longrightarrow>\n    monotone (\\<le>) (\\<sqsubseteq>)\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)", "by(erule monotone_enat_le_case) simp_all"], ["", "lemma mcont_enat_le_lprefix_case [cont_intro, simp]:\n  assumes \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>x. f x (eSuc x))\"\n  shows \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>x. case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lSup (\\<sqsubseteq>)\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)", "using llist_ccpo assms"], ["proof (prove)\nusing this:\n  class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\n  mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>x. f x (eSuc x))\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lSup (\\<sqsubseteq>)\n     (\\<lambda>x.\n         case x of 0 \\<Rightarrow> LNil | eSuc x' \\<Rightarrow> f x' x)", "by(rule mcont_enat_le_case) simp"], ["", "lemma compact_LConsI:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) xs\"\n  shows \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)", "using llist_ccpo"], ["proof (prove)\nusing this:\n  class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\n\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)", "proof(rule ccpo.compactI)"], ["proof (state)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> LCons x xs \\<sqsubseteq> y)", "from assms"], ["proof (chain)\npicking this:\n  ccpo.compact lSup (\\<sqsubseteq>) xs", "have \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\""], ["proof (prove)\nusing this:\n  ccpo.compact lSup (\\<sqsubseteq>) xs\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)", "by cases"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> LCons x xs \\<sqsubseteq> y)", "hence [cont_intro]: \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ltl ys)\""], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ltl ys)", "using mcont_ltl"], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n  mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) ltl\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ltl ys)", "by(rule admissible_subst)"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ltl ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> LCons x xs \\<sqsubseteq> y)", "have [cont_intro]: \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> lnull ys \\<and> lhd ys \\<noteq> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> lnull ys \\<and> lhd ys \\<noteq> x)", "proof(rule ccpo.admissibleI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        A \\<noteq> {};\n        \\<forall>xa\\<in>A. \\<not> lnull xa \\<and> lhd xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull (lSup A) \\<and>\n                         lhd (lSup A) \\<noteq> x", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        A \\<noteq> {};\n        \\<forall>xa\\<in>A. \\<not> lnull xa \\<and> lhd xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull (lSup A) \\<and>\n                         lhd (lSup A) \\<noteq> x", "assume chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y\"\n      and *: \"Y \\<noteq> {}\" \"\\<forall>ys\\<in>Y. \\<not> lnull ys \\<and> lhd ys \\<noteq> x\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  Y \\<noteq> {}\n  \\<forall>ys\\<in>Y. \\<not> lnull ys \\<and> lhd ys \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) A;\n        A \\<noteq> {};\n        \\<forall>xa\\<in>A. \\<not> lnull xa \\<and> lhd xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull (lSup A) \\<and>\n                         lhd (lSup A) \\<noteq> x", "from *"], ["proof (chain)\npicking this:\n  Y \\<noteq> {}\n  \\<forall>ys\\<in>Y. \\<not> lnull ys \\<and> lhd ys \\<noteq> x", "show \"\\<not> lnull (lSup Y) \\<and> lhd (lSup Y) \\<noteq> x\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n  \\<forall>ys\\<in>Y. \\<not> lnull ys \\<and> lhd ys \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lSup Y) \\<and> lhd (lSup Y) \\<noteq> x", "by(subst lhd_lSup)(auto 4 4 dest: chainD[OF chain] intro!: the_equality[symmetric] dest: lprefix_lhdD)"], ["proof (state)\nthis:\n  \\<not> lnull (lSup Y) \\<and> lhd (lSup Y) \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> lnull ys \\<and> lhd ys \\<noteq> x)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> LCons x xs \\<sqsubseteq> y)", "have eq: \"(\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys) = (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ltl ys \\<or> ys = LNil \\<or> \\<not> lnull ys \\<and> lhd ys \\<noteq> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys) =\n    (\\<lambda>ys.\n        \\<not> xs \\<sqsubseteq> ltl ys \\<or>\n        ys = LNil \\<or> \\<not> lnull ys \\<and> lhd ys \\<noteq> x)", "by(auto simp add: fun_eq_iff LCons_lprefix_conv neq_LNil_conv)"], ["proof (state)\nthis:\n  (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys) =\n  (\\<lambda>ys.\n      \\<not> xs \\<sqsubseteq> ltl ys \\<or>\n      ys = LNil \\<or> \\<not> lnull ys \\<and> lhd ys \\<noteq> x)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> LCons x xs \\<sqsubseteq> y)", "show \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)", "by(simp add: eq)"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compact_LConsD:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)\"\n  shows \"ccpo.compact lSup (\\<sqsubseteq>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) xs", "using llist_ccpo"], ["proof (prove)\nusing this:\n  class.ccpo lSup (\\<sqsubseteq>) (mk_less (\\<sqsubseteq>))\n\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) xs", "proof(rule ccpo.compactI)"], ["proof (state)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> xs \\<sqsubseteq> y)", "from assms"], ["proof (chain)\npicking this:\n  ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)", "have \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)\""], ["proof (prove)\nusing this:\n  ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)", "by cases"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> xs \\<sqsubseteq> y)", "hence \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> LCons x ys)\""], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> LCons x ys)", "by(rule admissible_subst)(rule mcont_LCons)"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> LCons x ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>y. \\<not> xs \\<sqsubseteq> y)", "thus \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\""], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> LCons x xs \\<sqsubseteq> LCons x ys)\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compact_LCons_iff [simp]:\n  \"ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs) \\<longleftrightarrow> ccpo.compact lSup (\\<sqsubseteq>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) (LCons x xs) =\n    ccpo.compact lSup (\\<sqsubseteq>) xs", "by(blast intro: compact_LConsI compact_LConsD)"], ["", "lemma compact_lfiniteI:\n  \"lfinite xs \\<Longrightarrow> ccpo.compact lSup (\\<sqsubseteq>) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ccpo.compact lSup (\\<sqsubseteq>) xs", "by(induction rule: lfinite.induct) simp_all"], ["", "lemma compact_lfiniteD:\n  assumes \"ccpo.compact lSup (\\<sqsubseteq>) xs\"\n  shows \"lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "assume inf: \"\\<not> lfinite xs\""], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  ccpo.compact lSup (\\<sqsubseteq>) xs", "have \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\""], ["proof (prove)\nusing this:\n  ccpo.compact lSup (\\<sqsubseteq>) xs\n\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)", "by cases"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "let ?C = \"{ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "have \"Complete_Partial_Order.chain (\\<sqsubseteq>) ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>)\n     {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}", "using lprefixes_chain[of xs]"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) {ys. ys \\<sqsubseteq> xs}\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>)\n     {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}", "by(auto dest: chain_compr)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "have \"?C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<noteq> {}", "using inf"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<noteq> {}", "by(cases xs) auto"], ["proof (state)\nthis:\n  {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n  {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<noteq> {}", "have \"\\<not> xs \\<sqsubseteq> lSup ?C\""], ["proof (prove)\nusing this:\n  ccpo.admissible lSup (\\<sqsubseteq>)\n   (\\<lambda>ys. \\<not> xs \\<sqsubseteq> ys)\n  Complete_Partial_Order.chain (\\<sqsubseteq>)\n   {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n  {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> xs \\<sqsubseteq>\n           lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}", "by(rule ccpo.admissibleD)(auto dest: lprefix_antisym)"], ["proof (state)\nthis:\n  \\<not> xs \\<sqsubseteq>\n         lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<not> xs \\<sqsubseteq>\n         lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs}\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "have \"lSup ?C = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs", "using inf"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs", "by(rule lSup_strict_prefixes)"], ["proof (state)\nthis:\n  lSup {ys. ys \\<sqsubseteq> xs \\<and> ys \\<noteq> xs} = xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<not> xs \\<sqsubseteq> xs", "show False"], ["proof (prove)\nusing this:\n  \\<not> xs \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compact_eq_lfinite [simp]: \"ccpo.compact lSup (\\<sqsubseteq>) = lfinite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.compact lSup (\\<sqsubseteq>) = lfinite", "by(blast intro: compact_lfiniteI compact_lfiniteD)"], ["", "subsection \\<open>More function definitions\\<close>"], ["", "primcorec iterates :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a llist\"\nwhere \"iterates f x = LCons x (iterates f (f x))\""], ["", "primrec llist_of :: \"'a list \\<Rightarrow> 'a llist\"\nwhere\n  \"llist_of [] = LNil\"\n| \"llist_of (x#xs) = LCons x (llist_of xs)\""], ["", "definition list_of :: \"'a llist \\<Rightarrow> 'a list\"\nwhere [code del]: \"list_of xs = (if lfinite xs then inv llist_of xs else undefined)\""], ["", "definition llength :: \"'a llist \\<Rightarrow> enat\"\nwhere [code del]:\n  \"llength = enat_unfold lnull ltl\""], ["", "primcorec ltake :: \"enat \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere\n  \"n = 0 \\<or> lnull xs \\<Longrightarrow> lnull (ltake n xs)\"\n| \"lhd (ltake n xs) = lhd xs\"\n| \"ltl (ltake n xs) = ltake (epred n) (ltl xs)\""], ["", "definition ldropn :: \"nat \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere \"ldropn n xs = (ltl ^^ n) xs\""], ["", "context notes [[function_internals]]\nbegin"], ["", "partial_function (llist) ldrop :: \"enat \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere\n  \"ldrop n xs = (case n of 0 \\<Rightarrow> xs | eSuc n' \\<Rightarrow> case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> ldrop n' xs')\""], ["", "end"], ["", "primcorec ltakeWhile :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist\"\nwhere\n  \"lnull xs \\<or> \\<not> P (lhd xs) \\<Longrightarrow> lnull (ltakeWhile P xs)\"\n| \"lhd (ltakeWhile P xs) = lhd xs\"\n| \"ltl (ltakeWhile P xs) = ltakeWhile P (ltl xs)\""], ["", "context fixes P :: \"'a \\<Rightarrow> bool\"\n  notes [[function_internals]]\nbegin"], ["", "partial_function (llist) ldropWhile :: \"'a llist \\<Rightarrow> 'a llist\"\nwhere \"ldropWhile xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> if P x then ldropWhile xs' else xs)\""], ["", "partial_function (llist) lfilter :: \"'a llist \\<Rightarrow> 'a llist\"\nwhere \"lfilter xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> if P x then LCons x (lfilter xs') else lfilter xs')\""], ["", "end"], ["", "primrec lnth :: \"'a llist \\<Rightarrow> nat \\<Rightarrow> 'a\"\nwhere\n  \"lnth xs 0 = (case xs of LNil \\<Rightarrow> undefined (0 :: nat) | LCons x xs' \\<Rightarrow> x)\"\n| \"lnth xs (Suc n) = (case xs of LNil \\<Rightarrow> undefined (Suc n) | LCons x xs' \\<Rightarrow> lnth xs' n)\""], ["", "declare lnth.simps [simp del]"], ["", "primcorec lzip :: \"'a llist \\<Rightarrow> 'b llist \\<Rightarrow> ('a \\<times> 'b) llist\"\nwhere\n  \"lnull xs \\<or> lnull ys \\<Longrightarrow> lnull (lzip xs ys)\"\n| \"lhd (lzip xs ys) = (lhd xs, lhd ys)\"\n| \"ltl (lzip xs ys) = lzip (ltl xs) (ltl ys)\""], ["", "definition llast :: \"'a llist \\<Rightarrow> 'a\"\nwhere [nitpick_simp]:\n  \"llast xs = (case llength xs of enat n \\<Rightarrow> (case n of 0 \\<Rightarrow> undefined | Suc n' \\<Rightarrow> lnth xs n') | \\<infinity> \\<Rightarrow> undefined)\""], ["", "coinductive ldistinct :: \"'a llist \\<Rightarrow> bool\"\nwhere\n  LNil [simp]: \"ldistinct LNil\"\n| LCons: \"\\<lbrakk> x \\<notin> lset xs; ldistinct xs \\<rbrakk> \\<Longrightarrow> ldistinct (LCons x xs)\""], ["", "hide_fact (open) LNil LCons"], ["", "definition inf_llist :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a llist\"\nwhere [code del]: \"inf_llist f = lmap f (iterates Suc 0)\""], ["", "abbreviation repeat :: \"'a \\<Rightarrow> 'a llist\"\nwhere \"repeat \\<equiv> iterates (\\<lambda>x. x)\""], ["", "definition lstrict_prefix :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> bool\"\nwhere [code del]: \"lstrict_prefix xs ys \\<equiv> xs \\<sqsubseteq> ys \\<and> xs \\<noteq> ys\""], ["", "text \\<open>longest common prefix\\<close>"], ["", "definition llcp :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> enat\"\nwhere [code del]:\n  \"llcp xs ys =\n   enat_unfold (\\<lambda>(xs, ys). lnull xs \\<or> lnull ys \\<or> lhd xs \\<noteq> lhd ys) (map_prod ltl ltl) (xs, ys)\""], ["", "coinductive llexord :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist \\<Rightarrow> bool\"\nfor r :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere\n  llexord_LCons_eq: \"llexord r xs ys \\<Longrightarrow> llexord r (LCons x xs) (LCons x ys)\"\n| llexord_LCons_less: \"r x y \\<Longrightarrow> llexord r (LCons x xs) (LCons y ys)\"\n| llexord_LNil [simp, intro!]: \"llexord r LNil ys\""], ["", "context notes [[function_internals]]\nbegin"], ["", "partial_function (llist) lconcat :: \"'a llist llist \\<Rightarrow> 'a llist\"\nwhere \"lconcat xss = (case xss of LNil \\<Rightarrow> LNil | LCons xs xss' \\<Rightarrow> lappend xs (lconcat xss'))\""], ["", "end"], ["", "definition lhd' :: \"'a llist \\<Rightarrow> 'a option\" where\n\"lhd' xs = (if lnull xs then None else Some (lhd xs))\""], ["", "lemma lhd'_simps[simp]:\n  \"lhd' LNil = None\"\n  \"lhd' (LCons x xs) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd' LNil = None &&& lhd' (LCons x xs) = Some x", "unfolding lhd'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if lnull LNil then None else Some (lhd LNil)) = None &&&\n    (if lnull (LCons x xs) then None else Some (lhd (LCons x xs))) = Some x", "by auto"], ["", "definition ltl' :: \"'a llist \\<Rightarrow> 'a llist option\" where\n\"ltl' xs = (if lnull xs then None else Some (ltl xs))\""], ["", "lemma ltl'_simps[simp]:\n  \"ltl' LNil = None\"\n  \"ltl' (LCons x xs) = Some xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl' LNil = None &&& ltl' (LCons x xs) = Some xs", "unfolding ltl'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if lnull LNil then None else Some (ltl LNil)) = None &&&\n    (if lnull (LCons x xs) then None else Some (ltl (LCons x xs))) = Some xs", "by auto"], ["", "definition lnths :: \"'a llist \\<Rightarrow> nat set \\<Rightarrow> 'a llist\"\nwhere \"lnths xs A = lmap fst (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0)))\""], ["", "definition (in monoid_add) lsum_list :: \"'a llist \\<Rightarrow> 'a\"\nwhere \"lsum_list xs = (if lfinite xs then sum_list (list_of xs) else 0)\""], ["", "subsection \\<open>Converting ordinary lists to lazy lists: @{term \"llist_of\"}\\<close>"], ["", "lemma lhd_llist_of [simp]: \"lhd (llist_of xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (llist_of xs) = hd xs", "by(cases xs)(simp_all add: hd_def lhd_def)"], ["", "lemma ltl_llist_of [simp]: \"ltl (llist_of xs) = llist_of (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (llist_of xs) = llist_of (tl xs)", "by(cases xs) simp_all"], ["", "lemma lfinite_llist_of [simp]: \"lfinite (llist_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (llist_of xs)", "by(induct xs) auto"], ["", "lemma lfinite_eq_range_llist_of: \"lfinite xs \\<longleftrightarrow> xs \\<in> range llist_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs = (xs \\<in> range llist_of)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> xs \\<in> range llist_of\n 2. xs \\<in> range llist_of \\<Longrightarrow> lfinite xs", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> xs \\<in> range llist_of\n 2. xs \\<in> range llist_of \\<Longrightarrow> lfinite xs", "thus \"xs \\<in> range llist_of\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of", "by(induct rule: lfinite.induct)(auto intro: llist_of.simps[symmetric])"], ["proof (state)\nthis:\n  xs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow> lfinite xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow> lfinite xs", "assume \"xs \\<in> range llist_of\""], ["proof (state)\nthis:\n  xs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow> lfinite xs", "thus \"lfinite xs\""], ["proof (prove)\nusing this:\n  xs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. lfinite xs", "by(auto intro: lfinite_llist_of)"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnull_llist_of [simp]: \"lnull (llist_of xs) \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (llist_of xs) = (xs = [])", "by(cases xs) simp_all"], ["", "lemma llist_of_eq_LNil_conv:\n  \"llist_of xs = LNil \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_of xs = LNil) = (xs = [])", "by(cases xs) simp_all"], ["", "lemma llist_of_eq_LCons_conv:\n  \"llist_of xs = LCons y ys \\<longleftrightarrow> (\\<exists>xs'. xs = y # xs' \\<and> ys = llist_of xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_of xs = LCons y ys) =\n    (\\<exists>xs'. xs = y # xs' \\<and> ys = llist_of xs')", "by(cases xs) auto"], ["", "lemma lappend_llist_of_llist_of:\n  \"lappend (llist_of xs) (llist_of ys) = llist_of (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (llist_of xs) (llist_of ys) = llist_of (xs @ ys)", "by(induct xs) simp_all"], ["", "lemma lfinite_rev_induct [consumes 1, case_names Nil snoc]:\n  assumes fin: \"lfinite xs\"\n  and Nil: \"P LNil\"\n  and snoc: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (lappend xs (LCons x LNil))\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "from fin"], ["proof (chain)\npicking this:\n  lfinite xs", "obtain xs' where xs: \"xs = llist_of xs'\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        xs = llist_of xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  xs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        xs = llist_of xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = llist_of xs'\n\ngoal (1 subgoal):\n 1. P xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (llist_of xs')", "by(induct xs' rule: rev_induct)(auto simp add: Nil lappend_llist_of_llist_of[symmetric] dest: snoc[rotated])"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_llist_of_LCons:\n  \"lappend (llist_of xs) (LCons y ys) = lappend (llist_of (xs @ [y])) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (llist_of xs) (LCons y ys) = lappend (llist_of (xs @ [y])) ys", "by(induct xs) simp_all"], ["", "lemma lmap_llist_of [simp]:\n  \"lmap f (llist_of xs) = llist_of (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (llist_of xs) = llist_of (map f xs)", "by(induct xs) simp_all"], ["", "lemma lset_llist_of [simp]: \"lset (llist_of xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (llist_of xs) = set xs", "by(induct xs) simp_all"], ["", "lemma llist_of_inject [simp]: \"llist_of xs = llist_of ys \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_of xs = llist_of ys) = (xs = ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llist_of xs = llist_of ys \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> llist_of xs = llist_of ys", "assume \"llist_of xs = llist_of ys\""], ["proof (state)\nthis:\n  llist_of xs = llist_of ys\n\ngoal (2 subgoals):\n 1. llist_of xs = llist_of ys \\<Longrightarrow> xs = ys\n 2. xs = ys \\<Longrightarrow> llist_of xs = llist_of ys", "thus \"xs = ys\""], ["proof (prove)\nusing this:\n  llist_of xs = llist_of ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. llist_of [] = llist_of ys \\<Longrightarrow> [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   llist_of xs = llist_of ys \\<Longrightarrow> xs = ys;\n        llist_of (a # xs) = llist_of ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "case Nil"], ["proof (state)\nthis:\n  llist_of [] = llist_of ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. llist_of [] = llist_of ys \\<Longrightarrow> [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   llist_of xs = llist_of ys \\<Longrightarrow> xs = ys;\n        llist_of (a # xs) = llist_of ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "thus ?case"], ["proof (prove)\nusing this:\n  llist_of [] = llist_of ys\n\ngoal (1 subgoal):\n 1. [] = ys", "by(cases ys) auto"], ["proof (state)\nthis:\n  [] = ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   llist_of xs = llist_of ys \\<Longrightarrow> xs = ys;\n        llist_of (a # xs) = llist_of ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   llist_of xs = llist_of ys \\<Longrightarrow> xs = ys;\n        llist_of (a # xs) = llist_of ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "case Cons"], ["proof (state)\nthis:\n  llist_of xs_ = llist_of ?ys \\<Longrightarrow> xs_ = ?ys\n  llist_of (a_ # xs_) = llist_of ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   llist_of xs = llist_of ys \\<Longrightarrow> xs = ys;\n        llist_of (a # xs) = llist_of ys\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys", "thus ?case"], ["proof (prove)\nusing this:\n  llist_of xs_ = llist_of ?ys \\<Longrightarrow> xs_ = ?ys\n  llist_of (a_ # xs_) = llist_of ys\n\ngoal (1 subgoal):\n 1. a_ # xs_ = ys", "by(cases ys) auto"], ["proof (state)\nthis:\n  a_ # xs_ = ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> llist_of xs = llist_of ys", "qed simp"], ["", "lemma inj_llist_of [simp]: \"inj llist_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj llist_of", "by(rule inj_onI) simp"], ["", "subsection \\<open>Converting finite lazy lists to ordinary lists: @{term \"list_of\"}\\<close>"], ["", "lemma list_of_llist_of [simp]: \"list_of (llist_of xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (llist_of xs) = xs", "by(fastforce simp add: list_of_def intro: inv_f_f inj_onI)"], ["", "lemma llist_of_list_of [simp]: \"lfinite xs \\<Longrightarrow> llist_of (list_of xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> llist_of (list_of xs) = xs", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow> llist_of (list_of xs) = xs", "by auto"], ["", "lemma list_of_LNil [simp, nitpick_simp]: \"list_of LNil = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of LNil = []", "using list_of_llist_of[of \"[]\"]"], ["proof (prove)\nusing this:\n  list_of (llist_of []) = []\n\ngoal (1 subgoal):\n 1. list_of LNil = []", "by simp"], ["", "lemma list_of_LCons [simp]: \"lfinite xs \\<Longrightarrow> list_of (LCons x xs) = x # list_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> list_of (LCons x xs) = x # list_of xs", "proof(induct arbitrary: x rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. list_of (LCons x LNil) = x # list_of LNil\n 2. \\<And>xs x xa.\n       \\<lbrakk>lfinite xs;\n        \\<And>x. list_of (LCons x xs) = x # list_of xs\\<rbrakk>\n       \\<Longrightarrow> list_of (LCons xa (LCons x xs)) =\n                         xa # list_of (LCons x xs)", "case lfinite_LNil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. list_of (LCons x LNil) = x # list_of LNil\n 2. \\<And>xs x xa.\n       \\<lbrakk>lfinite xs;\n        \\<And>x. list_of (LCons x xs) = x # list_of xs\\<rbrakk>\n       \\<Longrightarrow> list_of (LCons xa (LCons x xs)) =\n                         xa # list_of (LCons x xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (LCons x LNil) = x # list_of LNil", "using list_of_llist_of[of \"[x]\"]"], ["proof (prove)\nusing this:\n  list_of (llist_of [x]) = [x]\n\ngoal (1 subgoal):\n 1. list_of (LCons x LNil) = x # list_of LNil", "by simp"], ["proof (state)\nthis:\n  list_of (LCons x LNil) = x # list_of LNil\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa.\n       \\<lbrakk>lfinite xs;\n        \\<And>x. list_of (LCons x xs) = x # list_of xs\\<rbrakk>\n       \\<Longrightarrow> list_of (LCons xa (LCons x xs)) =\n                         xa # list_of (LCons x xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xa.\n       \\<lbrakk>lfinite xs;\n        \\<And>x. list_of (LCons x xs) = x # list_of xs\\<rbrakk>\n       \\<Longrightarrow> list_of (LCons xa (LCons x xs)) =\n                         xa # list_of (LCons x xs)", "case (lfinite_LConsI xs' x')"], ["proof (state)\nthis:\n  lfinite xs'\n  list_of (LCons ?x xs') = ?x # list_of xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa.\n       \\<lbrakk>lfinite xs;\n        \\<And>x. list_of (LCons x xs) = x # list_of xs\\<rbrakk>\n       \\<Longrightarrow> list_of (LCons xa (LCons x xs)) =\n                         xa # list_of (LCons x xs)", "from \\<open>list_of (LCons x' xs') = x' # list_of xs'\\<close>"], ["proof (chain)\npicking this:\n  list_of (LCons x' xs') = x' # list_of xs'", "show ?case"], ["proof (prove)\nusing this:\n  list_of (LCons x' xs') = x' # list_of xs'\n\ngoal (1 subgoal):\n 1. list_of (LCons x (LCons x' xs')) = x # list_of (LCons x' xs')", "using list_of_llist_of[of \"x # x' # list_of xs'\"]\n      llist_of_list_of[OF \\<open>lfinite xs'\\<close>]"], ["proof (prove)\nusing this:\n  list_of (LCons x' xs') = x' # list_of xs'\n  list_of (llist_of (x # x' # list_of xs')) = x # x' # list_of xs'\n  llist_of (list_of xs') = xs'\n\ngoal (1 subgoal):\n 1. list_of (LCons x (LCons x' xs')) = x # list_of (LCons x' xs')", "by simp"], ["proof (state)\nthis:\n  list_of (LCons x (LCons x' xs')) = x # list_of (LCons x' xs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_LCons_conv [nitpick_simp]:\n  \"list_of (LCons x xs) = (if lfinite xs then x # list_of xs else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (LCons x xs) =\n    (if lfinite xs then x # list_of xs else undefined)", "by(auto)(auto simp add: list_of_def)"], ["", "lemma list_of_lappend:\n  assumes \"lfinite xs\" \"lfinite ys\"\n  shows \"list_of (lappend xs ys) = list_of xs @ list_of ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (lappend xs ys) = list_of xs @ list_of ys", "using \\<open>lfinite xs\\<close>"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. list_of (lappend xs ys) = list_of xs @ list_of ys", "by induct(simp_all add: \\<open>lfinite ys\\<close>)"], ["", "lemma list_of_lmap [simp]:\n  assumes \"lfinite xs\"\n  shows \"list_of (lmap f xs) = map f (list_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (lmap f xs) = map f (list_of xs)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. list_of (lmap f xs) = map f (list_of xs)", "by induct simp_all"], ["", "lemma set_list_of [simp]:\n  assumes \"lfinite xs\"\n  shows \"set (list_of xs) = lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_of xs) = lset xs", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. set (list_of xs) = lset xs", "by(induct)(simp_all)"], ["", "lemma hd_list_of [simp]: \"lfinite xs \\<Longrightarrow> hd (list_of xs) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> hd (list_of xs) = lhd xs", "by(clarsimp simp add: lfinite_eq_range_llist_of)"], ["", "lemma tl_list_of: \"lfinite xs \\<Longrightarrow> tl (list_of xs) = list_of (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> tl (list_of xs) = list_of (ltl xs)", "by(auto simp add: lfinite_eq_range_llist_of)"], ["", "text \\<open>Efficient implementation via tail recursion suggested by Brian Huffman\\<close>"], ["", "definition list_of_aux :: \"'a list \\<Rightarrow> 'a llist \\<Rightarrow> 'a list\"\nwhere \"list_of_aux xs ys = (if lfinite ys then rev xs @ list_of ys else undefined)\""], ["", "lemma list_of_code [code]: \"list_of = list_of_aux []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of = list_of_aux []", "by(simp add: fun_eq_iff list_of_def list_of_aux_def)"], ["", "lemma list_of_aux_code [code]:\n  \"list_of_aux xs LNil = rev xs\"\n  \"list_of_aux xs (LCons y ys) = list_of_aux (y # xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_aux xs LNil = rev xs &&&\n    list_of_aux xs (LCons y ys) = list_of_aux (y # xs) ys", "by(simp_all add: list_of_aux_def)"], ["", "subsection \\<open>The length of a lazy list: @{term \"llength\"}\\<close>"], ["", "lemma [simp, nitpick_simp]:\n  shows llength_LNil: \"llength LNil = 0\"\n  and llength_LCons: \"llength (LCons x xs) = eSuc (llength xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength LNil = 0 &&& llength (LCons x xs) = eSuc (llength xs)", "by(simp_all add: llength_def enat_unfold)"], ["", "lemma llength_eq_0 [simp]: \"llength xs = 0 \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength xs = 0) = lnull xs", "by(cases xs) simp_all"], ["", "lemma llength_lnull [simp]: \"lnull xs \\<Longrightarrow> llength xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> llength xs = 0", "by simp"], ["", "lemma epred_llength:\n  \"epred (llength xs) = llength (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epred (llength xs) = llength (ltl xs)", "by(cases xs) simp_all"], ["", "lemmas llength_ltl = epred_llength[symmetric]"], ["", "lemma llength_lmap [simp]: \"llength (lmap f xs) = llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lmap f xs) = llength xs", "by(coinduction arbitrary: xs rule: enat_coinduct)(auto simp add: epred_llength)"], ["", "lemma llength_lappend [simp]: \"llength (lappend xs ys) = llength xs + llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lappend xs ys) = llength xs + llength ys", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(simp_all add: iadd_is_0 epred_iadd1 split_paired_all epred_llength, auto)"], ["", "lemma llength_llist_of [simp]:\n  \"llength (llist_of xs) = enat (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (llist_of xs) = enat (length xs)", "by(induct xs)(simp_all add: zero_enat_def eSuc_def)"], ["", "lemma length_list_of:\n  \"lfinite xs \\<Longrightarrow> enat (length (list_of xs)) = llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> enat (length (list_of xs)) = llength xs", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> llength xs = enat (length (list_of xs))", "by(induct rule: lfinite.induct)(auto simp add: eSuc_enat zero_enat_def)"], ["", "lemma length_list_of_conv_the_enat:\n  \"lfinite xs \\<Longrightarrow> length (list_of xs) = the_enat (llength xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> length (list_of xs) = the_enat (llength xs)", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> range llist_of \\<Longrightarrow>\n    length (list_of xs) = the_enat (llength xs)", "by auto"], ["", "lemma llength_eq_enat_lfiniteD: \"llength xs = enat n \\<Longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs = enat n \\<Longrightarrow> lfinite xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. llength xs = enat 0 \\<Longrightarrow> lfinite xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "case [folded zero_enat_def]: 0"], ["proof (state)\nthis:\n  llength xs = 0\n\ngoal (2 subgoals):\n 1. \\<And>xs. llength xs = enat 0 \\<Longrightarrow> lfinite xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs = 0\n\ngoal (1 subgoal):\n 1. lfinite xs", "by simp"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "case (Suc n)"], ["proof (state)\nthis:\n  llength ?xs = enat n \\<Longrightarrow> lfinite ?xs\n  llength xs = enat (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "note len = \\<open>llength xs = enat (Suc n)\\<close>"], ["proof (state)\nthis:\n  llength xs = enat (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "then"], ["proof (chain)\npicking this:\n  llength xs = enat (Suc n)", "obtain x xs' where \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  llength xs = enat (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs)(auto simp add: zero_enat_def)"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "moreover"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "with len"], ["proof (chain)\npicking this:\n  llength xs = enat (Suc n)\n  xs = LCons x xs'", "have \"llength xs' = enat n\""], ["proof (prove)\nusing this:\n  llength xs = enat (Suc n)\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. llength xs' = enat n", "by(simp add: eSuc_def split: enat.split_asm)"], ["proof (state)\nthis:\n  llength xs' = enat n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "hence \"lfinite xs'\""], ["proof (prove)\nusing this:\n  llength xs' = enat n\n\ngoal (1 subgoal):\n 1. lfinite xs'", "by(rule Suc)"], ["proof (state)\nthis:\n  lfinite xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs. llength xs = enat n \\<Longrightarrow> lfinite xs;\n        llength xs = enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "ultimately"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  lfinite xs'", "show ?case"], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  lfinite xs'\n\ngoal (1 subgoal):\n 1. lfinite xs", "by simp"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfinite_llength_enat:\n  assumes \"lfinite xs\"\n  shows \"\\<exists>n. llength xs = enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. llength xs = enat n", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. llength xs = enat n", "by induct(auto simp add: eSuc_def zero_enat_def)"], ["", "lemma lfinite_conv_llength_enat:\n  \"lfinite xs \\<longleftrightarrow> (\\<exists>n. llength xs = enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs = (\\<exists>n. llength xs = enat n)", "by(blast dest: llength_eq_enat_lfiniteD lfinite_llength_enat)"], ["", "lemma not_lfinite_llength:\n  \"\\<not> lfinite xs \\<Longrightarrow> llength xs = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> llength xs = \\<infinity>", "by(simp add: lfinite_conv_llength_enat)"], ["", "lemma llength_eq_infty_conv_lfinite:\n  \"llength xs = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength xs = \\<infinity>) = (\\<not> lfinite xs)", "by(simp add: lfinite_conv_llength_enat)"], ["", "lemma lfinite_finite_index: \"lfinite xs \\<Longrightarrow> finite {n. enat n < llength xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> finite {n. enat n < llength xs}", "by(auto dest: lfinite_llength_enat)"], ["", "text \\<open>tail-recursive implementation for @{term llength}\\<close>"], ["", "definition gen_llength :: \"nat \\<Rightarrow> 'a llist \\<Rightarrow> enat\"\nwhere \"gen_llength n xs = enat n + llength xs\""], ["", "lemma gen_llength_code [code]:\n  \"gen_llength n LNil = enat n\"\n  \"gen_llength n (LCons x xs) = gen_llength (n + 1) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_llength n LNil = enat n &&&\n    gen_llength n (LCons x xs) = gen_llength (n + 1) xs", "by(simp_all add: gen_llength_def iadd_Suc eSuc_enat[symmetric] iadd_Suc_right)"], ["", "lemma llength_code [code]: \"llength = gen_llength 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength = gen_llength 0", "by(simp add: gen_llength_def fun_eq_iff zero_enat_def)"], ["", "lemma fixes F\n  defines \"F \\<equiv> \\<lambda>llength xs. case xs of LNil \\<Rightarrow> 0 | LCons x xs \\<Rightarrow> eSuc (llength xs)\"\n  shows llength_conv_fixp: \"llength \\<equiv> ccpo.fixp (fun_lub Sup) (fun_ord (\\<le>)) F\" (is \"_ \\<equiv> ?fixp\")\n  and llength_mono: \"\\<And>xs. monotone (fun_ord (\\<le>)) (\\<le>) (\\<lambda>llength. F llength xs)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength \\<equiv> lfp.fixp_fun F) &&&\n    (\\<And>xs. lfp.mono_body (\\<lambda>llength. F llength xs))", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. llength x = lfp.fixp_fun F x\n 2. \\<And>xs. lfp.mono_body (\\<lambda>llength. F llength xs)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. lfp.mono_body (\\<lambda>llength. F llength xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lfp.mono_body\n        (\\<lambda>llength.\n            case xs of LNil \\<Rightarrow> 0\n            | LCons x xs \\<Rightarrow> eSuc (llength xs))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  lfp.mono_body (\\<lambda>llength. F llength ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. llength x = lfp.fixp_fun F x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. llength x = lfp.fixp_fun F x", "show \"llength xs = ?fixp xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs = lfp.fixp_fun F xs", "by(coinduction arbitrary: xs rule: enat_coinduct)(subst (1 2 3) lfp.mono_body_fixp[OF mono], fastforce simp add: F_def split: llist.split del: iffI)+"], ["proof (state)\nthis:\n  llength xs = lfp.fixp_fun F xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono2mono_llength[THEN lfp.mono2mono, simp, cont_intro]:\n  shows monotone_llength: \"monotone (\\<sqsubseteq>) (\\<le>) llength\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<le>) llength", "by(rule lfp.fixp_preserves_mono1[OF llength_mono llength_conv_fixp])(fold bot_enat_def, simp)"], ["", "lemma mcont2mcont_llength[THEN lfp.mcont2mcont, simp, cont_intro]:\n  shows mcont_llength: \"mcont lSup (\\<sqsubseteq>) Sup (\\<le>) llength\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) Sup (\\<le>) llength", "by(rule lfp.fixp_preserves_mcont1[OF llength_mono llength_conv_fixp])(fold bot_enat_def, simp)"], ["", "subsection \\<open>Taking and dropping from lazy lists: @{term \"ltake\"}, @{term \"ldropn\"}, and @{term \"ldrop\"}\\<close>"], ["", "lemma ltake_LNil [simp, code, nitpick_simp]: \"ltake n LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n LNil = LNil", "by simp"], ["", "lemma ltake_0 [simp]: \"ltake 0 xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake 0 xs = LNil", "by(simp add: ltake_def)"], ["", "lemma ltake_eSuc_LCons [simp]:\n  \"ltake (eSuc n) (LCons x xs) = LCons x (ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (eSuc n) (LCons x xs) = LCons x (ltake n xs)", "by(rule llist.expand)(simp_all)"], ["", "lemma ltake_eSuc:\n  \"ltake (eSuc n) xs =\n  (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> LCons x (ltake n xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (eSuc n) xs =\n    (case xs of LNil \\<Rightarrow> LNil\n     | LCons x xs' \\<Rightarrow> LCons x (ltake n xs'))", "by(cases xs) simp_all"], ["", "lemma lnull_ltake [simp]: \"lnull (ltake n xs) \\<longleftrightarrow> lnull xs \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltake n xs) = (lnull xs \\<or> n = 0)", "by(cases n xs rule: enat_coexhaust[case_product llist.exhaust]) simp_all"], ["", "lemma ltake_eq_LNil_iff: \"ltake n xs = LNil \\<longleftrightarrow> xs = LNil \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltake n xs = LNil) = (xs = LNil \\<or> n = 0)", "by(cases n xs rule: enat_coexhaust[case_product llist.exhaust]) simp_all"], ["", "lemma LNil_eq_ltake_iff [simp]: \"LNil = ltake n xs \\<longleftrightarrow> xs = LNil \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LNil = ltake n xs) = (xs = LNil \\<or> n = 0)", "by(cases n xs rule: enat_coexhaust[case_product llist.exhaust]) simp_all"], ["", "lemma ltake_LCons [code, nitpick_simp]:\n  \"ltake n (LCons x xs) =\n  (case n of 0 \\<Rightarrow> LNil | eSuc n' \\<Rightarrow> LCons x (ltake n' xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (LCons x xs) =\n    (case n of 0 \\<Rightarrow> LNil\n     | eSuc n' \\<Rightarrow> LCons x (ltake n' xs))", "by(rule llist.expand)(simp_all split: co.enat.split)"], ["", "lemma lhd_ltake [simp]: \"n \\<noteq> 0 \\<Longrightarrow> lhd (ltake n xs) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> lhd (ltake n xs) = lhd xs", "by(cases n xs rule: enat_coexhaust[case_product llist.exhaust]) simp_all"], ["", "lemma ltl_ltake: \"ltl (ltake n xs) = ltake (epred n) (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ltake n xs) = ltake (epred n) (ltl xs)", "by(cases n xs rule: enat_coexhaust[case_product llist.exhaust]) simp_all"], ["", "lemmas ltake_epred_ltl = ltl_ltake [symmetric]"], ["", "declare ltake.sel(2) [simp del]"], ["", "lemma ltake_ltl: \"ltake n (ltl xs) = ltl (ltake (eSuc n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (ltl xs) = ltl (ltake (eSuc n) xs)", "by(cases xs) simp_all"], ["", "lemma llength_ltake [simp]: \"llength (ltake n xs) = min n (llength xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltake n xs) = min n (llength xs)", "by(coinduction arbitrary: n xs rule: enat_coinduct)(auto 4 3 simp add: enat_min_eq_0_iff epred_llength ltl_ltake)"], ["", "lemma ltake_lmap [simp]: \"ltake n (lmap f xs) = lmap f (ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (lmap f xs) = lmap f (ltake n xs)", "by(coinduction arbitrary: n xs)(auto 4 3 simp add: ltl_ltake)"], ["", "lemma ltake_ltake [simp]: \"ltake n (ltake m xs) = ltake (min n m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (ltake m xs) = ltake (min n m) xs", "by(coinduction arbitrary: n m xs)(auto 4 4 simp add: enat_min_eq_0_iff ltl_ltake)"], ["", "lemma lset_ltake: \"lset (ltake n xs) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ltake n xs) \\<subseteq> lset xs", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset (ltake n xs) \\<Longrightarrow> x \\<in> lset xs", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset (ltake n xs) \\<Longrightarrow> x \\<in> lset xs", "assume \"x \\<in> lset (ltake n xs)\""], ["proof (state)\nthis:\n  x \\<in> lset (ltake n xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> lset (ltake n xs) \\<Longrightarrow> x \\<in> lset xs", "thus \"x \\<in> lset xs\""], ["proof (prove)\nusing this:\n  x \\<in> lset (ltake n xs)\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "proof(induct \"ltake n xs\" arbitrary: xs n rule: lset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs xsa n.\n       LCons x xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa\n 2. \\<And>x' xs xsa n.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa n. xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = ltake n xsa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "case find"], ["proof (state)\nthis:\n  LCons x xs_ = ltake n xs\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa n.\n       LCons x xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa\n 2. \\<And>x' xs xsa n.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa n. xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = ltake n xsa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "thus ?case"], ["proof (prove)\nusing this:\n  LCons x xs_ = ltake n xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by(cases xs)(simp, cases n rule: enat_coexhaust, simp_all)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa n.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa n. xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = ltake n xsa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa n.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa n. xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = ltake n xsa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "case step"], ["proof (state)\nthis:\n  x \\<in> lset xs_\n  x \\<noteq> x'_\n  xs_ = ltake ?n ?xs \\<Longrightarrow> x \\<in> lset ?xs\n  LCons x'_ xs_ = ltake n xs\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa n.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<And>xsa n. xs = ltake n xsa \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = ltake n xsa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> lset xs_\n  x \\<noteq> x'_\n  xs_ = ltake ?n ?xs \\<Longrightarrow> x \\<in> lset ?xs\n  LCons x'_ xs_ = ltake n xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by(cases xs)(simp, cases n rule: enat_coexhaust, simp_all)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_all: \"llength xs \\<le> m \\<Longrightarrow> ltake m xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> m \\<Longrightarrow> ltake m xs = xs", "by(coinduction arbitrary: m xs)(auto simp add: epred_llength[symmetric] ltl_ltake intro: epred_le_epredI)"], ["", "lemma ltake_llist_of [simp]:\n  \"ltake (enat n) (llist_of xs) = llist_of (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat n) (llist_of xs) = llist_of (take n xs)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ltake (enat 0) (llist_of xs) = llist_of (take 0 xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (llist_of xs) =\n           llist_of (take n xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs. ltake (enat 0) (llist_of xs) = llist_of (take 0 xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (llist_of xs) =\n           llist_of (take n xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) (llist_of xs) = llist_of (take 0 xs)", "unfolding zero_enat_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake 0 (llist_of xs) = llist_of (take 0 xs)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  ltake (enat 0) (llist_of xs) = llist_of (take 0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (llist_of xs) =\n           llist_of (take n xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (llist_of xs) =\n           llist_of (take n xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "case (Suc n)"], ["proof (state)\nthis:\n  ltake (enat n) (llist_of ?xs) = llist_of (take n ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (llist_of xs) =\n           llist_of (take n xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "thus ?case"], ["proof (prove)\nusing this:\n  ltake (enat n) (llist_of ?xs) = llist_of (take n ?xs)\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)", "unfolding eSuc_enat[symmetric]"], ["proof (prove)\nusing this:\n  ltake (enat n) (llist_of ?xs) = llist_of (take n ?xs)\n\ngoal (1 subgoal):\n 1. ltake (eSuc (enat n)) (llist_of xs) = llist_of (take (Suc n) xs)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (llist_of xs) = llist_of (take (Suc n) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfinite_ltake [simp]:\n  \"lfinite (ltake n xs) \\<longleftrightarrow> lfinite xs \\<or> n < \\<infinity>\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltake n xs) = (lfinite xs \\<or> n < \\<infinity>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (ltake n xs) \\<Longrightarrow> lfinite xs \\<or> n < \\<infinity>\n 2. lfinite xs \\<or> n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (ltake n xs)\n\ngoal (2 subgoals):\n 1. lfinite (ltake n xs) \\<Longrightarrow> lfinite xs \\<or> n < \\<infinity>\n 2. lfinite xs \\<or> n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (ltake n xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> n < \\<infinity>", "by(induct ys\\<equiv>\"ltake n xs\" arbitrary: n xs rule: lfinite_induct)(fastforce simp add: zero_enat_def ltl_ltake)+"], ["proof (state)\nthis:\n  lfinite xs \\<or> n < \\<infinity>\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<or> n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "assume ?rhs (is \"?xs \\<or> ?n\")"], ["proof (state)\nthis:\n  lfinite xs \\<or> n < \\<infinity>\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs \\<or> n < \\<infinity>\n\ngoal (1 subgoal):\n 1. lfinite (ltake n xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (ltake n xs)\n 2. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "assume ?xs"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (ltake n xs)\n 2. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (ltake n xs)", "by(induct xs arbitrary: n)(simp_all add: ltake_LCons split: enat_cosplit)"], ["proof (state)\nthis:\n  lfinite (ltake n xs)\n\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "assume ?n"], ["proof (state)\nthis:\n  n < \\<infinity>\n\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "then"], ["proof (chain)\npicking this:\n  n < \\<infinity>", "obtain n' where \"n = enat n'\""], ["proof (prove)\nusing this:\n  n < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = enat n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = enat n'\n\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "moreover"], ["proof (state)\nthis:\n  n = enat n'\n\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "have \"lfinite (ltake (enat n') xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltake (enat n') xs)", "by(induct n' arbitrary: xs)\n        (auto simp add: zero_enat_def[symmetric] eSuc_enat[symmetric] ltake_eSuc\n              split: llist.split)"], ["proof (state)\nthis:\n  lfinite (ltake (enat n') xs)\n\ngoal (1 subgoal):\n 1. n < \\<infinity> \\<Longrightarrow> lfinite (ltake n xs)", "ultimately"], ["proof (chain)\npicking this:\n  n = enat n'\n  lfinite (ltake (enat n') xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = enat n'\n  lfinite (ltake (enat n') xs)\n\ngoal (1 subgoal):\n 1. lfinite (ltake n xs)", "by simp"], ["proof (state)\nthis:\n  lfinite (ltake n xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (ltake n xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_lappend1:  \"n \\<le> llength xs \\<Longrightarrow> ltake n (lappend xs ys) = ltake n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> llength xs \\<Longrightarrow>\n    ltake n (lappend xs ys) = ltake n xs", "by(coinduction arbitrary: n xs)(auto intro!: exI simp add: llength_ltl epred_le_epredI ltl_ltake)"], ["", "lemma ltake_lappend2:\n  \"llength xs \\<le> n \\<Longrightarrow> ltake n (lappend xs ys) = lappend xs (ltake (n - llength xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> n \\<Longrightarrow>\n    ltake n (lappend xs ys) = lappend xs (ltake (n - llength xs) ys)", "by(coinduction arbitrary: n xs rule: llist.coinduct_strong)(auto intro!: exI simp add: llength_ltl epred_le_epredI ltl_ltake)"], ["", "lemma ltake_lappend:\n  \"ltake n (lappend xs ys) = lappend (ltake n xs) (ltake (n - llength xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (lappend xs ys) =\n    lappend (ltake n xs) (ltake (n - llength xs) ys)", "by(coinduction arbitrary: n xs ys rule: llist.coinduct_strong)(auto intro!: exI simp add: llength_ltl ltl_ltake)"], ["", "lemma take_list_of:\n  assumes \"lfinite xs\"\n  shows \"take n (list_of xs) = list_of (ltake (enat n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n (list_of xs) = list_of (ltake (enat n) xs)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. take n (list_of xs) = list_of (ltake (enat n) xs)", "by(induct arbitrary: n)\n  (simp_all add: take_Cons zero_enat_def[symmetric] eSuc_enat[symmetric] split: nat.split)"], ["", "lemma ltake_eq_ltake_antimono:\n  \"\\<lbrakk> ltake n xs = ltake n ys; m \\<le> n \\<rbrakk> \\<Longrightarrow> ltake m xs = ltake m ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ltake n xs = ltake n ys; m \\<le> n\\<rbrakk>\n    \\<Longrightarrow> ltake m xs = ltake m ys", "by (metis ltake_ltake min_def)"], ["", "lemma ltake_is_lprefix [simp, intro]: \"ltake n xs \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n xs \\<sqsubseteq> xs", "by(coinduction arbitrary: xs n)(auto simp add: ltl_ltake)"], ["", "lemma lprefix_ltake_same [simp]:\n  \"ltake n xs \\<sqsubseteq> ltake m xs \\<longleftrightarrow> n \\<le> m \\<or> llength xs \\<le> m\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n xs \\<sqsubseteq> ltake m xs =\n    (n \\<le> m \\<or> llength xs \\<le> m)", "proof(rule iffI disjCI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ltake n xs \\<sqsubseteq> ltake m xs;\n     \\<not> llength xs \\<le> m\\<rbrakk>\n    \\<Longrightarrow> n \\<le> m\n 2. n \\<le> m \\<or> llength xs \\<le> m \\<Longrightarrow>\n    ltake n xs \\<sqsubseteq> ltake m xs", "assume ?lhs \"\\<not> llength xs \\<le> m\""], ["proof (state)\nthis:\n  ltake n xs \\<sqsubseteq> ltake m xs\n  \\<not> llength xs \\<le> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ltake n xs \\<sqsubseteq> ltake m xs;\n     \\<not> llength xs \\<le> m\\<rbrakk>\n    \\<Longrightarrow> n \\<le> m\n 2. n \\<le> m \\<or> llength xs \\<le> m \\<Longrightarrow>\n    ltake n xs \\<sqsubseteq> ltake m xs", "thus \"n \\<le> m\""], ["proof (prove)\nusing this:\n  ltake n xs \\<sqsubseteq> ltake m xs\n  \\<not> llength xs \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m", "proof(coinduction arbitrary: n m xs rule: enat_le_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na ma xs.\n       \\<lbrakk>ltake na xs \\<sqsubseteq> ltake ma xs;\n        \\<not> llength xs \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (ma = 0 \\<longrightarrow> na = 0) \\<and>\n                         (na \\<noteq> 0 \\<longrightarrow>\n                          ma \\<noteq> 0 \\<longrightarrow>\n                          (\\<exists>k n'.\n                              (\\<exists>n m xs.\n                                  epred na = n \\<and>\n                                  n' = m \\<and>\n                                  ltake n xs \\<sqsubseteq> ltake m xs \\<and>\n                                  \\<not> llength xs \\<le> m) \\<and>\n                              epred ma = n' + k) \\<or>\n                          epred na \\<le> epred ma)", "case (le n m xs)"], ["proof (state)\nthis:\n  ltake n xs \\<sqsubseteq> ltake m xs\n  \\<not> llength xs \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>na ma xs.\n       \\<lbrakk>ltake na xs \\<sqsubseteq> ltake ma xs;\n        \\<not> llength xs \\<le> ma\\<rbrakk>\n       \\<Longrightarrow> (ma = 0 \\<longrightarrow> na = 0) \\<and>\n                         (na \\<noteq> 0 \\<longrightarrow>\n                          ma \\<noteq> 0 \\<longrightarrow>\n                          (\\<exists>k n'.\n                              (\\<exists>n m xs.\n                                  epred na = n \\<and>\n                                  n' = m \\<and>\n                                  ltake n xs \\<sqsubseteq> ltake m xs \\<and>\n                                  \\<not> llength xs \\<le> m) \\<and>\n                              epred ma = n' + k) \\<or>\n                          epred na \\<le> epred ma)", "thus ?case"], ["proof (prove)\nusing this:\n  ltake n xs \\<sqsubseteq> ltake m xs\n  \\<not> llength xs \\<le> m\n\ngoal (1 subgoal):\n 1. (m = 0 \\<longrightarrow> n = 0) \\<and>\n    (n \\<noteq> 0 \\<longrightarrow>\n     m \\<noteq> 0 \\<longrightarrow>\n     (\\<exists>k n'.\n         (\\<exists>n m xs.\n             epred n = n \\<and>\n             n' = m \\<and>\n             ltake n xs \\<sqsubseteq> ltake m xs \\<and>\n             \\<not> llength xs \\<le> m) \\<and>\n         epred m = n' + k) \\<or>\n     epred n \\<le> epred m)", "by(cases xs)(auto 4 3 simp add: ltake_LCons split: co.enat.splits)"], ["proof (state)\nthis:\n  (m = 0 \\<longrightarrow> n = 0) \\<and>\n  (n \\<noteq> 0 \\<longrightarrow>\n   m \\<noteq> 0 \\<longrightarrow>\n   (\\<exists>k n'.\n       (\\<exists>n m xs.\n           epred n = n \\<and>\n           n' = m \\<and>\n           ltake n xs \\<sqsubseteq> ltake m xs \\<and>\n           \\<not> llength xs \\<le> m) \\<and>\n       epred m = n' + k) \\<or>\n   epred n \\<le> epred m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m \\<or> llength xs \\<le> m \\<Longrightarrow>\n    ltake n xs \\<sqsubseteq> ltake m xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> m \\<or> llength xs \\<le> m \\<Longrightarrow>\n    ltake n xs \\<sqsubseteq> ltake m xs", "assume ?rhs"], ["proof (state)\nthis:\n  n \\<le> m \\<or> llength xs \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m \\<or> llength xs \\<le> m \\<Longrightarrow>\n    ltake n xs \\<sqsubseteq> ltake m xs", "thus ?lhs"], ["proof (prove)\nusing this:\n  n \\<le> m \\<or> llength xs \\<le> m\n\ngoal (1 subgoal):\n 1. ltake n xs \\<sqsubseteq> ltake m xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow> ltake n xs \\<sqsubseteq> ltake m xs\n 2. llength xs \\<le> m \\<Longrightarrow> ltake n xs \\<sqsubseteq> ltake m xs", "assume \"n \\<le> m\""], ["proof (state)\nthis:\n  n \\<le> m\n\ngoal (2 subgoals):\n 1. n \\<le> m \\<Longrightarrow> ltake n xs \\<sqsubseteq> ltake m xs\n 2. llength xs \\<le> m \\<Longrightarrow> ltake n xs \\<sqsubseteq> ltake m xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. ltake n xs \\<sqsubseteq> ltake m xs", "by(coinduction arbitrary: n m xs)(auto 4 4 simp add: ltl_ltake epred_le_epredI)"], ["proof (state)\nthis:\n  ltake n xs \\<sqsubseteq> ltake m xs\n\ngoal (1 subgoal):\n 1. llength xs \\<le> m \\<Longrightarrow> ltake n xs \\<sqsubseteq> ltake m xs", "qed(simp add: ltake_all)"], ["proof (state)\nthis:\n  ltake n xs \\<sqsubseteq> ltake m xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>ltake n xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> case n of 0 \\<Rightarrow> LNil | eSuc n \\<Rightarrow> LCons x (ltake n xs)\"\n  shows ltake_conv_fixp: \"ltake \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) (\\<lambda>ltake. case_prod (F (curry ltake))))\" (is \"?lhs \\<equiv> ?rhs\")\n  and ltake_mono: \"\\<And>nxs. mono_llist (\\<lambda>ltake. case nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltake \\<equiv>\n     curry\n      (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))) &&&\n    (\\<And>nxs.\n        mono_llist\n         (\\<lambda>ltake.\n             case nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs))", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       ltake x xa =\n       curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) x\n        xa\n 2. \\<And>nxs.\n       mono_llist\n        (\\<lambda>ltake.\n            case nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nxs.\n       mono_llist\n        (\\<lambda>ltake.\n            case nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nxs.\n       mono_llist\n        (\\<lambda>ltake.\n            case nxs of (n, LNil) \\<Rightarrow> LNil\n            | (0, LCons x xsa) \\<Rightarrow> LNil\n            | (eSuc na, LCons x xsa) \\<Rightarrow>\n                LCons x (curry ltake na xsa))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist\n   (\\<lambda>ltake. case ?nxs of (n, xs) \\<Rightarrow> F (curry ltake) n xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       ltake x xa =\n       curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) x\n        xa", "fix n xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       ltake x xa =\n       curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) x\n        xa", "show \"?lhs n xs = ?rhs n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n xs =\n    curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n xs", "proof(coinduction arbitrary: n xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       lnull (ltake n xs) =\n       lnull\n        (curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n          n xs) \\<and>\n       (\\<not> lnull (ltake n xs) \\<longrightarrow>\n        \\<not> lnull\n                (curry\n                  (llist.fixp_fun\n                    (\\<lambda>ltake (x, y). F (curry ltake) x y))\n                  n xs) \\<longrightarrow>\n        lhd (ltake n xs) =\n        lhd (curry\n              (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n              n xs) \\<and>\n        (\\<exists>na xsa.\n            ltl (ltake n xs) = ltake na xsa \\<and>\n            ltl (curry\n                  (llist.fixp_fun\n                    (\\<lambda>ltake (x, y). F (curry ltake) x y))\n                  n xs) =\n            curry\n             (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n             na xsa))", "case Eq_llist"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       lnull (ltake n xs) =\n       lnull\n        (curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n          n xs) \\<and>\n       (\\<not> lnull (ltake n xs) \\<longrightarrow>\n        \\<not> lnull\n                (curry\n                  (llist.fixp_fun\n                    (\\<lambda>ltake (x, y). F (curry ltake) x y))\n                  n xs) \\<longrightarrow>\n        lhd (ltake n xs) =\n        lhd (curry\n              (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n              n xs) \\<and>\n        (\\<exists>na xsa.\n            ltl (ltake n xs) = ltake na xsa \\<and>\n            ltl (curry\n                  (llist.fixp_fun\n                    (\\<lambda>ltake (x, y). F (curry ltake) x y))\n                  n xs) =\n            curry\n             (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n             na xsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltake n xs) =\n    lnull\n     (curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n       xs) \\<and>\n    (\\<not> lnull (ltake n xs) \\<longrightarrow>\n     \\<not> lnull\n             (curry\n               (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n               n xs) \\<longrightarrow>\n     lhd (ltake n xs) =\n     lhd (curry\n           (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n           xs) \\<and>\n     (\\<exists>n xs.\n         ltl (ltake n xs) = ltake n xs \\<and>\n         ltl (curry\n               (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n               n xs) =\n         curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n          n xs))", "by(subst (1 3 4) llist.mono_body_fixp[OF mono])(auto simp add: F_def split: llist.split prod.split co.enat.split)"], ["proof (state)\nthis:\n  lnull (ltake n xs) =\n  lnull\n   (curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n     xs) \\<and>\n  (\\<not> lnull (ltake n xs) \\<longrightarrow>\n   \\<not> lnull\n           (curry\n             (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n             xs) \\<longrightarrow>\n   lhd (ltake n xs) =\n   lhd (curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y))\n         n xs) \\<and>\n   (\\<exists>n xs.\n       ltl (ltake n xs) = ltake n xs \\<and>\n       ltl (curry\n             (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n             xs) =\n       curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n\n        xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ltake n xs =\n  curry (llist.fixp_fun (\\<lambda>ltake (x, y). F (curry ltake) x y)) n xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monotone_ltake: \"monotone (rel_prod (\\<le>) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod ltake)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<le>) (\\<sqsubseteq>)) (\\<sqsubseteq>)\n     (\\<lambda>(x, y). ltake x y)", "by(rule llist.fixp_preserves_mono2[OF ltake_mono ltake_conv_fixp]) simp"], ["", "lemma mono2mono_ltake1[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltake1: \"monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)", "using monotone_ltake"], ["proof (prove)\nusing this:\n  monotone (rel_prod (\\<le>) (\\<sqsubseteq>)) (\\<sqsubseteq>)\n   (\\<lambda>(x, y). ltake x y)\n\ngoal (1 subgoal):\n 1. monotone (\\<le>) (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)", "by auto"], ["", "lemma mono2mono_ltake2[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltake2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ltake n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ltake n)", "using monotone_ltake"], ["proof (prove)\nusing this:\n  monotone (rel_prod (\\<le>) (\\<sqsubseteq>)) (\\<sqsubseteq>)\n   (\\<lambda>(x, y). ltake x y)\n\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ltake n)", "by auto"], ["", "lemma mcont_ltake: \"mcont (prod_lub Sup lSup) (rel_prod (\\<le>) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod ltake)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (prod_lub Sup lSup) (rel_prod (\\<le>) (\\<sqsubseteq>)) lSup\n     (\\<sqsubseteq>) (\\<lambda>(x, y). ltake x y)", "by(rule llist.fixp_preserves_mcont2[OF ltake_mono ltake_conv_fixp]) simp"], ["", "lemma mcont2mcont_ltake1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltake1: \"mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)", "using mcont_ltake"], ["proof (prove)\nusing this:\n  mcont (prod_lub Sup lSup) (rel_prod (\\<le>) (\\<sqsubseteq>)) lSup\n   (\\<sqsubseteq>) (\\<lambda>(x, y). ltake x y)\n\ngoal (1 subgoal):\n 1. mcont Sup (\\<le>) lSup (\\<sqsubseteq>) (\\<lambda>n. ltake n xs)", "by auto"], ["", "lemma mcont2mcont_ltake2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltake2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ltake n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ltake n)", "using mcont_ltake"], ["proof (prove)\nusing this:\n  mcont (prod_lub Sup lSup) (rel_prod (\\<le>) (\\<sqsubseteq>)) lSup\n   (\\<sqsubseteq>) (\\<lambda>(x, y). ltake x y)\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ltake n)", "by auto"], ["", "lemma [partial_function_mono]: \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. ltake n (F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. ltake n (F f))", "by(rule mono2mono_ltake2)"], ["", "lemma llist_induct2:\n  assumes adm: \"ccpo.admissible (prod_lub lSup lSup) (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) (\\<lambda>x. P (fst x) (snd x))\"\n  and LNil: \"P LNil LNil\"\n  and LCons1: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs LNil \\<rbrakk> \\<Longrightarrow> P (LCons x xs) LNil\"\n  and LCons2: \"\\<And>y ys. \\<lbrakk> lfinite ys; P LNil ys \\<rbrakk> \\<Longrightarrow> P LNil (LCons y ys)\"\n  and LCons: \"\\<And>x xs y ys. \\<lbrakk> lfinite xs; lfinite ys; P xs ys \\<rbrakk> \\<Longrightarrow> P (LCons x xs) (LCons y ys)\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs ys", "let ?C = \"(\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat\""], ["proof (state)\ngoal (1 subgoal):\n 1. P xs ys", "have \"Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n     ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)", "by(rule chainI) auto"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)\n\ngoal (1 subgoal):\n 1. P xs ys", "with adm"], ["proof (chain)\npicking this:\n  ccpo.admissible (prod_lub lSup lSup)\n   (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (\\<lambda>x. P (fst x) (snd x))\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)", "have \"P (fst (prod_lub lSup lSup ?C)) (snd (prod_lub lSup lSup ?C))\""], ["proof (prove)\nusing this:\n  ccpo.admissible (prod_lub lSup lSup)\n   (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (\\<lambda>x. P (fst x) (snd x))\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)\n\ngoal (1 subgoal):\n 1. P (fst (prod_lub lSup lSup\n             ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))\n     (snd (prod_lub lSup lSup\n            ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))", "proof(rule ccpo.admissibleD)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "fix xsys"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "assume \"xsys \\<in> ?C\""], ["proof (state)\nthis:\n  xsys \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "then"], ["proof (chain)\npicking this:\n  xsys \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat", "obtain n where \"xsys = (ltake (enat n) xs, ltake (enat n) ys)\""], ["proof (prove)\nusing this:\n  xsys \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        xsys = (ltake (enat n) xs, ltake (enat n) ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xsys = (ltake (enat n) xs, ltake (enat n) ys)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "moreover"], ["proof (state)\nthis:\n  xsys = (ltake (enat n) xs, ltake (enat n) ys)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "{"], ["proof (state)\nthis:\n  xsys = (ltake (enat n) xs, ltake (enat n) ys)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "fix xs :: \"'a llist\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "hence \"P xs LNil\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs LNil", "by induct(auto intro: LNil LCons1)"], ["proof (state)\nthis:\n  P xs LNil\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "}"], ["proof (state)\nthis:\n  lfinite ?xsa2 \\<Longrightarrow> P ?xsa2 LNil\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "note 1 = this"], ["proof (state)\nthis:\n  lfinite ?xsa2 \\<Longrightarrow> P ?xsa2 LNil\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "{"], ["proof (state)\nthis:\n  lfinite ?xsa2 \\<Longrightarrow> P ?xsa2 LNil\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "fix ys :: \"'b llist\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "assume \"lfinite ys\""], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "hence \"P LNil ys\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. P LNil ys", "by induct(auto intro: LNil LCons2)"], ["proof (state)\nthis:\n  P LNil ys\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "}"], ["proof (state)\nthis:\n  lfinite ?ysa2 \\<Longrightarrow> P LNil ?ysa2\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "note 2 = this"], ["proof (state)\nthis:\n  lfinite ?ysa2 \\<Longrightarrow> P LNil ?ysa2\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "have \"P (ltake (enat n) xs) (ltake (enat n) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ltake (enat n) xs) (ltake (enat n) ys)", "by(induct n arbitrary: xs ys)(auto simp add: zero_enat_def[symmetric] LNil eSuc_enat[symmetric] ltake_eSuc split: llist.split intro: LNil LCons 1 2)"], ["proof (state)\nthis:\n  P (ltake (enat n) xs) (ltake (enat n) ys)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>n. (ltake n xs, ltake n ys)) `\n               range enat \\<Longrightarrow>\n       P (fst x) (snd x)", "ultimately"], ["proof (chain)\npicking this:\n  xsys = (ltake (enat n) xs, ltake (enat n) ys)\n  P (ltake (enat n) xs) (ltake (enat n) ys)", "show \"P (fst xsys) (snd xsys)\""], ["proof (prove)\nusing this:\n  xsys = (ltake (enat n) xs, ltake (enat n) ys)\n  P (ltake (enat n) xs) (ltake (enat n) ys)\n\ngoal (1 subgoal):\n 1. P (fst xsys) (snd xsys)", "by simp"], ["proof (state)\nthis:\n  P (fst xsys) (snd xsys)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat \\<noteq> {}", "qed simp"], ["proof (state)\nthis:\n  P (fst (prod_lub lSup lSup\n           ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))\n   (snd (prod_lub lSup lSup\n          ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))\n\ngoal (1 subgoal):\n 1. P xs ys", "also"], ["proof (state)\nthis:\n  P (fst (prod_lub lSup lSup\n           ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))\n   (snd (prod_lub lSup lSup\n          ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)))\n\ngoal (1 subgoal):\n 1. P xs ys", "have \"fst (prod_lub lSup lSup ?C) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (prod_lub lSup lSup\n          ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)) =\n    xs", "unfolding prod_lub_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup (fst ` (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat) = xs", "by(subst image_image)(simp add: mcont_contD[OF mcont_ltake1, symmetric] ltake_all)"], ["proof (state)\nthis:\n  fst (prod_lub lSup lSup\n        ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)) =\n  xs\n\ngoal (1 subgoal):\n 1. P xs ys", "also"], ["proof (state)\nthis:\n  fst (prod_lub lSup lSup\n        ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)) =\n  xs\n\ngoal (1 subgoal):\n 1. P xs ys", "have \"snd (prod_lub lSup lSup ?C) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (prod_lub lSup lSup\n          ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)) =\n    ys", "unfolding prod_lub_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. lSup (snd ` (\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat) = ys", "by(subst image_image)(simp add: mcont_contD[OF mcont_ltake1, symmetric] ltake_all)"], ["proof (state)\nthis:\n  snd (prod_lub lSup lSup\n        ((\\<lambda>n. (ltake n xs, ltake n ys)) ` range enat)) =\n  ys\n\ngoal (1 subgoal):\n 1. P xs ys", "finally"], ["proof (chain)\npicking this:\n  P xs ys", "show ?thesis"], ["proof (prove)\nusing this:\n  P xs ys\n\ngoal (1 subgoal):\n 1. P xs ys", "."], ["proof (state)\nthis:\n  P xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropn_0 [simp]: \"ldropn 0 xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn 0 xs = xs", "by(simp add: ldropn_def)"], ["", "lemma ldropn_LNil [code, simp]: \"ldropn n LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n LNil = LNil", "by(induct n)(simp_all add: ldropn_def)"], ["", "lemma ldropn_lnull: \"lnull xs \\<Longrightarrow> ldropn n xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> ldropn n xs = LNil", "by(simp add: lnull_def)"], ["", "lemma ldropn_LCons [code]:\n  \"ldropn n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | Suc n' \\<Rightarrow> ldropn n' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (LCons x xs) =\n    (case n of 0 \\<Rightarrow> LCons x xs\n     | Suc n' \\<Rightarrow> ldropn n' xs)", "by(cases n)(simp_all add: ldropn_def funpow_swap1)"], ["", "lemma ldropn_Suc: \"ldropn (Suc n) xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> ldropn n xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn (Suc n) xs =\n    (case xs of LNil \\<Rightarrow> LNil\n     | LCons x xs' \\<Rightarrow> ldropn n xs')", "by(simp split: llist.split)(simp add: ldropn_def funpow_swap1)"], ["", "lemma ldropn_Suc_LCons [simp]: \"ldropn (Suc n) (LCons x xs) = ldropn n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn (Suc n) (LCons x xs) = ldropn n xs", "by(simp add: ldropn_LCons)"], ["", "lemma ltl_ldropn: \"ltl (ldropn n xs) = ldropn n (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ldropn n xs) = ldropn n (ltl xs)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ltl (ldropn 0 xs) = ldropn 0 (ltl xs)\n 2. \\<And>n xs.\n       (\\<And>xs. ltl (ldropn n xs) = ldropn n (ltl xs)) \\<Longrightarrow>\n       ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs. ltl (ldropn 0 xs) = ldropn 0 (ltl xs)\n 2. \\<And>n xs.\n       (\\<And>xs. ltl (ldropn n xs) = ldropn n (ltl xs)) \\<Longrightarrow>\n       ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ldropn 0 xs) = ldropn 0 (ltl xs)", "by simp"], ["proof (state)\nthis:\n  ltl (ldropn 0 xs) = ldropn 0 (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltl (ldropn n xs) = ldropn n (ltl xs)) \\<Longrightarrow>\n       ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltl (ldropn n xs) = ldropn n (ltl xs)) \\<Longrightarrow>\n       ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "case (Suc n)"], ["proof (state)\nthis:\n  ltl (ldropn n ?xs) = ldropn n (ltl ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltl (ldropn n xs) = ldropn n (ltl xs)) \\<Longrightarrow>\n       ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "thus ?case"], ["proof (prove)\nusing this:\n  ltl (ldropn n ?xs) = ldropn n (ltl ?xs)\n\ngoal (1 subgoal):\n 1. ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)", "by(cases xs)(simp_all add: ldropn_Suc split: llist.split)"], ["proof (state)\nthis:\n  ltl (ldropn (Suc n) xs) = ldropn (Suc n) (ltl xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldrop_simps [simp]:\n  shows ldrop_LNil: \"ldrop n LNil = LNil\"\n  and ldrop_0: \"ldrop 0 xs = xs\"\n  and ldrop_eSuc_LCons: \"ldrop (eSuc n) (LCons x xs) = ldrop n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n LNil = LNil &&&\n    ldrop 0 xs = xs &&& ldrop (eSuc n) (LCons x xs) = ldrop n xs", "by(simp_all add: ldrop.simps split: co.enat.split)"], ["", "lemma ldrop_lnull: \"lnull xs \\<Longrightarrow> ldrop n xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> ldrop n xs = LNil", "by(simp add: lnull_def)"], ["", "lemma fixes f F\n  defines \"F \\<equiv> \\<lambda>ldropn xs. case xs of LNil \\<Rightarrow> \\<lambda>_. LNil | LCons x xs \\<Rightarrow> \\<lambda>n. if n = 0 then LCons x xs else ldropn xs (n - 1)\"\n  shows ldrop_conv_fixp: \"(\\<lambda>xs n. ldropn n xs) \\<equiv> ccpo.fixp (fun_lub (fun_lub lSup)) (fun_ord (fun_ord lprefix)) (\\<lambda>ldrop. F ldrop)\" (is \"?lhs \\<equiv> ?rhs\")\n  and ldrop_mono: \"\\<And>xs. mono_llist_lift (\\<lambda>ldrop. F ldrop xs)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs n. ldropn n xs \\<equiv> llist_lift.fixp_fun F) &&&\n    (\\<And>xs. mono_llist_lift (\\<lambda>ldrop. F ldrop xs))", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs n. ldropn n xs = llist_lift.fixp_fun F xs n\n 2. \\<And>xs. mono_llist_lift (\\<lambda>ldrop. F ldrop xs)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. mono_llist_lift (\\<lambda>ldrop. F ldrop xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mono_llist_lift\n        (\\<lambda>ldrop.\n            case xs of LNil \\<Rightarrow> \\<lambda>_. LNil\n            | LCons x xs \\<Rightarrow>\n                \\<lambda>n. if n = 0 then LCons x xs else ldrop xs (n - 1))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist_lift (\\<lambda>ldrop. F ldrop ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs n. ldropn n xs = llist_lift.fixp_fun F xs n", "fix n xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n. ldropn n xs = llist_lift.fixp_fun F xs n", "show \"?lhs xs n = ?rhs xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n xs = llist_lift.fixp_fun F xs n", "by(induction n arbitrary: xs)\n      (subst llist_lift.mono_body_fixp[OF mono], simp add: F_def split: llist.split)+"], ["proof (state)\nthis:\n  ldropn n xs = llist_lift.fixp_fun F xs n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropn_fixp_case_conv:\n  \"(\\<lambda>xs. case xs of LNil \\<Rightarrow> \\<lambda>_. LNil | LCons x xs \\<Rightarrow> \\<lambda>n. if n = 0 then LCons x xs else f xs (n - 1)) =\n   (\\<lambda>xs n. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> if n = 0 then LCons x xs else f xs (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        case xs of LNil \\<Rightarrow> \\<lambda>_. LNil\n        | LCons x xs \\<Rightarrow>\n            \\<lambda>n.\n               if n = (0::'b) then LCons x xs else f xs (n - (1::'b))) =\n    (\\<lambda>xs n.\n        case xs of LNil \\<Rightarrow> LNil\n        | LCons x xs \\<Rightarrow>\n            if n = (0::'b) then LCons x xs else f xs (n - (1::'b)))", "by(auto simp add: fun_eq_iff split: llist.split)"], ["", "lemma monotone_ldropn_aux: \"monotone lprefix (fun_ord lprefix) (\\<lambda>xs n. ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) llist.le_fun (\\<lambda>xs n. ldropn n xs)", "by(rule llist_lift.fixp_preserves_mono1[OF ldrop_mono ldrop_conv_fixp])\n  (simp add: ldropn_fixp_case_conv monotone_fun_ord_apply)"], ["", "lemma mono2mono_ldropn[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldropn': \"monotone lprefix lprefix (\\<lambda>xs. ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldropn n)", "using monotone_ldropn_aux"], ["proof (prove)\nusing this:\n  monotone (\\<sqsubseteq>) llist.le_fun (\\<lambda>xs n. ldropn n xs)\n\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldropn n)", "by(auto simp add: monotone_def fun_ord_def)"], ["", "lemma mcont_ldropn_aux: \"mcont lSup lprefix (fun_lub lSup) (fun_ord lprefix) (\\<lambda>xs n. ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) llist.lub_fun llist.le_fun\n     (\\<lambda>xs n. ldropn n xs)", "by(rule llist_lift.fixp_preserves_mcont1[OF ldrop_mono ldrop_conv_fixp])\n  (simp add: ldropn_fixp_case_conv mcont_fun_lub_apply)"], ["", "lemma mcont2mcont_ldropn [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldropn: \"mcont lSup lprefix lSup lprefix (ldropn n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldropn n)", "using mcont_ldropn_aux"], ["proof (prove)\nusing this:\n  mcont lSup (\\<sqsubseteq>) llist.lub_fun llist.le_fun\n   (\\<lambda>xs n. ldropn n xs)\n\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldropn n)", "by(auto simp add: mcont_fun_lub_apply)"], ["", "lemma monotone_enat_cocase [cont_intro, simp]:\n  \"\\<lbrakk> \\<And>n. monotone (\\<le>) ord (\\<lambda>n. f n (eSuc n));\n    \\<And>n. ord a (f n (eSuc n)); ord a a \\<rbrakk>\n  \\<Longrightarrow> monotone (\\<le>) ord (\\<lambda>n. case n of 0 \\<Rightarrow> a | eSuc n' \\<Rightarrow> f n' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n. monotone (\\<le>) ord (\\<lambda>n. f n (eSuc n));\n     \\<And>n. ord a (f n (eSuc n)); ord a a\\<rbrakk>\n    \\<Longrightarrow> monotone (\\<le>) ord\n                       (\\<lambda>n.\n                           case n of 0 \\<Rightarrow> a\n                           | eSuc n' \\<Rightarrow> f n' n)", "by(rule monotone_enat_le_case)"], ["", "lemma monotone_ldrop: \"monotone (rel_prod (=) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod ldrop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (=) (\\<sqsubseteq>)) (\\<sqsubseteq>)\n     (\\<lambda>(x, y). ldrop x y)", "by(rule llist.fixp_preserves_mono2[OF ldrop.mono ldrop_def]) simp"], ["", "lemma mono2mono_ldrop2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldrop2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldrop n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldrop n)", "by(simp add: monotone_ldrop[simplified])"], ["", "lemma mcont_ldrop: \"mcont (prod_lub the_Sup lSup) (rel_prod (=) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod ldrop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (prod_lub the_Sup lSup) (rel_prod (=) (\\<sqsubseteq>)) lSup\n     (\\<sqsubseteq>) (\\<lambda>(x, y). ldrop x y)", "by(rule llist.fixp_preserves_mcont2[OF ldrop.mono ldrop_def]) simp"], ["", "lemma mcont2monct_ldrop2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldrop2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldrop n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldrop n)", "by(simp add: mcont_ldrop[simplified])"], ["", "lemma ldrop_eSuc_conv_ltl: \"ldrop (eSuc n) xs = ltl (ldrop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (eSuc n) xs = ltl (ldrop n xs)", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop (eSuc x) a = ltl (ldrop x a))\n 2. \\<And>n. ldrop (eSuc n) LNil = ltl (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop (eSuc n) xs = ltl (ldrop n xs)\\<rbrakk>\n       \\<Longrightarrow> ldrop (eSuc n) (LCons x xs) =\n                         ltl (ldrop n (LCons x xs))", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  ldrop (eSuc ?n) xs_ = ltl (ldrop ?n xs_)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop (eSuc x) a = ltl (ldrop x a))\n 2. \\<And>n. ldrop (eSuc n) LNil = ltl (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop (eSuc n) xs = ltl (ldrop n xs)\\<rbrakk>\n       \\<Longrightarrow> ldrop (eSuc n) (LCons x xs) =\n                         ltl (ldrop n (LCons x xs))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  ldrop (eSuc ?n) xs_ = ltl (ldrop ?n xs_)\n\ngoal (1 subgoal):\n 1. ldrop (eSuc n) (LCons x_ xs_) = ltl (ldrop n (LCons x_ xs_))", "by(cases n rule: co.enat.exhaust) simp_all"], ["proof (state)\nthis:\n  ldrop (eSuc n) (LCons x_ xs_) = ltl (ldrop n (LCons x_ xs_))\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop (eSuc x) a = ltl (ldrop x a))\n 2. \\<And>n. ldrop (eSuc n) LNil = ltl (ldrop n LNil)", "qed simp_all"], ["", "lemma ldrop_ltl: \"ldrop n (ltl xs) = ldrop (eSuc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (ltl xs) = ldrop (eSuc n) xs", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (ltl a) = ldrop (eSuc x) a)\n 2. \\<And>n. ldrop n (ltl LNil) = ldrop (eSuc n) LNil\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop n (ltl xs) = ldrop (eSuc n) xs\\<rbrakk>\n       \\<Longrightarrow> ldrop n (ltl (LCons x xs)) =\n                         ldrop (eSuc n) (LCons x xs)", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  ldrop ?n (ltl xs_) = ldrop (eSuc ?n) xs_\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (ltl a) = ldrop (eSuc x) a)\n 2. \\<And>n. ldrop n (ltl LNil) = ldrop (eSuc n) LNil\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop n (ltl xs) = ldrop (eSuc n) xs\\<rbrakk>\n       \\<Longrightarrow> ldrop n (ltl (LCons x xs)) =\n                         ldrop (eSuc n) (LCons x xs)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  ldrop ?n (ltl xs_) = ldrop (eSuc ?n) xs_\n\ngoal (1 subgoal):\n 1. ldrop n (ltl (LCons x_ xs_)) = ldrop (eSuc n) (LCons x_ xs_)", "by(cases n rule: co.enat.exhaust) simp_all"], ["proof (state)\nthis:\n  ldrop n (ltl (LCons x_ xs_)) = ldrop (eSuc n) (LCons x_ xs_)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (ltl a) = ldrop (eSuc x) a)\n 2. \\<And>n. ldrop n (ltl LNil) = ldrop (eSuc n) LNil", "qed simp_all"], ["", "lemma lnull_ldropn [simp]: \"lnull (ldropn n xs) \\<longleftrightarrow> llength xs \\<le> enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ldropn n xs) = (llength xs \\<le> enat n)", "proof(induction n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. lnull (ldropn 0 xs) = (llength xs \\<le> enat 0)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           lnull (ldropn n xs) =\n           (llength xs \\<le> enat n)) \\<Longrightarrow>\n       lnull (ldropn (Suc n) xs) = (llength xs \\<le> enat (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  lnull (ldropn n ?xs) = (llength ?xs \\<le> enat n)\n\ngoal (2 subgoals):\n 1. \\<And>xs. lnull (ldropn 0 xs) = (llength xs \\<le> enat 0)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           lnull (ldropn n xs) =\n           (llength xs \\<le> enat n)) \\<Longrightarrow>\n       lnull (ldropn (Suc n) xs) = (llength xs \\<le> enat (Suc n))", "from Suc.IH[of \"ltl xs\"]"], ["proof (chain)\npicking this:\n  lnull (ldropn n (ltl xs)) = (llength (ltl xs) \\<le> enat n)", "show ?case"], ["proof (prove)\nusing this:\n  lnull (ldropn n (ltl xs)) = (llength (ltl xs) \\<le> enat n)\n\ngoal (1 subgoal):\n 1. lnull (ldropn (Suc n) xs) = (llength xs \\<le> enat (Suc n))", "by(cases xs)(simp_all add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  lnull (ldropn (Suc n) xs) = (llength xs \\<le> enat (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>xs. lnull (ldropn 0 xs) = (llength xs \\<le> enat 0)", "qed(simp add: zero_enat_def[symmetric])"], ["", "lemma ldrop_eq_LNil [simp]: \"ldrop n xs = LNil \\<longleftrightarrow> llength xs \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldrop n xs = LNil) = (llength xs \\<le> n)", "proof(induction xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. (ldrop x a = LNil) = (llength a \\<le> x))\n 2. \\<And>n. (ldrop n LNil = LNil) = (llength LNil \\<le> n)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. (ldrop n xs = LNil) = (llength xs \\<le> n)\\<rbrakk>\n       \\<Longrightarrow> (ldrop n (LCons x xs) = LNil) =\n                         (llength (LCons x xs) \\<le> n)", "case (LCons x xs n)"], ["proof (state)\nthis:\n  lfinite xs\n  (ldrop ?n xs = LNil) = (llength xs \\<le> ?n)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. (ldrop x a = LNil) = (llength a \\<le> x))\n 2. \\<And>n. (ldrop n LNil = LNil) = (llength LNil \\<le> n)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. (ldrop n xs = LNil) = (llength xs \\<le> n)\\<rbrakk>\n       \\<Longrightarrow> (ldrop n (LCons x xs) = LNil) =\n                         (llength (LCons x xs) \\<le> n)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  (ldrop ?n xs = LNil) = (llength xs \\<le> ?n)\n\ngoal (1 subgoal):\n 1. (ldrop n (LCons x xs) = LNil) = (llength (LCons x xs) \\<le> n)", "by(cases n rule: co.enat.exhaust) simp_all"], ["proof (state)\nthis:\n  (ldrop n (LCons x xs) = LNil) = (llength (LCons x xs) \\<le> n)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. (ldrop x a = LNil) = (llength a \\<le> x))\n 2. \\<And>n. (ldrop n LNil = LNil) = (llength LNil \\<le> n)", "qed simp_all"], ["", "lemma lnull_ldrop [simp]: \"lnull (ldrop n xs) \\<longleftrightarrow> llength xs \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ldrop n xs) = (llength xs \\<le> n)", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldrop n xs = LNil) = (llength xs \\<le> n)", "by(fact ldrop_eq_LNil)"], ["", "lemma ldropn_eq_LNil: \"(ldropn n xs = LNil) = (llength xs \\<le> enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldropn n xs = LNil) = (llength xs \\<le> enat n)", "using lnull_ldropn"], ["proof (prove)\nusing this:\n  lnull (ldropn ?n ?xs) = (llength ?xs \\<le> enat ?n)\n\ngoal (1 subgoal):\n 1. (ldropn n xs = LNil) = (llength xs \\<le> enat n)", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (ldropn ?n ?xs = LNil) = (llength ?xs \\<le> enat ?n)\n\ngoal (1 subgoal):\n 1. (ldropn n xs = LNil) = (llength xs \\<le> enat n)", "."], ["", "lemma ldropn_all: \"llength xs \\<le> enat m \\<Longrightarrow> ldropn m xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> enat m \\<Longrightarrow> ldropn m xs = LNil", "by(simp add: ldropn_eq_LNil)"], ["", "lemma ldrop_all: \"llength xs \\<le> m \\<Longrightarrow> ldrop m xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> m \\<Longrightarrow> ldrop m xs = LNil", "by(simp)"], ["", "lemma ltl_ldrop: \"ltl (ldrop n xs) = ldrop n (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ldrop n xs) = ldrop n (ltl xs)", "by(simp add: ldrop_eSuc_conv_ltl ldrop_ltl)"], ["", "lemma ldrop_eSuc:\n  \"ldrop (eSuc n) xs = (case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> ldrop n xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (eSuc n) xs =\n    (case xs of LNil \\<Rightarrow> LNil\n     | LCons x xs' \\<Rightarrow> ldrop n xs')", "by(cases xs) simp_all"], ["", "lemma ldrop_LCons:\n  \"ldrop n (LCons x xs) = (case n of 0 \\<Rightarrow> LCons x xs | eSuc n' \\<Rightarrow> ldrop n' xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (LCons x xs) =\n    (case n of 0 \\<Rightarrow> LCons x xs\n     | eSuc n' \\<Rightarrow> ldrop n' xs)", "by(cases n rule: enat_coexhaust) simp_all"], ["", "lemma ldrop_inf [code, simp]: \"ldrop \\<infinity> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop \\<infinity> xs = LNil", "by(induction xs)(simp_all add: ldrop_LCons enat_cocase_inf)"], ["", "lemma ldrop_enat [code]: \"ldrop (enat n) xs = ldropn n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat n) xs = ldropn n xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ldrop (enat 0) xs = ldropn 0 xs\n 2. \\<And>n xs.\n       (\\<And>xs. ldrop (enat n) xs = ldropn n xs) \\<Longrightarrow>\n       ldrop (enat (Suc n)) xs = ldropn (Suc n) xs", "case Suc"], ["proof (state)\nthis:\n  ldrop (enat n_) ?xs = ldropn n_ ?xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. ldrop (enat 0) xs = ldropn 0 xs\n 2. \\<And>n xs.\n       (\\<And>xs. ldrop (enat n) xs = ldropn n xs) \\<Longrightarrow>\n       ldrop (enat (Suc n)) xs = ldropn (Suc n) xs", "thus ?case"], ["proof (prove)\nusing this:\n  ldrop (enat n_) ?xs = ldropn n_ ?xs\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc n_)) xs = ldropn (Suc n_) xs", "by(cases xs)(simp_all add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  ldrop (enat (Suc n_)) xs = ldropn (Suc n_) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. ldrop (enat 0) xs = ldropn 0 xs", "qed(simp add: zero_enat_def[symmetric])"], ["", "lemma lfinite_ldropn [simp]: \"lfinite (ldropn n xs) = lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ldropn n xs) = lfinite xs", "by(induct n arbitrary: xs)(simp_all add: ldropn_Suc split: llist.split)"], ["", "lemma lfinite_ldrop [simp]:\n  \"lfinite (ldrop n xs) \\<longleftrightarrow> lfinite xs \\<or> n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ldrop n xs) = (lfinite xs \\<or> n = \\<infinity>)", "by(cases n)(simp_all add: ldrop_enat)"], ["", "lemma ldropn_ltl: \"ldropn n (ltl xs) = ldropn (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (ltl xs) = ldropn (Suc n) xs", "by(simp add: ldropn_def funpow_swap1)"], ["", "lemmas ldrop_eSuc_ltl = ldropn_ltl[symmetric]"], ["", "lemma lset_ldropn_subset: \"lset (ldropn n xs) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ldropn n xs) \\<subseteq> lset xs", "by(induct n arbitrary: xs)(fastforce simp add: ldropn_Suc split: llist.split_asm)+"], ["", "lemma in_lset_ldropnD: \"x \\<in> lset (ldropn n xs) \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (ldropn n xs) \\<Longrightarrow> x \\<in> lset xs", "using lset_ldropn_subset[of n xs]"], ["proof (prove)\nusing this:\n  lset (ldropn n xs) \\<subseteq> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (ldropn n xs) \\<Longrightarrow> x \\<in> lset xs", "by auto"], ["", "lemma lset_ldrop_subset: \"lset (ldrop n xs) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ldrop n xs) \\<subseteq> lset xs", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. lset (ldrop x a) \\<subseteq> lset a)\n 2. \\<And>n. lset (ldrop n LNil) \\<subseteq> lset LNil\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. lset (ldrop n xs) \\<subseteq> lset xs\\<rbrakk>\n       \\<Longrightarrow> lset (ldrop n (LCons x xs))\n                         \\<subseteq> lset (LCons x xs)", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  lset (ldrop ?n xs_) \\<subseteq> lset xs_\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. lset (ldrop x a) \\<subseteq> lset a)\n 2. \\<And>n. lset (ldrop n LNil) \\<subseteq> lset LNil\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. lset (ldrop n xs) \\<subseteq> lset xs\\<rbrakk>\n       \\<Longrightarrow> lset (ldrop n (LCons x xs))\n                         \\<subseteq> lset (LCons x xs)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  lset (ldrop ?n xs_) \\<subseteq> lset xs_\n\ngoal (1 subgoal):\n 1. lset (ldrop n (LCons x_ xs_)) \\<subseteq> lset (LCons x_ xs_)", "by(cases n rule: co.enat.exhaust) auto"], ["proof (state)\nthis:\n  lset (ldrop n (LCons x_ xs_)) \\<subseteq> lset (LCons x_ xs_)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. lset (ldrop x a) \\<subseteq> lset a)\n 2. \\<And>n. lset (ldrop n LNil) \\<subseteq> lset LNil", "qed simp_all"], ["", "lemma in_lset_ldropD: \"x \\<in> lset (ldrop n xs) \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (ldrop n xs) \\<Longrightarrow> x \\<in> lset xs", "using lset_ldrop_subset[of n xs]"], ["proof (prove)\nusing this:\n  lset (ldrop n xs) \\<subseteq> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (ldrop n xs) \\<Longrightarrow> x \\<in> lset xs", "by(auto)"], ["", "lemma lappend_ltake_ldrop: \"lappend (ltake n xs) (ldrop n xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (ltake n xs) (ldrop n xs) = xs", "by(coinduction arbitrary: n xs rule: llist.coinduct_strong)\n  (auto simp add: ldrop_ltl ltl_ltake intro!: arg_cong2[where f=lappend])"], ["", "lemma ldropn_lappend:\n  \"ldropn n (lappend xs ys) =\n  (if enat n < llength xs then lappend (ldropn n xs) ys\n   else ldropn (n - the_enat (llength xs)) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (lappend xs ys) =\n    (if enat n < llength xs then lappend (ldropn n xs) ys\n     else ldropn (n - the_enat (llength xs)) ys)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ldropn 0 (lappend xs ys) =\n       (if enat 0 < llength xs then lappend (ldropn 0 xs) ys\n        else ldropn (0 - the_enat (llength xs)) ys)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ldropn 0 (lappend xs ys) =\n       (if enat 0 < llength xs then lappend (ldropn 0 xs) ys\n        else ldropn (0 - the_enat (llength xs)) ys)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn 0 (lappend xs ys) =\n    (if enat 0 < llength xs then lappend (ldropn 0 xs) ys\n     else ldropn (0 - the_enat (llength xs)) ys)", "by(simp add: zero_enat_def[symmetric] lappend_lnull1)"], ["proof (state)\nthis:\n  ldropn 0 (lappend xs ys) =\n  (if enat 0 < llength xs then lappend (ldropn 0 xs) ys\n   else ldropn (0 - the_enat (llength xs)) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "case (Suc n)"], ["proof (state)\nthis:\n  ldropn n (lappend ?xs ys) =\n  (if enat n < llength ?xs then lappend (ldropn n ?xs) ys\n   else ldropn (n - the_enat (llength ?xs)) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "{"], ["proof (state)\nthis:\n  ldropn n (lappend ?xs ys) =\n  (if enat n < llength ?xs then lappend (ldropn n ?xs) ys\n   else ldropn (n - the_enat (llength ?xs)) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "assume \"llength zs \\<le> enat n\""], ["proof (state)\nthis:\n  llength zs \\<le> enat n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "hence \"the_enat (eSuc (llength zs)) = Suc (the_enat (llength zs))\""], ["proof (prove)\nusing this:\n  llength zs \\<le> enat n\n\ngoal (1 subgoal):\n 1. the_enat (eSuc (llength zs)) = Suc (the_enat (llength zs))", "by(auto intro!: the_enat_eSuc iff del: not_infinity_eq)"], ["proof (state)\nthis:\n  the_enat (eSuc (llength zs)) = Suc (the_enat (llength zs))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "}"], ["proof (state)\nthis:\n  llength ?zs2 \\<le> enat n \\<Longrightarrow>\n  the_enat (eSuc (llength ?zs2)) = Suc (the_enat (llength ?zs2))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "note eq = this"], ["proof (state)\nthis:\n  llength ?zs2 \\<le> enat n \\<Longrightarrow>\n  the_enat (eSuc (llength ?zs2)) = Suc (the_enat (llength ?zs2))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (lappend xs ys) =\n           (if enat n < llength xs then lappend (ldropn n xs) ys\n            else ldropn (n - the_enat (llength xs)) ys)) \\<Longrightarrow>\n       ldropn (Suc n) (lappend xs ys) =\n       (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n        else ldropn (Suc n - the_enat (llength xs)) ys)", "from Suc"], ["proof (chain)\npicking this:\n  ldropn n (lappend ?xs ys) =\n  (if enat n < llength ?xs then lappend (ldropn n ?xs) ys\n   else ldropn (n - the_enat (llength ?xs)) ys)", "show ?case"], ["proof (prove)\nusing this:\n  ldropn n (lappend ?xs ys) =\n  (if enat n < llength ?xs then lappend (ldropn n ?xs) ys\n   else ldropn (n - the_enat (llength ?xs)) ys)\n\ngoal (1 subgoal):\n 1. ldropn (Suc n) (lappend xs ys) =\n    (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n     else ldropn (Suc n - the_enat (llength xs)) ys)", "by(cases xs)(auto simp add: not_less not_le eSuc_enat[symmetric] eq)"], ["proof (state)\nthis:\n  ldropn (Suc n) (lappend xs ys) =\n  (if enat (Suc n) < llength xs then lappend (ldropn (Suc n) xs) ys\n   else ldropn (Suc n - the_enat (llength xs)) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropn_lappend2:\n  \"llength xs \\<le> enat n \\<Longrightarrow> ldropn n (lappend xs ys) = ldropn (n - the_enat (llength xs)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> enat n \\<Longrightarrow>\n    ldropn n (lappend xs ys) = ldropn (n - the_enat (llength xs)) ys", "by(auto simp add: ldropn_lappend)"], ["", "lemma lappend_ltake_enat_ldropn [simp]: \"lappend (ltake (enat n) xs) (ldropn n xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (ltake (enat n) xs) (ldropn n xs) = xs", "by(fold ldrop_enat)(rule lappend_ltake_ldrop)"], ["", "lemma ldrop_lappend:\n  \"ldrop n (lappend xs ys) =\n  (if n < llength xs then lappend (ldrop n xs) ys\n   else ldrop (n - llength xs) ys)\"\n  \\<comment> \\<open>cannot prove this directly using fixpoint induction,\n     because @{term \"(-) :: enat \\<Rightarrow> enat \\<Rightarrow> enat\"} is not a least fixpoint\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (lappend xs ys) =\n    (if n < llength xs then lappend (ldrop n xs) ys\n     else ldrop (n - llength xs) ys)", "by(cases n)(cases \"llength xs\", simp_all add: ldropn_lappend not_less ldrop_enat)"], ["", "lemma ltake_plus_conv_lappend:\n  \"ltake (n + m) xs = lappend (ltake n xs) (ltake m (ldrop n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (n + m) xs = lappend (ltake n xs) (ltake m (ldrop n xs))", "by(coinduction arbitrary: n m xs rule: llist.coinduct_strong)(auto intro!: exI simp add: iadd_is_0 ltl_ltake epred_iadd1 ldrop_ltl)"], ["", "lemma ldropn_eq_LConsD:\n  \"ldropn n xs = LCons y ys \\<Longrightarrow> enat n < llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n xs = LCons y ys \\<Longrightarrow> enat n < llength xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ldropn 0 xs = LCons y ys \\<Longrightarrow> enat 0 < llength xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   ldropn n xs = LCons y ys \\<Longrightarrow>\n                   enat n < llength xs;\n        ldropn (Suc n) xs = LCons y ys\\<rbrakk>\n       \\<Longrightarrow> enat (Suc n) < llength xs", "case 0"], ["proof (state)\nthis:\n  ldropn 0 xs = LCons y ys\n\ngoal (2 subgoals):\n 1. \\<And>xs. ldropn 0 xs = LCons y ys \\<Longrightarrow> enat 0 < llength xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   ldropn n xs = LCons y ys \\<Longrightarrow>\n                   enat n < llength xs;\n        ldropn (Suc n) xs = LCons y ys\\<rbrakk>\n       \\<Longrightarrow> enat (Suc n) < llength xs", "thus ?case"], ["proof (prove)\nusing this:\n  ldropn 0 xs = LCons y ys\n\ngoal (1 subgoal):\n 1. enat 0 < llength xs", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   ldropn n xs = LCons y ys \\<Longrightarrow>\n                   enat n < llength xs;\n        ldropn (Suc n) xs = LCons y ys\\<rbrakk>\n       \\<Longrightarrow> enat (Suc n) < llength xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   ldropn n xs = LCons y ys \\<Longrightarrow>\n                   enat n < llength xs;\n        ldropn (Suc n) xs = LCons y ys\\<rbrakk>\n       \\<Longrightarrow> enat (Suc n) < llength xs", "case (Suc n)"], ["proof (state)\nthis:\n  ldropn n ?xs = LCons y ys \\<Longrightarrow> enat n < llength ?xs\n  ldropn (Suc n) xs = LCons y ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   ldropn n xs = LCons y ys \\<Longrightarrow>\n                   enat n < llength xs;\n        ldropn (Suc n) xs = LCons y ys\\<rbrakk>\n       \\<Longrightarrow> enat (Suc n) < llength xs", "thus ?case"], ["proof (prove)\nusing this:\n  ldropn n ?xs = LCons y ys \\<Longrightarrow> enat n < llength ?xs\n  ldropn (Suc n) xs = LCons y ys\n\ngoal (1 subgoal):\n 1. enat (Suc n) < llength xs", "by(cases xs)(simp_all add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat (Suc n) < llength xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldrop_eq_LConsD:\n  \"ldrop n xs = LCons y ys \\<Longrightarrow> n < llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n xs = LCons y ys \\<Longrightarrow> n < llength xs", "by(rule ccontr)(simp add: not_less ldrop_all)"], ["", "lemma ldropn_lmap [simp]: \"ldropn n (lmap f xs) = lmap f (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (lmap f xs) = lmap f (ldropn n xs)", "by(induct n arbitrary: xs)(simp_all add: ldropn_Suc split: llist.split)"], ["", "lemma ldrop_lmap [simp]: \"ldrop n (lmap f xs) = lmap f (ldrop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (lmap f xs) = lmap f (ldrop n xs)", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (lmap f a) = lmap f (ldrop x a))\n 2. \\<And>n. ldrop n (lmap f LNil) = lmap f (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop n (lmap f xs) = lmap f (ldrop n xs)\\<rbrakk>\n       \\<Longrightarrow> ldrop n (lmap f (LCons x xs)) =\n                         lmap f (ldrop n (LCons x xs))", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  ldrop ?n (lmap f xs_) = lmap f (ldrop ?n xs_)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (lmap f a) = lmap f (ldrop x a))\n 2. \\<And>n. ldrop n (lmap f LNil) = lmap f (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldrop n (lmap f xs) = lmap f (ldrop n xs)\\<rbrakk>\n       \\<Longrightarrow> ldrop n (lmap f (LCons x xs)) =\n                         lmap f (ldrop n (LCons x xs))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  ldrop ?n (lmap f xs_) = lmap f (ldrop ?n xs_)\n\ngoal (1 subgoal):\n 1. ldrop n (lmap f (LCons x_ xs_)) = lmap f (ldrop n (LCons x_ xs_))", "by(cases n rule: co.enat.exhaust) simp_all"], ["proof (state)\nthis:\n  ldrop n (lmap f (LCons x_ xs_)) = lmap f (ldrop n (LCons x_ xs_))\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop x (lmap f a) = lmap f (ldrop x a))\n 2. \\<And>n. ldrop n (lmap f LNil) = lmap f (ldrop n LNil)", "qed simp_all"], ["", "lemma ldropn_ldropn [simp]:\n  \"ldropn n (ldropn m xs) = ldropn (n + m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (ldropn m xs) = ldropn (n + m) xs", "by(induct m arbitrary: xs)(auto simp add: ldropn_Suc split: llist.split)"], ["", "lemma ldrop_ldrop [simp]:\n  \"ldrop n (ldrop m xs) = ldrop (n + m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (ldrop m xs) = ldrop (n + m) xs", "proof(induct xs arbitrary: m)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop n (ldrop x a) = ldrop (n + x) a)\n 2. \\<And>m. ldrop n (ldrop m LNil) = ldrop (n + m) LNil\n 3. \\<And>x xs m.\n       \\<lbrakk>lfinite xs;\n        \\<And>m. ldrop n (ldrop m xs) = ldrop (n + m) xs\\<rbrakk>\n       \\<Longrightarrow> ldrop n (ldrop m (LCons x xs)) =\n                         ldrop (n + m) (LCons x xs)", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  ldrop n (ldrop ?m xs_) = ldrop (n + ?m) xs_\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop n (ldrop x a) = ldrop (n + x) a)\n 2. \\<And>m. ldrop n (ldrop m LNil) = ldrop (n + m) LNil\n 3. \\<And>x xs m.\n       \\<lbrakk>lfinite xs;\n        \\<And>m. ldrop n (ldrop m xs) = ldrop (n + m) xs\\<rbrakk>\n       \\<Longrightarrow> ldrop n (ldrop m (LCons x xs)) =\n                         ldrop (n + m) (LCons x xs)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  ldrop n (ldrop ?m xs_) = ldrop (n + ?m) xs_\n\ngoal (1 subgoal):\n 1. ldrop n (ldrop m (LCons x_ xs_)) = ldrop (n + m) (LCons x_ xs_)", "by(cases m rule: co.enat.exhaust)(simp_all add: iadd_Suc_right)"], ["proof (state)\nthis:\n  ldrop n (ldrop m (LCons x_ xs_)) = ldrop (n + m) (LCons x_ xs_)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a. \\<forall>x. ldrop n (ldrop x a) = ldrop (n + x) a)\n 2. \\<And>m. ldrop n (ldrop m LNil) = ldrop (n + m) LNil", "qed simp_all"], ["", "lemma llength_ldropn [simp]: \"llength (ldropn n xs) = llength xs - enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ldropn n xs) = llength xs - enat n", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. llength (ldropn 0 xs) = llength xs - enat 0\n 2. \\<And>n xs.\n       (\\<And>xs.\n           llength (ldropn n xs) = llength xs - enat n) \\<Longrightarrow>\n       llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs. llength (ldropn 0 xs) = llength xs - enat 0\n 2. \\<And>n xs.\n       (\\<And>xs.\n           llength (ldropn n xs) = llength xs - enat n) \\<Longrightarrow>\n       llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ldropn 0 xs) = llength xs - enat 0", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  llength (ldropn 0 xs) = llength xs - enat 0\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           llength (ldropn n xs) = llength xs - enat n) \\<Longrightarrow>\n       llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           llength (ldropn n xs) = llength xs - enat n) \\<Longrightarrow>\n       llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  llength (ldropn n ?xs) = llength ?xs - enat n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           llength (ldropn n xs) = llength xs - enat n) \\<Longrightarrow>\n       llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  llength (ldropn n ?xs) = llength ?xs - enat n\n\ngoal (1 subgoal):\n 1. llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)", "by(cases xs)(simp_all add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  llength (ldropn (Suc n) xs) = llength xs - enat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enat_llength_ldropn:\n  \"enat n \\<le> llength xs \\<Longrightarrow> enat (n - m) \\<le> llength (ldropn m xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    enat (n - m) \\<le> llength (ldropn m xs)", "by(cases \"llength xs\") simp_all"], ["", "lemma ldropn_llist_of [simp]: \"ldropn n (llist_of xs) = llist_of (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (llist_of xs) = llist_of (drop n xs)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ldropn 0 (llist_of xs) = llist_of (drop 0 xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (llist_of xs) = llist_of (drop n xs)) \\<Longrightarrow>\n       ldropn (Suc n) (llist_of xs) = llist_of (drop (Suc n) xs)", "case Suc"], ["proof (state)\nthis:\n  ldropn n_ (llist_of ?xs) = llist_of (drop n_ ?xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs. ldropn 0 (llist_of xs) = llist_of (drop 0 xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ldropn n (llist_of xs) = llist_of (drop n xs)) \\<Longrightarrow>\n       ldropn (Suc n) (llist_of xs) = llist_of (drop (Suc n) xs)", "thus ?case"], ["proof (prove)\nusing this:\n  ldropn n_ (llist_of ?xs) = llist_of (drop n_ ?xs)\n\ngoal (1 subgoal):\n 1. ldropn (Suc n_) (llist_of xs) = llist_of (drop (Suc n_) xs)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  ldropn (Suc n_) (llist_of xs) = llist_of (drop (Suc n_) xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs. ldropn 0 (llist_of xs) = llist_of (drop 0 xs)", "qed simp"], ["", "lemma ldrop_llist_of: \"ldrop (enat n) (llist_of xs) = llist_of (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat n) (llist_of xs) = llist_of (drop n xs)", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. ldrop (enat n) (llist_of []) = llist_of (drop n [])\n 2. \\<And>a xs n.\n       (\\<And>n.\n           ldrop (enat n) (llist_of xs) =\n           llist_of (drop n xs)) \\<Longrightarrow>\n       ldrop (enat n) (llist_of (a # xs)) = llist_of (drop n (a # xs))", "case Cons"], ["proof (state)\nthis:\n  ldrop (enat ?n) (llist_of xs_) = llist_of (drop ?n xs_)\n\ngoal (2 subgoals):\n 1. \\<And>n. ldrop (enat n) (llist_of []) = llist_of (drop n [])\n 2. \\<And>a xs n.\n       (\\<And>n.\n           ldrop (enat n) (llist_of xs) =\n           llist_of (drop n xs)) \\<Longrightarrow>\n       ldrop (enat n) (llist_of (a # xs)) = llist_of (drop n (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  ldrop (enat ?n) (llist_of xs_) = llist_of (drop ?n xs_)\n\ngoal (1 subgoal):\n 1. ldrop (enat n) (llist_of (a_ # xs_)) = llist_of (drop n (a_ # xs_))", "by(cases n)(simp_all add: zero_enat_def[symmetric] eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  ldrop (enat n) (llist_of (a_ # xs_)) = llist_of (drop n (a_ # xs_))\n\ngoal (1 subgoal):\n 1. \\<And>n. ldrop (enat n) (llist_of []) = llist_of (drop n [])", "qed simp"], ["", "lemma drop_list_of:\n  \"lfinite xs \\<Longrightarrow> drop n (list_of xs) = list_of (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> drop n (list_of xs) = list_of (ldropn n xs)", "by (metis ldropn_llist_of list_of_llist_of llist_of_list_of)"], ["", "lemma llength_ldrop: \"llength (ldrop n xs) = (if n = \\<infinity> then 0 else llength xs - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ldrop n xs) = (if n = \\<infinity> then 0 else llength xs - n)", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x.\n            llength (ldrop x a) =\n            (if x = \\<infinity> then 0 else llength a - x))\n 2. \\<And>n.\n       llength (ldrop n LNil) =\n       (if n = \\<infinity> then 0 else llength LNil - n)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n.\n           llength (ldrop n xs) =\n           (if n = \\<infinity> then 0 else llength xs - n)\\<rbrakk>\n       \\<Longrightarrow> llength (ldrop n (LCons x xs)) =\n                         (if n = \\<infinity> then 0\n                          else llength (LCons x xs) - n)", "case (LCons x xs)"], ["proof (state)\nthis:\n  lfinite xs\n  llength (ldrop ?n xs) = (if ?n = \\<infinity> then 0 else llength xs - ?n)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x.\n            llength (ldrop x a) =\n            (if x = \\<infinity> then 0 else llength a - x))\n 2. \\<And>n.\n       llength (ldrop n LNil) =\n       (if n = \\<infinity> then 0 else llength LNil - n)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n.\n           llength (ldrop n xs) =\n           (if n = \\<infinity> then 0 else llength xs - n)\\<rbrakk>\n       \\<Longrightarrow> llength (ldrop n (LCons x xs)) =\n                         (if n = \\<infinity> then 0\n                          else llength (LCons x xs) - n)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  llength (ldrop ?n xs) = (if ?n = \\<infinity> then 0 else llength xs - ?n)\n\ngoal (1 subgoal):\n 1. llength (ldrop n (LCons x xs)) =\n    (if n = \\<infinity> then 0 else llength (LCons x xs) - n)", "by simp(cases n rule: co.enat.exhaust, simp_all)"], ["proof (state)\nthis:\n  llength (ldrop n (LCons x xs)) =\n  (if n = \\<infinity> then 0 else llength (LCons x xs) - n)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x.\n            llength (ldrop x a) =\n            (if x = \\<infinity> then 0 else llength a - x))\n 2. \\<And>n.\n       llength (ldrop n LNil) =\n       (if n = \\<infinity> then 0 else llength LNil - n)", "qed simp_all"], ["", "lemma ltake_ldropn: \"ltake n (ldropn m xs) = ldropn m (ltake (n + enat m) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (ldropn m xs) = ldropn m (ltake (n + enat m) xs)", "by(induct m arbitrary: n xs)(auto simp add: zero_enat_def[symmetric] ldropn_Suc eSuc_enat[symmetric] iadd_Suc_right split: llist.split)"], ["", "lemma ldropn_ltake: \"ldropn n (ltake m xs) = ltake (m - enat n) (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (ltake m xs) = ltake (m - enat n) (ldropn n xs)", "by(induct n arbitrary: m xs)(auto simp add: zero_enat_def[symmetric] ltake_LCons ldropn_Suc eSuc_enat[symmetric] iadd_Suc_right split: llist.split co.enat.split_asm)"], ["", "lemma ltake_ldrop: \"ltake n (ldrop m xs) = ldrop m (ltake (n + m) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (ldrop m xs) = ldrop m (ltake (n + m) xs)", "by(induct xs arbitrary: n m)(simp_all add: ldrop_LCons iadd_Suc_right split: co.enat.split)"], ["", "lemma ldrop_ltake: \"ldrop n (ltake m xs) = ltake (m - n) (ldrop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (ltake m xs) = ltake (m - n) (ldrop n xs)", "by(induct xs arbitrary: n m)(simp_all add: ltake_LCons ldrop_LCons split: co.enat.split)"], ["", "subsection \\<open>Taking the $n$-th element of a lazy list: @{term \"lnth\" }\\<close>"], ["", "lemma lnth_LNil:\n  \"lnth LNil n = undefined n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth LNil n = undefined n", "by(cases n)(simp_all add: lnth.simps)"], ["", "lemma lnth_0 [simp]:\n  \"lnth (LCons x xs) 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (LCons x xs) 0 = x", "by(simp add: lnth.simps)"], ["", "lemma lnth_Suc_LCons [simp]:\n  \"lnth (LCons x xs) (Suc n) = lnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (LCons x xs) (Suc n) = lnth xs n", "by(simp add: lnth.simps)"], ["", "lemma lnth_LCons:\n  \"lnth (LCons x xs) n = (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> lnth xs n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (LCons x xs) n =\n    (case n of 0 \\<Rightarrow> x | Suc n' \\<Rightarrow> lnth xs n')", "by(cases n) simp_all"], ["", "lemma lnth_LCons': \"lnth (LCons x xs) n = (if n = 0 then x else lnth xs (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (LCons x xs) n = (if n = 0 then x else lnth xs (n - 1))", "by(simp add: lnth_LCons split: nat.split)"], ["", "lemma lhd_conv_lnth:\n  \"\\<not> lnull xs \\<Longrightarrow> lhd xs = lnth xs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<Longrightarrow> lhd xs = lnth xs 0", "by(auto simp add: lhd_def not_lnull_conv)"], ["", "lemmas lnth_0_conv_lhd = lhd_conv_lnth[symmetric]"], ["", "lemma lnth_ltl: \"\\<not> lnull xs \\<Longrightarrow> lnth (ltl xs) n = lnth xs (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<Longrightarrow> lnth (ltl xs) n = lnth xs (Suc n)", "by(auto simp add: not_lnull_conv)"], ["", "lemma lhd_ldropn:\n  \"enat n < llength xs \\<Longrightarrow> lhd (ldropn n xs) = lnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength xs \\<Longrightarrow> lhd (ldropn n xs) = lnth xs n", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow> lhd (ldropn 0 xs) = lnth xs 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow> lhd (ldropn 0 xs) = lnth xs 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. lhd (ldropn 0 xs) = lnth xs 0", "by(cases xs) auto"], ["proof (state)\nthis:\n  lhd (ldropn 0 xs) = lnth xs 0\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength ?xs \\<Longrightarrow> lhd (ldropn n ?xs) = lnth ?xs n\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "obtain x xs'\n    where [simp]: \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs) auto"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "have \"enat n < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. enat n < llength xs'", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "hence \"lhd (ldropn n xs') = lnth xs' n\""], ["proof (prove)\nusing this:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. lhd (ldropn n xs') = lnth xs' n", "by(rule Suc)"], ["proof (state)\nthis:\n  lhd (ldropn n xs') = lnth xs' n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lhd (ldropn n xs) = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  lhd (ldropn n xs') = lnth xs' n\n\ngoal (1 subgoal):\n 1. lhd (ldropn (Suc n) xs) = lnth xs (Suc n)", "by simp"], ["proof (state)\nthis:\n  lhd (ldropn (Suc n) xs) = lnth xs (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lhd_ldrop:\n  assumes \"n < llength xs\"\n  shows \"lhd (ldrop n xs) = lnth xs (the_enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (ldrop n xs) = lnth xs (the_enat n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lhd (ldrop n xs) = lnth xs (the_enat n)", "from assms"], ["proof (chain)\npicking this:\n  n < llength xs", "obtain n' where n: \"n = enat n'\""], ["proof (prove)\nusing this:\n  n < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = enat n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = enat n'\n\ngoal (1 subgoal):\n 1. lhd (ldrop n xs) = lnth xs (the_enat n)", "from assms"], ["proof (chain)\npicking this:\n  n < llength xs", "show ?thesis"], ["proof (prove)\nusing this:\n  n < llength xs\n\ngoal (1 subgoal):\n 1. lhd (ldrop n xs) = lnth xs (the_enat n)", "unfolding n"], ["proof (prove)\nusing this:\n  enat n' < llength xs\n\ngoal (1 subgoal):\n 1. lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'))", "proof(induction n' arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lhd (ldrop (enat 0) xs) = lnth xs (the_enat (enat 0))\n 2. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'));\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldrop (enat (Suc n')) xs) =\n                         lnth xs (the_enat (enat (Suc n')))", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lhd (ldrop (enat 0) xs) = lnth xs (the_enat (enat 0))\n 2. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'));\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldrop (enat (Suc n')) xs) =\n                         lnth xs (the_enat (enat (Suc n')))", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. lhd (ldrop (enat 0) xs) = lnth xs (the_enat (enat 0))", "by(simp add: zero_enat_def[symmetric] lhd_conv_lnth)"], ["proof (state)\nthis:\n  lhd (ldrop (enat 0) xs) = lnth xs (the_enat (enat 0))\n\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'));\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldrop (enat (Suc n')) xs) =\n                         lnth xs (the_enat (enat (Suc n')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'));\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldrop (enat (Suc n')) xs) =\n                         lnth xs (the_enat (enat (Suc n')))", "case (Suc n')"], ["proof (state)\nthis:\n  enat n' < llength ?xs \\<Longrightarrow>\n  lhd (ldrop (enat n') ?xs) = lnth ?xs (the_enat (enat n'))\n  enat (Suc n') < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   lhd (ldrop (enat n') xs) = lnth xs (the_enat (enat n'));\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> lhd (ldrop (enat (Suc n')) xs) =\n                         lnth xs (the_enat (enat (Suc n')))", "thus ?case"], ["proof (prove)\nusing this:\n  enat n' < llength ?xs \\<Longrightarrow>\n  lhd (ldrop (enat n') ?xs) = lnth ?xs (the_enat (enat n'))\n  enat (Suc n') < llength xs\n\ngoal (1 subgoal):\n 1. lhd (ldrop (enat (Suc n')) xs) = lnth xs (the_enat (enat (Suc n')))", "by(cases xs)(simp_all add: eSuc_enat[symmetric], simp add: eSuc_enat)"], ["proof (state)\nthis:\n  lhd (ldrop (enat (Suc n')) xs) = lnth xs (the_enat (enat (Suc n')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lhd (ldrop n xs) = lnth xs (the_enat n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_beyond:\n  \"llength xs \\<le> enat n \\<Longrightarrow> lnth xs n = undefined (n - (case llength xs of enat m \\<Rightarrow> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> enat n \\<Longrightarrow>\n    lnth xs n = undefined (n - (case llength xs of enat m \\<Rightarrow> m))", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       llength xs \\<le> enat 0 \\<Longrightarrow>\n       lnth xs 0 =\n       undefined (0 - (case llength xs of enat m \\<Rightarrow> m))\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   llength xs \\<le> enat n \\<Longrightarrow>\n                   lnth xs n =\n                   undefined\n                    (n - (case llength xs of enat m \\<Rightarrow> m));\n        llength xs \\<le> enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lnth xs (Suc n) =\n                         undefined\n                          (Suc n -\n                           (case llength xs of enat m \\<Rightarrow> m))", "case 0"], ["proof (state)\nthis:\n  llength xs \\<le> enat 0\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       llength xs \\<le> enat 0 \\<Longrightarrow>\n       lnth xs 0 =\n       undefined (0 - (case llength xs of enat m \\<Rightarrow> m))\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   llength xs \\<le> enat n \\<Longrightarrow>\n                   lnth xs n =\n                   undefined\n                    (n - (case llength xs of enat m \\<Rightarrow> m));\n        llength xs \\<le> enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lnth xs (Suc n) =\n                         undefined\n                          (Suc n -\n                           (case llength xs of enat m \\<Rightarrow> m))", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs \\<le> enat 0\n\ngoal (1 subgoal):\n 1. lnth xs 0 = undefined (0 - (case llength xs of enat m \\<Rightarrow> m))", "by(simp add: zero_enat_def[symmetric] lnth_def lnull_def)"], ["proof (state)\nthis:\n  lnth xs 0 = undefined (0 - (case llength xs of enat m \\<Rightarrow> m))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   llength xs \\<le> enat n \\<Longrightarrow>\n                   lnth xs n =\n                   undefined\n                    (n - (case llength xs of enat m \\<Rightarrow> m));\n        llength xs \\<le> enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lnth xs (Suc n) =\n                         undefined\n                          (Suc n -\n                           (case llength xs of enat m \\<Rightarrow> m))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   llength xs \\<le> enat n \\<Longrightarrow>\n                   lnth xs n =\n                   undefined\n                    (n - (case llength xs of enat m \\<Rightarrow> m));\n        llength xs \\<le> enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lnth xs (Suc n) =\n                         undefined\n                          (Suc n -\n                           (case llength xs of enat m \\<Rightarrow> m))", "case Suc"], ["proof (state)\nthis:\n  llength ?xs \\<le> enat n_ \\<Longrightarrow>\n  lnth ?xs n_ =\n  undefined (n_ - (case llength ?xs of enat m \\<Rightarrow> m))\n  llength xs \\<le> enat (Suc n_)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   llength xs \\<le> enat n \\<Longrightarrow>\n                   lnth xs n =\n                   undefined\n                    (n - (case llength xs of enat m \\<Rightarrow> m));\n        llength xs \\<le> enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> lnth xs (Suc n) =\n                         undefined\n                          (Suc n -\n                           (case llength xs of enat m \\<Rightarrow> m))", "thus ?case"], ["proof (prove)\nusing this:\n  llength ?xs \\<le> enat n_ \\<Longrightarrow>\n  lnth ?xs n_ =\n  undefined (n_ - (case llength ?xs of enat m \\<Rightarrow> m))\n  llength xs \\<le> enat (Suc n_)\n\ngoal (1 subgoal):\n 1. lnth xs (Suc n_) =\n    undefined (Suc n_ - (case llength xs of enat m \\<Rightarrow> m))", "by(cases xs)(simp_all add: zero_enat_def lnth_def eSuc_enat[symmetric] split: enat.split, auto simp add: eSuc_enat)"], ["proof (state)\nthis:\n  lnth xs (Suc n_) =\n  undefined (Suc n_ - (case llength xs of enat m \\<Rightarrow> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_lmap [simp]:\n  \"enat n < llength xs \\<Longrightarrow> lnth (lmap f xs) n = f (lnth xs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength xs \\<Longrightarrow> lnth (lmap f xs) n = f (lnth xs n)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lnth (lmap f xs) 0 = f (lnth xs 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lnth (lmap f xs) 0 = f (lnth xs 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. lnth (lmap f xs) 0 = f (lnth xs 0)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  lnth (lmap f xs) 0 = f (lnth xs 0)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength ?xs \\<Longrightarrow>\n  lnth (lmap f ?xs) n = f (lnth ?xs n)\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "obtain x xs'\n    where xs: \"xs = LCons x xs'\" and len: \"enat n < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        \\<lbrakk>xs = LCons x xs'; enat n < llength xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs)(auto simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  xs = LCons x xs'\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "from len"], ["proof (chain)\npicking this:\n  enat n < llength xs'", "have \"lnth (lmap f xs') n = f (lnth xs' n)\""], ["proof (prove)\nusing this:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. lnth (lmap f xs') n = f (lnth xs' n)", "by(rule Suc)"], ["proof (state)\nthis:\n  lnth (lmap f xs') n = f (lnth xs' n)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lmap f xs) n = f (lnth xs n);\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "with xs"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  lnth (lmap f xs') n = f (lnth xs' n)", "show ?case"], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  lnth (lmap f xs') n = f (lnth xs' n)\n\ngoal (1 subgoal):\n 1. lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))", "by simp"], ["proof (state)\nthis:\n  lnth (lmap f xs) (Suc n) = f (lnth xs (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_ldropn [simp]:\n  \"enat (n + m) < llength xs \\<Longrightarrow> lnth (ldropn n xs) m = lnth xs (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (n + m) < llength xs \\<Longrightarrow>\n    lnth (ldropn n xs) m = lnth xs (m + n)", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  enat (n + m) < llength ?xs \\<Longrightarrow>\n  lnth (ldropn n ?xs) m = lnth ?xs (m + n)\n  enat (Suc n + m) < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "from \\<open>enat (Suc n + m) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n + m) < llength xs", "obtain x xs' where \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n + m) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs) auto"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "moreover"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "with \\<open>enat (Suc n + m) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n + m) < llength xs\n  xs = LCons x xs'", "have \"enat (n + m) < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n + m) < llength xs\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. enat (n + m) < llength xs'", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat (n + m) < llength xs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "hence \"lnth (ldropn n xs') m = lnth xs' (m + n)\""], ["proof (prove)\nusing this:\n  enat (n + m) < llength xs'\n\ngoal (1 subgoal):\n 1. lnth (ldropn n xs') m = lnth xs' (m + n)", "by(rule Suc)"], ["proof (state)\nthis:\n  lnth (ldropn n xs') m = lnth xs' (m + n)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat (n + m) < llength xs \\<Longrightarrow>\n                   lnth (ldropn n xs) m = lnth xs (m + n);\n        enat (Suc n + m) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "ultimately"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  lnth (ldropn n xs') m = lnth xs' (m + n)", "show ?case"], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  lnth (ldropn n xs') m = lnth xs' (m + n)\n\ngoal (1 subgoal):\n 1. lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)", "by simp"], ["proof (state)\nthis:\n  lnth (ldropn (Suc n) xs) m = lnth xs (m + Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       enat (0 + m) < llength xs \\<Longrightarrow>\n       lnth (ldropn 0 xs) m = lnth xs (m + 0)", "qed simp"], ["", "lemma lnth_ldrop [simp]:\n  \"n + enat m < llength xs \\<Longrightarrow> lnth (ldrop n xs) m = lnth xs (m + the_enat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + enat m < llength xs \\<Longrightarrow>\n    lnth (ldrop n xs) m = lnth xs (m + the_enat n)", "by(cases n)(simp_all add: ldrop_enat)"], ["", "lemma in_lset_conv_lnth:\n  \"x \\<in> lset xs \\<longleftrightarrow> (\\<exists>n. enat n < llength xs \\<and> lnth xs n = x)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> lset xs) =\n    (\\<exists>n. enat n < llength xs \\<and> lnth xs n = x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n 2. \\<exists>n. enat n < llength xs \\<and> lnth xs n = x \\<Longrightarrow>\n    x \\<in> lset xs", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n\ngoal (2 subgoals):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n 2. \\<exists>n. enat n < llength xs \\<and> lnth xs n = x \\<Longrightarrow>\n    x \\<in> lset xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x", "obtain n where \"enat n < llength xs\" \"lnth xs n = x\""], ["proof (prove)\nusing this:\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enat n < llength xs\n  lnth xs n = x\n\ngoal (2 subgoals):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n 2. \\<exists>n. enat n < llength xs \\<and> lnth xs n = x \\<Longrightarrow>\n    x \\<in> lset xs", "thus ?lhs"], ["proof (prove)\nusing this:\n  enat n < llength xs\n  lnth xs n = x\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>enat 0 < llength xs; lnth xs 0 = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> lset xs;\n        enat (Suc n) < llength xs; lnth xs (Suc n) = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n  lnth xs 0 = x\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>enat 0 < llength xs; lnth xs 0 = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> lset xs;\n        enat (Suc n) < llength xs; lnth xs (Suc n) = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n  lnth xs 0 = x\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by(auto simp add: zero_enat_def[symmetric] not_lnull_conv)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> lset xs;\n        enat (Suc n) < llength xs; lnth xs (Suc n) = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> lset xs;\n        enat (Suc n) < llength xs; lnth xs (Suc n) = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>enat n < llength ?xs; lnth ?xs n = x\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset ?xs\n  enat (Suc n) < llength xs\n  lnth xs (Suc n) = x\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>enat n < llength xs; lnth xs n = x\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> lset xs;\n        enat (Suc n) < llength xs; lnth xs (Suc n) = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat n < llength ?xs; lnth ?xs n = x\\<rbrakk>\n  \\<Longrightarrow> x \\<in> lset ?xs\n  enat (Suc n) < llength xs\n  lnth xs (Suc n) = x\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by(cases xs)(auto simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x", "assume ?lhs"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<Longrightarrow>\n    \\<exists>n. enat n < llength xs \\<and> lnth xs n = x", "thus ?rhs"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. enat n < llength xs \\<and> lnth xs n = x", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>n.\n          enat n < llength (LCons x xs) \\<and> lnth (LCons x xs) n = x\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            enat n < llength (LCons x' xs) \\<and>\n                            lnth (LCons x' xs) n = x", "case (find xs)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<exists>n.\n          enat n < llength (LCons x xs) \\<and> lnth (LCons x xs) n = x\n 2. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            enat n < llength (LCons x' xs) \\<and>\n                            lnth (LCons x' xs) n = x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. enat n < llength (LCons x xs) \\<and> lnth (LCons x xs) n = x", "by(auto intro: exI[where x=0] simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  \\<exists>n. enat n < llength (LCons x xs) \\<and> lnth (LCons x xs) n = x\n\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            enat n < llength (LCons x' xs) \\<and>\n                            lnth (LCons x' xs) n = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            enat n < llength (LCons x' xs) \\<and>\n                            lnth (LCons x' xs) n = x", "case (step x' xs)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  x \\<noteq> x'\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n\ngoal (1 subgoal):\n 1. \\<And>x' xs.\n       \\<lbrakk>x \\<in> lset xs; x \\<noteq> x';\n        \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            enat n < llength (LCons x' xs) \\<and>\n                            lnth (LCons x' xs) n = x", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  x \\<noteq> x'\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < llength (LCons x' xs) \\<and> lnth (LCons x' xs) n = x", "by(auto 4 4 intro: exI[where x=\"Suc n\" for n] ileI1 simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  \\<exists>n. enat n < llength (LCons x' xs) \\<and> lnth (LCons x' xs) n = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. enat n < llength xs \\<and> lnth xs n = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_conv_lnth: \"lset xs = {lnth xs n|n. enat n < llength xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs = {lnth xs n |n. enat n < llength xs}", "by(auto simp add: in_lset_conv_lnth)"], ["", "lemma lnth_llist_of [simp]: \"lnth (llist_of xs) = nth xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of xs) = (!) xs", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lnth (llist_of xs) x = xs ! x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lnth (llist_of xs) x = xs ! x", "show \"lnth (llist_of xs) n = xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of xs) n = xs ! n", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. lnth (llist_of []) n = [] ! n\n 2. \\<And>a xs n.\n       (\\<And>n. lnth (llist_of xs) n = xs ! n) \\<Longrightarrow>\n       lnth (llist_of (a # xs)) n = (a # xs) ! n", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. lnth (llist_of []) n = [] ! n\n 2. \\<And>a xs n.\n       (\\<And>n. lnth (llist_of xs) n = xs ! n) \\<Longrightarrow>\n       lnth (llist_of (a # xs)) n = (a # xs) ! n", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (llist_of []) n = [] ! n", "by(cases n)(simp_all add: nth_def lnth_def)"], ["proof (state)\nthis:\n  lnth (llist_of []) n = [] ! n\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. lnth (llist_of xs) n = xs ! n) \\<Longrightarrow>\n       lnth (llist_of (a # xs)) n = (a # xs) ! n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. lnth (llist_of xs) n = xs ! n) \\<Longrightarrow>\n       lnth (llist_of (a # xs)) n = (a # xs) ! n", "case Cons"], ["proof (state)\nthis:\n  lnth (llist_of xs_) ?n = xs_ ! ?n\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. lnth (llist_of xs) n = xs ! n) \\<Longrightarrow>\n       lnth (llist_of (a # xs)) n = (a # xs) ! n", "thus ?case"], ["proof (prove)\nusing this:\n  lnth (llist_of xs_) ?n = xs_ ! ?n\n\ngoal (1 subgoal):\n 1. lnth (llist_of (a_ # xs_)) n = (a_ # xs_) ! n", "by(simp add: lnth_LCons split: nat.split)"], ["proof (state)\nthis:\n  lnth (llist_of (a_ # xs_)) n = (a_ # xs_) ! n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth (llist_of xs) n = xs ! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_list_of [simp]:\n  assumes \"lfinite xs\"\n  shows \"nth (list_of xs) = lnth xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (list_of xs) = lnth xs", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. (!) (list_of xs) = lnth xs", "by induct(auto intro: simp add: nth_def lnth_LNil nth_Cons split: nat.split)"], ["", "lemma lnth_lappend1:\n  \"enat n < llength xs \\<Longrightarrow> lnth (lappend xs ys) n = lnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength xs \\<Longrightarrow> lnth (lappend xs ys) n = lnth xs n", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lnth (lappend xs ys) 0 = lnth xs 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       lnth (lappend xs ys) 0 = lnth xs 0\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. lnth (lappend xs ys) 0 = lnth xs 0", "by(auto simp add: zero_enat_def[symmetric] not_lnull_conv)"], ["proof (state)\nthis:\n  lnth (lappend xs ys) 0 = lnth xs 0\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength ?xs \\<Longrightarrow>\n  lnth (lappend ?xs ys) n = lnth ?xs n\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "obtain x xs'\n    where [simp]: \"xs = LCons x xs'\" and len: \"enat n < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        \\<lbrakk>xs = LCons x xs'; enat n < llength xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs)(auto simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  xs = LCons x xs'\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "from len"], ["proof (chain)\npicking this:\n  enat n < llength xs'", "have \"lnth (lappend xs' ys) n = lnth xs' n\""], ["proof (prove)\nusing this:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. lnth (lappend xs' ys) n = lnth xs' n", "by(rule Suc)"], ["proof (state)\nthis:\n  lnth (lappend xs' ys) n = lnth xs' n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   lnth (lappend xs ys) n = lnth xs n;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  lnth (lappend xs' ys) n = lnth xs' n\n\ngoal (1 subgoal):\n 1. lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)", "by simp"], ["proof (state)\nthis:\n  lnth (lappend xs ys) (Suc n) = lnth xs (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_lappend_llist_of:\n  \"lnth (lappend (llist_of xs) ys) n =\n  (if n < length xs then xs ! n else lnth ys (n - length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lappend (llist_of xs) ys) n =\n    (if n < length xs then xs ! n else lnth ys (n - length xs))", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       lnth (lappend (llist_of []) ys) n =\n       (if n < length [] then [] ! n else lnth ys (n - length []))\n 2. \\<And>a xs n.\n       (\\<And>n.\n           lnth (lappend (llist_of xs) ys) n =\n           (if n < length xs then xs ! n\n            else lnth ys (n - length xs))) \\<Longrightarrow>\n       lnth (lappend (llist_of (a # xs)) ys) n =\n       (if n < length (a # xs) then (a # xs) ! n\n        else lnth ys (n - length (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  lnth (lappend (llist_of xs) ys) ?n =\n  (if ?n < length xs then xs ! ?n else lnth ys (?n - length xs))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       lnth (lappend (llist_of []) ys) n =\n       (if n < length [] then [] ! n else lnth ys (n - length []))\n 2. \\<And>a xs n.\n       (\\<And>n.\n           lnth (lappend (llist_of xs) ys) n =\n           (if n < length xs then xs ! n\n            else lnth ys (n - length xs))) \\<Longrightarrow>\n       lnth (lappend (llist_of (a # xs)) ys) n =\n       (if n < length (a # xs) then (a # xs) ! n\n        else lnth ys (n - length (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  lnth (lappend (llist_of xs) ys) ?n =\n  (if ?n < length xs then xs ! ?n else lnth ys (?n - length xs))\n\ngoal (1 subgoal):\n 1. lnth (lappend (llist_of (x # xs)) ys) n =\n    (if n < length (x # xs) then (x # xs) ! n\n     else lnth ys (n - length (x # xs)))", "by(cases n) auto"], ["proof (state)\nthis:\n  lnth (lappend (llist_of (x # xs)) ys) n =\n  (if n < length (x # xs) then (x # xs) ! n\n   else lnth ys (n - length (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       lnth (lappend (llist_of []) ys) n =\n       (if n < length [] then [] ! n else lnth ys (n - length []))", "qed simp"], ["", "lemma lnth_lappend2:\n  \"\\<lbrakk> llength xs = enat k; k \\<le> n \\<rbrakk> \\<Longrightarrow> lnth (lappend xs ys) n = lnth ys (n - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n    \\<Longrightarrow> lnth (lappend xs ys) n = lnth ys (n - k)", "proof(induct n arbitrary: xs k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs k.\n       \\<lbrakk>llength xs = enat k; k \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) 0 = lnth ys (0 - k)\n 2. \\<And>n xs k.\n       \\<lbrakk>\\<And>xs k.\n                   \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> lnth (lappend xs ys) n =\n                                     lnth ys (n - k);\n        llength xs = enat k; k \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "case 0"], ["proof (state)\nthis:\n  llength xs = enat k\n  k \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>xs k.\n       \\<lbrakk>llength xs = enat k; k \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) 0 = lnth ys (0 - k)\n 2. \\<And>n xs k.\n       \\<lbrakk>\\<And>xs k.\n                   \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> lnth (lappend xs ys) n =\n                                     lnth ys (n - k);\n        llength xs = enat k; k \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs = enat k\n  k \\<le> 0\n\ngoal (1 subgoal):\n 1. lnth (lappend xs ys) 0 = lnth ys (0 - k)", "by(simp add: zero_enat_def[symmetric] lappend_lnull1)"], ["proof (state)\nthis:\n  lnth (lappend xs ys) 0 = lnth ys (0 - k)\n\ngoal (1 subgoal):\n 1. \\<And>n xs k.\n       \\<lbrakk>\\<And>xs k.\n                   \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> lnth (lappend xs ys) n =\n                                     lnth ys (n - k);\n        llength xs = enat k; k \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs k.\n       \\<lbrakk>\\<And>xs k.\n                   \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> lnth (lappend xs ys) n =\n                                     lnth ys (n - k);\n        llength xs = enat k; k \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>llength ?xs = enat ?k; ?k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> lnth (lappend ?xs ys) n = lnth ys (n - ?k)\n  llength xs = enat k\n  k \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n xs k.\n       \\<lbrakk>\\<And>xs k.\n                   \\<lbrakk>llength xs = enat k; k \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> lnth (lappend xs ys) n =\n                                     lnth ys (n - k);\n        llength xs = enat k; k \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>llength ?xs = enat ?k; ?k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> lnth (lappend ?xs ys) n = lnth ys (n - ?k)\n  llength xs = enat k\n  k \\<le> Suc n\n\ngoal (1 subgoal):\n 1. lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)", "by(cases xs)(auto simp add: eSuc_def zero_enat_def split: enat.split_asm)"], ["proof (state)\nthis:\n  lnth (lappend xs ys) (Suc n) = lnth ys (Suc n - k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_lappend:\n  \"lnth (lappend xs ys) n = (if enat n < llength xs then lnth xs n else lnth ys (n - the_enat (llength xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lappend xs ys) n =\n    (if enat n < llength xs then lnth xs n\n     else lnth ys (n - the_enat (llength xs)))", "by(cases \"llength xs\")(auto simp add: lnth_lappend1 lnth_lappend2)"], ["", "lemma lnth_ltake:\n  \"enat m < n \\<Longrightarrow> lnth (ltake n xs) m = lnth xs m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m < n \\<Longrightarrow> lnth (ltake n xs) m = lnth xs m", "proof(induct m arbitrary: xs n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs n. enat 0 < n \\<Longrightarrow> lnth (ltake n xs) 0 = lnth xs 0\n 2. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "case 0"], ["proof (state)\nthis:\n  enat 0 < n\n\ngoal (2 subgoals):\n 1. \\<And>xs n. enat 0 < n \\<Longrightarrow> lnth (ltake n xs) 0 = lnth xs 0\n 2. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < n\n\ngoal (1 subgoal):\n 1. lnth (ltake n xs) 0 = lnth xs 0", "by(cases n rule: enat_coexhaust)(auto, cases xs, auto)"], ["proof (state)\nthis:\n  lnth (ltake n xs) 0 = lnth xs 0\n\ngoal (1 subgoal):\n 1. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  enat m < ?n \\<Longrightarrow> lnth (ltake ?n ?xs) m = lnth ?xs m\n  enat (Suc m) < n\n\ngoal (1 subgoal):\n 1. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "from \\<open>enat (Suc m) < n\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc m) < n", "obtain n' where \"n = eSuc n'\""], ["proof (prove)\nusing this:\n  enat (Suc m) < n\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = eSuc n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n rule: enat_coexhaust) auto"], ["proof (state)\nthis:\n  n = eSuc n'\n\ngoal (1 subgoal):\n 1. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "with \\<open>enat (Suc m) < n\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc m) < n\n  n = eSuc n'", "have \"enat m < n'\""], ["proof (prove)\nusing this:\n  enat (Suc m) < n\n  n = eSuc n'\n\ngoal (1 subgoal):\n 1. enat m < n'", "by(simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  enat m < n'\n\ngoal (1 subgoal):\n 1. \\<And>m xs n.\n       \\<lbrakk>\\<And>xs n.\n                   enat m < n \\<Longrightarrow>\n                   lnth (ltake n xs) m = lnth xs m;\n        enat (Suc m) < n\\<rbrakk>\n       \\<Longrightarrow> lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "with Suc \\<open>n = eSuc n'\\<close>"], ["proof (chain)\npicking this:\n  enat m < ?n \\<Longrightarrow> lnth (ltake ?n ?xs) m = lnth ?xs m\n  enat (Suc m) < n\n  n = eSuc n'\n  enat m < n'", "show ?case"], ["proof (prove)\nusing this:\n  enat m < ?n \\<Longrightarrow> lnth (ltake ?n ?xs) m = lnth ?xs m\n  enat (Suc m) < n\n  n = eSuc n'\n  enat m < n'\n\ngoal (1 subgoal):\n 1. lnth (ltake n xs) (Suc m) = lnth xs (Suc m)", "by(cases xs) auto"], ["proof (state)\nthis:\n  lnth (ltake n xs) (Suc m) = lnth xs (Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropn_Suc_conv_ldropn:\n  \"enat n < llength xs \\<Longrightarrow> LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength xs \\<Longrightarrow>\n    LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       LCons (lnth xs 0) (ldropn (Suc 0) xs) = ldropn 0 xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       LCons (lnth xs 0) (ldropn (Suc 0) xs) = ldropn 0 xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. LCons (lnth xs 0) (ldropn (Suc 0) xs) = ldropn 0 xs", "by(cases xs) auto"], ["proof (state)\nthis:\n  LCons (lnth xs 0) (ldropn (Suc 0) xs) = ldropn 0 xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength ?xs \\<Longrightarrow>\n  LCons (lnth ?xs n) (ldropn (Suc n) ?xs) = ldropn n ?xs\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "obtain x xs'\n    where [simp]: \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs) auto"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "have \"enat n < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. enat n < llength xs'", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "hence \"LCons (lnth xs' n) (ldropn (Suc n) xs') = ldropn n xs'\""], ["proof (prove)\nusing this:\n  enat n < llength xs'\n\ngoal (1 subgoal):\n 1. LCons (lnth xs' n) (ldropn (Suc n) xs') = ldropn n xs'", "by(rule Suc)"], ["proof (state)\nthis:\n  LCons (lnth xs' n) (ldropn (Suc n) xs') = ldropn n xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   LCons (lnth xs n) (ldropn (Suc n) xs) = ldropn n xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) =\n                         ldropn (Suc n) xs", "thus ?case"], ["proof (prove)\nusing this:\n  LCons (lnth xs' n) (ldropn (Suc n) xs') = ldropn n xs'\n\ngoal (1 subgoal):\n 1. LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) = ldropn (Suc n) xs", "by simp"], ["proof (state)\nthis:\n  LCons (lnth xs (Suc n)) (ldropn (Suc (Suc n)) xs) = ldropn (Suc n) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_Suc_conv_snoc_lnth:\n  \"enat m < llength xs \\<Longrightarrow> ltake (enat (Suc m)) xs = lappend (ltake (enat m) xs) (LCons (lnth xs m) LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m < llength xs \\<Longrightarrow>\n    ltake (enat (Suc m)) xs =\n    lappend (ltake (enat m) xs) (LCons (lnth xs m) LNil)", "by(metis eSuc_enat eSuc_plus_1 ltake_plus_conv_lappend ldrop_enat ldropn_Suc_conv_ldropn ltake_0 ltake_eSuc_LCons one_eSuc)"], ["", "lemma lappend_eq_lappend_conv:\n  assumes len: \"llength xs = llength us\"\n  shows \"lappend xs ys = lappend us vs \\<longleftrightarrow>\n         xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lappend xs ys = lappend us vs) =\n    (xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lappend xs ys = lappend us vs \\<Longrightarrow>\n    xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\n 2. xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs) \\<Longrightarrow>\n    lappend xs ys = lappend us vs", "assume ?rhs"], ["proof (state)\nthis:\n  xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\n\ngoal (2 subgoals):\n 1. lappend xs ys = lappend us vs \\<Longrightarrow>\n    xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\n 2. xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs) \\<Longrightarrow>\n    lappend xs ys = lappend us vs", "thus ?lhs"], ["proof (prove)\nusing this:\n  xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\n\ngoal (1 subgoal):\n 1. lappend xs ys = lappend us vs", "by(auto simp add: lappend_inf)"], ["proof (state)\nthis:\n  lappend xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. lappend xs ys = lappend us vs \\<Longrightarrow>\n    xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lappend xs ys = lappend us vs \\<Longrightarrow>\n    xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)", "assume eq: ?lhs"], ["proof (state)\nthis:\n  lappend xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. lappend xs ys = lappend us vs \\<Longrightarrow>\n    xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)", "proof(intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = us\n 2. lfinite xs \\<Longrightarrow> ys = vs", "show \"xs = us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = us", "using len eq"], ["proof (prove)\nusing this:\n  llength xs = llength us\n  lappend xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. xs = us", "proof(coinduction arbitrary: xs us)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs us.\n       \\<lbrakk>llength xs = llength us;\n        lappend xs ys = lappend us vs\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull us \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull us \\<longrightarrow>\n                          lhd xs = lhd us \\<and>\n                          (\\<exists>xsa usa.\n                              ltl xs = xsa \\<and>\n                              ltl us = usa \\<and>\n                              llength xsa = llength usa \\<and>\n                              lappend xsa ys = lappend usa vs))", "case (Eq_llist xs us)"], ["proof (state)\nthis:\n  llength xs = llength us\n  lappend xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. \\<And>xs us.\n       \\<lbrakk>llength xs = llength us;\n        lappend xs ys = lappend us vs\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull us \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull us \\<longrightarrow>\n                          lhd xs = lhd us \\<and>\n                          (\\<exists>xsa usa.\n                              ltl xs = xsa \\<and>\n                              ltl us = usa \\<and>\n                              llength xsa = llength usa \\<and>\n                              lappend xsa ys = lappend usa vs))", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs = llength us\n  lappend xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. lnull xs = lnull us \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull us \\<longrightarrow>\n     lhd xs = lhd us \\<and>\n     (\\<exists>xs us.\n         ltl xs = xs \\<and>\n         ltl us = us \\<and>\n         llength xs = llength us \\<and> lappend xs ys = lappend us vs))", "by(cases xs us rule: llist.exhaust[case_product llist.exhaust]) auto"], ["proof (state)\nthis:\n  lnull xs = lnull us \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull us \\<longrightarrow>\n   lhd xs = lhd us \\<and>\n   (\\<exists>xs us.\n       ltl xs = xs \\<and>\n       ltl us = us \\<and>\n       llength xs = llength us \\<and> lappend xs ys = lappend us vs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = us\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys = vs", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys = vs", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "obtain xs' where \"xs = llist_of xs'\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        xs = llist_of xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  xs = llist_of xs'\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys = vs", "hence \"lappend (llist_of xs') ys = lappend (llist_of xs') vs\""], ["proof (prove)\nusing this:\n  xs = llist_of xs'\n\ngoal (1 subgoal):\n 1. lappend (llist_of xs') ys = lappend (llist_of xs') vs", "using eq \\<open>xs = us\\<close>"], ["proof (prove)\nusing this:\n  xs = llist_of xs'\n  lappend xs ys = lappend us vs\n  xs = us\n\ngoal (1 subgoal):\n 1. lappend (llist_of xs') ys = lappend (llist_of xs') vs", "by blast"], ["proof (state)\nthis:\n  lappend (llist_of xs') ys = lappend (llist_of xs') vs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> ys = vs", "thus \"ys = vs\""], ["proof (prove)\nusing this:\n  lappend (llist_of xs') ys = lappend (llist_of xs') vs\n\ngoal (1 subgoal):\n 1. ys = vs", "by (induct xs') simp_all"], ["proof (state)\nthis:\n  ys = vs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = us \\<and> (lfinite xs \\<longrightarrow> ys = vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>iterates\\<close>"], ["", "lemmas iterates [code, nitpick_simp] = iterates.ctr\n  and lnull_iterates = iterates.simps(1)\n  and lhd_iterates = iterates.simps(2)\n  and ltl_iterates = iterates.simps(3)"], ["", "lemma lfinite_iterates [iff]: \"\\<not> lfinite (iterates f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (iterates f x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite (iterates f x) \\<Longrightarrow> False", "assume \"lfinite (iterates f x)\""], ["proof (state)\nthis:\n  lfinite (iterates f x)\n\ngoal (1 subgoal):\n 1. lfinite (iterates f x) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lfinite (iterates f x)\n\ngoal (1 subgoal):\n 1. False", "by(induct zs\\<equiv>\"iterates f x\" arbitrary: x rule: lfinite_induct) auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmap_iterates: \"lmap f (iterates f x) = iterates f (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (iterates f x) = iterates f (f x)", "by(coinduction arbitrary: x) auto"], ["", "lemma iterates_lmap: \"iterates f x = LCons x (lmap f (iterates f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterates f x = LCons x (lmap f (iterates f x))", "by(simp add: lmap_iterates)(rule iterates)"], ["", "lemma lappend_iterates: \"lappend (iterates f x) xs = iterates f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (iterates f x) xs = iterates f x", "by(coinduction arbitrary: x) auto"], ["", "lemma [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  shows lnull_funpow_lmap: \"lnull ((lmap f ^^ n) xs) \\<longleftrightarrow> lnull xs\"\n  and lhd_funpow_lmap: \"\\<not> lnull xs \\<Longrightarrow> lhd ((lmap f ^^ n) xs) = (f ^^ n) (lhd xs)\"\n  and ltl_funpow_lmap: \"\\<not> lnull xs \\<Longrightarrow> ltl ((lmap f ^^ n) xs) = (lmap f ^^ n) (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull ((lmap f ^^ n) xs) = lnull xs &&&\n    (\\<not> lnull xs \\<Longrightarrow>\n     lhd ((lmap f ^^ n) xs) = (f ^^ n) (lhd xs)) &&&\n    (\\<not> lnull xs \\<Longrightarrow>\n     ltl ((lmap f ^^ n) xs) = (lmap f ^^ n) (ltl xs))", "by(induct n) simp_all"], ["", "lemma iterates_equality:\n  assumes h: \"\\<And>x. h x = LCons x (lmap f (h x))\"\n  shows \"h = iterates f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = iterates f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h = iterates f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. h = iterates f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. h = iterates f", "have \"\\<not> lnull (h x)\" \"lhd (h x) = x\" \"ltl (h x) = lmap f (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (h x) &&& lhd (h x) = x &&& ltl (h x) = lmap f (h x)", "by(subst h, simp)+"], ["proof (state)\nthis:\n  \\<not> lnull (h x)\n  lhd (h x) = x\n  ltl (h x) = lmap f (h x)\n\ngoal (1 subgoal):\n 1. h = iterates f", "}"], ["proof (state)\nthis:\n  \\<not> lnull (h ?x2)\n  lhd (h ?x2) = ?x2\n  ltl (h ?x2) = lmap f (h ?x2)\n\ngoal (1 subgoal):\n 1. h = iterates f", "note [simp] = this"], ["proof (state)\nthis:\n  \\<not> lnull (h ?x2)\n  lhd (h ?x2) = ?x2\n  ltl (h ?x2) = lmap f (h ?x2)\n\ngoal (1 subgoal):\n 1. h = iterates f", "{"], ["proof (state)\nthis:\n  \\<not> lnull (h ?x2)\n  lhd (h ?x2) = ?x2\n  ltl (h ?x2) = lmap f (h ?x2)\n\ngoal (1 subgoal):\n 1. h = iterates f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. h = iterates f", "define n :: nat where \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (1 subgoal):\n 1. h = iterates f", "have \"(lmap f ^^ n) (h x) = (lmap f ^^ n) (iterates f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmap f ^^ n) (h x) = (lmap f ^^ n) (iterates f x)", "by(coinduction arbitrary: n)(auto simp add: funpow_swap1 lmap_iterates intro: exI[where x=\"Suc n\" for n])"], ["proof (state)\nthis:\n  (lmap f ^^ n) (h x) = (lmap f ^^ n) (iterates f x)\n\ngoal (1 subgoal):\n 1. h = iterates f", "}"], ["proof (state)\nthis:\n  (lmap f ^^ 0) (h ?x2) = (lmap f ^^ 0) (iterates f ?x2)\n\ngoal (1 subgoal):\n 1. h = iterates f", "thus ?thesis"], ["proof (prove)\nusing this:\n  (lmap f ^^ 0) (h ?x2) = (lmap f ^^ 0) (iterates f ?x2)\n\ngoal (1 subgoal):\n 1. h = iterates f", "by auto"], ["proof (state)\nthis:\n  h = iterates f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_iterates [simp]: \"llength (iterates f x) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (iterates f x) = \\<infinity>", "by(coinduction arbitrary: x rule: enat_coinduct)(auto simp add: epred_llength)"], ["", "lemma ldropn_iterates: \"ldropn n (iterates f x) = iterates f ((f ^^ n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (iterates f x) = iterates f ((f ^^ n) x)", "proof(induct n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. ldropn 0 (iterates f x) = iterates f ((f ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. ldropn 0 (iterates f x) = iterates f ((f ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn 0 (iterates f x) = iterates f ((f ^^ 0) x)", "by simp"], ["proof (state)\nthis:\n  ldropn 0 (iterates f x) = iterates f ((f ^^ 0) x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "case (Suc n)"], ["proof (state)\nthis:\n  ldropn n (iterates f ?x) = iterates f ((f ^^ n) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "have \"ldropn (Suc n) (iterates f x) = ldropn n (iterates f (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn (Suc n) (iterates f x) = ldropn n (iterates f (f x))", "by(subst iterates)simp"], ["proof (state)\nthis:\n  ldropn (Suc n) (iterates f x) = ldropn n (iterates f (f x))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "also"], ["proof (state)\nthis:\n  ldropn (Suc n) (iterates f x) = ldropn n (iterates f (f x))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "have \"\\<dots> = iterates f ((f ^^ n) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (iterates f (f x)) = iterates f ((f ^^ n) (f x))", "by(rule Suc)"], ["proof (state)\nthis:\n  ldropn n (iterates f (f x)) = iterates f ((f ^^ n) (f x))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ldropn n (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "finally"], ["proof (chain)\npicking this:\n  ldropn (Suc n) (iterates f x) = iterates f ((f ^^ n) (f x))", "show ?case"], ["proof (prove)\nusing this:\n  ldropn (Suc n) (iterates f x) = iterates f ((f ^^ n) (f x))\n\ngoal (1 subgoal):\n 1. ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)", "by(simp add: funpow_swap1)"], ["proof (state)\nthis:\n  ldropn (Suc n) (iterates f x) = iterates f ((f ^^ Suc n) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldrop_iterates: \"ldrop (enat n) (iterates f x) = iterates f ((f ^^ n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat n) (iterates f x) = iterates f ((f ^^ n) x)", "proof(induct n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. ldrop (enat 0) (iterates f x) = iterates f ((f ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           ldrop (enat n) (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldrop (enat (Suc n)) (iterates f x) = iterates f ((f ^^ Suc n) x)", "case Suc"], ["proof (state)\nthis:\n  ldrop (enat n_) (iterates f ?x) = iterates f ((f ^^ n_) ?x)\n\ngoal (2 subgoals):\n 1. \\<And>x. ldrop (enat 0) (iterates f x) = iterates f ((f ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           ldrop (enat n) (iterates f x) =\n           iterates f ((f ^^ n) x)) \\<Longrightarrow>\n       ldrop (enat (Suc n)) (iterates f x) = iterates f ((f ^^ Suc n) x)", "thus ?case"], ["proof (prove)\nusing this:\n  ldrop (enat n_) (iterates f ?x) = iterates f ((f ^^ n_) ?x)\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc n_)) (iterates f x) = iterates f ((f ^^ Suc n_) x)", "by(subst iterates)(simp add: eSuc_enat[symmetric] funpow_swap1)"], ["proof (state)\nthis:\n  ldrop (enat (Suc n_)) (iterates f x) = iterates f ((f ^^ Suc n_) x)\n\ngoal (1 subgoal):\n 1. \\<And>x. ldrop (enat 0) (iterates f x) = iterates f ((f ^^ 0) x)", "qed(simp add: zero_enat_def[symmetric])"], ["", "lemma lnth_iterates [simp]: \"lnth (iterates f x) n = (f ^^ n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (iterates f x) n = (f ^^ n) x", "proof(induct n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. lnth (iterates f x) 0 = (f ^^ 0) x\n 2. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. lnth (iterates f x) 0 = (f ^^ 0) x\n 2. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (iterates f x) 0 = (f ^^ 0) x", "by(subst iterates) simp"], ["proof (state)\nthis:\n  lnth (iterates f x) 0 = (f ^^ 0) x\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "case (Suc n)"], ["proof (state)\nthis:\n  lnth (iterates f ?x) n = (f ^^ n) ?x\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "hence \"lnth (iterates f (f x)) n = (f ^^ n) (f x)\""], ["proof (prove)\nusing this:\n  lnth (iterates f ?x) n = (f ^^ n) ?x\n\ngoal (1 subgoal):\n 1. lnth (iterates f (f x)) n = (f ^^ n) (f x)", "."], ["proof (state)\nthis:\n  lnth (iterates f (f x)) n = (f ^^ n) (f x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x. lnth (iterates f x) n = (f ^^ n) x) \\<Longrightarrow>\n       lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "thus ?case"], ["proof (prove)\nusing this:\n  lnth (iterates f (f x)) n = (f ^^ n) (f x)\n\ngoal (1 subgoal):\n 1. lnth (iterates f x) (Suc n) = (f ^^ Suc n) x", "by(subst iterates)(simp add: funpow_swap1)"], ["proof (state)\nthis:\n  lnth (iterates f x) (Suc n) = (f ^^ Suc n) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_iterates:\n  \"lset (iterates f x) = {(f ^^ n) x|n. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (iterates f x) = {(f ^^ n) x |n. True}", "by(auto simp add: lset_conv_lnth)"], ["", "lemma lset_repeat [simp]: \"lset (repeat x) = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (repeat x) = {x}", "by(simp add: lset_iterates id_def[symmetric])"], ["", "subsection \\<open>\n  More on the prefix ordering on lazy lists: @{term \"lprefix\"} and @{term \"lstrict_prefix\"}\n\\<close>"], ["", "lemma lstrict_prefix_code [code, simp]:\n  \"lstrict_prefix LNil LNil \\<longleftrightarrow> False\"\n  \"lstrict_prefix LNil (LCons y ys) \\<longleftrightarrow> True\"\n  \"lstrict_prefix (LCons x xs) LNil \\<longleftrightarrow> False\"\n  \"lstrict_prefix (LCons x xs) (LCons y ys) \\<longleftrightarrow> x = y \\<and> lstrict_prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lstrict_prefix LNil LNil = False &&&\n     lstrict_prefix LNil (LCons y ys) = True) &&&\n    lstrict_prefix (LCons x xs) LNil = False &&&\n    lstrict_prefix (LCons x xs) (LCons y ys) =\n    (x = y \\<and> lstrict_prefix xs ys)", "by(auto simp add: lstrict_prefix_def)"], ["", "lemma lmap_lprefix: \"xs \\<sqsubseteq> ys \\<Longrightarrow> lmap f xs \\<sqsubseteq> lmap f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> lmap f xs \\<sqsubseteq> lmap f ys", "by(rule monotoneD[OF monotone_lmap])"], ["", "lemma lprefix_llength_eq_imp_eq:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; llength xs = llength ys \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; llength xs = llength ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by(coinduction arbitrary: xs ys)(auto simp add: not_lnull_conv)"], ["", "lemma lprefix_llength_le: \"xs \\<sqsubseteq> ys \\<Longrightarrow> llength xs \\<le> llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> llength xs \\<le> llength ys", "using monotone_llength"], ["proof (prove)\nusing this:\n  monotone (\\<sqsubseteq>) (\\<le>) llength\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> llength xs \\<le> llength ys", "by(rule monotoneD)"], ["", "lemma lstrict_prefix_llength_less:\n  assumes \"lstrict_prefix xs ys\"\n  shows \"llength xs < llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs < llength ys", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "assume \"\\<not> llength xs < llength ys\""], ["proof (state)\nthis:\n  \\<not> llength xs < llength ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> llength xs < llength ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "from \\<open>lstrict_prefix xs ys\\<close>"], ["proof (chain)\npicking this:\n  lstrict_prefix xs ys", "have \"xs \\<sqsubseteq> ys\" \"xs \\<noteq> ys\""], ["proof (prove)\nusing this:\n  lstrict_prefix xs ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys &&& xs \\<noteq> ys", "unfolding lstrict_prefix_def"], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys \\<and> xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys &&& xs \\<noteq> ys", "by simp_all"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "from \\<open>xs \\<sqsubseteq> ys\\<close>"], ["proof (chain)\npicking this:\n  xs \\<sqsubseteq> ys", "have \"llength xs \\<le> llength ys\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys", "by(rule lprefix_llength_le)"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> llength xs < llength ys\n  llength xs \\<le> llength ys", "have \"llength xs = llength ys\""], ["proof (prove)\nusing this:\n  \\<not> llength xs < llength ys\n  llength xs \\<le> llength ys\n\ngoal (1 subgoal):\n 1. llength xs = llength ys", "by auto"], ["proof (state)\nthis:\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "with \\<open>xs \\<sqsubseteq> ys\\<close>"], ["proof (chain)\npicking this:\n  xs \\<sqsubseteq> ys\n  llength xs = llength ys", "have \"xs = ys\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by(rule lprefix_llength_eq_imp_eq)"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. \\<not> llength xs < llength ys \\<Longrightarrow> False", "with \\<open>xs \\<noteq> ys\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> ys\n  xs = ys", "show False"], ["proof (prove)\nusing this:\n  xs \\<noteq> ys\n  xs = ys\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lstrict_prefix_lfinite1: \"lstrict_prefix xs ys \\<Longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lstrict_prefix xs ys \\<Longrightarrow> lfinite xs", "by (metis lstrict_prefix_def not_lfinite_lprefix_conv_eq)"], ["", "lemma wfP_lstrict_prefix: \"wfP lstrict_prefix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP lstrict_prefix", "proof(unfold wfP_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. wf {(x, y). lstrict_prefix x y}", "have \"wf {(x :: enat, y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). x < y}", "unfolding wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       (\\<forall>x.\n           (\\<forall>y.\n               (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n               P y) \\<longrightarrow>\n           P x) \\<longrightarrow>\n       All P", "by(blast intro: less_induct)"], ["proof (state)\nthis:\n  wf {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. wf {(x, y). lstrict_prefix x y}", "hence \"wf (inv_image {(x, y). x < y} llength)\""], ["proof (prove)\nusing this:\n  wf {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. wf (inv_image {(x, y). x < y} llength)", "by(rule wf_inv_image)"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y} llength)\n\ngoal (1 subgoal):\n 1. wf {(x, y). lstrict_prefix x y}", "moreover"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y} llength)\n\ngoal (1 subgoal):\n 1. wf {(x, y). lstrict_prefix x y}", "have \"{(xs, ys). lstrict_prefix xs ys} \\<subseteq> inv_image {(x, y). x < y} llength\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(xs, ys). lstrict_prefix xs ys}\n    \\<subseteq> inv_image {(x, y). x < y} llength", "by(auto intro: lstrict_prefix_llength_less)"], ["proof (state)\nthis:\n  {(xs, ys). lstrict_prefix xs ys}\n  \\<subseteq> inv_image {(x, y). x < y} llength\n\ngoal (1 subgoal):\n 1. wf {(x, y). lstrict_prefix x y}", "ultimately"], ["proof (chain)\npicking this:\n  wf (inv_image {(x, y). x < y} llength)\n  {(xs, ys). lstrict_prefix xs ys}\n  \\<subseteq> inv_image {(x, y). x < y} llength", "show \"wf {(xs, ys). lstrict_prefix xs ys}\""], ["proof (prove)\nusing this:\n  wf (inv_image {(x, y). x < y} llength)\n  {(xs, ys). lstrict_prefix xs ys}\n  \\<subseteq> inv_image {(x, y). x < y} llength\n\ngoal (1 subgoal):\n 1. wf {(xs, ys). lstrict_prefix xs ys}", "by(rule wf_subset)"], ["proof (state)\nthis:\n  wf {(xs, ys). lstrict_prefix xs ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_less_induct[case_names less]:\n  \"(\\<And>xs. (\\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys) \\<Longrightarrow> P xs) \\<Longrightarrow> P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        (\\<And>ys.\n            lstrict_prefix ys xs \\<Longrightarrow> P ys) \\<Longrightarrow>\n        P xs) \\<Longrightarrow>\n    P xs", "by(rule wfP_induct[OF wfP_lstrict_prefix]) blast"], ["", "lemma ltake_enat_eq_imp_eq: \"(\\<And>n. ltake (enat n) xs = ltake (enat n) ys) \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. ltake (enat n) xs = ltake (enat n) ys) \\<Longrightarrow>\n    xs = ys", "by(coinduction arbitrary: xs ys)(auto simp add: zero_enat_def lnull_def neq_LNil_conv ltake_eq_LNil_iff eSuc_enat[symmetric] elim: allE[where x=\"Suc n\" for n])"], ["", "lemma ltake_enat_lprefix_imp_lprefix:\n  assumes \"\\<And>n. lprefix (ltake (enat n) xs) (ltake (enat n) ys)\"\n  shows \"lprefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "have \"ccpo.admissible Sup (\\<le>) (\\<lambda>n. ltake n xs \\<sqsubseteq> ltake n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible Sup (\\<le>)\n     (\\<lambda>n. ltake n xs \\<sqsubseteq> ltake n ys)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible Sup (\\<le>)\n   (\\<lambda>n. ltake n xs \\<sqsubseteq> ltake n ys)\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "hence \"ltake (Sup (range enat)) xs \\<sqsubseteq> ltake (Sup (range enat)) ys\""], ["proof (prove)\nusing this:\n  ccpo.admissible Sup (\\<le>)\n   (\\<lambda>n. ltake n xs \\<sqsubseteq> ltake n ys)\n\ngoal (1 subgoal):\n 1. ltake (\\<Squnion> range enat) xs \\<sqsubseteq>\n    ltake (\\<Squnion> range enat) ys", "by(rule ccpo.admissibleD)(auto intro: assms)"], ["proof (state)\nthis:\n  ltake (\\<Squnion> range enat) xs \\<sqsubseteq>\n  ltake (\\<Squnion> range enat) ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  ltake (\\<Squnion> range enat) xs \\<sqsubseteq>\n  ltake (\\<Squnion> range enat) ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(simp add: ltake_all)"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_conv_lappend: \"xs \\<sqsubseteq> ys \\<longleftrightarrow> (\\<exists>zs. ys = lappend xs zs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys = (\\<exists>zs. ys = lappend xs zs)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> \\<exists>zs. ys = lappend xs zs\n 2. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "assume ?lhs"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> \\<exists>zs. ys = lappend xs zs\n 2. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "hence \"ys = lappend xs (ldrop (llength xs) ys)\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. ys = lappend xs (ldrop (llength xs) ys)", "by(coinduction arbitrary: xs ys)(auto dest: lprefix_lnullD lprefix_lhdD intro: lprefix_ltlI simp add: not_lnull_conv lprefix_LCons_conv intro: exI[where x=LNil])"], ["proof (state)\nthis:\n  ys = lappend xs (ldrop (llength xs) ys)\n\ngoal (2 subgoals):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> \\<exists>zs. ys = lappend xs zs\n 2. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "thus ?rhs"], ["proof (prove)\nusing this:\n  ys = lappend xs (ldrop (llength xs) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = lappend xs zs", ".."], ["proof (state)\nthis:\n  \\<exists>zs. ys = lappend xs zs\n\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>zs. ys = lappend xs zs\n\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = lappend xs zs \\<Longrightarrow> xs \\<sqsubseteq> ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>zs. ys = lappend xs zs\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(coinduct rule: lprefix_coinduct) auto"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_lprefixE:\n  assumes \"lappend xs ys \\<sqsubseteq> zs\"\n  obtains zs' where \"zs = lappend xs zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = lappend xs zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  lappend xs ys \\<sqsubseteq> zs\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = lappend xs zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lprefix_conv_lappend"], ["proof (prove)\nusing this:\n  \\<exists>zsa. zs = lappend (lappend xs ys) zsa\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = lappend xs zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: lappend_assoc)"], ["", "lemma lprefix_lfiniteD:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; lfinite ys \\<rbrakk> \\<Longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; lfinite ys\\<rbrakk>\n    \\<Longrightarrow> lfinite xs", "unfolding lprefix_conv_lappend"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>zs. ys = lappend xs zs; lfinite ys\\<rbrakk>\n    \\<Longrightarrow> lfinite xs", "by auto"], ["", "lemma lprefix_lappendD:\n  assumes \"xs \\<sqsubseteq> lappend ys zs\"\n  shows \"xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "assume \"\\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs)\""], ["proof (state)\nthis:\n  \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs)\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "hence \"\\<not> xs \\<sqsubseteq> ys\" \"\\<not> ys \\<sqsubseteq> xs\""], ["proof (prove)\nusing this:\n  \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs)\n\ngoal (1 subgoal):\n 1. \\<not> xs \\<sqsubseteq> ys &&& \\<not> ys \\<sqsubseteq> xs", "by simp_all"], ["proof (state)\nthis:\n  \\<not> xs \\<sqsubseteq> ys\n  \\<not> ys \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "from \\<open>xs \\<sqsubseteq> lappend ys zs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<sqsubseteq> lappend ys zs", "obtain xs'\n    where \"lappend xs xs' = lappend ys zs\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> lappend ys zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        lappend xs xs' = lappend ys zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding lprefix_conv_lappend"], ["proof (prove)\nusing this:\n  \\<exists>zsa. lappend ys zs = lappend xs zsa\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        lappend xs xs' = lappend ys zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lappend xs xs' = lappend ys zs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "hence eq: \"lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n             lappend ys zs\""], ["proof (prove)\nusing this:\n  lappend xs xs' = lappend ys zs\n\ngoal (1 subgoal):\n 1. lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n    lappend ys zs", "unfolding lappend_assoc[symmetric]"], ["proof (prove)\nusing this:\n  lappend xs xs' = lappend ys zs\n\ngoal (1 subgoal):\n 1. lappend (lappend (ltake (llength ys) xs) (ldrop (llength ys) xs)) xs' =\n    lappend ys zs", "by(simp only: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n  lappend ys zs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n  lappend ys zs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "have \"llength xs \\<ge> llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength ys \\<le> llength xs", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> llength ys \\<le> llength xs\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "hence \"llength xs < llength ys\""], ["proof (prove)\nusing this:\n  \\<not> llength ys \\<le> llength xs\n\ngoal (1 subgoal):\n 1. llength xs < llength ys", "by simp"], ["proof (state)\nthis:\n  llength xs < llength ys\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "hence \"ltake (llength ys) xs = xs\""], ["proof (prove)\nusing this:\n  llength xs < llength ys\n\ngoal (1 subgoal):\n 1. ltake (llength ys) xs = xs", "by(simp add: ltake_all)"], ["proof (state)\nthis:\n  ltake (llength ys) xs = xs\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "hence \"lappend xs (lappend (ldrop (llength ys) xs) xs') =\n           lappend (ltake (llength xs) ys) (lappend (ldrop (llength xs) ys) zs)\""], ["proof (prove)\nusing this:\n  ltake (llength ys) xs = xs\n\ngoal (1 subgoal):\n 1. lappend xs (lappend (ldrop (llength ys) xs) xs') =\n    lappend (ltake (llength xs) ys) (lappend (ldrop (llength xs) ys) zs)", "unfolding lappend_assoc[symmetric] lappend_ltake_ldrop"], ["proof (prove)\nusing this:\n  ltake (llength ys) xs = xs\n\ngoal (1 subgoal):\n 1. lappend (lappend xs (ldrop (llength ys) xs)) xs' = lappend ys zs", "using eq"], ["proof (prove)\nusing this:\n  ltake (llength ys) xs = xs\n  lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n  lappend ys zs\n\ngoal (1 subgoal):\n 1. lappend (lappend xs (ldrop (llength ys) xs)) xs' = lappend ys zs", "by(simp add: lappend_assoc)"], ["proof (state)\nthis:\n  lappend xs (lappend (ldrop (llength ys) xs) xs') =\n  lappend (ltake (llength xs) ys) (lappend (ldrop (llength xs) ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "hence xs: \"xs = ltake (llength xs) ys\""], ["proof (prove)\nusing this:\n  lappend xs (lappend (ldrop (llength ys) xs) xs') =\n  lappend (ltake (llength xs) ys) (lappend (ldrop (llength xs) ys) zs)\n\ngoal (1 subgoal):\n 1. xs = ltake (llength xs) ys", "using \\<open>llength xs < llength ys\\<close>"], ["proof (prove)\nusing this:\n  lappend xs (lappend (ldrop (llength ys) xs) xs') =\n  lappend (ltake (llength xs) ys) (lappend (ldrop (llength xs) ys) zs)\n  llength xs < llength ys\n\ngoal (1 subgoal):\n 1. xs = ltake (llength xs) ys", "by(subst (asm) lappend_eq_lappend_conv)(auto simp add: min_def)"], ["proof (state)\nthis:\n  xs = ltake (llength xs) ys\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "have \"xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(subst xs) auto"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. \\<not> llength ys \\<le> llength xs \\<Longrightarrow> False", "with \\<open>\\<not> xs \\<sqsubseteq> ys\\<close>"], ["proof (chain)\npicking this:\n  \\<not> xs \\<sqsubseteq> ys\n  xs \\<sqsubseteq> ys", "show False"], ["proof (prove)\nusing this:\n  \\<not> xs \\<sqsubseteq> ys\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llength ys \\<le> llength xs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n  lappend ys zs\n  llength ys \\<le> llength xs", "have ys: \"ys = ltake (llength ys) xs\""], ["proof (prove)\nusing this:\n  lappend (ltake (llength ys) xs) (lappend (ldrop (llength ys) xs) xs') =\n  lappend ys zs\n  llength ys \\<le> llength xs\n\ngoal (1 subgoal):\n 1. ys = ltake (llength ys) xs", "by(subst (asm) lappend_eq_lappend_conv)(simp_all add: min_def)"], ["proof (state)\nthis:\n  ys = ltake (llength ys) xs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "have \"ys \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<sqsubseteq> xs", "by(subst ys) auto"], ["proof (state)\nthis:\n  ys \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. \\<not> (xs \\<sqsubseteq> ys \\<or> ys \\<sqsubseteq> xs) \\<Longrightarrow>\n    False", "with \\<open>\\<not> ys \\<sqsubseteq> xs\\<close>"], ["proof (chain)\npicking this:\n  \\<not> ys \\<sqsubseteq> xs\n  ys \\<sqsubseteq> xs", "show False"], ["proof (prove)\nusing this:\n  \\<not> ys \\<sqsubseteq> xs\n  ys \\<sqsubseteq> xs\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lstrict_prefix_lappend_conv:\n  \"lstrict_prefix xs (lappend xs ys) \\<longleftrightarrow> lfinite xs \\<and> \\<not> lnull ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "assume \"lfinite xs\" \"xs = lappend xs ys\""], ["proof (state)\nthis:\n  lfinite xs\n  xs = lappend xs ys\n\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "hence \"lnull ys\""], ["proof (prove)\nusing this:\n  lfinite xs\n  xs = lappend xs ys\n\ngoal (1 subgoal):\n 1. lnull ys", "by induct auto"], ["proof (state)\nthis:\n  lnull ys\n\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lfinite xs; xs = lappend xs ys\\<rbrakk>\n  \\<Longrightarrow> lnull ys\n\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite xs; xs = lappend xs ys\\<rbrakk>\n  \\<Longrightarrow> lnull ys\n\ngoal (1 subgoal):\n 1. lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)", "by(auto simp add: lstrict_prefix_def lprefix_lappend lappend_inf lappend_lnull2\n            elim: contrapos_np)"], ["proof (state)\nthis:\n  lstrict_prefix xs (lappend xs ys) = (lfinite xs \\<and> \\<not> lnull ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_llist_ofI:\n  \"\\<exists>zs. ys = xs @ zs \\<Longrightarrow> llist_of xs \\<sqsubseteq> llist_of ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = xs @ zs \\<Longrightarrow>\n    llist_of xs \\<sqsubseteq> llist_of ys", "by(clarsimp simp add: lappend_llist_of_llist_of[symmetric] lprefix_lappend)"], ["", "lemma lprefix_llist_of [simp]: \"llist_of xs \\<sqsubseteq> llist_of ys \\<longleftrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of xs \\<sqsubseteq> llist_of ys = prefix xs ys", "by(auto simp add: prefix_def lprefix_conv_lappend)(metis lfinite_lappend lfinite_llist_of list_of_lappend list_of_llist_of lappend_llist_of_llist_of)+"], ["", "lemma llimit_induct [case_names LNil LCons limit]:\n  \\<comment> \\<open>The limit case is just an instance of admissibility\\<close>\n  assumes LNil: \"P LNil\"\n  and LCons: \"\\<And>x xs. \\<lbrakk> lfinite xs; P xs \\<rbrakk> \\<Longrightarrow> P (LCons x xs)\"\n  and limit: \"(\\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys) \\<Longrightarrow> P xs\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof(rule limit)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys", "assume \"lstrict_prefix ys xs\""], ["proof (state)\nthis:\n  lstrict_prefix ys xs\n\ngoal (1 subgoal):\n 1. \\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys", "hence \"lfinite ys\""], ["proof (prove)\nusing this:\n  lstrict_prefix ys xs\n\ngoal (1 subgoal):\n 1. lfinite ys", "by(rule lstrict_prefix_lfinite1)"], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. \\<And>ys. lstrict_prefix ys xs \\<Longrightarrow> P ys", "thus \"P ys\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. P ys", "by(induct)(blast intro: LNil LCons)+"], ["proof (state)\nthis:\n  P ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmap_lstrict_prefix:\n  \"lstrict_prefix xs ys \\<Longrightarrow> lstrict_prefix (lmap f xs) (lmap f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lstrict_prefix xs ys \\<Longrightarrow>\n    lstrict_prefix (lmap f xs) (lmap f ys)", "by (metis llength_lmap lmap_lprefix lprefix_llength_eq_imp_eq lstrict_prefix_def)"], ["", "lemma lprefix_lnthD:\n  assumes \"xs \\<sqsubseteq> ys\" and \"enat n < llength xs\"\n  shows \"lnth xs n = lnth ys n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth xs n = lnth ys n", "using assms"], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. lnth xs n = lnth ys n", "by (metis lnth_lappend1 lprefix_conv_lappend)"], ["", "lemma lfinite_lSup_chain:\n  assumes chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) A\"\n  shows \"lfinite (lSup A) \\<longleftrightarrow> finite A \\<and> (\\<forall>xs \\<in> A. lfinite xs)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lSup A) = (finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs))", "proof(intro iffI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (lSup A)\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "then"], ["proof (chain)\npicking this:\n  lfinite (lSup A)", "obtain n where n: \"llength (lSup A) = enat n\""], ["proof (prove)\nusing this:\n  lfinite (lSup A)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength (lSup A) = enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_conv_llength_enat"], ["proof (prove)\nusing this:\n  \\<exists>n. llength (lSup A) = enat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength (lSup A) = enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  llength (lSup A) = enat n\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "have \"llength ` A \\<subseteq> {..<enat (Suc n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength ` A \\<subseteq> {..<enat (Suc n)}", "by(auto dest!: chain_lprefix_lSup[OF chain] lprefix_llength_le simp add: n intro: le_less_trans)"], ["proof (state)\nthis:\n  llength ` A \\<subseteq> {..<enat (Suc n)}\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "hence \"finite (llength ` A)\""], ["proof (prove)\nusing this:\n  llength ` A \\<subseteq> {..<enat (Suc n)}\n\ngoal (1 subgoal):\n 1. finite (llength ` A)", "by(rule finite_subset)(simp add: finite_lessThan_enat_iff)"], ["proof (state)\nthis:\n  finite (llength ` A)\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "moreover"], ["proof (state)\nthis:\n  finite (llength ` A)\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "have \"inj_on llength A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on llength A", "by(rule inj_onI)(auto 4 3 dest: chainD[OF chain] lprefix_llength_eq_imp_eq)"], ["proof (state)\nthis:\n  inj_on llength A\n\ngoal (3 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> finite A\n 2. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 3. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "ultimately"], ["proof (chain)\npicking this:\n  finite (llength ` A)\n  inj_on llength A", "show \"finite A\""], ["proof (prove)\nusing this:\n  finite (llength ` A)\n  inj_on llength A\n\ngoal (1 subgoal):\n 1. finite A", "by(rule finite_imageD)"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 2. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 2. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "assume ?rhs"], ["proof (state)\nthis:\n  finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs)\n\ngoal (2 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 2. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "hence \"finite A\" \"\\<forall>xs\\<in>A. lfinite xs\""], ["proof (prove)\nusing this:\n  finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs)\n\ngoal (1 subgoal):\n 1. finite A &&& \\<forall>xs\\<in>A. lfinite xs", "by simp_all"], ["proof (state)\nthis:\n  finite A\n  \\<forall>xs\\<in>A. lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs\n 2. finite A \\<and> (\\<forall>xs\\<in>A. lfinite xs) \\<Longrightarrow>\n    lfinite (lSup A)", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lSup A)", "proof(cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> lfinite (lSup A)\n 2. A \\<noteq> {} \\<Longrightarrow> lfinite (lSup A)", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> lfinite (lSup A)\n 2. A \\<noteq> {} \\<Longrightarrow> lfinite (lSup A)", "with chain \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n  finite A\n  A \\<noteq> {}", "have \"lSup A \\<in> A\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) A\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lSup A \\<in> A", "by(rule ccpo.in_chain_finite[OF llist_ccpo])"], ["proof (state)\nthis:\n  lSup A \\<in> A\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> lfinite (lSup A)\n 2. A \\<noteq> {} \\<Longrightarrow> lfinite (lSup A)", "with \\<open>\\<forall>xs\\<in>A. lfinite xs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>A. lfinite xs\n  lSup A \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>A. lfinite xs\n  lSup A \\<in> A\n\ngoal (1 subgoal):\n 1. lfinite (lSup A)", ".."], ["proof (state)\nthis:\n  lfinite (lSup A)\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> lfinite (lSup A)", "qed simp"], ["proof (state)\nthis:\n  lfinite (lSup A)\n\ngoal (1 subgoal):\n 1. lfinite (lSup A) \\<Longrightarrow> \\<forall>xs\\<in>A. lfinite xs", "qed(rule lfinite_lSupD)"], ["", "text \\<open>Setup for @{term \"lprefix\"} for Nitpick\\<close>"], ["", "definition finite_lprefix :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> bool\"\nwhere \"finite_lprefix = (\\<sqsubseteq>)\""], ["", "lemma finite_lprefix_nitpick_simps [nitpick_simp]:\n  \"finite_lprefix xs LNil \\<longleftrightarrow> xs = LNil\"\n  \"finite_lprefix LNil xs \\<longleftrightarrow> True\"\n  \"finite_lprefix xs (LCons y ys) \\<longleftrightarrow>\n   xs = LNil \\<or> (\\<exists>xs'. xs = LCons y xs' \\<and> finite_lprefix xs' ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_lprefix xs LNil = (xs = LNil) &&&\n    finite_lprefix LNil xs = True &&&\n    finite_lprefix xs (LCons y ys) =\n    (xs = LNil \\<or>\n     (\\<exists>xs'. xs = LCons y xs' \\<and> finite_lprefix xs' ys))", "by(simp_all add: lprefix_LCons_conv finite_lprefix_def lnull_def)"], ["", "lemma lprefix_nitpick_simps [nitpick_simp]:\n  \"xs \\<sqsubseteq> ys = (if lfinite xs then finite_lprefix xs ys else xs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys =\n    (if lfinite xs then finite_lprefix xs ys else xs = ys)", "by(simp add: finite_lprefix_def not_lfinite_lprefix_conv_eq)"], ["", "hide_const (open) finite_lprefix"], ["", "hide_fact (open) finite_lprefix_def finite_lprefix_nitpick_simps lprefix_nitpick_simps"], ["", "subsection \\<open>Length of the longest common prefix\\<close>"], ["", "lemma llcp_simps [simp, code, nitpick_simp]:\n  shows llcp_LNil1: \"llcp LNil ys = 0\"\n  and llcp_LNil2: \"llcp xs LNil = 0\"\n  and llcp_LCons: \"llcp (LCons x xs) (LCons y ys) = (if x = y then eSuc (llcp xs ys) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp LNil ys = 0 &&&\n    llcp xs LNil = 0 &&&\n    llcp (LCons x xs) (LCons y ys) =\n    (if x = y then eSuc (llcp xs ys) else 0)", "by(simp_all add: llcp_def enat_unfold split: llist.split)"], ["", "lemma llcp_eq_0_iff:\n  \"llcp xs ys = 0 \\<longleftrightarrow> lnull xs \\<or> lnull ys \\<or> lhd xs \\<noteq> lhd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llcp xs ys = 0) =\n    (lnull xs \\<or> lnull ys \\<or> lhd xs \\<noteq> lhd ys)", "by(simp add: llcp_def)"], ["", "lemma epred_llcp:\n  \"\\<lbrakk> \\<not> lnull xs; \\<not> lnull ys; lhd xs = lhd ys \\<rbrakk>\n  \\<Longrightarrow>  epred (llcp xs ys) = llcp (ltl xs) (ltl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys; lhd xs = lhd ys\\<rbrakk>\n    \\<Longrightarrow> epred (llcp xs ys) = llcp (ltl xs) (ltl ys)", "by(simp add: llcp_def)"], ["", "lemma llcp_commute: \"llcp xs ys = llcp ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp xs ys = llcp ys xs", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(auto simp add: llcp_eq_0_iff epred_llcp)"], ["", "lemma llcp_same_conv_length [simp]: \"llcp xs xs = llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp xs xs = llength xs", "by(coinduction arbitrary: xs rule: enat_coinduct)(auto simp add: llcp_eq_0_iff epred_llcp epred_llength)"], ["", "lemma llcp_lappend_same [simp]:\n  \"llcp (lappend xs ys) (lappend xs zs) = llength xs + llcp ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp (lappend xs ys) (lappend xs zs) = llength xs + llcp ys zs", "by(coinduction arbitrary: xs rule: enat_coinduct)(auto simp add: iadd_is_0 llcp_eq_0_iff epred_iadd1 epred_llcp epred_llength)"], ["", "lemma llcp_lprefix1 [simp]: \"xs \\<sqsubseteq> ys \\<Longrightarrow> llcp xs ys = llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow> llcp xs ys = llength xs", "by (metis add_0_right lappend_LNil2 llcp_LNil1 llcp_lappend_same lprefix_conv_lappend)"], ["", "lemma llcp_lprefix2 [simp]: \"ys \\<sqsubseteq> xs \\<Longrightarrow> llcp xs ys = llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<sqsubseteq> xs \\<Longrightarrow> llcp xs ys = llength ys", "by (metis llcp_commute llcp_lprefix1)"], ["", "lemma llcp_le_length: \"llcp xs ys \\<le> min (llength xs) (llength ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp xs ys \\<le> min (llength xs) (llength ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llcp xs ys \\<le> min (llength xs) (llength ys)", "define m n where \"m = llcp xs ys\" and \"n = min (llength xs) (llength ys)\""], ["proof (state)\nthis:\n  m = llcp xs ys\n  n = min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. llcp xs ys \\<le> min (llength xs) (llength ys)", "hence \"(m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys :: 'a llist. True}\""], ["proof (prove)\nusing this:\n  m = llcp xs ys\n  n = min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}", "by blast"], ["proof (state)\nthis:\n  (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}\n\ngoal (1 subgoal):\n 1. llcp xs ys \\<le> min (llength xs) (llength ys)", "thus \"m \\<le> n\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}\n\ngoal (1 subgoal):\n 1. m \\<le> n", "proof(coinduct rule: enat_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n)\n       \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n              True} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n')\n            \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n                   True} \\<or>\n            m' \\<le> n'))", "case (Leenat m n)"], ["proof (state)\nthis:\n  (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n)\n       \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n              True} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n')\n            \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n                   True} \\<or>\n            m' \\<le> n'))", "then"], ["proof (chain)\npicking this:\n  (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}", "obtain xs ys :: \"'a llist\" where \"m = llcp xs ys\" \"n = min (llength xs) (llength ys)\""], ["proof (prove)\nusing this:\n  (m, n) \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys. True}\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>m = llcp xs ys; n = min (llength xs) (llength ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m = llcp xs ys\n  n = min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       (m, n)\n       \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n              True} \\<Longrightarrow>\n       m = 0 \\<or>\n       (\\<exists>m' n' k.\n           m = eSuc m' \\<and>\n           n = n' + enat k \\<and>\n           k \\<noteq> 0 \\<and>\n           ((m', n')\n            \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n                   True} \\<or>\n            m' \\<le> n'))", "thus ?case"], ["proof (prove)\nusing this:\n  m = llcp xs ys\n  n = min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. m = 0 \\<or>\n    (\\<exists>m' n' k.\n        m = eSuc m' \\<and>\n        n = n' + enat k \\<and>\n        k \\<noteq> 0 \\<and>\n        ((m', n')\n         \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n                True} \\<or>\n         m' \\<le> n'))", "by(cases xs ys rule: llist.exhaust[case_product llist.exhaust])(auto 4 3 intro!: exI[where x=\"Suc 0\"] simp add: eSuc_enat[symmetric] iadd_Suc_right zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  m = 0 \\<or>\n  (\\<exists>m' n' k.\n      m = eSuc m' \\<and>\n      n = n' + enat k \\<and>\n      k \\<noteq> 0 \\<and>\n      ((m', n')\n       \\<in> {(llcp xs ys, min (llength xs) (llength ys)) |xs ys.\n              True} \\<or>\n       m' \\<le> n'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llcp_ltake1: \"llcp (ltake n xs) ys = min n (llcp xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp (ltake n xs) ys = min n (llcp xs ys)", "by(coinduction arbitrary: n xs ys rule: enat_coinduct)(auto simp add: llcp_eq_0_iff enat_min_eq_0_iff epred_llcp ltl_ltake)"], ["", "lemma llcp_ltake2: \"llcp xs (ltake n ys) = min n (llcp xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp xs (ltake n ys) = min n (llcp xs ys)", "by(metis llcp_commute llcp_ltake1)"], ["", "lemma llcp_ltake [simp]: \"llcp (ltake n xs) (ltake m ys) = min (min n m) (llcp xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp (ltake n xs) (ltake m ys) = min (min n m) (llcp xs ys)", "by(metis llcp_ltake1 llcp_ltake2 min.assoc)"], ["", "subsection \\<open>Zipping two lazy lists to a lazy list of pairs @{term \"lzip\" }\\<close>"], ["", "lemma lzip_simps [simp, code, nitpick_simp]:\n  \"lzip LNil ys = LNil\"\n  \"lzip xs LNil = LNil\"\n  \"lzip (LCons x xs) (LCons y ys) = LCons (x, y) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip LNil ys = LNil &&&\n    lzip xs LNil = LNil &&&\n    lzip (LCons x xs) (LCons y ys) = LCons (x, y) (lzip xs ys)", "by(auto intro: llist.expand)"], ["", "lemma lnull_lzip [simp]: \"lnull (lzip xs ys) \\<longleftrightarrow> lnull xs \\<or> lnull ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lzip xs ys) = (lnull xs \\<or> lnull ys)", "by(simp add: lzip_def)"], ["", "lemma lzip_eq_LNil_conv: \"lzip xs ys = LNil \\<longleftrightarrow> xs = LNil \\<or> ys = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lzip xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "using lnull_lzip"], ["proof (prove)\nusing this:\n  lnull (lzip ?xs ?ys) = (lnull ?xs \\<or> lnull ?ys)\n\ngoal (1 subgoal):\n 1. (lzip xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (lzip ?xs ?ys = LNil) = (?xs = LNil \\<or> ?ys = LNil)\n\ngoal (1 subgoal):\n 1. (lzip xs ys = LNil) = (xs = LNil \\<or> ys = LNil)", "."], ["", "lemmas lhd_lzip = lzip.sel(1)\n  and ltl_lzip = lzip.sel(2)"], ["", "lemma lzip_eq_LCons_conv:\n  \"lzip xs ys = LCons z zs \\<longleftrightarrow>\n   (\\<exists>x xs' y ys'. xs = LCons x xs' \\<and> ys = LCons y ys' \\<and> z = (x, y) \\<and> zs = lzip xs' ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lzip xs ys = LCons z zs) =\n    (\\<exists>x xs' y ys'.\n        xs = LCons x xs' \\<and>\n        ys = LCons y ys' \\<and> z = (x, y) \\<and> zs = lzip xs' ys')", "by(cases xs ys rule: llist.exhaust[case_product llist.exhaust]) auto"], ["", "lemma lzip_lappend:\n  \"llength xs = llength us\n  \\<Longrightarrow> lzip (lappend xs ys) (lappend us vs) = lappend (lzip xs us) (lzip ys vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs = llength us \\<Longrightarrow>\n    lzip (lappend xs ys) (lappend us vs) = lappend (lzip xs us) (lzip ys vs)", "by(coinduction arbitrary: xs ys us vs rule: llist.coinduct_strong)(auto 4 6 simp add: llength_ltl)"], ["", "lemma llength_lzip [simp]:\n  \"llength (lzip xs ys) = min (llength xs) (llength ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lzip xs ys) = min (llength xs) (llength ys)", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(auto simp add: enat_min_eq_0_iff epred_llength)"], ["", "lemma ltake_lzip: \"ltake n (lzip xs ys) = lzip (ltake n xs) (ltake n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (lzip xs ys) = lzip (ltake n xs) (ltake n ys)", "by(coinduction arbitrary: xs ys n)(auto simp add: ltl_ltake)"], ["", "lemma ldropn_lzip [simp]:\n  \"ldropn n (lzip xs ys) = lzip (ldropn n xs) (ldropn n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (lzip xs ys) = lzip (ldropn n xs) (ldropn n ys)", "by(induct n arbitrary: xs ys)(simp_all add: ldropn_Suc split: llist.split)"], ["", "lemma\n  fixes F\n  defines \"F \\<equiv> \\<lambda>lzip (xs, ys). case xs of LNil \\<Rightarrow> LNil | LCons x xs' \\<Rightarrow> case ys of LNil \\<Rightarrow> LNil | LCons y ys' \\<Rightarrow> LCons (x, y) (curry lzip xs' ys')\"\n  shows lzip_conv_fixp: \"lzip \\<equiv> curry (ccpo.fixp (fun_lub lSup) (fun_ord (\\<sqsubseteq>)) F)\" (is \"?lhs \\<equiv> ?rhs\")\n  and lzip_mono: \"mono_llist (\\<lambda>lzip. F lzip xs)\" (is \"?mono xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lzip \\<equiv> curry (llist.fixp_fun F)) &&&\n    mono_llist (\\<lambda>lzip. F lzip xs)", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. lzip x xa = curry (llist.fixp_fun F) x xa\n 2. mono_llist (\\<lambda>lzip. F lzip xs)", "show mono: \"\\<And>xs. ?mono xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. mono_llist (\\<lambda>lzip. F lzip xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mono_llist\n        (\\<lambda>lzip.\n            case xs of (LNil, ys) \\<Rightarrow> LNil\n            | (LCons x xs', LNil) \\<Rightarrow> LNil\n            | (LCons x xs', LCons y ys') \\<Rightarrow>\n                LCons (x, y) (curry lzip xs' ys'))", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist (\\<lambda>lzip. F lzip ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa. lzip x xa = curry (llist.fixp_fun F) x xa", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. lzip x xa = curry (llist.fixp_fun F) x xa", "show \"lzip xs ys = ?rhs xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs ys = curry (llist.fixp_fun F) xs ys", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       lnull (lzip xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n       (\\<not> lnull (lzip xs ys) \\<longrightarrow>\n        \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n        lhd (lzip xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n        (\\<exists>xsa ysa.\n            ltl (lzip xs ys) = lzip xsa ysa \\<and>\n            ltl (curry (llist.fixp_fun F) xs ys) =\n            curry (llist.fixp_fun F) xsa ysa))", "case Eq_llist"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       lnull (lzip xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n       (\\<not> lnull (lzip xs ys) \\<longrightarrow>\n        \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n        lhd (lzip xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n        (\\<exists>xsa ysa.\n            ltl (lzip xs ys) = lzip xsa ysa \\<and>\n            ltl (curry (llist.fixp_fun F) xs ys) =\n            curry (llist.fixp_fun F) xsa ysa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lzip xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n    (\\<not> lnull (lzip xs ys) \\<longrightarrow>\n     \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n     lhd (lzip xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n     (\\<exists>xs ys.\n         ltl (lzip xs ys) = lzip xs ys \\<and>\n         ltl (curry (llist.fixp_fun F) xs ys) =\n         curry (llist.fixp_fun F) xs ys))", "by(subst (1 3 4) llist.mono_body_fixp[OF mono])(auto simp add: F_def split: llist.split)"], ["proof (state)\nthis:\n  lnull (lzip xs ys) = lnull (curry (llist.fixp_fun F) xs ys) \\<and>\n  (\\<not> lnull (lzip xs ys) \\<longrightarrow>\n   \\<not> lnull (curry (llist.fixp_fun F) xs ys) \\<longrightarrow>\n   lhd (lzip xs ys) = lhd (curry (llist.fixp_fun F) xs ys) \\<and>\n   (\\<exists>xs ys.\n       ltl (lzip xs ys) = lzip xs ys \\<and>\n       ltl (curry (llist.fixp_fun F) xs ys) =\n       curry (llist.fixp_fun F) xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lzip xs ys = curry (llist.fixp_fun F) xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monotone_lzip: \"monotone (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) (\\<sqsubseteq>) (case_prod lzip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) (\\<sqsubseteq>)\n     (\\<lambda>(x, y). lzip x y)", "by(rule llist.fixp_preserves_mono2[OF lzip_mono lzip_conv_fixp]) simp"], ["", "lemma mono2mono_lzip1 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lzip1: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>xs. lzip xs ys)", "by(simp add: monotone_lzip[simplified])"], ["", "lemma mono2mono_lzip2 [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lzip2: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (\\<lambda>ys. lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lzip xs)", "by(simp add: monotone_lzip[simplified])"], ["", "lemma mcont_lzip: \"mcont (prod_lub lSup lSup) (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) lSup (\\<sqsubseteq>) (case_prod lzip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont (prod_lub lSup lSup) (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n     lSup (\\<sqsubseteq>) (\\<lambda>(x, y). lzip x y)", "by(rule llist.fixp_preserves_mcont2[OF lzip_mono lzip_conv_fixp]) simp"], ["", "lemma mcont2mcont_lzip1 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lzip1: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>xs. lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>)\n     (\\<lambda>xs. lzip xs ys)", "by(simp add: mcont_lzip[simplified])"], ["", "lemma mcont2mcont_lzip2 [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lzip2: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (\\<lambda>ys. lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lzip xs)", "by(simp add: mcont_lzip[simplified])"], ["", "lemma ldrop_lzip [simp]: \"ldrop n (lzip xs ys) = lzip (ldrop n xs) (ldrop n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop n (lzip xs ys) = lzip (ldrop n xs) (ldrop n ys)", "proof(induct xs arbitrary: ys n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x xa.\n            ldrop xa (lzip a x) = lzip (ldrop xa a) (ldrop xa x))\n 2. \\<And>ys n. ldrop n (lzip LNil ys) = lzip (ldrop n LNil) (ldrop n ys)\n 3. \\<And>x xs ys n.\n       \\<lbrakk>lfinite xs;\n        \\<And>ys n.\n           ldrop n (lzip xs ys) = lzip (ldrop n xs) (ldrop n ys)\\<rbrakk>\n       \\<Longrightarrow> ldrop n (lzip (LCons x xs) ys) =\n                         lzip (ldrop n (LCons x xs)) (ldrop n ys)", "case LCons"], ["proof (state)\nthis:\n  lfinite xs_\n  ldrop ?n (lzip xs_ ?ys) = lzip (ldrop ?n xs_) (ldrop ?n ?ys)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x xa.\n            ldrop xa (lzip a x) = lzip (ldrop xa a) (ldrop xa x))\n 2. \\<And>ys n. ldrop n (lzip LNil ys) = lzip (ldrop n LNil) (ldrop n ys)\n 3. \\<And>x xs ys n.\n       \\<lbrakk>lfinite xs;\n        \\<And>ys n.\n           ldrop n (lzip xs ys) = lzip (ldrop n xs) (ldrop n ys)\\<rbrakk>\n       \\<Longrightarrow> ldrop n (lzip (LCons x xs) ys) =\n                         lzip (ldrop n (LCons x xs)) (ldrop n ys)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs_\n  ldrop ?n (lzip xs_ ?ys) = lzip (ldrop ?n xs_) (ldrop ?n ?ys)\n\ngoal (1 subgoal):\n 1. ldrop n (lzip (LCons x_ xs_) ys) =\n    lzip (ldrop n (LCons x_ xs_)) (ldrop n ys)", "by(cases ys n rule: llist.exhaust[case_product co.enat.exhaust]) simp_all"], ["proof (state)\nthis:\n  ldrop n (lzip (LCons x_ xs_) ys) =\n  lzip (ldrop n (LCons x_ xs_)) (ldrop n ys)\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         \\<forall>x xa.\n            ldrop xa (lzip a x) = lzip (ldrop xa a) (ldrop xa x))\n 2. \\<And>ys n. ldrop n (lzip LNil ys) = lzip (ldrop n LNil) (ldrop n ys)", "qed simp_all"], ["", "lemma lzip_iterates:\n  \"lzip (iterates f x) (iterates g y) = iterates (\\<lambda>(x, y). (f x, g y)) (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (iterates f x) (iterates g y) =\n    iterates (\\<lambda>(x, y). (f x, g y)) (x, y)", "by(coinduction arbitrary: x y) auto"], ["", "lemma lzip_llist_of [simp]:\n  \"lzip (llist_of xs) (llist_of ys) = llist_of (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (llist_of xs) (llist_of ys) = llist_of (zip xs ys)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. lzip (llist_of []) (llist_of ys) = llist_of (zip [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           lzip (llist_of xs) (llist_of ys) =\n           llist_of (zip xs ys)) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (llist_of ys) = llist_of (zip (a # xs) ys)", "case (Cons x xs')"], ["proof (state)\nthis:\n  lzip (llist_of xs') (llist_of ?ys) = llist_of (zip xs' ?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys. lzip (llist_of []) (llist_of ys) = llist_of (zip [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           lzip (llist_of xs) (llist_of ys) =\n           llist_of (zip xs ys)) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (llist_of ys) = llist_of (zip (a # xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  lzip (llist_of xs') (llist_of ?ys) = llist_of (zip xs' ?ys)\n\ngoal (1 subgoal):\n 1. lzip (llist_of (x # xs')) (llist_of ys) = llist_of (zip (x # xs') ys)", "by(cases ys) simp_all"], ["proof (state)\nthis:\n  lzip (llist_of (x # xs')) (llist_of ys) = llist_of (zip (x # xs') ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys. lzip (llist_of []) (llist_of ys) = llist_of (zip [] ys)", "qed simp"], ["", "lemma lnth_lzip:\n  \"\\<lbrakk> enat n < llength xs; enat n < llength ys \\<rbrakk>\n  \\<Longrightarrow> lnth (lzip xs ys) n = (lnth xs n, lnth ys n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat n < llength xs; enat n < llength ys\\<rbrakk>\n    \\<Longrightarrow> lnth (lzip xs ys) n = (lnth xs n, lnth ys n)", "proof(induct n arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>enat 0 < llength xs; enat 0 < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) 0 = (lnth xs 0, lnth ys 0)\n 2. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs;\n                    enat n < llength ys\\<rbrakk>\n                   \\<Longrightarrow> lnth (lzip xs ys) n =\n                                     (lnth xs n, lnth ys n);\n        enat (Suc n) < llength xs; enat (Suc n) < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) (Suc n) =\n                         (lnth xs (Suc n), lnth ys (Suc n))", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n  enat 0 < llength ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>enat 0 < llength xs; enat 0 < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) 0 = (lnth xs 0, lnth ys 0)\n 2. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs;\n                    enat n < llength ys\\<rbrakk>\n                   \\<Longrightarrow> lnth (lzip xs ys) n =\n                                     (lnth xs n, lnth ys n);\n        enat (Suc n) < llength xs; enat (Suc n) < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) (Suc n) =\n                         (lnth xs (Suc n), lnth ys (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n  enat 0 < llength ys\n\ngoal (1 subgoal):\n 1. lnth (lzip xs ys) 0 = (lnth xs 0, lnth ys 0)", "by(simp add: zero_enat_def[symmetric] lnth_0_conv_lhd)"], ["proof (state)\nthis:\n  lnth (lzip xs ys) 0 = (lnth xs 0, lnth ys 0)\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs;\n                    enat n < llength ys\\<rbrakk>\n                   \\<Longrightarrow> lnth (lzip xs ys) n =\n                                     (lnth xs n, lnth ys n);\n        enat (Suc n) < llength xs; enat (Suc n) < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) (Suc n) =\n                         (lnth xs (Suc n), lnth ys (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs;\n                    enat n < llength ys\\<rbrakk>\n                   \\<Longrightarrow> lnth (lzip xs ys) n =\n                                     (lnth xs n, lnth ys n);\n        enat (Suc n) < llength xs; enat (Suc n) < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) (Suc n) =\n                         (lnth xs (Suc n), lnth ys (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>enat n < llength ?xs; enat n < llength ?ys\\<rbrakk>\n  \\<Longrightarrow> lnth (lzip ?xs ?ys) n = (lnth ?xs n, lnth ?ys n)\n  enat (Suc n) < llength xs\n  enat (Suc n) < llength ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs;\n                    enat n < llength ys\\<rbrakk>\n                   \\<Longrightarrow> lnth (lzip xs ys) n =\n                                     (lnth xs n, lnth ys n);\n        enat (Suc n) < llength xs; enat (Suc n) < llength ys\\<rbrakk>\n       \\<Longrightarrow> lnth (lzip xs ys) (Suc n) =\n                         (lnth xs (Suc n), lnth ys (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat n < llength ?xs; enat n < llength ?ys\\<rbrakk>\n  \\<Longrightarrow> lnth (lzip ?xs ?ys) n = (lnth ?xs n, lnth ?ys n)\n  enat (Suc n) < llength xs\n  enat (Suc n) < llength ys\n\ngoal (1 subgoal):\n 1. lnth (lzip xs ys) (Suc n) = (lnth xs (Suc n), lnth ys (Suc n))", "by(cases xs ys rule: llist.exhaust[case_product llist.exhaust])(auto simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  lnth (lzip xs ys) (Suc n) = (lnth xs (Suc n), lnth ys (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lzip:\n  \"lset (lzip xs ys) =\n   {(lnth xs n, lnth ys n)|n. enat n < min (llength xs) (llength ys)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lzip xs ys) =\n    {(lnth xs n, lnth ys n) |n. enat n < min (llength xs) (llength ys)}", "by(auto simp add: lset_conv_lnth lnth_lzip)(auto intro!: exI simp add: lnth_lzip)"], ["", "lemma lset_lzipD1: \"(x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> x \\<in> lset xs", "proof(induct \"lzip xs ys\" arbitrary: xs ys rule: lset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs xsa ys.\n       LCons (x, y) xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa\n 2. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "case [symmetric]: find"], ["proof (state)\nthis:\n  lzip xs ys = LCons (x, y) xs_\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa ys.\n       LCons (x, y) xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa\n 2. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "thus ?case"], ["proof (prove)\nusing this:\n  lzip xs ys = LCons (x, y) xs_\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by(auto simp add: lzip_eq_LCons_conv)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "case (step z zs)"], ["proof (state)\nthis:\n  (x, y) \\<in> lset zs\n  (x, y) \\<noteq> z\n  zs = lzip ?xs ?ys \\<Longrightarrow> x \\<in> lset ?xs\n  LCons z zs = lzip xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> x \\<in> lset xsa;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lset xsa", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> lset zs\n  (x, y) \\<noteq> z\n  zs = lzip ?xs ?ys \\<Longrightarrow> x \\<in> lset ?xs\n  LCons z zs = lzip xs ys\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs", "by -(drule sym, auto simp add: lzip_eq_LCons_conv)"], ["proof (state)\nthis:\n  x \\<in> lset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lzipD2: \"(x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> y \\<in> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> lset (lzip xs ys) \\<Longrightarrow> y \\<in> lset ys", "proof(induct \"lzip xs ys\" arbitrary: xs ys rule: lset_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs xsa ys.\n       LCons (x, y) xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys\n 2. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset ys", "case [symmetric]: find"], ["proof (state)\nthis:\n  lzip xs ys = LCons (x, y) xs_\n\ngoal (2 subgoals):\n 1. \\<And>xs xsa ys.\n       LCons (x, y) xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys\n 2. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset ys", "thus ?case"], ["proof (prove)\nusing this:\n  lzip xs ys = LCons (x, y) xs_\n\ngoal (1 subgoal):\n 1. y \\<in> lset ys", "by(auto simp add: lzip_eq_LCons_conv)"], ["proof (state)\nthis:\n  y \\<in> lset ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset ys", "case (step z zs)"], ["proof (state)\nthis:\n  (x, y) \\<in> lset zs\n  (x, y) \\<noteq> z\n  zs = lzip ?xs ?ys \\<Longrightarrow> y \\<in> lset ?ys\n  LCons z zs = lzip xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x' xs xsa ys.\n       \\<lbrakk>(x, y) \\<in> lset xs; (x, y) \\<noteq> x';\n        \\<And>xsa ys. xs = lzip xsa ys \\<Longrightarrow> y \\<in> lset ys;\n        LCons x' xs = lzip xsa ys\\<rbrakk>\n       \\<Longrightarrow> y \\<in> lset ys", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> lset zs\n  (x, y) \\<noteq> z\n  zs = lzip ?xs ?ys \\<Longrightarrow> y \\<in> lset ?ys\n  LCons z zs = lzip xs ys\n\ngoal (1 subgoal):\n 1. y \\<in> lset ys", "by -(drule sym, auto simp add: lzip_eq_LCons_conv)"], ["proof (state)\nthis:\n  y \\<in> lset ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lzip_same [simp]: \"lset (lzip xs xs) = (\\<lambda>x. (x, x)) ` lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lzip xs xs) = (\\<lambda>x. (x, x)) ` lset xs", "by(auto 4 3 simp add: lset_lzip in_lset_conv_lnth)"], ["", "lemma lfinite_lzip [simp]:\n  \"lfinite (lzip xs ys) \\<longleftrightarrow> lfinite xs \\<or> lfinite ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lzip xs ys) = (lfinite xs \\<or> lfinite ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lzip xs ys) \\<Longrightarrow> lfinite xs \\<or> lfinite ys\n 2. lfinite xs \\<or> lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (lzip xs ys)\n\ngoal (2 subgoals):\n 1. lfinite (lzip xs ys) \\<Longrightarrow> lfinite xs \\<or> lfinite ys\n 2. lfinite xs \\<or> lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (lzip xs ys)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> lfinite ys", "by(induct zs\\<equiv>\"lzip xs ys\" arbitrary: xs ys rule: lfinite_induct) fastforce+"], ["proof (state)\nthis:\n  lfinite xs \\<or> lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<or> lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "assume ?rhs (is \"?xs \\<or> ?ys\")"], ["proof (state)\nthis:\n  lfinite xs \\<or> lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs \\<or> lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite (lzip xs ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (lzip xs ys)\n 2. lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "assume ?xs"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (lzip xs ys)\n 2. lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lzip xs ys)", "proof(induct arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. lfinite (lzip LNil ys)\n 2. \\<And>xs x ys.\n       \\<lbrakk>lfinite xs; \\<And>ys. lfinite (lzip xs ys)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lzip (LCons x xs) ys)", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  lfinite (lzip xs ?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys. lfinite (lzip LNil ys)\n 2. \\<And>xs x ys.\n       \\<lbrakk>lfinite xs; \\<And>ys. lfinite (lzip xs ys)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lzip (LCons x xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  lfinite (lzip xs ?ys)\n\ngoal (1 subgoal):\n 1. lfinite (lzip (LCons x xs) ys)", "by(cases ys) simp_all"], ["proof (state)\nthis:\n  lfinite (lzip (LCons x xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys. lfinite (lzip LNil ys)", "qed simp"], ["proof (state)\nthis:\n  lfinite (lzip xs ys)\n\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "assume ?ys"], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite (lzip xs ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite (lzip xs ys)", "proof(induct arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. lfinite (lzip xs LNil)\n 2. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs; \\<And>xsa. lfinite (lzip xsa xs)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lzip xsa (LCons x xs))", "case (lfinite_LConsI ys y)"], ["proof (state)\nthis:\n  lfinite ys\n  lfinite (lzip ?xs ys)\n\ngoal (2 subgoals):\n 1. \\<And>xs. lfinite (lzip xs LNil)\n 2. \\<And>xs x xsa.\n       \\<lbrakk>lfinite xs; \\<And>xsa. lfinite (lzip xsa xs)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lzip xsa (LCons x xs))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite ys\n  lfinite (lzip ?xs ys)\n\ngoal (1 subgoal):\n 1. lfinite (lzip xs (LCons y ys))", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  lfinite (lzip xs (LCons y ys))\n\ngoal (1 subgoal):\n 1. \\<And>xs. lfinite (lzip xs LNil)", "qed simp"], ["proof (state)\nthis:\n  lfinite (lzip xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (lzip xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lzip_eq_lappend_conv:\n  assumes eq: \"lzip xs ys = lappend us vs\"\n  shows \"\\<exists>xs' xs'' ys' ys''. xs = lappend xs' xs'' \\<and> ys = lappend ys' ys'' \\<and>\n                             llength xs' = llength ys' \\<and> us = lzip xs' ys' \\<and>\n                             vs = lzip xs'' ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?xs' = \"ltake (llength us) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?xs'' = \"ldrop (llength us) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?ys' = \"ltake (llength us) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?ys'' = \"ldrop (llength us) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "from eq"], ["proof (chain)\npicking this:\n  lzip xs ys = lappend us vs", "have \"llength (lzip xs ys) = llength (lappend us vs)\""], ["proof (prove)\nusing this:\n  lzip xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. llength (lzip xs ys) = llength (lappend us vs)", "by simp"], ["proof (state)\nthis:\n  llength (lzip xs ys) = llength (lappend us vs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "hence \"min (llength xs) (llength ys) \\<ge> llength us\""], ["proof (prove)\nusing this:\n  llength (lzip xs ys) = llength (lappend us vs)\n\ngoal (1 subgoal):\n 1. llength us \\<le> min (llength xs) (llength ys)", "by(auto simp add: enat_le_plus_same)"], ["proof (state)\nthis:\n  llength us \\<le> min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "hence len: \"llength xs \\<ge> llength us\" \"llength ys \\<ge> llength us\""], ["proof (prove)\nusing this:\n  llength us \\<le> min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. llength us \\<le> llength xs &&& llength us \\<le> llength ys", "by(auto)"], ["proof (state)\nthis:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "hence leneq: \"llength ?xs' = llength ?ys'\""], ["proof (prove)\nusing this:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n\ngoal (1 subgoal):\n 1. llength (ltake (llength us) xs) = llength (ltake (llength us) ys)", "by(simp add: min_def)"], ["proof (state)\nthis:\n  llength (ltake (llength us) xs) = llength (ltake (llength us) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "have xs: \"xs = lappend ?xs' ?xs''\" and ys: \"ys = lappend ?ys' ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs) &&&\n    ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)", "by(simp_all add: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs)\n  ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "hence \"lappend us vs = lzip (lappend ?xs' ?xs'') (lappend ?ys' ?ys'')\""], ["proof (prove)\nusing this:\n  xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs)\n  ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)\n\ngoal (1 subgoal):\n 1. lappend us vs =\n    lzip (lappend (ltake (llength us) xs) (ldrop (llength us) xs))\n     (lappend (ltake (llength us) ys) (ldrop (llength us) ys))", "using eq"], ["proof (prove)\nusing this:\n  xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs)\n  ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)\n  lzip xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. lappend us vs =\n    lzip (lappend (ltake (llength us) xs) (ldrop (llength us) xs))\n     (lappend (ltake (llength us) ys) (ldrop (llength us) ys))", "by simp"], ["proof (state)\nthis:\n  lappend us vs =\n  lzip (lappend (ltake (llength us) xs) (ldrop (llength us) xs))\n   (lappend (ltake (llength us) ys) (ldrop (llength us) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "with len"], ["proof (chain)\npicking this:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  lappend us vs =\n  lzip (lappend (ltake (llength us) xs) (ldrop (llength us) xs))\n   (lappend (ltake (llength us) ys) (ldrop (llength us) ys))", "have \"lappend us vs = lappend (lzip ?xs' ?ys') (lzip ?xs'' ?ys'')\""], ["proof (prove)\nusing this:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  lappend us vs =\n  lzip (lappend (ltake (llength us) xs) (ldrop (llength us) xs))\n   (lappend (ltake (llength us) ys) (ldrop (llength us) ys))\n\ngoal (1 subgoal):\n 1. lappend us vs =\n    lappend (lzip (ltake (llength us) xs) (ltake (llength us) ys))\n     (lzip (ldrop (llength us) xs) (ldrop (llength us) ys))", "by(simp add: lzip_lappend min_def)"], ["proof (state)\nthis:\n  lappend us vs =\n  lappend (lzip (ltake (llength us) xs) (ltake (llength us) ys))\n   (lzip (ldrop (llength us) xs) (ldrop (llength us) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "hence us: \"us = lzip ?xs' ?ys'\"\n    and vs: \"lfinite us \\<longrightarrow> vs = lzip ?xs'' ?ys''\""], ["proof (prove)\nusing this:\n  lappend us vs =\n  lappend (lzip (ltake (llength us) xs) (ltake (llength us) ys))\n   (lzip (ldrop (llength us) xs) (ldrop (llength us) ys))\n\ngoal (1 subgoal):\n 1. us = lzip (ltake (llength us) xs) (ltake (llength us) ys) &&&\n    lfinite us \\<longrightarrow>\n    vs = lzip (ldrop (llength us) xs) (ldrop (llength us) ys)", "using len"], ["proof (prove)\nusing this:\n  lappend us vs =\n  lappend (lzip (ltake (llength us) xs) (ltake (llength us) ys))\n   (lzip (ldrop (llength us) xs) (ldrop (llength us) ys))\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n\ngoal (1 subgoal):\n 1. us = lzip (ltake (llength us) xs) (ltake (llength us) ys) &&&\n    lfinite us \\<longrightarrow>\n    vs = lzip (ldrop (llength us) xs) (ldrop (llength us) ys)", "by(simp_all add: min_def lappend_eq_lappend_conv)"], ["proof (state)\nthis:\n  us = lzip (ltake (llength us) xs) (ltake (llength us) ys)\n  lfinite us \\<longrightarrow>\n  vs = lzip (ldrop (llength us) xs) (ldrop (llength us) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "proof(cases \"lfinite us\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''\n 2. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "case True"], ["proof (state)\nthis:\n  lfinite us\n\ngoal (2 subgoals):\n 1. lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''\n 2. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "with leneq xs ys us vs len"], ["proof (chain)\npicking this:\n  llength (ltake (llength us) xs) = llength (ltake (llength us) ys)\n  xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs)\n  ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)\n  us = lzip (ltake (llength us) xs) (ltake (llength us) ys)\n  lfinite us \\<longrightarrow>\n  vs = lzip (ldrop (llength us) xs) (ldrop (llength us) ys)\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  lfinite us", "show ?thesis"], ["proof (prove)\nusing this:\n  llength (ltake (llength us) xs) = llength (ltake (llength us) ys)\n  xs = lappend (ltake (llength us) xs) (ldrop (llength us) xs)\n  ys = lappend (ltake (llength us) ys) (ldrop (llength us) ys)\n  us = lzip (ltake (llength us) xs) (ltake (llength us) ys)\n  lfinite us \\<longrightarrow>\n  vs = lzip (ldrop (llength us) xs) (ldrop (llength us) ys)\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  lfinite us\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs' xs'' ys' ys''.\n     xs = lappend xs' xs'' \\<and>\n     ys = lappend ys' ys'' \\<and>\n     llength xs' = llength ys' \\<and>\n     us = lzip xs' ys' \\<and> vs = lzip xs'' ys''\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite us\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?xs'' = \"lmap fst vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "let ?ys'' = \"lmap snd vs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "from False"], ["proof (chain)\npicking this:\n  \\<not> lfinite us", "have \"lappend us vs = us\""], ["proof (prove)\nusing this:\n  \\<not> lfinite us\n\ngoal (1 subgoal):\n 1. lappend us vs = us", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  lappend us vs = us\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "moreover"], ["proof (state)\nthis:\n  lappend us vs = us\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "from False"], ["proof (chain)\npicking this:\n  \\<not> lfinite us", "have \"llength us = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> lfinite us\n\ngoal (1 subgoal):\n 1. llength us = \\<infinity>", "by(rule not_lfinite_llength)"], ["proof (state)\nthis:\n  llength us = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "moreover"], ["proof (state)\nthis:\n  llength us = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "with len"], ["proof (chain)\npicking this:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  llength us = \\<infinity>", "have \"llength xs = \\<infinity>\" \"llength ys = \\<infinity>\""], ["proof (prove)\nusing this:\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n  llength us = \\<infinity>\n\ngoal (1 subgoal):\n 1. llength xs = \\<infinity> &&& llength ys = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "moreover"], ["proof (state)\nthis:\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "with \\<open>llength us = \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  llength us = \\<infinity>\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>", "have \"xs = ?xs'\" \"ys = ?ys'\""], ["proof (prove)\nusing this:\n  llength us = \\<infinity>\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n\ngoal (1 subgoal):\n 1. xs = ltake (llength us) xs &&& ys = ltake (llength us) ys", "by(simp_all add: ltake_all)"], ["proof (state)\nthis:\n  xs = ltake (llength us) xs\n  ys = ltake (llength us) ys\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "from \\<open>llength us = \\<infinity>\\<close> len"], ["proof (chain)\npicking this:\n  llength us = \\<infinity>\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys", "have \"\\<not> lfinite ?xs'\" \"\\<not> lfinite ?ys'\""], ["proof (prove)\nusing this:\n  llength us = \\<infinity>\n  llength us \\<le> llength xs\n  llength us \\<le> llength ys\n\ngoal (1 subgoal):\n 1. \\<not> lfinite (ltake (llength us) xs) &&&\n    \\<not> lfinite (ltake (llength us) ys)", "by(auto simp del: llength_ltake lfinite_ltake\n             simp add: ltake_all dest: lfinite_llength_enat)"], ["proof (state)\nthis:\n  \\<not> lfinite (ltake (llength us) xs)\n  \\<not> lfinite (ltake (llength us) ys)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "with \\<open>xs = ?xs'\\<close> \\<open>ys = ?ys'\\<close>"], ["proof (chain)\npicking this:\n  xs = ltake (llength us) xs\n  ys = ltake (llength us) ys\n  \\<not> lfinite (ltake (llength us) xs)\n  \\<not> lfinite (ltake (llength us) ys)", "have \"xs = lappend ?xs' ?xs''\" \"ys = lappend ?ys' ?ys''\""], ["proof (prove)\nusing this:\n  xs = ltake (llength us) xs\n  ys = ltake (llength us) ys\n  \\<not> lfinite (ltake (llength us) xs)\n  \\<not> lfinite (ltake (llength us) ys)\n\ngoal (1 subgoal):\n 1. xs = lappend (ltake (llength us) xs) (lmap fst vs) &&&\n    ys = lappend (ltake (llength us) ys) (lmap snd vs)", "by(simp_all add: lappend_inf)"], ["proof (state)\nthis:\n  xs = lappend (ltake (llength us) xs) (lmap fst vs)\n  ys = lappend (ltake (llength us) ys) (lmap snd vs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "moreover"], ["proof (state)\nthis:\n  xs = lappend (ltake (llength us) xs) (lmap fst vs)\n  ys = lappend (ltake (llength us) ys) (lmap snd vs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "have \"vs = lzip ?xs'' ?ys''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs = lzip (lmap fst vs) (lmap snd vs)", "by(coinduction arbitrary: vs) auto"], ["proof (state)\nthis:\n  vs = lzip (lmap fst vs) (lmap snd vs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite us \\<Longrightarrow>\n    \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "ultimately"], ["proof (chain)\npicking this:\n  lappend us vs = us\n  llength us = \\<infinity>\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n  xs = lappend (ltake (llength us) xs) (lmap fst vs)\n  ys = lappend (ltake (llength us) ys) (lmap snd vs)\n  vs = lzip (lmap fst vs) (lmap snd vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  lappend us vs = us\n  llength us = \\<infinity>\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n  xs = lappend (ltake (llength us) xs) (lmap fst vs)\n  ys = lappend (ltake (llength us) ys) (lmap snd vs)\n  vs = lzip (lmap fst vs) (lmap snd vs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "using eq"], ["proof (prove)\nusing this:\n  lappend us vs = us\n  llength us = \\<infinity>\n  llength xs = \\<infinity>\n  llength ys = \\<infinity>\n  xs = lappend (ltake (llength us) xs) (lmap fst vs)\n  ys = lappend (ltake (llength us) ys) (lmap snd vs)\n  vs = lzip (lmap fst vs) (lmap snd vs)\n  lzip xs ys = lappend us vs\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' ys' ys''.\n       xs = lappend xs' xs'' \\<and>\n       ys = lappend ys' ys'' \\<and>\n       llength xs' = llength ys' \\<and>\n       us = lzip xs' ys' \\<and> vs = lzip xs'' ys''", "by(fastforce simp add: ltake_all)"], ["proof (state)\nthis:\n  \\<exists>xs' xs'' ys' ys''.\n     xs = lappend xs' xs'' \\<and>\n     ys = lappend ys' ys'' \\<and>\n     llength xs' = llength ys' \\<and>\n     us = lzip xs' ys' \\<and> vs = lzip xs'' ys''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs' xs'' ys' ys''.\n     xs = lappend xs' xs'' \\<and>\n     ys = lappend ys' ys'' \\<and>\n     llength xs' = llength ys' \\<and>\n     us = lzip xs' ys' \\<and> vs = lzip xs'' ys''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lzip_lmap [simp]:\n  \"lzip (lmap f xs) (lmap g ys) = lmap (\\<lambda>(x, y). (f x, g y)) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (lmap f xs) (lmap g ys) =\n    lmap (\\<lambda>(x, y). (f x, g y)) (lzip xs ys)", "by(coinduction arbitrary: xs ys) auto"], ["", "lemma lzip_lmap1:\n  \"lzip (lmap f xs) ys = lmap (\\<lambda>(x, y). (f x, y)) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (lmap f xs) ys = lmap (\\<lambda>(x, y). (f x, y)) (lzip xs ys)", "by(subst (4) llist.map_ident[symmetric])(simp only: lzip_lmap)"], ["", "lemma lzip_lmap2:\n  \"lzip xs (lmap f ys) = lmap (\\<lambda>(x, y). (x, f y)) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs (lmap f ys) = lmap (\\<lambda>(x, y). (x, f y)) (lzip xs ys)", "by(subst (1) llist.map_ident[symmetric])(simp only: lzip_lmap)"], ["", "lemma lmap_fst_lzip_conv_ltake:\n  \"lmap fst (lzip xs ys) = ltake (min (llength xs) (llength ys)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst (lzip xs ys) = ltake (min (llength xs) (llength ys)) xs", "by(coinduction arbitrary: xs ys)(auto simp add: enat_min_eq_0_iff ltl_ltake epred_llength)"], ["", "lemma lmap_snd_lzip_conv_ltake:\n  \"lmap snd (lzip xs ys) = ltake (min (llength xs) (llength ys)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap snd (lzip xs ys) = ltake (min (llength xs) (llength ys)) ys", "by(coinduction arbitrary: xs ys)(auto simp add: enat_min_eq_0_iff ltl_ltake epred_llength)"], ["", "lemma lzip_conv_lzip_ltake_min_llength:\n  \"lzip xs ys =\n  lzip (ltake (min (llength xs) (llength ys)) xs)\n       (ltake (min (llength xs) (llength ys)) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs ys =\n    lzip (ltake (min (llength xs) (llength ys)) xs)\n     (ltake (min (llength xs) (llength ys)) ys)", "by(coinduction arbitrary: xs ys)(auto simp add: enat_min_eq_0_iff ltl_ltake epred_llength)"], ["", "subsection \\<open>Taking and dropping from a lazy list: @{term \"ltakeWhile\"} and @{term \"ldropWhile\"}\\<close>"], ["", "lemma ltakeWhile_simps [simp, code, nitpick_simp]:\n  shows ltakeWhile_LNil: \"ltakeWhile P LNil = LNil\"\n  and ltakeWhile_LCons: \"ltakeWhile P (LCons x xs) = (if P x then LCons x (ltakeWhile P xs) else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P LNil = LNil &&&\n    ltakeWhile P (LCons x xs) =\n    (if P x then LCons x (ltakeWhile P xs) else LNil)", "by(auto simp add: ltakeWhile_def intro: llist.expand)"], ["", "lemma ldropWhile_simps [simp, code]:\n  shows ldropWhile_LNil: \"ldropWhile P LNil = LNil\"\n  and ldropWhile_LCons: \"ldropWhile P (LCons x xs) = (if P x then ldropWhile P xs else LCons x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P LNil = LNil &&&\n    ldropWhile P (LCons x xs) =\n    (if P x then ldropWhile P xs else LCons x xs)", "by(simp_all add: ldropWhile.simps)"], ["", "lemma fixes f F P\n  defines \"F \\<equiv> \\<lambda>ltakeWhile xs. case xs of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> if P x then LCons x (ltakeWhile xs) else LNil\"\n  shows ltakeWhile_conv_fixp: \"ltakeWhile P \\<equiv> ccpo.fixp (fun_lub lSup) (fun_ord lprefix) F\" (is \"?lhs \\<equiv> ?rhs\")\n  and ltakeWhile_mono: \"\\<And>xs. mono_llist (\\<lambda>ltakeWhile. F ltakeWhile xs)\" (is \"PROP ?mono\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltakeWhile P \\<equiv> llist.fixp_fun F) &&&\n    (\\<And>xs. mono_llist (\\<lambda>ltakeWhile. F ltakeWhile xs))", "proof(intro eq_reflection ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. ltakeWhile P x = llist.fixp_fun F x\n 2. \\<And>xs. mono_llist (\\<lambda>ltakeWhile. F ltakeWhile xs)", "show mono: \"PROP ?mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. mono_llist (\\<lambda>ltakeWhile. F ltakeWhile xs)", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mono_llist\n        (\\<lambda>ltakeWhile.\n            case xs of LNil \\<Rightarrow> LNil\n            | LCons x xs \\<Rightarrow>\n                if P x then LCons x (ltakeWhile xs) else LNil)", "by(tactic \\<open>Partial_Function.mono_tac @{context} 1\\<close>)"], ["proof (state)\nthis:\n  mono_llist (\\<lambda>ltakeWhile. F ltakeWhile ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>x. ltakeWhile P x = llist.fixp_fun F x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ltakeWhile P x = llist.fixp_fun F x", "show \"?lhs xs = ?rhs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P xs = llist.fixp_fun F xs", "proof(coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P xs) = lnull (llist.fixp_fun F xs) \\<and>\n       (\\<not> lnull (ltakeWhile P xs) \\<longrightarrow>\n        \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n        lhd (ltakeWhile P xs) = lhd (llist.fixp_fun F xs) \\<and>\n        (\\<exists>xsa.\n            ltl (ltakeWhile P xs) = ltakeWhile P xsa \\<and>\n            ltl (llist.fixp_fun F xs) = llist.fixp_fun F xsa))", "case Eq_llist"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P xs) = lnull (llist.fixp_fun F xs) \\<and>\n       (\\<not> lnull (ltakeWhile P xs) \\<longrightarrow>\n        \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n        lhd (ltakeWhile P xs) = lhd (llist.fixp_fun F xs) \\<and>\n        (\\<exists>xsa.\n            ltl (ltakeWhile P xs) = ltakeWhile P xsa \\<and>\n            ltl (llist.fixp_fun F xs) = llist.fixp_fun F xsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltakeWhile P xs) = lnull (llist.fixp_fun F xs) \\<and>\n    (\\<not> lnull (ltakeWhile P xs) \\<longrightarrow>\n     \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n     lhd (ltakeWhile P xs) = lhd (llist.fixp_fun F xs) \\<and>\n     (\\<exists>xs.\n         ltl (ltakeWhile P xs) = ltakeWhile P xs \\<and>\n         ltl (llist.fixp_fun F xs) = llist.fixp_fun F xs))", "by(subst (1 3 4) llist.mono_body_fixp[OF mono])(auto simp add: F_def split: llist.split prod.split co.enat.split)"], ["proof (state)\nthis:\n  lnull (ltakeWhile P xs) = lnull (llist.fixp_fun F xs) \\<and>\n  (\\<not> lnull (ltakeWhile P xs) \\<longrightarrow>\n   \\<not> lnull (llist.fixp_fun F xs) \\<longrightarrow>\n   lhd (ltakeWhile P xs) = lhd (llist.fixp_fun F xs) \\<and>\n   (\\<exists>xs.\n       ltl (ltakeWhile P xs) = ltakeWhile P xs \\<and>\n       ltl (llist.fixp_fun F xs) = llist.fixp_fun F xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ltakeWhile P xs = llist.fixp_fun F xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono2mono_ltakeWhile[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ltakeWhile: \"monotone lprefix lprefix (ltakeWhile P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ltakeWhile P)", "by(rule llist.fixp_preserves_mono1[OF ltakeWhile_mono ltakeWhile_conv_fixp]) simp"], ["", "lemma mcont2mcont_ltakeWhile [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ltakeWhile: \"mcont lSup lprefix lSup lprefix (ltakeWhile P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ltakeWhile P)", "by(rule llist.fixp_preserves_mcont1[OF ltakeWhile_mono ltakeWhile_conv_fixp]) simp"], ["", "lemma mono_llist_ltakeWhile [partial_function_mono]:\n  \"mono_llist F \\<Longrightarrow> mono_llist (\\<lambda>f. ltakeWhile P (F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist F \\<Longrightarrow>\n    mono_llist (\\<lambda>f. ltakeWhile P (F f))", "by(rule mono2mono_ltakeWhile)"], ["", "lemma mono2mono_ldropWhile [THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_ldropWhile: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldropWhile P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (ldropWhile P)", "by(rule llist.fixp_preserves_mono1[OF ldropWhile.mono ldropWhile_def]) simp"], ["", "lemma mcont2mcont_ldropWhile [THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_ldropWhile: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldropWhile P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (ldropWhile P)", "by(rule llist.fixp_preserves_mcont1[OF ldropWhile.mono ldropWhile_def]) simp"], ["", "lemma lnull_ltakeWhile [simp]: \"lnull (ltakeWhile P xs) \\<longleftrightarrow> (\\<not> lnull xs \\<longrightarrow> \\<not> P (lhd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltakeWhile P xs) =\n    (\\<not> lnull xs \\<longrightarrow> \\<not> P (lhd xs))", "by(cases xs) simp_all"], ["", "lemma ltakeWhile_eq_LNil_iff: \"ltakeWhile P xs = LNil \\<longleftrightarrow> (xs \\<noteq> LNil \\<longrightarrow> \\<not> P (lhd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltakeWhile P xs = LNil) =\n    (xs \\<noteq> LNil \\<longrightarrow> \\<not> P (lhd xs))", "using lnull_ltakeWhile"], ["proof (prove)\nusing this:\n  lnull (ltakeWhile ?P ?xs) =\n  (\\<not> lnull ?xs \\<longrightarrow> \\<not> ?P (lhd ?xs))\n\ngoal (1 subgoal):\n 1. (ltakeWhile P xs = LNil) =\n    (xs \\<noteq> LNil \\<longrightarrow> \\<not> P (lhd xs))", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  (ltakeWhile ?P ?xs = LNil) =\n  (?xs \\<noteq> LNil \\<longrightarrow> \\<not> ?P (lhd ?xs))\n\ngoal (1 subgoal):\n 1. (ltakeWhile P xs = LNil) =\n    (xs \\<noteq> LNil \\<longrightarrow> \\<not> P (lhd xs))", "."], ["", "lemmas lhd_ltakeWhile = ltakeWhile.sel(1)"], ["", "lemma ltl_ltakeWhile:\n  \"ltl (ltakeWhile P xs) = (if P (lhd xs) then ltakeWhile P (ltl xs) else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ltakeWhile P xs) =\n    (if P (lhd xs) then ltakeWhile P (ltl xs) else LNil)", "by(cases xs) simp_all"], ["", "lemma lprefix_ltakeWhile: \"ltakeWhile P xs \\<sqsubseteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P xs \\<sqsubseteq> xs", "by(coinduction arbitrary: xs)(auto simp add: ltl_ltakeWhile)"], ["", "lemma llength_ltakeWhile_le: \"llength (ltakeWhile P xs) \\<le> llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltakeWhile P xs) \\<le> llength xs", "by(rule lprefix_llength_le)(rule lprefix_ltakeWhile)"], ["", "lemma ltakeWhile_nth: \"enat i < llength (ltakeWhile P xs) \\<Longrightarrow> lnth (ltakeWhile P xs) i = lnth xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < llength (ltakeWhile P xs) \\<Longrightarrow>\n    lnth (ltakeWhile P xs) i = lnth xs i", "by(rule lprefix_lnthD[OF lprefix_ltakeWhile])"], ["", "lemma ltakeWhile_all: \"\\<forall>x\\<in>lset xs. P x \\<Longrightarrow> ltakeWhile P xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> ltakeWhile P xs = xs", "by(coinduction arbitrary: xs)(auto 4 3 simp add: ltl_ltakeWhile simp del: ltakeWhile.disc_iff dest: in_lset_ltlD)"], ["", "lemma lset_ltakeWhileD:\n  assumes \"x \\<in> lset (ltakeWhile P xs)\"\n  shows \"x \\<in> lset xs \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<and> P x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> lset (ltakeWhile P xs)\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs \\<and> P x", "by(induct ys\\<equiv>\"ltakeWhile P xs\" arbitrary: xs rule: llist_set_induct)(auto simp add: ltl_ltakeWhile dest: in_lset_ltlD)"], ["", "lemma lset_ltakeWhile_subset:\n  \"lset (ltakeWhile P xs) \\<subseteq> lset xs \\<inter> {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ltakeWhile P xs) \\<subseteq> lset xs \\<inter> {x. P x}", "by(auto dest: lset_ltakeWhileD)"], ["", "lemma ltakeWhile_all_conv: \"ltakeWhile P xs = xs \\<longleftrightarrow> lset xs \\<subseteq> {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltakeWhile P xs = xs) = (lset xs \\<subseteq> {x. P x})", "by (metis Int_Collect Int_absorb2 le_infE lset_ltakeWhile_subset ltakeWhile_all)"], ["", "lemma llength_ltakeWhile_all: \"llength (ltakeWhile P xs) = llength xs \\<longleftrightarrow> ltakeWhile P xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (ltakeWhile P xs) = llength xs) = (ltakeWhile P xs = xs)", "by(auto intro: lprefix_llength_eq_imp_eq lprefix_ltakeWhile)"], ["", "lemma ldropWhile_eq_LNil_iff: \"ldropWhile P xs = LNil \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldropWhile P xs = LNil) = (\\<forall>x\\<in>lset xs. P x)", "by(induct xs) simp_all"], ["", "lemma lnull_ldropWhile [simp]:\n  \"lnull (ldropWhile P xs) \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ldropWhile P xs) = (\\<forall>x\\<in>lset xs. P x)", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldropWhile P xs = LNil) = (\\<forall>x\\<in>lset xs. P x)", "by(simp add: ldropWhile_eq_LNil_iff)"], ["", "lemma lset_ldropWhile_subset:\n  \"lset (ldropWhile P xs) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ldropWhile P xs) \\<subseteq> lset xs", "by(induct xs) auto"], ["", "lemma in_lset_ldropWhileD: \"x \\<in> lset (ldropWhile P xs) \\<Longrightarrow> x \\<in> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lset (ldropWhile P xs) \\<Longrightarrow> x \\<in> lset xs", "using lset_ldropWhile_subset[of P xs]"], ["proof (prove)\nusing this:\n  lset (ldropWhile P xs) \\<subseteq> lset xs\n\ngoal (1 subgoal):\n 1. x \\<in> lset (ldropWhile P xs) \\<Longrightarrow> x \\<in> lset xs", "by auto"], ["", "lemma ltakeWhile_lmap: \"ltakeWhile P (lmap f xs) = lmap f (ltakeWhile (P \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P (lmap f xs) = lmap f (ltakeWhile (P \\<circ> f) xs)", "by(coinduction arbitrary: xs)(auto simp add: ltl_ltakeWhile)"], ["", "lemma ldropWhile_lmap: \"ldropWhile P (lmap f xs) = lmap f (ldropWhile (P \\<circ> f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P (lmap f xs) = lmap f (ldropWhile (P \\<circ> f) xs)", "by(induct xs) simp_all"], ["", "lemma llength_ltakeWhile_lt_iff: \"llength (ltakeWhile P xs) < llength xs \\<longleftrightarrow> (\\<exists>x\\<in>lset xs. \\<not> P x)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (ltakeWhile P xs) < llength xs) =\n    (\\<exists>x\\<in>lset xs. \\<not> P x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llength (ltakeWhile P xs) < llength xs \\<Longrightarrow>\n    \\<exists>x\\<in>lset xs. \\<not> P x\n 2. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "assume ?lhs"], ["proof (state)\nthis:\n  llength (ltakeWhile P xs) < llength xs\n\ngoal (2 subgoals):\n 1. llength (ltakeWhile P xs) < llength xs \\<Longrightarrow>\n    \\<exists>x\\<in>lset xs. \\<not> P x\n 2. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "hence \"ltakeWhile P xs \\<noteq> xs\""], ["proof (prove)\nusing this:\n  llength (ltakeWhile P xs) < llength xs\n\ngoal (1 subgoal):\n 1. ltakeWhile P xs \\<noteq> xs", "by auto"], ["proof (state)\nthis:\n  ltakeWhile P xs \\<noteq> xs\n\ngoal (2 subgoals):\n 1. llength (ltakeWhile P xs) < llength xs \\<Longrightarrow>\n    \\<exists>x\\<in>lset xs. \\<not> P x\n 2. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "thus ?rhs"], ["proof (prove)\nusing this:\n  ltakeWhile P xs \\<noteq> xs\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x", "by(auto simp add: ltakeWhile_all_conv)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "hence \"ltakeWhile P xs \\<noteq> xs\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. ltakeWhile P xs \\<noteq> xs", "by(auto simp add: ltakeWhile_all_conv)"], ["proof (state)\nthis:\n  ltakeWhile P xs \\<noteq> xs\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    llength (ltakeWhile P xs) < llength xs", "thus ?lhs"], ["proof (prove)\nusing this:\n  ltakeWhile P xs \\<noteq> xs\n\ngoal (1 subgoal):\n 1. llength (ltakeWhile P xs) < llength xs", "unfolding llength_ltakeWhile_all[symmetric]"], ["proof (prove)\nusing this:\n  llength (ltakeWhile P xs) \\<noteq> llength xs\n\ngoal (1 subgoal):\n 1. llength (ltakeWhile P xs) < llength xs", "using llength_ltakeWhile_le[of P xs]"], ["proof (prove)\nusing this:\n  llength (ltakeWhile P xs) \\<noteq> llength xs\n  llength (ltakeWhile P xs) \\<le> llength xs\n\ngoal (1 subgoal):\n 1. llength (ltakeWhile P xs) < llength xs", "by(auto)"], ["proof (state)\nthis:\n  llength (ltakeWhile P xs) < llength xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltakeWhile_K_False [simp]: \"ltakeWhile (\\<lambda>_. False) xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile (\\<lambda>_. False) xs = LNil", "by(simp add: ltakeWhile_def)"], ["", "lemma ltakeWhile_K_True [simp]: \"ltakeWhile (\\<lambda>_. True) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile (\\<lambda>_. True) xs = xs", "by(coinduction arbitrary: xs) simp"], ["", "lemma ldropWhile_K_False [simp]: \"ldropWhile (\\<lambda>_. False) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile (\\<lambda>_. False) = id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ldropWhile (\\<lambda>_. False) x = id x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ldropWhile (\\<lambda>_. False) x = id x", "show \"ldropWhile (\\<lambda>_. False) xs = id xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile (\\<lambda>_. False) xs = id xs", "by(induct xs) simp_all"], ["proof (state)\nthis:\n  ldropWhile (\\<lambda>_. False) xs = id xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_K_True [simp]: \"ldropWhile (\\<lambda>_. True) xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile (\\<lambda>_. True) xs = LNil", "by(induct xs)(simp_all)"], ["", "lemma lappend_ltakeWhile_ldropWhile [simp]:\n  \"lappend (ltakeWhile P xs) (ldropWhile P xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (ltakeWhile P xs) (ldropWhile P xs) = xs", "by(coinduction arbitrary: xs rule: llist.coinduct_strong)(auto 4 4 simp add: not_lnull_conv lset_lnull intro: ccontr)"], ["", "lemma ltakeWhile_lappend:\n  \"ltakeWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n   else lappend xs (ltakeWhile P ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n     else lappend xs (ltakeWhile P ys))", "proof(coinduction arbitrary: xs rule: llist.coinduct_strong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P (lappend xs ys)) =\n       lnull\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n       (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n        \\<not> lnull\n                (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                 else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n        lhd (ltakeWhile P (lappend xs ys)) =\n        lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<and>\n        ((\\<exists>xsa.\n             ltl (ltakeWhile P (lappend xs ys)) =\n             ltakeWhile P (lappend xsa ys) \\<and>\n             ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                  else lappend xs (ltakeWhile P ys)) =\n             (if \\<exists>x\\<in>lset xsa. \\<not> P x then ltakeWhile P xsa\n              else lappend xsa (ltakeWhile P ys))) \\<or>\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys))))", "case (Eq_llist xs)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P (lappend xs ys)) =\n       lnull\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n       (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n        \\<not> lnull\n                (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                 else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n        lhd (ltakeWhile P (lappend xs ys)) =\n        lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<and>\n        ((\\<exists>xsa.\n             ltl (ltakeWhile P (lappend xs ys)) =\n             ltakeWhile P (lappend xsa ys) \\<and>\n             ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                  else lappend xs (ltakeWhile P ys)) =\n             (if \\<exists>x\\<in>lset xsa. \\<not> P x then ltakeWhile P xsa\n              else lappend xsa (ltakeWhile P ys))) \\<or>\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys))))", "have ?lnull"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (ltakeWhile P (lappend xs ys)) =\n    lnull\n     (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n      else lappend xs (ltakeWhile P ys))", "by(auto simp add: lset_lnull)"], ["proof (state)\nthis:\n  lnull (ltakeWhile P (lappend xs ys)) =\n  lnull\n   (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n    else lappend xs (ltakeWhile P ys))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P (lappend xs ys)) =\n       lnull\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n       (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n        \\<not> lnull\n                (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                 else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n        lhd (ltakeWhile P (lappend xs ys)) =\n        lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<and>\n        ((\\<exists>xsa.\n             ltl (ltakeWhile P (lappend xs ys)) =\n             ltakeWhile P (lappend xsa ys) \\<and>\n             ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                  else lappend xs (ltakeWhile P ys)) =\n             (if \\<exists>x\\<in>lset xsa. \\<not> P x then ltakeWhile P xsa\n              else lappend xsa (ltakeWhile P ys))) \\<or>\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys))))", "moreover"], ["proof (state)\nthis:\n  lnull (ltakeWhile P (lappend xs ys)) =\n  lnull\n   (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n    else lappend xs (ltakeWhile P ys))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P (lappend xs ys)) =\n       lnull\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n       (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n        \\<not> lnull\n                (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                 else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n        lhd (ltakeWhile P (lappend xs ys)) =\n        lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<and>\n        ((\\<exists>xsa.\n             ltl (ltakeWhile P (lappend xs ys)) =\n             ltakeWhile P (lappend xsa ys) \\<and>\n             ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                  else lappend xs (ltakeWhile P ys)) =\n             (if \\<exists>x\\<in>lset xsa. \\<not> P x then ltakeWhile P xsa\n              else lappend xsa (ltakeWhile P ys))) \\<or>\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys))))", "have ?LCons"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n    \\<not> lnull\n            (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n    lhd (ltakeWhile P (lappend xs ys)) =\n    lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n    ((\\<exists>xs.\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltakeWhile P (lappend xs ys) \\<and>\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys)) =\n         (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n          else lappend xs (ltakeWhile P ys))) \\<or>\n     ltl (ltakeWhile P (lappend xs ys)) =\n     ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n          else lappend xs (ltakeWhile P ys)))", "by(clarsimp split: if_split_asm split del: if_split simp add: ltl_ltakeWhile)(auto 4 3 simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  \\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n  \\<not> lnull\n          (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n           else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n  lhd (ltakeWhile P (lappend xs ys)) =\n  lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n       else lappend xs (ltakeWhile P ys)) \\<and>\n  ((\\<exists>xs.\n       ltl (ltakeWhile P (lappend xs ys)) =\n       ltakeWhile P (lappend xs ys) \\<and>\n       ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n            else lappend xs (ltakeWhile P ys)) =\n       (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys))) \\<or>\n   ltl (ltakeWhile P (lappend xs ys)) =\n   ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys)))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       lnull (ltakeWhile P (lappend xs ys)) =\n       lnull\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys)) \\<and>\n       (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n        \\<not> lnull\n                (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                 else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n        lhd (ltakeWhile P (lappend xs ys)) =\n        lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) \\<and>\n        ((\\<exists>xsa.\n             ltl (ltakeWhile P (lappend xs ys)) =\n             ltakeWhile P (lappend xsa ys) \\<and>\n             ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n                  else lappend xs (ltakeWhile P ys)) =\n             (if \\<exists>x\\<in>lset xsa. \\<not> P x then ltakeWhile P xsa\n              else lappend xsa (ltakeWhile P ys))) \\<or>\n         ltl (ltakeWhile P (lappend xs ys)) =\n         ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys))))", "ultimately"], ["proof (chain)\npicking this:\n  lnull (ltakeWhile P (lappend xs ys)) =\n  lnull\n   (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n    else lappend xs (ltakeWhile P ys))\n  \\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n  \\<not> lnull\n          (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n           else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n  lhd (ltakeWhile P (lappend xs ys)) =\n  lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n       else lappend xs (ltakeWhile P ys)) \\<and>\n  ((\\<exists>xs.\n       ltl (ltakeWhile P (lappend xs ys)) =\n       ltakeWhile P (lappend xs ys) \\<and>\n       ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n            else lappend xs (ltakeWhile P ys)) =\n       (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys))) \\<or>\n   ltl (ltakeWhile P (lappend xs ys)) =\n   ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys)))", "show ?case"], ["proof (prove)\nusing this:\n  lnull (ltakeWhile P (lappend xs ys)) =\n  lnull\n   (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n    else lappend xs (ltakeWhile P ys))\n  \\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n  \\<not> lnull\n          (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n           else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n  lhd (ltakeWhile P (lappend xs ys)) =\n  lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n       else lappend xs (ltakeWhile P ys)) \\<and>\n  ((\\<exists>xs.\n       ltl (ltakeWhile P (lappend xs ys)) =\n       ltakeWhile P (lappend xs ys) \\<and>\n       ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n            else lappend xs (ltakeWhile P ys)) =\n       (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys))) \\<or>\n   ltl (ltakeWhile P (lappend xs ys)) =\n   ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys)))\n\ngoal (1 subgoal):\n 1. lnull (ltakeWhile P (lappend xs ys)) =\n    lnull\n     (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n      else lappend xs (ltakeWhile P ys)) \\<and>\n    (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n     \\<not> lnull\n             (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n              else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n     lhd (ltakeWhile P (lappend xs ys)) =\n     lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n          else lappend xs (ltakeWhile P ys)) \\<and>\n     ((\\<exists>xs.\n          ltl (ltakeWhile P (lappend xs ys)) =\n          ltakeWhile P (lappend xs ys) \\<and>\n          ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n               else lappend xs (ltakeWhile P ys)) =\n          (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n           else lappend xs (ltakeWhile P ys))) \\<or>\n      ltl (ltakeWhile P (lappend xs ys)) =\n      ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n           else lappend xs (ltakeWhile P ys))))", ".."], ["proof (state)\nthis:\n  lnull (ltakeWhile P (lappend xs ys)) =\n  lnull\n   (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n    else lappend xs (ltakeWhile P ys)) \\<and>\n  (\\<not> lnull (ltakeWhile P (lappend xs ys)) \\<longrightarrow>\n   \\<not> lnull\n           (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n            else lappend xs (ltakeWhile P ys)) \\<longrightarrow>\n   lhd (ltakeWhile P (lappend xs ys)) =\n   lhd (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n        else lappend xs (ltakeWhile P ys)) \\<and>\n   ((\\<exists>xs.\n        ltl (ltakeWhile P (lappend xs ys)) =\n        ltakeWhile P (lappend xs ys) \\<and>\n        ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n             else lappend xs (ltakeWhile P ys)) =\n        (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys))) \\<or>\n    ltl (ltakeWhile P (lappend xs ys)) =\n    ltl (if \\<exists>x\\<in>lset xs. \\<not> P x then ltakeWhile P xs\n         else lappend xs (ltakeWhile P ys))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_lappend:\n  \"ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "proof(cases \"\\<exists>x\\<in>lset xs. \\<not> P x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)\n 2. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "case True"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)\n 2. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. \\<not> P x", "obtain x where \"x \\<in> lset xs\" \"\\<not> P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> lset xs; \\<not> P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)\n 2. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "by induct simp_all"], ["proof (state)\nthis:\n  ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "note xs = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "using xs"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "using xs"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<not> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. ldropWhile P (lappend xs ys) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n     else if lfinite xs then ldropWhile P ys else LNil)", "by induct simp_all"], ["proof (state)\nthis:\n  ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ldropWhile P (lappend xs ys) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then lappend (ldropWhile P xs) ys\n   else if lfinite xs then ldropWhile P ys else LNil)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfinite_ltakeWhile:\n  \"lfinite (ltakeWhile P xs) \\<longleftrightarrow> lfinite xs \\<or> (\\<exists>x \\<in> lset xs. \\<not> P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile P xs) =\n    (lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (ltakeWhile P xs) \\<Longrightarrow>\n    lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)\n 2. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "assume ?lhs"], ["proof (state)\nthis:\n  lfinite (ltakeWhile P xs)\n\ngoal (2 subgoals):\n 1. lfinite (ltakeWhile P xs) \\<Longrightarrow>\n    lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)\n 2. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "thus ?rhs"], ["proof (prove)\nusing this:\n  lfinite (ltakeWhile P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)", "by(auto simp add: ltakeWhile_all)"], ["proof (state)\nthis:\n  lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "assume \"?rhs\""], ["proof (state)\nthis:\n  lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x) \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite xs \\<or> (\\<exists>x\\<in>lset xs. \\<not> P x)\n\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile P xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (ltakeWhile P xs)\n 2. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (ltakeWhile P xs)\n 2. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "with lprefix_ltakeWhile"], ["proof (chain)\npicking this:\n  ltakeWhile ?P ?xs \\<sqsubseteq> ?xs\n  lfinite xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ltakeWhile ?P ?xs \\<sqsubseteq> ?xs\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile P xs)", "by(rule lprefix_lfiniteD)"], ["proof (state)\nthis:\n  lfinite (ltakeWhile P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "assume \"\\<exists>x\\<in>lset xs. \\<not> P x\""], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. \\<not> P x", "obtain x where \"x \\<in> lset xs\" \"\\<not> P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> lset xs; \\<not> P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lfinite (ltakeWhile P xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile P xs)", "by(induct rule: lset_induct) simp_all"], ["proof (state)\nthis:\n  lfinite (ltakeWhile P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (ltakeWhile P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_ltakeWhile_eq_infinity:\n  \"llength (ltakeWhile P xs) = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs \\<and> ltakeWhile P xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (ltakeWhile P xs) = \\<infinity>) =\n    (\\<not> lfinite xs \\<and> ltakeWhile P xs = xs)", "unfolding llength_ltakeWhile_all[symmetric] llength_eq_infty_conv_lfinite[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (ltakeWhile P xs) = \\<infinity>) =\n    (llength xs = \\<infinity> \\<and> llength (ltakeWhile P xs) = llength xs)", "by(auto)(auto simp add: llength_eq_infty_conv_lfinite lfinite_ltakeWhile intro: sym)"], ["", "lemma llength_ltakeWhile_eq_infinity':\n  \"llength (ltakeWhile P xs) = \\<infinity> \\<longleftrightarrow> \\<not> lfinite xs \\<and> (\\<forall>x\\<in>lset xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (ltakeWhile P xs) = \\<infinity>) =\n    (\\<not> lfinite xs \\<and> (\\<forall>x\\<in>lset xs. P x))", "by (metis lfinite_ltakeWhile llength_eq_infty_conv_lfinite)"], ["", "lemma lzip_ltakeWhile_fst: \"lzip (ltakeWhile P xs) ys = ltakeWhile (P \\<circ> fst) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (ltakeWhile P xs) ys = ltakeWhile (P \\<circ> fst) (lzip xs ys)", "by(coinduction arbitrary: xs ys)(auto simp add: ltl_ltakeWhile simp del: simp del: ltakeWhile.disc_iff)"], ["", "lemma lzip_ltakeWhile_snd: \"lzip xs (ltakeWhile P ys) = ltakeWhile (P \\<circ> snd) (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs (ltakeWhile P ys) = ltakeWhile (P \\<circ> snd) (lzip xs ys)", "by(coinduction arbitrary: xs ys)(auto simp add: ltl_ltakeWhile)"], ["", "lemma ltakeWhile_lappend1:\n  \"\\<lbrakk> x \\<in> lset xs; \\<not> P x \\<rbrakk> \\<Longrightarrow> ltakeWhile P (lappend xs ys) = ltakeWhile P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> lset xs; \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> ltakeWhile P (lappend xs ys) = ltakeWhile P xs", "by(induct rule: lset_induct) simp_all"], ["", "lemma ltakeWhile_lappend2:\n  \"lset xs \\<subseteq> {x. P x}\n  \\<Longrightarrow> ltakeWhile P (lappend xs ys) = lappend xs (ltakeWhile P ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs \\<subseteq> {x. P x} \\<Longrightarrow>\n    ltakeWhile P (lappend xs ys) = lappend xs (ltakeWhile P ys)", "by(coinduction arbitrary: xs ys rule: llist.coinduct_strong)(auto 4 4 simp add: not_lnull_conv lappend_lnull1)"], ["", "lemma ltakeWhile_cong [cong, fundef_cong]:\n  assumes xs: \"xs = ys\"\n  and PQ: \"\\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x\"\n  shows \"ltakeWhile P xs = ltakeWhile Q ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P xs = ltakeWhile Q ys", "using PQ"], ["proof (prove)\nusing this:\n  ?x \\<in> lset ys \\<Longrightarrow> P ?x = Q ?x\n\ngoal (1 subgoal):\n 1. ltakeWhile P xs = ltakeWhile Q ys", "unfolding xs"], ["proof (prove)\nusing this:\n  ?x \\<in> lset ys \\<Longrightarrow> P ?x = Q ?x\n\ngoal (1 subgoal):\n 1. ltakeWhile P ys = ltakeWhile Q ys", "by(coinduction arbitrary: ys)(auto simp add: ltl_ltakeWhile not_lnull_conv)"], ["", "lemma lnth_llength_ltakeWhile:\n  assumes len: \"llength (ltakeWhile P xs) < llength xs\"\n  shows \"\\<not> P (lnth xs (the_enat (llength (ltakeWhile P xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (lnth xs (the_enat (llength (ltakeWhile P xs))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. P (lnth xs (the_enat (llength (ltakeWhile P xs)))) \\<Longrightarrow>\n    False", "assume P: \"P (lnth xs (the_enat (llength (ltakeWhile P xs))))\""], ["proof (state)\nthis:\n  P (lnth xs (the_enat (llength (ltakeWhile P xs))))\n\ngoal (1 subgoal):\n 1. P (lnth xs (the_enat (llength (ltakeWhile P xs)))) \\<Longrightarrow>\n    False", "from len"], ["proof (chain)\npicking this:\n  llength (ltakeWhile P xs) < llength xs", "obtain len where \"llength (ltakeWhile P xs) = enat len\""], ["proof (prove)\nusing this:\n  llength (ltakeWhile P xs) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>len.\n        llength (ltakeWhile P xs) = enat len \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"llength (ltakeWhile P xs)\") auto"], ["proof (state)\nthis:\n  llength (ltakeWhile P xs) = enat len\n\ngoal (1 subgoal):\n 1. P (lnth xs (the_enat (llength (ltakeWhile P xs)))) \\<Longrightarrow>\n    False", "with P len"], ["proof (chain)\npicking this:\n  P (lnth xs (the_enat (llength (ltakeWhile P xs))))\n  llength (ltakeWhile P xs) < llength xs\n  llength (ltakeWhile P xs) = enat len", "show False"], ["proof (prove)\nusing this:\n  P (lnth xs (the_enat (llength (ltakeWhile P xs))))\n  llength (ltakeWhile P xs) < llength xs\n  llength (ltakeWhile P xs) = enat len\n\ngoal (1 subgoal):\n 1. False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (lnth xs len); enat len < llength xs;\n     llength (ltakeWhile P xs) = enat len\\<rbrakk>\n    \\<Longrightarrow> False", "proof(induct len arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P (lnth xs 0); enat 0 < llength xs;\n        llength (ltakeWhile P xs) = enat 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>len xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>P (lnth xs len); enat len < llength xs;\n                    llength (ltakeWhile P xs) = enat len\\<rbrakk>\n                   \\<Longrightarrow> False;\n        P (lnth xs (Suc len)); enat (Suc len) < llength xs;\n        llength (ltakeWhile P xs) = enat (Suc len)\\<rbrakk>\n       \\<Longrightarrow> False", "case 0"], ["proof (state)\nthis:\n  P (lnth xs 0)\n  enat 0 < llength xs\n  llength (ltakeWhile P xs) = enat 0\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>P (lnth xs 0); enat 0 < llength xs;\n        llength (ltakeWhile P xs) = enat 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>len xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>P (lnth xs len); enat len < llength xs;\n                    llength (ltakeWhile P xs) = enat len\\<rbrakk>\n                   \\<Longrightarrow> False;\n        P (lnth xs (Suc len)); enat (Suc len) < llength xs;\n        llength (ltakeWhile P xs) = enat (Suc len)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  P (lnth xs 0)\n  enat 0 < llength xs\n  llength (ltakeWhile P xs) = enat 0\n\ngoal (1 subgoal):\n 1. False", "by(simp add: zero_enat_def[symmetric] lnth_0_conv_lhd)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>len xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>P (lnth xs len); enat len < llength xs;\n                    llength (ltakeWhile P xs) = enat len\\<rbrakk>\n                   \\<Longrightarrow> False;\n        P (lnth xs (Suc len)); enat (Suc len) < llength xs;\n        llength (ltakeWhile P xs) = enat (Suc len)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>len xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>P (lnth xs len); enat len < llength xs;\n                    llength (ltakeWhile P xs) = enat len\\<rbrakk>\n                   \\<Longrightarrow> False;\n        P (lnth xs (Suc len)); enat (Suc len) < llength xs;\n        llength (ltakeWhile P xs) = enat (Suc len)\\<rbrakk>\n       \\<Longrightarrow> False", "case (Suc len)"], ["proof (state)\nthis:\n  \\<lbrakk>P (lnth ?xs len); enat len < llength ?xs;\n   llength (ltakeWhile P ?xs) = enat len\\<rbrakk>\n  \\<Longrightarrow> False\n  P (lnth xs (Suc len))\n  enat (Suc len) < llength xs\n  llength (ltakeWhile P xs) = enat (Suc len)\n\ngoal (1 subgoal):\n 1. \\<And>len xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>P (lnth xs len); enat len < llength xs;\n                    llength (ltakeWhile P xs) = enat len\\<rbrakk>\n                   \\<Longrightarrow> False;\n        P (lnth xs (Suc len)); enat (Suc len) < llength xs;\n        llength (ltakeWhile P xs) = enat (Suc len)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>P (lnth ?xs len); enat len < llength ?xs;\n   llength (ltakeWhile P ?xs) = enat len\\<rbrakk>\n  \\<Longrightarrow> False\n  P (lnth xs (Suc len))\n  enat (Suc len) < llength xs\n  llength (ltakeWhile P xs) = enat (Suc len)\n\ngoal (1 subgoal):\n 1. False", "by(cases xs)(auto split: if_split_asm simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"\\<exists>x\\<in>lset xs. \\<not> P x\"\n  shows lhd_ldropWhile: \"\\<not> P (lhd (ldropWhile P xs))\" (is ?thesis1)\n  and lhd_ldropWhile_in_lset: \"lhd (ldropWhile P xs) \\<in> lset xs\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (lhd (ldropWhile P xs)) &&& lhd (ldropWhile P xs) \\<in> lset xs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> P (lhd (ldropWhile P xs))\n 2. lhd (ldropWhile P xs) \\<in> lset xs", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. \\<not> P x", "obtain x where \"x \\<in> lset xs\" \"\\<not> P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> lset xs; \\<not> P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (2 subgoals):\n 1. \\<not> P (lhd (ldropWhile P xs))\n 2. lhd (ldropWhile P xs) \\<in> lset xs", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<not> P (lhd (ldropWhile P xs)) &&& lhd (ldropWhile P xs) \\<in> lset xs", "by induct simp_all"], ["proof (state)\nthis:\n  \\<not> P (lhd (ldropWhile P xs))\n  lhd (ldropWhile P xs) \\<in> lset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_eq_ldrop:\n  \"ldropWhile P xs = ldrop (llength (ltakeWhile P xs)) xs\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P xs = ldrop (llength (ltakeWhile P xs)) xs", "proof(rule lprefix_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ldropWhile P xs \\<sqsubseteq> ldrop (llength (ltakeWhile P xs)) xs\n 2. ldrop (llength (ltakeWhile P xs)) xs \\<sqsubseteq> ldropWhile P xs", "show \"?lhs \\<sqsubseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P xs \\<sqsubseteq> ldrop (llength (ltakeWhile P xs)) xs", "by(induct arbitrary: xs rule: ldropWhile.fixp_induct)(auto split: llist.split)"], ["proof (state)\nthis:\n  ldropWhile P xs \\<sqsubseteq> ldrop (llength (ltakeWhile P xs)) xs\n\ngoal (1 subgoal):\n 1. ldrop (llength (ltakeWhile P xs)) xs \\<sqsubseteq> ldropWhile P xs", "show \"?rhs \\<sqsubseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (llength (ltakeWhile P xs)) xs \\<sqsubseteq> ldropWhile P xs", "proof(induct arbitrary: xs rule: ldrop.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>ldrop.\n         \\<forall>x.\n            curry ldrop (llength (ltakeWhile P x)) x \\<sqsubseteq>\n            ldropWhile P x)\n 2. \\<And>xs. LNil \\<sqsubseteq> ldropWhile P xs\n 3. \\<And>xs xsa.\n       \\<lbrakk>\\<And>xsa.\n                   xs (llength (ltakeWhile P xsa)) xsa \\<sqsubseteq>\n                   ldropWhile P xsa;\n        llist.le_fun (\\<lambda>(x, y). xs x y)\n         (\\<lambda>(b, a). ldrop b a)\\<rbrakk>\n       \\<Longrightarrow> (case llength (ltakeWhile P xsa) of\n                          0 \\<Rightarrow> xsa\n                          | eSuc n' \\<Rightarrow>\n                              case xsa of LNil \\<Rightarrow> LNil\n                              | LCons x xa \\<Rightarrow>\n                                  xs n' xa) \\<sqsubseteq>\n                         ldropWhile P xsa", "case (3 ldrop xs)"], ["proof (state)\nthis:\n  ldrop (llength (ltakeWhile P ?xs)) ?xs \\<sqsubseteq> ldropWhile P ?xs\n  llist.le_fun (\\<lambda>(x, y). ldrop x y) (\\<lambda>(b, a). ldrop b a)\n\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>ldrop.\n         \\<forall>x.\n            curry ldrop (llength (ltakeWhile P x)) x \\<sqsubseteq>\n            ldropWhile P x)\n 2. \\<And>xs. LNil \\<sqsubseteq> ldropWhile P xs\n 3. \\<And>xs xsa.\n       \\<lbrakk>\\<And>xsa.\n                   xs (llength (ltakeWhile P xsa)) xsa \\<sqsubseteq>\n                   ldropWhile P xsa;\n        llist.le_fun (\\<lambda>(x, y). xs x y)\n         (\\<lambda>(b, a). ldrop b a)\\<rbrakk>\n       \\<Longrightarrow> (case llength (ltakeWhile P xsa) of\n                          0 \\<Rightarrow> xsa\n                          | eSuc n' \\<Rightarrow>\n                              case xsa of LNil \\<Rightarrow> LNil\n                              | LCons x xa \\<Rightarrow>\n                                  xs n' xa) \\<sqsubseteq>\n                         ldropWhile P xsa", "thus ?case"], ["proof (prove)\nusing this:\n  ldrop (llength (ltakeWhile P ?xs)) ?xs \\<sqsubseteq> ldropWhile P ?xs\n  llist.le_fun (\\<lambda>(x, y). ldrop x y) (\\<lambda>(b, a). ldrop b a)\n\ngoal (1 subgoal):\n 1. (case llength (ltakeWhile P xs) of 0 \\<Rightarrow> xs\n     | eSuc n' \\<Rightarrow>\n         case xs of LNil \\<Rightarrow> LNil\n         | LCons x xs' \\<Rightarrow> ldrop n' xs') \\<sqsubseteq>\n    ldropWhile P xs", "by(cases xs) auto"], ["proof (state)\nthis:\n  (case llength (ltakeWhile P xs) of 0 \\<Rightarrow> xs\n   | eSuc n' \\<Rightarrow>\n       case xs of LNil \\<Rightarrow> LNil\n       | LCons x xs' \\<Rightarrow> ldrop n' xs') \\<sqsubseteq>\n  ldropWhile P xs\n\ngoal (2 subgoals):\n 1. llist.admissible\n     (\\<lambda>ldrop.\n         \\<forall>x.\n            curry ldrop (llength (ltakeWhile P x)) x \\<sqsubseteq>\n            ldropWhile P x)\n 2. \\<And>xs. LNil \\<sqsubseteq> ldropWhile P xs", "qed simp_all"], ["proof (state)\nthis:\n  ldrop (llength (ltakeWhile P xs)) xs \\<sqsubseteq> ldropWhile P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_cong [cong]:\n  \"\\<lbrakk> xs = ys; \\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x \\<rbrakk> \\<Longrightarrow> ldropWhile P xs = ldropWhile Q ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys;\n     \\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x\\<rbrakk>\n    \\<Longrightarrow> ldropWhile P xs = ldropWhile Q ys", "by(simp add: ldropWhile_eq_ldrop)"], ["", "lemma ltakeWhile_repeat:\n  \"ltakeWhile P (repeat x) = (if P x then repeat x else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P (repeat x) = (if P x then repeat x else LNil)", "by(coinduction arbitrary: x)(auto simp add: ltl_ltakeWhile)"], ["", "lemma ldropWhile_repeat: \"ldropWhile P (repeat x) = (if P x then LNil else repeat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P (repeat x) = (if P x then LNil else repeat x)", "by(simp add: ldropWhile_eq_ldrop ltakeWhile_repeat)"], ["", "lemma lfinite_ldropWhile: \"lfinite (ldropWhile P xs) \\<longleftrightarrow> (\\<exists>x \\<in> lset xs. \\<not> P x) \\<longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ldropWhile P xs) =\n    ((\\<exists>x\\<in>lset xs. \\<not> P x) \\<longrightarrow> lfinite xs)", "by(auto simp add: ldropWhile_eq_ldrop llength_eq_infty_conv_lfinite lfinite_ltakeWhile)"], ["", "lemma llength_ldropWhile:\n  \"llength (ldropWhile P xs) =\n  (if \\<exists>x\\<in>lset xs. \\<not> P x then llength xs - llength (ltakeWhile P xs) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ldropWhile P xs) =\n    (if \\<exists>x\\<in>lset xs. \\<not> P x\n     then llength xs - llength (ltakeWhile P xs) else 0)", "by(auto simp add: ldropWhile_eq_ldrop llength_ldrop llength_ltakeWhile_all ltakeWhile_all_conv llength_ltakeWhile_eq_infinity zero_enat_def dest!: lfinite_llength_enat)"], ["", "lemma lhd_ldropWhile_conv_lnth:\n  \"\\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lhd (ldropWhile P xs) = lnth xs (the_enat (llength (ltakeWhile P xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. \\<not> P x \\<Longrightarrow>\n    lhd (ldropWhile P xs) = lnth xs (the_enat (llength (ltakeWhile P xs)))", "by(simp add: ldropWhile_eq_ldrop lhd_ldrop llength_ltakeWhile_lt_iff)"], ["", "subsection \\<open>@{term \"llist_all2\"}\\<close>"], ["", "lemmas llist_all2_LNil_LNil = llist.rel_inject(1)"], ["", "lemmas llist_all2_LNil_LCons = llist.rel_distinct(1)"], ["", "lemmas llist_all2_LCons_LNil = llist.rel_distinct(2)"], ["", "lemmas llist_all2_LCons_LCons = llist.rel_inject(2)"], ["", "lemma llist_all2_LNil1 [simp]: \"llist_all2 P LNil xs \\<longleftrightarrow> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P LNil xs = (xs = LNil)", "by(cases xs) simp_all"], ["", "lemma llist_all2_LNil2 [simp]: \"llist_all2 P xs LNil \\<longleftrightarrow> xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs LNil = (xs = LNil)", "by(cases xs) simp_all"], ["", "lemma llist_all2_LCons1:\n  \"llist_all2 P (LCons x xs) ys \\<longleftrightarrow> (\\<exists>y ys'. ys = LCons y ys' \\<and> P x y \\<and> llist_all2 P xs ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (LCons x xs) ys =\n    (\\<exists>y ys'.\n        ys = LCons y ys' \\<and> P x y \\<and> llist_all2 P xs ys')", "by(cases ys) simp_all"], ["", "lemma llist_all2_LCons2:\n  \"llist_all2 P xs (LCons y ys) \\<longleftrightarrow> (\\<exists>x xs'. xs = LCons x xs' \\<and> P x y \\<and> llist_all2 P xs' ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs (LCons y ys) =\n    (\\<exists>x xs'.\n        xs = LCons x xs' \\<and> P x y \\<and> llist_all2 P xs' ys)", "by(cases xs) simp_all"], ["", "lemma llist_all2_llist_of [simp]:\n  \"llist_all2 P (llist_of xs) (llist_of ys) = list_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (llist_of xs) (llist_of ys) = list_all2 P xs ys", "by(induct xs ys rule: list_induct2')(simp_all)"], ["", "lemma llist_all2_conv_lzip:\n  \"llist_all2 P xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>(x, y) \\<in> lset (lzip xs ys). P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys =\n    (llength xs = llength ys \\<and>\n     (\\<forall>(x, y)\\<in>lset (lzip xs ys). P x y))", "by(auto 4 4 elim!: GrpE simp add:\n  llist_all2_def lmap_fst_lzip_conv_ltake lmap_snd_lzip_conv_ltake ltake_all\n  intro!: GrpI relcomppI[of _ xs _ _ ys])"], ["", "lemma llist_all2_llengthD:\n  \"llist_all2 P xs ys \\<Longrightarrow> llength xs = llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow> llength xs = llength ys", "by(simp add: llist_all2_conv_lzip)"], ["", "lemma llist_all2_lnullD: \"llist_all2 P xs ys \\<Longrightarrow> lnull xs \\<longleftrightarrow> lnull ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow> lnull xs = lnull ys", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow> (xs = LNil) = (ys = LNil)", "by auto"], ["", "lemma llist_all2_all_lnthI:\n  \"\\<lbrakk> llength xs = llength ys;\n     \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n) \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llength xs = llength ys;\n     \\<And>n.\n        enat n < llength xs \\<Longrightarrow>\n        P (lnth xs n) (lnth ys n)\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P xs ys", "by(auto simp add: llist_all2_conv_lzip lset_lzip)"], ["", "lemma llist_all2_lnthD:\n  \"\\<lbrakk> llist_all2 P xs ys; enat n < llength xs \\<rbrakk> \\<Longrightarrow> P (lnth xs n) (lnth ys n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; enat n < llength xs\\<rbrakk>\n    \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "by(fastforce simp add: llist_all2_conv_lzip lset_lzip)"], ["", "lemma llist_all2_lnthD2:\n  \"\\<lbrakk> llist_all2 P xs ys; enat n < llength ys \\<rbrakk> \\<Longrightarrow> P (lnth xs n) (lnth ys n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; enat n < llength ys\\<rbrakk>\n    \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "by(fastforce simp add: llist_all2_conv_lzip lset_lzip)"], ["", "lemma llist_all2_conv_all_lnth:\n  \"llist_all2 P xs ys \\<longleftrightarrow>\n   llength xs = llength ys \\<and>\n   (\\<forall>n. enat n < llength ys \\<longrightarrow> P (lnth xs n) (lnth ys n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys =\n    (llength xs = llength ys \\<and>\n     (\\<forall>n.\n         enat n < llength ys \\<longrightarrow> P (lnth xs n) (lnth ys n)))", "by(auto dest: llist_all2_llengthD llist_all2_lnthD2 intro: llist_all2_all_lnthI)"], ["", "lemma llist_all2_True [simp]: \"llist_all2 (\\<lambda>_ _. True) xs ys \\<longleftrightarrow> llength xs = llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>_ _. True) xs ys = (llength xs = llength ys)", "by(simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_reflI:\n  \"(\\<And>x. x \\<in> lset xs \\<Longrightarrow> P x x) \\<Longrightarrow> llist_all2 P xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> lset xs \\<Longrightarrow> P x x) \\<Longrightarrow>\n    llist_all2 P xs xs", "by(auto simp add: llist_all2_conv_all_lnth lset_conv_lnth)"], ["", "lemma llist_all2_lmap1:\n  \"llist_all2 P (lmap f xs) ys \\<longleftrightarrow> llist_all2 (\\<lambda>x. P (f x)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lmap f xs) ys = llist_all2 (\\<lambda>x. P (f x)) xs ys", "by(auto simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_lmap2:\n  \"llist_all2 P xs (lmap g ys) \\<longleftrightarrow> llist_all2 (\\<lambda>x y. P x (g y)) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs (lmap g ys) = llist_all2 (\\<lambda>x y. P x (g y)) xs ys", "by(auto simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_lfiniteD:\n  \"llist_all2 P xs ys \\<Longrightarrow> lfinite xs \\<longleftrightarrow> lfinite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow> lfinite xs = lfinite ys", "by(drule llist_all2_llengthD)(simp add: lfinite_conv_llength_enat)"], ["", "lemma llist_all2_coinduct[consumes 1, case_names LNil LCons, case_conclusion LCons lhd ltl, coinduct pred]:\n  assumes major: \"X xs ys\"\n  and step:\n  \"\\<And>xs ys. X xs ys \\<Longrightarrow> lnull xs \\<longleftrightarrow> lnull ys\"\n  \"\\<And>xs ys. \\<lbrakk> X xs ys; \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and> (X (ltl xs) (ltl ys) \\<or> llist_all2 P (ltl xs) (ltl ys))\"\n  shows \"llist_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys", "proof(rule llist_all2_all_lnthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. llength xs = llength ys\n 2. \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "from major"], ["proof (chain)\npicking this:\n  X xs ys", "show \"llength xs = llength ys\""], ["proof (prove)\nusing this:\n  X xs ys\n\ngoal (1 subgoal):\n 1. llength xs = llength ys", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(auto 4 3 dest: step llist_all2_llengthD simp add: epred_llength)"], ["proof (state)\nthis:\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "assume \"enat n < llength xs\""], ["proof (state)\nthis:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n. enat n < llength xs \\<Longrightarrow> P (lnth xs n) (lnth ys n)", "thus \"P (lnth xs n) (lnth ys n)\""], ["proof (prove)\nusing this:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. P (lnth xs n) (lnth ys n)", "using major \\<open>llength xs = llength ys\\<close>"], ["proof (prove)\nusing this:\n  enat n < llength xs\n  X xs ys\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. P (lnth xs n) (lnth ys n)", "proof(induct n arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>enat 0 < llength xs; X xs ys;\n        llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs 0) (lnth ys 0)\n 2. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs; X xs ys;\n                    llength xs = llength ys\\<rbrakk>\n                   \\<Longrightarrow> P (lnth xs n) (lnth ys n);\n        enat (Suc n) < llength xs; X xs ys; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs (Suc n)) (lnth ys (Suc n))", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n  X xs ys\n  llength xs = llength ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>enat 0 < llength xs; X xs ys;\n        llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs 0) (lnth ys 0)\n 2. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs; X xs ys;\n                    llength xs = llength ys\\<rbrakk>\n                   \\<Longrightarrow> P (lnth xs n) (lnth ys n);\n        enat (Suc n) < llength xs; X xs ys; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs (Suc n)) (lnth ys (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n  X xs ys\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. P (lnth xs 0) (lnth ys 0)", "by(cases \"lnull xs\")(auto dest: step simp add: zero_enat_def[symmetric] lnth_0_conv_lhd)"], ["proof (state)\nthis:\n  P (lnth xs 0) (lnth ys 0)\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs; X xs ys;\n                    llength xs = llength ys\\<rbrakk>\n                   \\<Longrightarrow> P (lnth xs n) (lnth ys n);\n        enat (Suc n) < llength xs; X xs ys; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs (Suc n)) (lnth ys (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs; X xs ys;\n                    llength xs = llength ys\\<rbrakk>\n                   \\<Longrightarrow> P (lnth xs n) (lnth ys n);\n        enat (Suc n) < llength xs; X xs ys; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs (Suc n)) (lnth ys (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>enat n < llength ?xs; X ?xs ?ys;\n   llength ?xs = llength ?ys\\<rbrakk>\n  \\<Longrightarrow> P (lnth ?xs n) (lnth ?ys n)\n  enat (Suc n) < llength xs\n  X xs ys\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>enat n < llength xs; X xs ys;\n                    llength xs = llength ys\\<rbrakk>\n                   \\<Longrightarrow> P (lnth xs n) (lnth ys n);\n        enat (Suc n) < llength xs; X xs ys; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs (Suc n)) (lnth ys (Suc n))", "from step[OF \\<open>X xs ys\\<close>] \\<open>enat (Suc n) < llength xs\\<close> Suc"], ["proof (chain)\npicking this:\n  lnull xs = lnull ys\n  \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n  \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                    (X (ltl xs) (ltl ys) \\<or>\n                     llist_all2 P (ltl xs) (ltl ys))\n  enat (Suc n) < llength xs\n  \\<lbrakk>enat n < llength ?xs; X ?xs ?ys;\n   llength ?xs = llength ?ys\\<rbrakk>\n  \\<Longrightarrow> P (lnth ?xs n) (lnth ?ys n)\n  enat (Suc n) < llength xs\n  X xs ys\n  llength xs = llength ys", "show ?case"], ["proof (prove)\nusing this:\n  lnull xs = lnull ys\n  \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n  \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                    (X (ltl xs) (ltl ys) \\<or>\n                     llist_all2 P (ltl xs) (ltl ys))\n  enat (Suc n) < llength xs\n  \\<lbrakk>enat n < llength ?xs; X ?xs ?ys;\n   llength ?xs = llength ?ys\\<rbrakk>\n  \\<Longrightarrow> P (lnth ?xs n) (lnth ?ys n)\n  enat (Suc n) < llength xs\n  X xs ys\n  llength xs = llength ys\n\ngoal (1 subgoal):\n 1. P (lnth xs (Suc n)) (lnth ys (Suc n))", "by(auto 4 3 simp add: not_lnull_conv Suc_ile_eq intro: Suc.hyps llist_all2_lnthD dest: llist_all2_llengthD)"], ["proof (state)\nthis:\n  P (lnth xs (Suc n)) (lnth ys (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (lnth xs n) (lnth ys n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_cases[consumes 1, case_names LNil LCons, cases pred]:\n  assumes \"llist_all2 P xs ys\"\n  obtains (LNil) \"xs = LNil\" \"ys = LNil\"\n  | (LCons) x xs' y ys'\n    where \"xs = LCons x xs'\" and \"ys = LCons y ys'\"\n    and \"P x y\" and \"llist_all2 P xs' ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs = LNil; ys = LNil\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>x xs' y ys'.\n        \\<lbrakk>xs = LCons x xs'; ys = LCons y ys'; P x y;\n         llist_all2 P xs' ys'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs = LNil; ys = LNil\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>x xs' y ys'.\n        \\<lbrakk>xs = LCons x xs'; ys = LCons y ys'; P x y;\n         llist_all2 P xs' ys'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases xs)(auto simp add: llist_all2_LCons1)"], ["", "lemma llist_all2_mono:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<And>x y. P x y \\<Longrightarrow> P' x y \\<rbrakk> \\<Longrightarrow> llist_all2 P' xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys;\n     \\<And>x y. P x y \\<Longrightarrow> P' x y\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P' xs ys", "by(auto simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_left: \"llist_all2 (\\<lambda>x _. P x) xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>x\\<in>lset xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x _. P x) xs ys =\n    (llength xs = llength ys \\<and> (\\<forall>x\\<in>lset xs. P x))", "by(fastforce simp add: llist_all2_conv_all_lnth lset_conv_lnth)"], ["", "lemma llist_all2_right: \"llist_all2 (\\<lambda>_. P) xs ys \\<longleftrightarrow> llength xs = llength ys \\<and> (\\<forall>x\\<in>lset ys. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>_. P) xs ys =\n    (llength xs = llength ys \\<and> (\\<forall>x\\<in>lset ys. P x))", "by(fastforce simp add: llist_all2_conv_all_lnth lset_conv_lnth)"], ["", "lemma llist_all2_lsetD1: \"\\<lbrakk> llist_all2 P xs ys; x \\<in> lset xs \\<rbrakk> \\<Longrightarrow> \\<exists>y\\<in>lset ys. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; x \\<in> lset xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>lset ys. P x y", "by(auto 4 4 simp add: llist_all2_conv_lzip lset_lzip lset_conv_lnth split_beta lnth_lzip simp del: split_paired_All)"], ["", "lemma llist_all2_lsetD2: \"\\<lbrakk> llist_all2 P xs ys; y \\<in> lset ys \\<rbrakk> \\<Longrightarrow> \\<exists>x\\<in>lset xs. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; y \\<in> lset ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>lset xs. P x y", "by(auto 4 4 simp add: llist_all2_conv_lzip lset_lzip lset_conv_lnth split_beta lnth_lzip simp del: split_paired_All)"], ["", "lemma llist_all2_conj:\n  \"llist_all2 (\\<lambda>x y. P x y \\<and> Q x y) xs ys \\<longleftrightarrow> llist_all2 P xs ys \\<and> llist_all2 Q xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. P x y \\<and> Q x y) xs ys =\n    (llist_all2 P xs ys \\<and> llist_all2 Q xs ys)", "by(auto simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_lhdD:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> P (lhd xs) (lhd ys)", "by(auto simp add: not_lnull_conv llist_all2_LCons1)"], ["", "lemma llist_all2_lhdD2:\n  \"\\<lbrakk> llist_all2 P xs ys; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; \\<not> lnull ys\\<rbrakk>\n    \\<Longrightarrow> P (lhd xs) (lhd ys)", "by(auto simp add: not_lnull_conv llist_all2_LCons2)"], ["", "lemma llist_all2_ltlI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ltl xs) (ltl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ltl xs) (ltl ys)", "by(cases xs)(auto simp add: llist_all2_LCons1)"], ["", "lemma llist_all2_lappendI:\n  assumes 1: \"llist_all2 P xs ys\"\n  and 2: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> llist_all2 P xs' ys'\"\n  shows \"llist_all2 P (lappend xs xs') (lappend ys ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lappend xs xs') (lappend ys ys')", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "with 1"], ["proof (chain)\npicking this:\n  llist_all2 P xs ys\n  lfinite xs", "have \"lfinite ys\""], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite ys", "by(auto dest: llist_all2_lfiniteD)"], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "from 1 2[OF True this]"], ["proof (chain)\npicking this:\n  llist_all2 P xs ys\n  llist_all2 P xs' ys'", "show ?thesis"], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n  llist_all2 P xs' ys'\n\ngoal (1 subgoal):\n 1. llist_all2 P (lappend xs xs') (lappend ys ys')", "by(coinduction arbitrary: xs ys)(auto dest: llist_all2_lnullD llist_all2_lhdD intro: llist_all2_ltlI simp add: lappend_eq_LNil_iff)"], ["proof (state)\nthis:\n  llist_all2 P (lappend xs xs') (lappend ys ys')\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "with 1"], ["proof (chain)\npicking this:\n  llist_all2 P xs ys\n  \\<not> lfinite xs", "have \"\\<not> lfinite ys\""], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite ys", "by(auto dest: llist_all2_lfiniteD)"], ["proof (state)\nthis:\n  \\<not> lfinite ys\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llist_all2 P (lappend xs xs') (lappend ys ys')", "with False 1"], ["proof (chain)\npicking this:\n  \\<not> lfinite xs\n  llist_all2 P xs ys\n  \\<not> lfinite ys", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  llist_all2 P xs ys\n  \\<not> lfinite ys\n\ngoal (1 subgoal):\n 1. llist_all2 P (lappend xs xs') (lappend ys ys')", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  llist_all2 P (lappend xs xs') (lappend ys ys')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_lappend1D:\n  assumes \"llist_all2 P (lappend xs xs') ys\"\n  shows \"llist_all2 P xs (ltake (llength xs) ys)\"\n  and \"lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs (ltake (llength xs) ys) &&&\n    (lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. llist_all2 P xs (ltake (llength xs) ys)\n 2. lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)", "from assms"], ["proof (chain)\npicking this:\n  llist_all2 P (lappend xs xs') ys", "have len: \"llength xs + llength xs' = llength ys\""], ["proof (prove)\nusing this:\n  llist_all2 P (lappend xs xs') ys\n\ngoal (1 subgoal):\n 1. llength xs + llength xs' = llength ys", "by(auto dest: llist_all2_llengthD)"], ["proof (state)\nthis:\n  llength xs + llength xs' = llength ys\n\ngoal (2 subgoals):\n 1. llist_all2 P xs (ltake (llength xs) ys)\n 2. lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)", "hence len_xs: \"llength xs \\<le> llength ys\" and len_xs': \"llength xs' \\<le> llength ys\""], ["proof (prove)\nusing this:\n  llength xs + llength xs' = llength ys\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys &&& llength xs' \\<le> llength ys", "by (metis enat_le_plus_same llength_lappend)+"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys\n  llength xs' \\<le> llength ys\n\ngoal (2 subgoals):\n 1. llist_all2 P xs (ltake (llength xs) ys)\n 2. lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)", "show \"llist_all2 P xs (ltake (llength xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs (ltake (llength xs) ys)", "proof(rule llist_all2_all_lnthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. llength xs = llength (ltake (llength xs) ys)\n 2. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "show \"llength xs = llength (ltake (llength xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs = llength (ltake (llength xs) ys)", "using len_xs"], ["proof (prove)\nusing this:\n  llength xs \\<le> llength ys\n\ngoal (1 subgoal):\n 1. llength xs = llength (ltake (llength xs) ys)", "by(simp add: min_def)"], ["proof (state)\nthis:\n  llength xs = llength (ltake (llength xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "assume n: \"enat n < llength xs\""], ["proof (state)\nthis:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "also"], ["proof (state)\nthis:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "have \"\\<dots> \\<le> llength (lappend xs xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> llength (lappend xs xs')", "by(simp add: enat_le_plus_same)"], ["proof (state)\nthis:\n  llength xs \\<le> llength (lappend xs xs')\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "finally"], ["proof (chain)\npicking this:\n  enat n < llength (lappend xs xs')", "have \"P (lnth (lappend xs xs') n) (lnth ys n)\""], ["proof (prove)\nusing this:\n  enat n < llength (lappend xs xs')\n\ngoal (1 subgoal):\n 1. P (lnth (lappend xs xs') n) (lnth ys n)", "using assms"], ["proof (prove)\nusing this:\n  enat n < llength (lappend xs xs')\n  llist_all2 P (lappend xs xs') ys\n\ngoal (1 subgoal):\n 1. P (lnth (lappend xs xs') n) (lnth ys n)", "by -(rule llist_all2_lnthD)"], ["proof (state)\nthis:\n  P (lnth (lappend xs xs') n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "also"], ["proof (state)\nthis:\n  P (lnth (lappend xs xs') n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "from n"], ["proof (chain)\npicking this:\n  enat n < llength xs", "have \"lnth ys n = lnth (ltake (llength xs) ys) n\""], ["proof (prove)\nusing this:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. lnth ys n = lnth (ltake (llength xs) ys) n", "by(rule lnth_ltake[symmetric])"], ["proof (state)\nthis:\n  lnth ys n = lnth (ltake (llength xs) ys) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "also"], ["proof (state)\nthis:\n  lnth ys n = lnth (ltake (llength xs) ys) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "from n"], ["proof (chain)\npicking this:\n  enat n < llength xs", "have \"lnth (lappend xs xs') n = lnth xs n\""], ["proof (prove)\nusing this:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. lnth (lappend xs xs') n = lnth xs n", "by(simp add: lnth_lappend1)"], ["proof (state)\nthis:\n  lnth (lappend xs xs') n = lnth xs n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       enat n < llength xs \\<Longrightarrow>\n       P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "finally"], ["proof (chain)\npicking this:\n  P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "show \"P (lnth xs n) (lnth (ltake (llength xs) ys) n)\""], ["proof (prove)\nusing this:\n  P (lnth xs n) (lnth (ltake (llength xs) ys) n)\n\ngoal (1 subgoal):\n 1. P (lnth xs n) (lnth (ltake (llength xs) ys) n)", "."], ["proof (state)\nthis:\n  P (lnth xs n) (lnth (ltake (llength xs) ys) n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llist_all2 P xs (ltake (llength xs) ys)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> llist_all2 P xs' (ldrop (llength xs) ys)", "thus \"llist_all2 P xs' (ldrop (llength xs) ys)\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. llist_all2 P xs' (ldrop (llength xs) ys)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n  llist_all2 P (lappend xs xs') ys\n\ngoal (1 subgoal):\n 1. llist_all2 P xs' (ldrop (llength xs) ys)", "by(induct arbitrary: ys)(auto simp add: llist_all2_LCons1)"], ["proof (state)\nthis:\n  llist_all2 P xs' (ldrop (llength xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lmap_eq_lmap_conv_llist_all2:\n  \"lmap f xs = lmap g ys \\<longleftrightarrow> llist_all2 (\\<lambda>x y. f x = g y) xs ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lmap f xs = lmap g ys) = llist_all2 (\\<lambda>x y. f x = g y) xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lmap f xs = lmap g ys \\<Longrightarrow>\n    llist_all2 (\\<lambda>x y. f x = g y) xs ys\n 2. llist_all2 (\\<lambda>x y. f x = g y) xs ys \\<Longrightarrow>\n    lmap f xs = lmap g ys", "assume ?lhs"], ["proof (state)\nthis:\n  lmap f xs = lmap g ys\n\ngoal (2 subgoals):\n 1. lmap f xs = lmap g ys \\<Longrightarrow>\n    llist_all2 (\\<lambda>x y. f x = g y) xs ys\n 2. llist_all2 (\\<lambda>x y. f x = g y) xs ys \\<Longrightarrow>\n    lmap f xs = lmap g ys", "thus ?rhs"], ["proof (prove)\nusing this:\n  lmap f xs = lmap g ys\n\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. f x = g y) xs ys", "by(coinduction arbitrary: xs ys)(auto simp add: neq_LNil_conv lnull_def LNil_eq_lmap lmap_eq_LNil)"], ["proof (state)\nthis:\n  llist_all2 (\\<lambda>x y. f x = g y) xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. f x = g y) xs ys \\<Longrightarrow>\n    lmap f xs = lmap g ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. f x = g y) xs ys \\<Longrightarrow>\n    lmap f xs = lmap g ys", "assume ?rhs"], ["proof (state)\nthis:\n  llist_all2 (\\<lambda>x y. f x = g y) xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. f x = g y) xs ys \\<Longrightarrow>\n    lmap f xs = lmap g ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  llist_all2 (\\<lambda>x y. f x = g y) xs ys\n\ngoal (1 subgoal):\n 1. lmap f xs = lmap g ys", "by(coinduction arbitrary: xs ys)(auto dest: llist_all2_lnullD llist_all2_lhdD llist_all2_ltlI)"], ["proof (state)\nthis:\n  lmap f xs = lmap g ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_expand:\n  \"\\<lbrakk> lnull xs \\<longleftrightarrow> lnull ys;\n     \\<lbrakk> \\<not> lnull xs; \\<not> lnull ys \\<rbrakk> \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and> llist_all2 P (ltl xs) (ltl ys) \\<rbrakk>\n   \\<Longrightarrow> llist_all2 P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lnull xs = lnull ys;\n     \\<lbrakk>\\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n     \\<Longrightarrow> P (lhd xs) (lhd ys) \\<and>\n                       llist_all2 P (ltl xs) (ltl ys)\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P xs ys", "by(cases xs)(auto simp add: not_lnull_conv)"], ["", "lemma llist_all2_llength_ltakeWhileD:\n  assumes major: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llength (ltakeWhile Q1 xs) = llength (ltakeWhile Q2 ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltakeWhile Q1 xs) = llength (ltakeWhile Q2 ys)", "using major"], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. llength (ltakeWhile Q1 xs) = llength (ltakeWhile Q2 ys)", "by(coinduction arbitrary: xs ys rule: enat_coinduct)(auto 4 3 simp add: not_lnull_conv llist_all2_LCons1 llist_all2_LCons2 dest!: Q)"], ["", "lemma llist_all2_lzipI:\n  \"\\<lbrakk> llist_all2 P xs ys; llist_all2 P' xs' ys' \\<rbrakk>\n  \\<Longrightarrow> llist_all2 (rel_prod P P') (lzip xs xs') (lzip ys ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; llist_all2 P' xs' ys'\\<rbrakk>\n    \\<Longrightarrow> llist_all2 (rel_prod P P') (lzip xs xs') (lzip ys ys')", "by(coinduction arbitrary: xs xs' ys ys')(auto 6 6 dest: llist_all2_lhdD llist_all2_lnullD intro: llist_all2_ltlI)"], ["", "lemma llist_all2_ltakeI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ltake n xs) (ltake n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow>\n    llist_all2 P (ltake n xs) (ltake n ys)", "by(auto simp add: llist_all2_conv_all_lnth lnth_ltake)"], ["", "lemma llist_all2_ldropnI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ldropn n xs) (ldropn n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow>\n    llist_all2 P (ldropn n xs) (ldropn n ys)", "by(cases \"llength ys\")(auto simp add: llist_all2_conv_all_lnth)"], ["", "lemma llist_all2_ldropI:\n  \"llist_all2 P xs ys \\<Longrightarrow> llist_all2 P (ldrop n xs) (ldrop n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs ys \\<Longrightarrow>\n    llist_all2 P (ldrop n xs) (ldrop n ys)", "by(cases \"llength ys\")(auto simp add: llist_all2_conv_all_lnth llength_ldrop)"], ["", "lemma llist_all2_lSupI:\n  assumes \"Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\" \"\\<forall>(xs, ys)\\<in>Y. llist_all2 P xs ys\"\n  shows \"llist_all2 P (lSup (fst ` Y)) (lSup (snd ` Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lSup (fst ` Y)) (lSup (snd ` Y))", "using assms"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(xs, ys)\\<in>Y. llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 P (lSup (fst ` Y)) (lSup (snd ` Y))", "proof(coinduction arbitrary: Y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y\\<rbrakk>\n       \\<Longrightarrow> lnull (lSup (fst ` Y)) = lnull (lSup (snd ` Y))\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "case LNil"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y\\<rbrakk>\n       \\<Longrightarrow> lnull (lSup (fst ` Y)) = lnull (lSup (snd ` Y))\n 2. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "thus ?case"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n\ngoal (1 subgoal):\n 1. lnull (lSup (fst ` Y)) = lnull (lSup (snd ` Y))", "by(auto dest: llist_all2_lnullD simp add: split_beta)"], ["proof (state)\nthis:\n  lnull (lSup (fst ` Y)) = lnull (lSup (snd ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "case (LCons Y)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "note chain = \\<open>Complete_Partial_Order.chain _ Y\\<close>"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "from LCons"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))", "have Y: \"\\<And>xs ys. (xs, ys) \\<in> Y \\<Longrightarrow> llist_all2 P xs ys\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>xs ys. (xs, ys) \\<in> Y \\<Longrightarrow> llist_all2 P xs ys", "by blast"], ["proof (state)\nthis:\n  (?xs, ?ys) \\<in> Y \\<Longrightarrow> llist_all2 P ?xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "from LCons"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))", "obtain xs ys where xsysY: \"(xs, ys) \\<in> Y\"\n    and [simp]: \"\\<not> lnull xs\" \"\\<not> lnull ys\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>(xs, ys) \\<in> Y; \\<not> lnull xs; \\<not> lnull ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto 4 3 dest: llist_all2_lnullD simp add: split_beta)"], ["proof (state)\nthis:\n  (xs, ys) \\<in> Y\n  \\<not> lnull xs\n  \\<not> lnull ys\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "from xsysY"], ["proof (chain)\npicking this:\n  (xs, ys) \\<in> Y", "have \"lhd xs \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> Y\n\ngoal (1 subgoal):\n 1. lhd xs \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  lhd xs \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "hence \"(THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\""], ["proof (prove)\nusing this:\n  lhd xs \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs", "by(rule the_equality)(auto dest!: lprefix_lhdD chainD[OF chain xsysY])"], ["proof (state)\nthis:\n  (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "moreover"], ["proof (state)\nthis:\n  (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "from xsysY"], ["proof (chain)\npicking this:\n  (xs, ys) \\<in> Y", "have \"lhd ys \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> Y\n\ngoal (1 subgoal):\n 1. lhd ys \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  lhd ys \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "hence \"(THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\""], ["proof (prove)\nusing this:\n  lhd ys \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys", "by(rule the_equality)(auto dest!: lprefix_lhdD chainD[OF chain xsysY])"], ["proof (state)\nthis:\n  (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "moreover"], ["proof (state)\nthis:\n  (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "from xsysY"], ["proof (chain)\npicking this:\n  (xs, ys) \\<in> Y", "have \"llist_all2 P xs ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> Y\n\ngoal (1 subgoal):\n 1. llist_all2 P xs ys", "by(rule Y)"], ["proof (state)\nthis:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "hence \"P (lhd xs) (lhd ys)\""], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. P (lhd xs) (lhd ys)", "by(rule llist_all2_lhdD) simp"], ["proof (state)\nthis:\n  P (lhd xs) (lhd ys)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "ultimately"], ["proof (chain)\npicking this:\n  (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\n  (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\n  P (lhd xs) (lhd ys)", "have ?lhd"], ["proof (prove)\nusing this:\n  (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\n  (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\n  P (lhd xs) (lhd ys)\n\ngoal (1 subgoal):\n 1. P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))", "using LCons"], ["proof (prove)\nusing this:\n  (THE x. x \\<in> lhd ` (fst ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd xs\n  (THE x. x \\<in> lhd ` (snd ` Y \\<inter> {xs. \\<not> lnull xs})) = lhd ys\n  P (lhd xs) (lhd ys)\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y\n  \\<forall>(x, y)\\<in>Y. llist_all2 P x y\n  \\<not> lnull (lSup (fst ` Y))\n  \\<not> lnull (lSup (snd ` Y))\n\ngoal (1 subgoal):\n 1. P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))", "by simp"], ["proof (state)\nthis:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "moreover"], ["proof (state)\nthis:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "{"], ["proof (state)\nthis:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "let ?Y = \"map_prod ltl ltl ` (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "have \"Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n     (map_prod ltl ltl `\n      (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}))", "by(rule chainI)(auto 4 3 dest: Y chainD[OF chain] intro: lprefix_ltlI)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "moreover"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "have \"ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) = fst ` ?Y\"\n      and \"ltl ` (snd ` Y \\<inter> {xs. \\<not> lnull xs}) = snd ` ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n    fst `\n    map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}) &&&\n    ltl ` (snd ` Y \\<inter> {xs. \\<not> lnull xs}) =\n    snd `\n    map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})", "by(fastforce simp add: image_image dest: Y llist_all2_lnullD intro: rev_image_eqI)+"], ["proof (state)\nthis:\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\n  ltl ` (snd ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  snd `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "ultimately"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}))\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\n  ltl ` (snd ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  snd `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})", "have ?ltl"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   (map_prod ltl ltl `\n    (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys}))\n  ltl ` (fst ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  fst `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\n  ltl ` (snd ` Y \\<inter> {xs. \\<not> lnull xs}) =\n  snd `\n  map_prod ltl ltl `\n  (Y \\<inter> {(xs, ys). \\<not> lnull xs \\<and> \\<not> lnull ys})\n\ngoal (1 subgoal):\n 1. (\\<exists>Y.\n        ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n        ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n        Complete_Partial_Order.chain\n         (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n        (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n    llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y)))", "by(auto 4 3 intro: llist_all2_ltlI dest: Y)"], ["proof (state)\nthis:\n  (\\<exists>Y.\n      ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n      ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n      Complete_Partial_Order.chain\n       (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n      (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n  llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "}"], ["proof (state)\nthis:\n  (\\<exists>Y.\n      ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n      ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n      Complete_Partial_Order.chain\n       (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n      (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n  llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain\n                 (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y;\n        \\<forall>(x, y)\\<in>Y. llist_all2 P x y;\n        \\<not> lnull (lSup (fst ` Y));\n        \\<not> lnull (lSup (snd ` Y))\\<rbrakk>\n       \\<Longrightarrow> P (lhd (lSup (fst ` Y)))\n                          (lhd (lSup (snd ` Y))) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup (fst ` Y)) = lSup (fst ` Ya) \\<and>\n                              ltl (lSup (snd ` Y)) = lSup (snd ` Ya) \\<and>\n                              Complete_Partial_Order.chain\n                               (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n                               Ya \\<and>\n                              (\\<forall>(x, y)\\<in>Ya.\n                                  llist_all2 P x y)) \\<or>\n                          llist_all2 P (ltl (lSup (fst ` Y)))\n                           (ltl (lSup (snd ` Y))))", "ultimately"], ["proof (chain)\npicking this:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))\n  (\\<exists>Y.\n      ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n      ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n      Complete_Partial_Order.chain\n       (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n      (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n  llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y)))", "show ?case"], ["proof (prove)\nusing this:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y)))\n  (\\<exists>Y.\n      ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n      ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n      Complete_Partial_Order.chain\n       (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n      (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n  llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y)))\n\ngoal (1 subgoal):\n 1. P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y))) \\<and>\n    ((\\<exists>Y.\n         ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n         ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n         Complete_Partial_Order.chain\n          (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n         (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n     llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y))))", ".."], ["proof (state)\nthis:\n  P (lhd (lSup (fst ` Y))) (lhd (lSup (snd ` Y))) \\<and>\n  ((\\<exists>Y.\n       ltl (lSup (fst ` Y)) = lSup (fst ` Y) \\<and>\n       ltl (lSup (snd ` Y)) = lSup (snd ` Y) \\<and>\n       Complete_Partial_Order.chain\n        (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) Y \\<and>\n       (\\<forall>(x, y)\\<in>Y. llist_all2 P x y)) \\<or>\n   llist_all2 P (ltl (lSup (fst ` Y))) (ltl (lSup (snd ` Y))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_llist_all2 [cont_intro, simp]:\n  assumes f: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  and g: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. g x)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. llist_all2 P (f x) (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. llist_all2 P (f x) (g x))", "proof(rule ccpo.admissibleI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. llist_all2 P (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P (f (lub A)) (g (lub A))", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. llist_all2 P (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P (f (lub A)) (g (lub A))", "assume chain: \"Complete_Partial_Order.chain ord Y\"\n    and Y: \"\\<forall>x\\<in>Y. llist_all2 P (f x) (g x)\"\n    and \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. llist_all2 P (f x) (g x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. llist_all2 P (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P (f (lub A)) (g (lub A))", "from chain"], ["proof (chain)\npicking this:\n  Complete_Partial_Order.chain ord Y", "have \"Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>)) ((\\<lambda>x. (f x, g x)) ` Y)\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n     ((\\<lambda>x. (f x, g x)) ` Y)", "by(rule chain_imageI)(auto intro: mcont_monoD[OF f] mcont_monoD[OF g])"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (rel_prod (\\<sqsubseteq>) (\\<sqsubseteq>))\n   ((\\<lambda>x. (f x, g x)) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. llist_all2 P (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> llist_all2 P (f (lub A)) (g (lub A))", "from llist_all2_lSupI[OF this, of P] chain Y"], ["proof (chain)\npicking this:\n  \\<forall>(xs, ys)\\<in>(\\<lambda>x. (f x, g x)) ` Y.\n     llist_all2 P xs ys \\<Longrightarrow>\n  llist_all2 P (lSup (fst ` (\\<lambda>x. (f x, g x)) ` Y))\n   (lSup (snd ` (\\<lambda>x. (f x, g x)) ` Y))\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. llist_all2 P (f x) (g x)", "show \"llist_all2 P (f (lub Y)) (g (lub Y))\""], ["proof (prove)\nusing this:\n  \\<forall>(xs, ys)\\<in>(\\<lambda>x. (f x, g x)) ` Y.\n     llist_all2 P xs ys \\<Longrightarrow>\n  llist_all2 P (lSup (fst ` (\\<lambda>x. (f x, g x)) ` Y))\n   (lSup (snd ` (\\<lambda>x. (f x, g x)) ` Y))\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. llist_all2 P (f x) (g x)\n\ngoal (1 subgoal):\n 1. llist_all2 P (f (lub Y)) (g (lub Y))", "using \\<open>Y \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>(xs, ys)\\<in>(\\<lambda>x. (f x, g x)) ` Y.\n     llist_all2 P xs ys \\<Longrightarrow>\n  llist_all2 P (lSup (fst ` (\\<lambda>x. (f x, g x)) ` Y))\n   (lSup (snd ` (\\<lambda>x. (f x, g x)) ` Y))\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. llist_all2 P (f x) (g x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. llist_all2 P (f (lub Y)) (g (lub Y))", "by(simp add: mcont_contD[OF f chain] mcont_contD[OF g chain] image_image)"], ["proof (state)\nthis:\n  llist_all2 P (f (lub Y)) (g (lub Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [cont_intro] =\n  ccpo.mcont2mcont[OF llist_ccpo _ mcont_fst]\n  ccpo.mcont2mcont[OF llist_ccpo _ mcont_snd]"], ["", "lemmas ldropWhile_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    ldropWhile.mono ldropWhile.mono ldropWhile_def ldropWhile_def, case_names adm LNil step]"], ["", "lemma llist_all2_ldropWhileI:\n  assumes *: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llist_all2 P (ldropWhile Q1 xs) (ldropWhile Q2 ys)\"\n\\<comment> \\<open>cannot prove this with parallel induction over @{term xs} and @{term ys}\n  because @{term \"\\<lambda>x. \\<not> llist_all2 P (f x) (g x)\"} is not admissible.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (ldropWhile Q1 xs) (ldropWhile Q2 ys)", "using *"], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 P (ldropWhile Q1 xs) (ldropWhile Q2 ys)", "by(induction arbitrary: xs ys rule: ldropWhile_fixp_parallel_induct)(auto split: llist.split dest: Q)"], ["", "lemma llist_all2_same [simp]: \"llist_all2 P xs xs \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. P x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P xs xs = (\\<forall>x\\<in>lset xs. P x x)", "by(auto simp add: llist_all2_conv_all_lnth in_lset_conv_lnth Ball_def)"], ["", "lemma llist_all2_trans:\n  \"\\<lbrakk> llist_all2 P xs ys; llist_all2 P ys zs; transp P \\<rbrakk>\n  \\<Longrightarrow> llist_all2 P xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llist_all2 P xs ys; llist_all2 P ys zs; transp P\\<rbrakk>\n    \\<Longrightarrow> llist_all2 P xs zs", "apply(rule llist_all2_all_lnthI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>llist_all2 P xs ys; llist_all2 P ys zs; transp P\\<rbrakk>\n    \\<Longrightarrow> llength xs = llength zs\n 2. \\<And>n.\n       \\<lbrakk>llist_all2 P xs ys; llist_all2 P ys zs; transp P;\n        enat n < llength xs\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply(simp add: llist_all2_llengthD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>llist_all2 P xs ys; llist_all2 P ys zs; transp P;\n        enat n < llength xs\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply(frule llist_all2_llengthD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>llist_all2 P xs ys; llist_all2 P ys zs; transp P;\n        enat n < llength xs; llength xs = llength ys\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply(drule (1) llist_all2_lnthD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>llist_all2 P ys zs; transp P; enat n < llength xs;\n        llength xs = llength ys; P (lnth xs n) (lnth ys n)\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply(drule llist_all2_lnthD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>transp P; enat n < llength xs; llength xs = llength ys;\n        P (lnth xs n) (lnth ys n)\\<rbrakk>\n       \\<Longrightarrow> enat (?n8 n) < llength ys\n 2. \\<And>n.\n       \\<lbrakk>transp P; enat n < llength xs; llength xs = llength ys;\n        P (lnth xs n) (lnth ys n);\n        P (lnth ys (?n8 n)) (lnth zs (?n8 n))\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>transp P; enat n < llength xs; llength xs = llength ys;\n        P (lnth xs n) (lnth ys n); P (lnth ys n) (lnth zs n)\\<rbrakk>\n       \\<Longrightarrow> P (lnth xs n) (lnth zs n)", "apply(erule (2) transpD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>The last element @{term \"llast\"}\\<close>"], ["", "lemma llast_LNil: \"llast LNil = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast LNil = undefined", "by(simp add: llast_def zero_enat_def)"], ["", "lemma llast_LCons: \"llast (LCons x xs) = (if lnull xs then x else llast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (LCons x xs) = (if lnull xs then x else llast xs)", "by(cases \"llength xs\")(auto simp add: llast_def eSuc_def zero_enat_def not_lnull_conv split: enat.splits)"], ["", "lemma llast_linfinite: \"\\<not> lfinite xs \\<Longrightarrow> llast xs = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> llast xs = undefined", "by(simp add: llast_def lfinite_conv_llength_enat)"], ["", "lemma [simp, code]:\n  shows llast_singleton: \"llast (LCons x LNil) = x\"\n  and llast_LCons2: \"llast (LCons x (LCons y xs)) = llast (LCons y xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (LCons x LNil) = x &&&\n    llast (LCons x (LCons y xs)) = llast (LCons y xs)", "by(simp_all add: llast_LCons)"], ["", "lemma llast_lappend:\n  \"llast (lappend xs ys) = (if lnull ys then llast xs else if lfinite xs then llast ys else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "hence \"\\<not> lnull ys \\<Longrightarrow> llast (lappend xs ys) = llast ys\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<Longrightarrow> llast (lappend xs ys) = llast ys", "by(induct rule: lfinite.induct)(simp_all add: llast_LCons)"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<Longrightarrow> llast (lappend xs ys) = llast ys\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "with True"], ["proof (chain)\npicking this:\n  lfinite xs\n  \\<not> lnull ys \\<Longrightarrow> llast (lappend xs ys) = llast ys", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<not> lnull ys \\<Longrightarrow> llast (lappend xs ys) = llast ys\n\ngoal (1 subgoal):\n 1. llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "by(simp add: lappend_lnull2)"], ["proof (state)\nthis:\n  llast (lappend xs ys) =\n  (if lnull ys then llast xs\n   else if lfinite xs then llast ys else undefined)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. llast (lappend xs ys) =\n    (if lnull ys then llast xs\n     else if lfinite xs then llast ys else undefined)", "by(simp add: llast_linfinite)"], ["proof (state)\nthis:\n  llast (lappend xs ys) =\n  (if lnull ys then llast xs\n   else if lfinite xs then llast ys else undefined)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llast_lappend_LCons [simp]:\n  \"lfinite xs \\<Longrightarrow> llast (lappend xs (LCons y ys)) = llast (LCons y ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    llast (lappend xs (LCons y ys)) = llast (LCons y ys)", "by(simp add: llast_lappend)"], ["", "lemma llast_ldropn: \"enat n < llength xs \\<Longrightarrow> llast (ldropn n xs) = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n < llength xs \\<Longrightarrow> llast (ldropn n xs) = llast xs", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow> llast (ldropn 0 xs) = llast xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   llast (ldropn n xs) = llast xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldropn (Suc n) xs) = llast xs", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow> llast (ldropn 0 xs) = llast xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   llast (ldropn n xs) = llast xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldropn (Suc n) xs) = llast xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldropn 0 xs) = llast xs", "by simp"], ["proof (state)\nthis:\n  llast (ldropn 0 xs) = llast xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   llast (ldropn n xs) = llast xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldropn (Suc n) xs) = llast xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   llast (ldropn n xs) = llast xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldropn (Suc n) xs) = llast xs", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength ?xs \\<Longrightarrow> llast (ldropn n ?xs) = llast ?xs\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n < llength xs \\<Longrightarrow>\n                   llast (ldropn n xs) = llast xs;\n        enat (Suc n) < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldropn (Suc n) xs) = llast xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat n < llength ?xs \\<Longrightarrow> llast (ldropn n ?xs) = llast ?xs\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldropn (Suc n) xs) = llast xs", "by(cases xs)(auto simp add: Suc_ile_eq llast_LCons)"], ["proof (state)\nthis:\n  llast (ldropn (Suc n) xs) = llast xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llast_ldrop:\n  assumes \"n < llength xs\"\n  shows \"llast (ldrop n xs) = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (ldrop n xs) = llast xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llast (ldrop n xs) = llast xs", "from assms"], ["proof (chain)\npicking this:\n  n < llength xs", "obtain n' where n: \"n = enat n'\""], ["proof (prove)\nusing this:\n  n < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = enat n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = enat n'\n\ngoal (1 subgoal):\n 1. llast (ldrop n xs) = llast xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (ldrop n xs) = llast xs", "using assms"], ["proof (prove)\nusing this:\n  n < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldrop n xs) = llast xs", "unfolding n"], ["proof (prove)\nusing this:\n  enat n' < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldrop (enat n') xs) = llast xs", "proof(induct n' arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       llast (ldrop (enat 0) xs) = llast xs\n 2. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   llast (ldrop (enat n') xs) = llast xs;\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldrop (enat (Suc n')) xs) = llast xs", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       enat 0 < llength xs \\<Longrightarrow>\n       llast (ldrop (enat 0) xs) = llast xs\n 2. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   llast (ldrop (enat n') xs) = llast xs;\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldrop (enat (Suc n')) xs) = llast xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldrop (enat 0) xs) = llast xs", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  llast (ldrop (enat 0) xs) = llast xs\n\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   llast (ldrop (enat n') xs) = llast xs;\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldrop (enat (Suc n')) xs) = llast xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   llast (ldrop (enat n') xs) = llast xs;\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldrop (enat (Suc n')) xs) = llast xs", "case Suc"], ["proof (state)\nthis:\n  enat n'_ < llength ?xs \\<Longrightarrow>\n  llast (ldrop (enat n'_) ?xs) = llast ?xs\n  enat (Suc n'_) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>n' xs.\n       \\<lbrakk>\\<And>xs.\n                   enat n' < llength xs \\<Longrightarrow>\n                   llast (ldrop (enat n') xs) = llast xs;\n        enat (Suc n') < llength xs\\<rbrakk>\n       \\<Longrightarrow> llast (ldrop (enat (Suc n')) xs) = llast xs", "thus ?case"], ["proof (prove)\nusing this:\n  enat n'_ < llength ?xs \\<Longrightarrow>\n  llast (ldrop (enat n'_) ?xs) = llast ?xs\n  enat (Suc n'_) < llength xs\n\ngoal (1 subgoal):\n 1. llast (ldrop (enat (Suc n'_)) xs) = llast xs", "by(cases xs)(auto simp add: eSuc_enat[symmetric] llast_LCons)"], ["proof (state)\nthis:\n  llast (ldrop (enat (Suc n'_)) xs) = llast xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llast (ldrop n xs) = llast xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llast_llist_of [simp]: \"llast (llist_of xs) = last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (llist_of xs) = last xs", "by(induct xs)(auto simp add: last_def zero_enat_def llast_LCons llast_LNil)"], ["", "lemma llast_conv_lnth: \"llength xs = eSuc (enat n) \\<Longrightarrow> llast xs = lnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs = eSuc (enat n) \\<Longrightarrow> llast xs = lnth xs n", "by(clarsimp simp add: llast_def zero_enat_def[symmetric] eSuc_enat split: nat.split)"], ["", "lemma llast_lmap:\n  assumes \"lfinite xs\" \"\\<not> lnull xs\"\n  shows \"llast (lmap f xs) = f (llast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (lmap f xs) = f (llast xs)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. llast (lmap f xs) = f (llast xs)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> lnull LNil \\<Longrightarrow> llast (lmap f LNil) = f (llast LNil)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        \\<not> lnull xs \\<Longrightarrow> llast (lmap f xs) = f (llast xs);\n        \\<not> lnull (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> llast (lmap f (LCons x xs)) =\n                         f (llast (LCons x xs))", "case (lfinite_LConsI xs)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<not> lnull xs \\<Longrightarrow> llast (lmap f xs) = f (llast xs)\n  \\<not> lnull (LCons x_ xs)\n\ngoal (2 subgoals):\n 1. \\<not> lnull LNil \\<Longrightarrow> llast (lmap f LNil) = f (llast LNil)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        \\<not> lnull xs \\<Longrightarrow> llast (lmap f xs) = f (llast xs);\n        \\<not> lnull (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> llast (lmap f (LCons x xs)) =\n                         f (llast (LCons x xs))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  \\<not> lnull xs \\<Longrightarrow> llast (lmap f xs) = f (llast xs)\n  \\<not> lnull (LCons x_ xs)\n\ngoal (1 subgoal):\n 1. llast (lmap f (LCons x_ xs)) = f (llast (LCons x_ xs))", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  llast (lmap f (LCons x_ xs)) = f (llast (LCons x_ xs))\n\ngoal (1 subgoal):\n 1. \\<not> lnull LNil \\<Longrightarrow> llast (lmap f LNil) = f (llast LNil)", "qed simp"], ["", "subsection \\<open>Distinct lazy lists @{term \"ldistinct\"}\\<close>"], ["", "inductive_simps ldistinct_LCons [code, simp]:\n  \"ldistinct (LCons x xs)\""], ["", "lemma ldistinct_LNil_code [code]:\n  \"ldistinct LNil = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct LNil = True", "by simp"], ["", "lemma ldistinct_llist_of [simp]:\n  \"ldistinct (llist_of xs) \\<longleftrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (llist_of xs) = distinct xs", "by(induct xs) auto"], ["", "lemma ldistinct_coinduct [consumes 1, case_names ldistinct, case_conclusion ldistinct lhd ltl, coinduct pred: ldistinct]:\n  assumes \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs \\<rbrakk>\n    \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and> (X (ltl xs) \\<or> ldistinct (ltl xs))\"\n  shows \"ldistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs", "using \\<open>X xs\\<close>"], ["proof (prove)\nusing this:\n  X xs\n\ngoal (1 subgoal):\n 1. ldistinct xs", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       X x \\<Longrightarrow>\n       x = LNil \\<or>\n       (\\<exists>xa xs.\n           x = LCons xa xs \\<and>\n           xa \\<notin> lset xs \\<and> (X xs \\<or> ldistinct xs))", "case (ldistinct xs)"], ["proof (state)\nthis:\n  X xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       X x \\<Longrightarrow>\n       x = LNil \\<or>\n       (\\<exists>xa xs.\n           x = LCons xa xs \\<and>\n           xa \\<notin> lset xs \\<and> (X xs \\<or> ldistinct xs))", "thus ?case"], ["proof (prove)\nusing this:\n  X xs\n\ngoal (1 subgoal):\n 1. xs = LNil \\<or>\n    (\\<exists>x xs.\n        xs = LCons x xs \\<and>\n        x \\<notin> lset xs \\<and> (X xs \\<or> ldistinct xs))", "by(cases xs)(auto dest: step)"], ["proof (state)\nthis:\n  xs = LNil \\<or>\n  (\\<exists>x xs.\n      xs = LCons x xs \\<and>\n      x \\<notin> lset xs \\<and> (X xs \\<or> ldistinct xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lhdD:\n  \"\\<lbrakk> ldistinct xs; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ldistinct xs; \\<not> lnull xs\\<rbrakk>\n    \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs)", "by(clarsimp simp add: not_lnull_conv)"], ["", "lemma ldistinct_ltlI:\n  \"ldistinct xs \\<Longrightarrow> ldistinct (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (ltl xs)", "by(cases xs) simp_all"], ["", "lemma ldistinct_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) Y; \\<forall>xs\\<in>Y. ldistinct xs \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lSup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n     \\<forall>xs\\<in>Y. ldistinct xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct (lSup Y)", "proof(coinduction arbitrary: Y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "case (ldistinct Y)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x\n  \\<not> lnull (lSup Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "hence chain: \"Complete_Partial_Order.chain (\\<sqsubseteq>) Y\"\n    and distinct: \"\\<And>xs. xs \\<in> Y \\<Longrightarrow> ldistinct xs\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x\n  \\<not> lnull (lSup Y)\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (\\<sqsubseteq>) Y &&&\n    (\\<And>xs. xs \\<in> Y \\<Longrightarrow> ldistinct xs)", "by blast+"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  ?xs \\<in> Y \\<Longrightarrow> ldistinct ?xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "have ?lhd"], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lSup Y) \\<notin> lset (ltl (lSup Y))", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) \\<notin> lset (ltl (lSup Y))", "by(auto 4 4 simp add: lset_lSup chain_lprefix_ltl dest: distinct lhd_lSup_eq ldistinct_lhdD)"], ["proof (state)\nthis:\n  lhd (lSup Y) \\<notin> lset (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "moreover"], ["proof (state)\nthis:\n  lhd (lSup Y) \\<notin> lset (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "have ?ltl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y.\n        ltl (lSup Y) = lSup Y \\<and>\n        Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n        (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n    ldistinct (ltl (lSup Y))", "by(auto 4 3 simp add: chain_lprefix_ltl chain intro: ldistinct_ltlI distinct)"], ["proof (state)\nthis:\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n  ldistinct (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x;\n        \\<not> lnull (lSup Y)\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  ldistinct x)) \\<or>\n                          ldistinct (ltl (lSup Y)))", "ultimately"], ["proof (chain)\npicking this:\n  lhd (lSup Y) \\<notin> lset (ltl (lSup Y))\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n  ldistinct (ltl (lSup Y))", "show ?case"], ["proof (prove)\nusing this:\n  lhd (lSup Y) \\<notin> lset (ltl (lSup Y))\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n  ldistinct (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n    ((\\<exists>Y.\n         ltl (lSup Y) = lSup Y \\<and>\n         Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n         (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n     ldistinct (ltl (lSup Y)))", ".."], ["proof (state)\nthis:\n  lhd (lSup Y) \\<notin> lset (ltl (lSup Y)) \\<and>\n  ((\\<exists>Y.\n       ltl (lSup Y) = lSup Y \\<and>\n       Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n       (\\<forall>x. x \\<in> Y \\<longrightarrow> ldistinct x)) \\<or>\n   ldistinct (ltl (lSup Y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_ldistinct [cont_intro, simp]:\n  assumes mcont: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. ldistinct (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. ldistinct (f x))", "proof(rule ccpo.admissibleI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. ldistinct (f x)\\<rbrakk>\n       \\<Longrightarrow> ldistinct (f (lub A))", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. ldistinct (f x)\\<rbrakk>\n       \\<Longrightarrow> ldistinct (f (lub A))", "assume chain: \"Complete_Partial_Order.chain ord Y\"\n    and distinct: \"\\<forall>x\\<in>Y. ldistinct (f x)\"\n    and \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. ldistinct (f x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. ldistinct (f x)\\<rbrakk>\n       \\<Longrightarrow> ldistinct (f (lub A))", "thus \"ldistinct (f (lub Y))\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. ldistinct (f x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ldistinct (f (lub Y))", "by(simp add: mcont_contD[OF mcont] ldistinct_lSup chain_imageI mcont_monoD[OF mcont])"], ["proof (state)\nthis:\n  ldistinct (f (lub Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lappend:\n  \"ldistinct (lappend xs ys) \\<longleftrightarrow> ldistinct xs \\<and> (lfinite xs \\<longrightarrow> ldistinct ys \\<and> lset xs \\<inter> lset ys = {})\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lappend xs ys) =\n    (ldistinct xs \\<and>\n     (lfinite xs \\<longrightarrow>\n      ldistinct ys \\<and> lset xs \\<inter> lset ys = {}))", "proof(intro iffI conjI strip)"], ["proof (state)\ngoal (4 subgoals):\n 1. ldistinct (lappend xs ys) \\<Longrightarrow> ldistinct xs\n 2. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct ys\n 3. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> lset xs \\<inter> lset ys = {}\n 4. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "assume \"?lhs\""], ["proof (state)\nthis:\n  ldistinct (lappend xs ys)\n\ngoal (4 subgoals):\n 1. ldistinct (lappend xs ys) \\<Longrightarrow> ldistinct xs\n 2. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct ys\n 3. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> lset xs \\<inter> lset ys = {}\n 4. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "thus \"ldistinct xs\""], ["proof (prove)\nusing this:\n  ldistinct (lappend xs ys)\n\ngoal (1 subgoal):\n 1. ldistinct xs", "by(coinduct)(auto simp add: not_lnull_conv in_lset_lappend_iff)"], ["proof (state)\nthis:\n  ldistinct xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct ys\n 2. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> lset xs \\<inter> lset ys = {}\n 3. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct ys\n 2. \\<lbrakk>ldistinct (lappend xs ys); lfinite xs\\<rbrakk>\n    \\<Longrightarrow> lset xs \\<inter> lset ys = {}\n 3. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "thus \"ldistinct ys\" \"lset xs \\<inter> lset ys = {}\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. ldistinct ys &&& lset xs \\<inter> lset ys = {}", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  lfinite xs\n  ldistinct (lappend xs ys)\n\ngoal (1 subgoal):\n 1. ldistinct ys &&& lset xs \\<inter> lset ys = {}", "by induct simp_all"], ["proof (state)\nthis:\n  ldistinct ys\n  lset xs \\<inter> lset ys = {}\n\ngoal (1 subgoal):\n 1. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "assume \"?rhs\""], ["proof (state)\nthis:\n  ldistinct xs \\<and>\n  (lfinite xs \\<longrightarrow>\n   ldistinct ys \\<and> lset xs \\<inter> lset ys = {})\n\ngoal (1 subgoal):\n 1. ldistinct xs \\<and>\n    (lfinite xs \\<longrightarrow>\n     ldistinct ys \\<and> lset xs \\<inter> lset ys = {}) \\<Longrightarrow>\n    ldistinct (lappend xs ys)", "thus ?lhs"], ["proof (prove)\nusing this:\n  ldistinct xs \\<and>\n  (lfinite xs \\<longrightarrow>\n   ldistinct ys \\<and> lset xs \\<inter> lset ys = {})\n\ngoal (1 subgoal):\n 1. ldistinct (lappend xs ys)", "by(coinduction arbitrary: xs)(auto simp add: not_lnull_conv in_lset_lappend_iff)"], ["proof (state)\nthis:\n  ldistinct (lappend xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lprefix:\n  \"\\<lbrakk> ldistinct xs; ys \\<sqsubseteq> xs \\<rbrakk> \\<Longrightarrow> ldistinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ldistinct xs; ys \\<sqsubseteq> xs\\<rbrakk>\n    \\<Longrightarrow> ldistinct ys", "by(clarsimp simp add: lprefix_conv_lappend ldistinct_lappend)"], ["", "lemma admissible_not_ldistinct[THEN admissible_subst, cont_intro, simp]:\n  \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>x. \\<not> ldistinct x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>x. \\<not> ldistinct x)", "by(rule ccpo.admissibleI)(auto dest: ldistinct_lprefix intro: chain_lprefix_lSup)"], ["", "lemma ldistinct_ltake: \"ldistinct xs \\<Longrightarrow> ldistinct (ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (ltake n xs)", "by (metis ldistinct_lprefix ltake_is_lprefix)"], ["", "lemma ldistinct_ldropn:\n  \"ldistinct xs \\<Longrightarrow> ldistinct (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (ldropn n xs)", "by(induct n arbitrary: xs)(simp, case_tac xs, simp_all)"], ["", "lemma ldistinct_ldrop: \"ldistinct xs \\<Longrightarrow> ldistinct (ldrop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (ldrop n xs)", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         ldistinct a \\<longrightarrow> (\\<forall>x. ldistinct (ldrop x a)))\n 2. \\<And>n. ldistinct LNil \\<Longrightarrow> ldistinct (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldistinct xs \\<Longrightarrow> ldistinct (ldrop n xs);\n        ldistinct (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> ldistinct (ldrop n (LCons x xs))", "case (LCons x xs)"], ["proof (state)\nthis:\n  lfinite xs\n  ldistinct xs \\<Longrightarrow> ldistinct (ldrop ?n xs)\n  ldistinct (LCons x xs)\n\ngoal (3 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         ldistinct a \\<longrightarrow> (\\<forall>x. ldistinct (ldrop x a)))\n 2. \\<And>n. ldistinct LNil \\<Longrightarrow> ldistinct (ldrop n LNil)\n 3. \\<And>x xs n.\n       \\<lbrakk>lfinite xs;\n        \\<And>n. ldistinct xs \\<Longrightarrow> ldistinct (ldrop n xs);\n        ldistinct (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> ldistinct (ldrop n (LCons x xs))", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  ldistinct xs \\<Longrightarrow> ldistinct (ldrop ?n xs)\n  ldistinct (LCons x xs)\n\ngoal (1 subgoal):\n 1. ldistinct (ldrop n (LCons x xs))", "by(cases n rule: co.enat.exhaust) simp_all"], ["proof (state)\nthis:\n  ldistinct (ldrop n (LCons x xs))\n\ngoal (2 subgoals):\n 1. ccpo.admissible lSup (\\<sqsubseteq>)\n     (\\<lambda>a.\n         ldistinct a \\<longrightarrow> (\\<forall>x. ldistinct (ldrop x a)))\n 2. \\<And>n. ldistinct LNil \\<Longrightarrow> ldistinct (ldrop n LNil)", "qed simp_all"], ["", "lemma ldistinct_conv_lnth:\n  \"ldistinct xs \\<longleftrightarrow> (\\<forall>i j. enat i < llength xs \\<longrightarrow> enat j < llength xs \\<longrightarrow> i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs =\n    (\\<forall>i j.\n        enat i < llength xs \\<longrightarrow>\n        enat j < llength xs \\<longrightarrow>\n        i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j)", "proof(intro iffI strip)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j\n 2. \\<forall>i j.\n       enat i < llength xs \\<longrightarrow>\n       enat j < llength xs \\<longrightarrow>\n       i \\<noteq> j \\<longrightarrow>\n       lnth xs i \\<noteq> lnth xs j \\<Longrightarrow>\n    ldistinct xs", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<forall>i j.\n     enat i < llength xs \\<longrightarrow>\n     enat j < llength xs \\<longrightarrow>\n     i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j\n 2. \\<forall>i j.\n       enat i < llength xs \\<longrightarrow>\n       enat j < llength xs \\<longrightarrow>\n       i \\<noteq> j \\<longrightarrow>\n       lnth xs i \\<noteq> lnth xs j \\<Longrightarrow>\n    ldistinct xs", "thus \"?lhs\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     enat i < llength xs \\<longrightarrow>\n     enat j < llength xs \\<longrightarrow>\n     i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j\n\ngoal (1 subgoal):\n 1. ldistinct xs", "proof(coinduct xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "case (ldistinct xs)"], ["proof (state)\nthis:\n  \\<forall>i j.\n     enat i < llength xs \\<longrightarrow>\n     enat j < llength xs \\<longrightarrow>\n     i \\<noteq> j \\<longrightarrow> lnth xs i \\<noteq> lnth xs j\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "from \\<open>\\<not> lnull xs\\<close>"], ["proof (chain)\npicking this:\n  \\<not> lnull xs", "obtain x xs' where LCons: \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "have \"x \\<notin> lset xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> lset xs'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> lset xs' \\<Longrightarrow> False", "assume \"x \\<in> lset xs'\""], ["proof (state)\nthis:\n  x \\<in> lset xs'\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> lset xs'", "obtain j where \"enat j < llength xs'\" \"lnth xs' j = x\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs'\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>enat j < llength xs'; lnth xs' j = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lset_conv_lnth"], ["proof (prove)\nusing this:\n  x \\<in> {lnth xs' n |n. enat n < llength xs'}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>enat j < llength xs'; lnth xs' j = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  enat j < llength xs'\n  lnth xs' j = x\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs' \\<Longrightarrow> False", "hence \"enat 0 < llength xs\" \"enat (Suc j) < llength xs\" \"lnth xs (Suc j) = x\" \"lnth xs 0 = x\""], ["proof (prove)\nusing this:\n  enat j < llength xs'\n  lnth xs' j = x\n\ngoal (1 subgoal):\n 1. (enat 0 < llength xs &&& enat (Suc j) < llength xs) &&&\n    lnth xs (Suc j) = x &&& lnth xs 0 = x", "by(simp_all add: LCons Suc_ile_eq zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  enat 0 < llength xs\n  enat (Suc j) < llength xs\n  lnth xs (Suc j) = x\n  lnth xs 0 = x\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  enat 0 < llength xs\n  enat (Suc j) < llength xs\n  lnth xs (Suc j) = x\n  lnth xs 0 = x\n\ngoal (1 subgoal):\n 1. False", "by(auto dest: ldistinct(1)[rule_format])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> lset xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "moreover"], ["proof (state)\nthis:\n  x \\<notin> lset xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "{"], ["proof (state)\nthis:\n  x \\<notin> lset xs'\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "assume \"enat i < llength xs'\" \"enat j < llength xs'\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  enat i < llength xs'\n  enat j < llength xs'\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "hence \"enat (Suc i) < llength xs\" \"enat (Suc j) < llength xs\""], ["proof (prove)\nusing this:\n  enat i < llength xs'\n  enat j < llength xs'\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. enat (Suc i) < llength xs &&& enat (Suc j) < llength xs", "by(simp_all add: LCons Suc_ile_eq)"], ["proof (state)\nthis:\n  enat (Suc i) < llength xs\n  enat (Suc j) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  enat (Suc i) < llength xs\n  enat (Suc j) < llength xs", "have \"lnth xs (Suc i) \\<noteq> lnth xs (Suc j)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  enat (Suc i) < llength xs\n  enat (Suc j) < llength xs\n\ngoal (1 subgoal):\n 1. lnth xs (Suc i) \\<noteq> lnth xs (Suc j)", "by(auto dest: ldistinct(1)[rule_format])"], ["proof (state)\nthis:\n  lnth xs (Suc i) \\<noteq> lnth xs (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "hence \"lnth xs' i \\<noteq> lnth xs' j\""], ["proof (prove)\nusing this:\n  lnth xs (Suc i) \\<noteq> lnth xs (Suc j)\n\ngoal (1 subgoal):\n 1. lnth xs' i \\<noteq> lnth xs' j", "unfolding LCons"], ["proof (prove)\nusing this:\n  lnth (LCons x xs') (Suc i) \\<noteq> lnth (LCons x xs') (Suc j)\n\ngoal (1 subgoal):\n 1. lnth xs' i \\<noteq> lnth xs' j", "by simp"], ["proof (state)\nthis:\n  lnth xs' i \\<noteq> lnth xs' j\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?i2 < llength xs'; enat ?j2 < llength xs';\n   ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> lnth xs' ?i2 \\<noteq> lnth xs' ?j2\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>i j.\n                   enat i < llength xs \\<longrightarrow>\n                   enat j < llength xs \\<longrightarrow>\n                   i \\<noteq> j \\<longrightarrow>\n                   lnth xs i \\<noteq> lnth xs j;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> lhd xs \\<notin> lset (ltl xs) \\<and>\n                         ((\\<forall>i j.\n                              enat i < llength (ltl xs) \\<longrightarrow>\n                              enat j < llength (ltl xs) \\<longrightarrow>\n                              i \\<noteq> j \\<longrightarrow>\n                              lnth (ltl xs) i \\<noteq>\n                              lnth (ltl xs) j) \\<or>\n                          ldistinct (ltl xs))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> lset xs'\n  \\<lbrakk>enat ?i2 < llength xs'; enat ?j2 < llength xs';\n   ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> lnth xs' ?i2 \\<noteq> lnth xs' ?j2", "show ?case"], ["proof (prove)\nusing this:\n  x \\<notin> lset xs'\n  \\<lbrakk>enat ?i2 < llength xs'; enat ?j2 < llength xs';\n   ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> lnth xs' ?i2 \\<noteq> lnth xs' ?j2\n\ngoal (1 subgoal):\n 1. lhd xs \\<notin> lset (ltl xs) \\<and>\n    ((\\<forall>i j.\n         enat i < llength (ltl xs) \\<longrightarrow>\n         enat j < llength (ltl xs) \\<longrightarrow>\n         i \\<noteq> j \\<longrightarrow>\n         lnth (ltl xs) i \\<noteq> lnth (ltl xs) j) \\<or>\n     ldistinct (ltl xs))", "using LCons"], ["proof (prove)\nusing this:\n  x \\<notin> lset xs'\n  \\<lbrakk>enat ?i2 < llength xs'; enat ?j2 < llength xs';\n   ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> lnth xs' ?i2 \\<noteq> lnth xs' ?j2\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. lhd xs \\<notin> lset (ltl xs) \\<and>\n    ((\\<forall>i j.\n         enat i < llength (ltl xs) \\<longrightarrow>\n         enat j < llength (ltl xs) \\<longrightarrow>\n         i \\<noteq> j \\<longrightarrow>\n         lnth (ltl xs) i \\<noteq> lnth (ltl xs) j) \\<or>\n     ldistinct (ltl xs))", "by simp"], ["proof (state)\nthis:\n  lhd xs \\<notin> lset (ltl xs) \\<and>\n  ((\\<forall>i j.\n       enat i < llength (ltl xs) \\<longrightarrow>\n       enat j < llength (ltl xs) \\<longrightarrow>\n       i \\<noteq> j \\<longrightarrow>\n       lnth (ltl xs) i \\<noteq> lnth (ltl xs) j) \\<or>\n   ldistinct (ltl xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ldistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "assume \"?lhs\""], ["proof (state)\nthis:\n  ldistinct xs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "assume \"enat i < llength xs\" \"enat j < llength xs\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>ldistinct xs; enat i < llength xs; enat j < llength xs;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "thus \"lnth xs i \\<noteq> lnth xs j\""], ["proof (prove)\nusing this:\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. lnth xs i \\<noteq> lnth xs j", "proof(induct i j rule: wlog_linorder_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b\n 2. \\<lbrakk>\\<lbrakk>enat j < llength xs; enat i < llength xs;\n              j \\<noteq> i\\<rbrakk>\n             \\<Longrightarrow> lnth xs j \\<noteq> lnth xs i;\n     enat i < llength xs; enat j < llength xs; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "case symmetry"], ["proof (state)\nthis:\n  \\<lbrakk>enat j < llength xs; enat i < llength xs; j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> lnth xs j \\<noteq> lnth xs i\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b\n 2. \\<lbrakk>\\<lbrakk>enat j < llength xs; enat i < llength xs;\n              j \\<noteq> i\\<rbrakk>\n             \\<Longrightarrow> lnth xs j \\<noteq> lnth xs i;\n     enat i < llength xs; enat j < llength xs; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> lnth xs i \\<noteq> lnth xs j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat j < llength xs; enat i < llength xs; j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> lnth xs j \\<noteq> lnth xs i\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. lnth xs i \\<noteq> lnth xs j", "by simp"], ["proof (state)\nthis:\n  lnth xs i \\<noteq> lnth xs j\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "case (le i j)"], ["proof (state)\nthis:\n  i \\<le> j\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "from \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  ldistinct xs", "have \"ldistinct (ldropn i xs)\""], ["proof (prove)\nusing this:\n  ldistinct xs\n\ngoal (1 subgoal):\n 1. ldistinct (ldropn i xs)", "by(rule ldistinct_ldropn)"], ["proof (state)\nthis:\n  ldistinct (ldropn i xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "also"], ["proof (state)\nthis:\n  ldistinct (ldropn i xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "note ldropn_Suc_conv_ldropn[symmetric]"], ["proof (state)\nthis:\n  enat ?n < llength ?xs \\<Longrightarrow>\n  ldropn ?n ?xs = LCons (lnth ?xs ?n) (ldropn (Suc ?n) ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "also"], ["proof (state)\nthis:\n  enat ?n < llength ?xs \\<Longrightarrow>\n  ldropn ?n ?xs = LCons (lnth ?xs ?n) (ldropn (Suc ?n) ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "from le"], ["proof (chain)\npicking this:\n  i \\<le> j\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j", "have \"i < j\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i < j", "by simp"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "hence \"lnth xs j \\<in> lset (ldropn (Suc i) xs)\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. lnth xs j \\<in> lset (ldropn (Suc i) xs)", "using le"], ["proof (prove)\nusing this:\n  i < j\n  i \\<le> j\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. lnth xs j \\<in> lset (ldropn (Suc i) xs)", "unfolding in_lset_conv_lnth"], ["proof (prove)\nusing this:\n  i < j\n  i \\<le> j\n  enat i < llength xs\n  enat j < llength xs\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < llength (ldropn (Suc i) xs) \\<and>\n       lnth (ldropn (Suc i) xs) n = lnth xs j", "by(cases \"llength xs\")(auto intro!: exI[where x=\"j - Suc i\"])"], ["proof (state)\nthis:\n  lnth xs j \\<in> lset (ldropn (Suc i) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> b; enat a < llength xs; enat b < llength xs;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> lnth xs a \\<noteq> lnth xs b", "ultimately"], ["proof (chain)\npicking this:\n  enat i < llength xs \\<Longrightarrow>\n  ldistinct (LCons (lnth xs i) (ldropn (Suc i) xs))\n  lnth xs j \\<in> lset (ldropn (Suc i) xs)", "show ?case"], ["proof (prove)\nusing this:\n  enat i < llength xs \\<Longrightarrow>\n  ldistinct (LCons (lnth xs i) (ldropn (Suc i) xs))\n  lnth xs j \\<in> lset (ldropn (Suc i) xs)\n\ngoal (1 subgoal):\n 1. lnth xs i \\<noteq> lnth xs j", "using \\<open>enat i < llength xs\\<close>"], ["proof (prove)\nusing this:\n  enat i < llength xs \\<Longrightarrow>\n  ldistinct (LCons (lnth xs i) (ldropn (Suc i) xs))\n  lnth xs j \\<in> lset (ldropn (Suc i) xs)\n  enat i < llength xs\n\ngoal (1 subgoal):\n 1. lnth xs i \\<noteq> lnth xs j", "by auto"], ["proof (state)\nthis:\n  lnth xs i \\<noteq> lnth xs j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnth xs i \\<noteq> lnth xs j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lmap [simp]:\n  \"ldistinct (lmap f xs) \\<longleftrightarrow> ldistinct xs \\<and> inj_on f (lset xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lmap f xs) = (ldistinct xs \\<and> inj_on f (lset xs))", "proof(intro iffI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ldistinct (lmap f xs) \\<Longrightarrow> ldistinct xs\n 2. ldistinct (lmap f xs) \\<Longrightarrow> inj_on f (lset xs)\n 3. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "assume dist: ?lhs"], ["proof (state)\nthis:\n  ldistinct (lmap f xs)\n\ngoal (3 subgoals):\n 1. ldistinct (lmap f xs) \\<Longrightarrow> ldistinct xs\n 2. ldistinct (lmap f xs) \\<Longrightarrow> inj_on f (lset xs)\n 3. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "thus \"ldistinct xs\""], ["proof (prove)\nusing this:\n  ldistinct (lmap f xs)\n\ngoal (1 subgoal):\n 1. ldistinct xs", "by(coinduct)(auto simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  ldistinct xs\n\ngoal (2 subgoals):\n 1. ldistinct (lmap f xs) \\<Longrightarrow> inj_on f (lset xs)\n 2. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "show \"inj_on f (lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (lset xs)", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> lset xs; y \\<in> lset xs; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> lset xs; y \\<in> lset xs; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> lset xs\" and \"y \\<in> lset xs\" and \"f x = f y\""], ["proof (state)\nthis:\n  x \\<in> lset xs\n  y \\<in> lset xs\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> lset xs; y \\<in> lset xs; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<in> lset xs\n  y \\<in> lset xs\n  f x = f y", "obtain i j\n      where \"enat i < llength xs\" \"x = lnth xs i\" \"enat j < llength xs\" \"y = lnth xs j\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  y \\<in> lset xs\n  f x = f y\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>enat i < llength xs; x = lnth xs i; enat j < llength xs;\n         y = lnth xs j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lset_conv_lnth"], ["proof (prove)\nusing this:\n  x \\<in> {lnth xs n |n. enat n < llength xs}\n  y \\<in> {lnth xs n |n. enat n < llength xs}\n  f x = f y\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>enat i < llength xs; x = lnth xs i; enat j < llength xs;\n         y = lnth xs j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enat i < llength xs\n  x = lnth xs i\n  enat j < llength xs\n  y = lnth xs j\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> lset xs; y \\<in> lset xs; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with dist \\<open>f x = f y\\<close>"], ["proof (chain)\npicking this:\n  ldistinct (lmap f xs)\n  f x = f y\n  enat i < llength xs\n  x = lnth xs i\n  enat j < llength xs\n  y = lnth xs j", "show \"x = y\""], ["proof (prove)\nusing this:\n  ldistinct (lmap f xs)\n  f x = f y\n  enat i < llength xs\n  x = lnth xs i\n  enat j < llength xs\n  y = lnth xs j\n\ngoal (1 subgoal):\n 1. x = y", "unfolding ldistinct_conv_lnth"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     enat i < llength (lmap f xs) \\<longrightarrow>\n     enat j < llength (lmap f xs) \\<longrightarrow>\n     i \\<noteq> j \\<longrightarrow>\n     lnth (lmap f xs) i \\<noteq> lnth (lmap f xs) j\n  f x = f y\n  enat i < llength xs\n  x = lnth xs i\n  enat j < llength xs\n  y = lnth xs j\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f (lset xs)\n\ngoal (1 subgoal):\n 1. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "assume ?rhs"], ["proof (state)\nthis:\n  ldistinct xs \\<and> inj_on f (lset xs)\n\ngoal (1 subgoal):\n 1. ldistinct xs \\<and> inj_on f (lset xs) \\<Longrightarrow>\n    ldistinct (lmap f xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  ldistinct xs \\<and> inj_on f (lset xs)\n\ngoal (1 subgoal):\n 1. ldistinct (lmap f xs)", "by(coinduction arbitrary: xs)(auto simp add: not_lnull_conv)"], ["proof (state)\nthis:\n  ldistinct (lmap f xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lzipI1: \"ldistinct xs \\<Longrightarrow> ldistinct (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (lzip xs ys)", "by(coinduction arbitrary: xs ys)(auto simp add: not_lnull_conv dest: lset_lzipD1)"], ["", "lemma ldistinct_lzipI2: \"ldistinct ys \\<Longrightarrow> ldistinct (lzip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct ys \\<Longrightarrow> ldistinct (lzip xs ys)", "by(coinduction arbitrary: xs ys)(auto 4 3 simp add: not_lnull_conv dest: lset_lzipD2)"], ["", "subsection \\<open>Sortedness @{term lsorted}\\<close>"], ["", "context ord begin"], ["", "coinductive lsorted :: \"'a llist \\<Rightarrow> bool\"\nwhere\n  LNil [simp]: \"lsorted LNil\"\n| Singleton [simp]: \"lsorted (LCons x LNil)\"\n| LCons_LCons: \"\\<lbrakk> x \\<le> y; lsorted (LCons y xs) \\<rbrakk> \\<Longrightarrow> lsorted (LCons x (LCons y xs))\""], ["", "inductive_simps lsorted_LCons_LCons [simp]:\n  \"lsorted (LCons x (LCons y xs))\""], ["", "inductive_simps lsorted_code [code]:\n  \"lsorted LNil\"\n  \"lsorted (LCons x LNil)\"\n  \"lsorted (LCons x (LCons y xs))\""], ["", "lemma lsorted_coinduct' [consumes 1, case_names lsorted, case_conclusion lsorted lhd ltl, coinduct pred: lsorted]:\n  assumes major: \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs; \\<not> lnull (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> lhd (ltl xs) \\<and> (X (ltl xs) \\<or> lsorted (ltl xs))\"\n  shows \"lsorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs", "using major"], ["proof (prove)\nusing this:\n  X xs\n\ngoal (1 subgoal):\n 1. lsorted xs", "by coinduct(subst disj_commute, auto 4 4 simp add: neq_LNil_conv dest: step)"], ["", "lemma lsorted_ltlI: \"lsorted xs \\<Longrightarrow> lsorted (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs \\<Longrightarrow> lsorted (ltl xs)", "by(erule lsorted.cases) simp_all"], ["", "lemma lsorted_lhdD:\n  \"\\<lbrakk> lsorted xs; \\<not> lnull xs; \\<not> lnull (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> lhd (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsorted xs; \\<not> lnull xs; \\<not> lnull (ltl xs)\\<rbrakk>\n    \\<Longrightarrow> lhd xs \\<le> lhd (ltl xs)", "by(auto elim: lsorted.cases)"], ["", "lemma lsorted_LCons':\n  \"lsorted (LCons x xs) \\<longleftrightarrow> (\\<not> lnull xs \\<longrightarrow> x \\<le> lhd xs \\<and> lsorted xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (LCons x xs) =\n    (\\<not> lnull xs \\<longrightarrow> x \\<le> lhd xs \\<and> lsorted xs)", "by(cases xs) auto"], ["", "lemma lsorted_lSup:\n  \"\\<lbrakk> Complete_Partial_Order.chain (\\<sqsubseteq>) Y; \\<forall>xs \\<in> Y. lsorted xs \\<rbrakk>\n  \\<Longrightarrow> lsorted (lSup Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n     \\<forall>xs\\<in>Y. lsorted xs\\<rbrakk>\n    \\<Longrightarrow> lsorted (lSup Y)", "proof(coinduction arbitrary: Y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "case (lsorted Y)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x\n  \\<not> lnull (lSup Y)\n  \\<not> lnull (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "hence sorted: \"\\<And>xs. xs \\<in> Y \\<Longrightarrow> lsorted xs\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x\n  \\<not> lnull (lSup Y)\n  \\<not> lnull (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> Y \\<Longrightarrow> lsorted xs", "by blast"], ["proof (state)\nthis:\n  ?xs \\<in> Y \\<Longrightarrow> lsorted ?xs\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "note chain = \\<open>Complete_Partial_Order.chain (\\<sqsubseteq>) Y\\<close>"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "from \\<open>\\<not> lnull (lSup Y)\\<close> \\<open>\\<not> lnull (ltl (lSup Y))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> lnull (lSup Y)\n  \\<not> lnull (ltl (lSup Y))", "obtain xs where \"xs \\<in> Y\" \"\\<not> lnull xs\" \"\\<not> lnull (ltl xs)\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lSup Y)\n  \\<not> lnull (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> Y; \\<not> lnull xs; \\<not> lnull (ltl xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs \\<in> Y\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "hence \"lhd (lSup Y) = lhd xs\" \"lhd (ltl (lSup Y)) = lhd (ltl xs)\" \"lhd xs \\<le> lhd (ltl xs)\""], ["proof (prove)\nusing this:\n  xs \\<in> Y\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) = lhd xs &&&\n    lhd (ltl (lSup Y)) = lhd (ltl xs) &&& lhd xs \\<le> lhd (ltl xs)", "using chain sorted"], ["proof (prove)\nusing this:\n  xs \\<in> Y\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  ?xs \\<in> Y \\<Longrightarrow> lsorted ?xs\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) = lhd xs &&&\n    lhd (ltl (lSup Y)) = lhd (ltl xs) &&& lhd xs \\<le> lhd (ltl xs)", "by(auto intro: lhd_lSup_eq chain_lprefix_ltl lsorted_lhdD)"], ["proof (state)\nthis:\n  lhd (lSup Y) = lhd xs\n  lhd (ltl (lSup Y)) = lhd (ltl xs)\n  lhd xs \\<le> lhd (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "hence ?lhd"], ["proof (prove)\nusing this:\n  lhd (lSup Y) = lhd xs\n  lhd (ltl (lSup Y)) = lhd (ltl xs)\n  lhd xs \\<le> lhd (ltl xs)\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) \\<le> lhd (ltl (lSup Y))", "by simp"], ["proof (state)\nthis:\n  lhd (lSup Y) \\<le> lhd (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "moreover"], ["proof (state)\nthis:\n  lhd (lSup Y) \\<le> lhd (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "have ?ltl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y.\n        ltl (lSup Y) = lSup Y \\<and>\n        Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n        (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n    lsorted (ltl (lSup Y))", "using chain sorted"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (\\<sqsubseteq>) Y\n  ?xs \\<in> Y \\<Longrightarrow> lsorted ?xs\n\ngoal (1 subgoal):\n 1. (\\<exists>Y.\n        ltl (lSup Y) = lSup Y \\<and>\n        Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n        (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n    lsorted (ltl (lSup Y))", "by(auto intro: chain_lprefix_ltl lsorted_ltlI)"], ["proof (state)\nthis:\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n  lsorted (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<sqsubseteq>) Y;\n        \\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x;\n        \\<not> lnull (lSup Y); \\<not> lnull (ltl (lSup Y))\\<rbrakk>\n       \\<Longrightarrow> lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n                         ((\\<exists>Ya.\n                              ltl (lSup Y) = lSup Ya \\<and>\n                              Complete_Partial_Order.chain (\\<sqsubseteq>)\n                               Ya \\<and>\n                              (\\<forall>x.\n                                  x \\<in> Ya \\<longrightarrow>\n                                  lsorted x)) \\<or>\n                          lsorted (ltl (lSup Y)))", "ultimately"], ["proof (chain)\npicking this:\n  lhd (lSup Y) \\<le> lhd (ltl (lSup Y))\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n  lsorted (ltl (lSup Y))", "show ?case"], ["proof (prove)\nusing this:\n  lhd (lSup Y) \\<le> lhd (ltl (lSup Y))\n  (\\<exists>Y.\n      ltl (lSup Y) = lSup Y \\<and>\n      Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n      (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n  lsorted (ltl (lSup Y))\n\ngoal (1 subgoal):\n 1. lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n    ((\\<exists>Y.\n         ltl (lSup Y) = lSup Y \\<and>\n         Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n         (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n     lsorted (ltl (lSup Y)))", ".."], ["proof (state)\nthis:\n  lhd (lSup Y) \\<le> lhd (ltl (lSup Y)) \\<and>\n  ((\\<exists>Y.\n       ltl (lSup Y) = lSup Y \\<and>\n       Complete_Partial_Order.chain (\\<sqsubseteq>) Y \\<and>\n       (\\<forall>x. x \\<in> Y \\<longrightarrow> lsorted x)) \\<or>\n   lsorted (ltl (lSup Y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsorted_lprefixD:\n  \"\\<lbrakk> xs \\<sqsubseteq> ys; lsorted ys \\<rbrakk> \\<Longrightarrow> lsorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<sqsubseteq> ys; lsorted ys\\<rbrakk>\n    \\<Longrightarrow> lsorted xs", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "case (lsorted xs ys)"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n  lsorted ys\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "hence \"lhd xs = lhd ys\" \"lhd (ltl xs) = lhd (ltl ys)\""], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n  lsorted ys\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. lhd xs = lhd ys &&& lhd (ltl xs) = lhd (ltl ys)", "by(auto dest: lprefix_lhdD lprefix_ltlI)"], ["proof (state)\nthis:\n  lhd xs = lhd ys\n  lhd (ltl xs) = lhd (ltl ys)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "moreover"], ["proof (state)\nthis:\n  lhd xs = lhd ys\n  lhd (ltl xs) = lhd (ltl ys)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "have \"lhd ys \\<le> lhd (ltl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd ys \\<le> lhd (ltl ys)", "using lsorted"], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n  lsorted ys\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. lhd ys \\<le> lhd (ltl ys)", "by(auto intro: lsorted_lhdD dest: lprefix_lnullD lprefix_ltlI)"], ["proof (state)\nthis:\n  lhd ys \\<le> lhd (ltl ys)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "ultimately"], ["proof (chain)\npicking this:\n  lhd xs = lhd ys\n  lhd (ltl xs) = lhd (ltl ys)\n  lhd ys \\<le> lhd (ltl ys)", "have ?lhd"], ["proof (prove)\nusing this:\n  lhd xs = lhd ys\n  lhd (ltl xs) = lhd (ltl ys)\n  lhd ys \\<le> lhd (ltl ys)\n\ngoal (1 subgoal):\n 1. lhd xs \\<le> lhd (ltl xs)", "by simp"], ["proof (state)\nthis:\n  lhd xs \\<le> lhd (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "moreover"], ["proof (state)\nthis:\n  lhd xs \\<le> lhd (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "have ?ltl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs ys.\n        ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n    lsorted (ltl xs)", "using lsorted"], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n  lsorted ys\n  \\<not> lnull xs\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs ys.\n        ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n    lsorted (ltl xs)", "by(blast intro: lsorted_ltlI lprefix_ltlI)"], ["proof (state)\nthis:\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n  lsorted (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa ys.\n       \\<lbrakk>xsa \\<sqsubseteq> ys; lsorted ys; \\<not> lnull xsa;\n        \\<not> lnull (ltl xsa)\\<rbrakk>\n       \\<Longrightarrow> lhd xsa \\<le> lhd (ltl xsa) \\<and>\n                         ((\\<exists>xs ys.\n                              ltl xsa = xs \\<and>\n                              xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n                          lsorted (ltl xsa))", "ultimately"], ["proof (chain)\npicking this:\n  lhd xs \\<le> lhd (ltl xs)\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n  lsorted (ltl xs)", "show ?case"], ["proof (prove)\nusing this:\n  lhd xs \\<le> lhd (ltl xs)\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n  lsorted (ltl xs)\n\ngoal (1 subgoal):\n 1. lhd xs \\<le> lhd (ltl xs) \\<and>\n    ((\\<exists>xs ys.\n         ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n     lsorted (ltl xs))", ".."], ["proof (state)\nthis:\n  lhd xs \\<le> lhd (ltl xs) \\<and>\n  ((\\<exists>xs ys.\n       ltl xs = xs \\<and> xs \\<sqsubseteq> ys \\<and> lsorted ys) \\<or>\n   lsorted (ltl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_lsorted [cont_intro, simp]:\n  assumes mcont: \"mcont lub ord lSup (\\<sqsubseteq>) (\\<lambda>x. f x)\"\n  and ccpo: \"class.ccpo lub ord (mk_less ord)\"\n  shows \"ccpo.admissible lub ord (\\<lambda>x. lsorted (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. lsorted (f x))", "proof(rule ccpo.admissibleI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. lsorted (f x)\\<rbrakk>\n       \\<Longrightarrow> lsorted (f (lub A))", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. lsorted (f x)\\<rbrakk>\n       \\<Longrightarrow> lsorted (f (lub A))", "assume chain: \"Complete_Partial_Order.chain ord Y\"\n    and sorted: \"\\<forall>x\\<in>Y. lsorted (f x)\"\n    and \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. lsorted (f x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>Complete_Partial_Order.chain ord A; A \\<noteq> {};\n        \\<forall>x\\<in>A. lsorted (f x)\\<rbrakk>\n       \\<Longrightarrow> lsorted (f (lub A))", "thus \"lsorted (f (lub Y))\""], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain ord Y\n  \\<forall>x\\<in>Y. lsorted (f x)\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lsorted (f (lub Y))", "by(simp add: mcont_contD[OF mcont] lsorted_lSup chain_imageI mcont_monoD[OF mcont])"], ["proof (state)\nthis:\n  lsorted (f (lub Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma admissible_not_lsorted[THEN admissible_subst, cont_intro, simp]:\n  \"ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>xs. \\<not> lsorted xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lSup (\\<sqsubseteq>) (\\<lambda>xs. \\<not> lsorted xs)", "by(rule ccpo.admissibleI)(auto dest: lsorted_lprefixD[rotated] intro: chain_lprefix_lSup)"], ["", "lemma lsorted_ltake [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ltake n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs \\<Longrightarrow> lsorted (ltake n xs)", "by(rule lsorted_lprefixD)(rule ltake_is_lprefix)"], ["", "lemma lsorted_ldropn [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs \\<Longrightarrow> lsorted (ldropn n xs)", "by(induct n arbitrary: xs)(fastforce simp add: ldropn_Suc lsorted_LCons' ldropn_lnull split: llist.split)+"], ["", "lemma lsorted_ldrop [simp]: \"lsorted xs \\<Longrightarrow> lsorted (ldrop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs \\<Longrightarrow> lsorted (ldrop n xs)", "by(induct xs arbitrary: n)(auto simp add: ldrop_LCons lsorted_LCons' ldrop_lnull split: co.enat.split)"], ["", "end"], ["", "declare\n  ord.lsorted_code [code]\n  ord.admissible_lsorted [cont_intro, simp]\n  ord.admissible_not_lsorted [THEN admissible_subst, cont_intro, simp]"], ["", "context preorder begin"], ["", "lemma lsorted_LCons:\n  \"lsorted (LCons x xs) \\<longleftrightarrow> lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (LCons x xs) =\n    (lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "assume ?lhs"], ["proof (state)\nthis:\n  lsorted (LCons x xs)\n\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "{"], ["proof (state)\nthis:\n  lsorted (LCons x xs)\n\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "assume \"y \\<in> lset xs\""], ["proof (state)\nthis:\n  y \\<in> lset xs\n\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "hence \"x \\<le> y\""], ["proof (prove)\nusing this:\n  y \\<in> lset xs\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> lset xs\n  lsorted (LCons x xs)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by(induct arbitrary: x)(auto intro: order_trans)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> lset xs \\<Longrightarrow> x \\<le> ?y2\n\ngoal (2 subgoals):\n 1. lsorted (LCons x xs) \\<Longrightarrow>\n    lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n 2. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  lsorted (LCons x xs)\n  ?y2 \\<in> lset xs \\<Longrightarrow> x \\<le> ?y2", "show ?rhs"], ["proof (prove)\nusing this:\n  lsorted (LCons x xs)\n  ?y2 \\<in> lset xs \\<Longrightarrow> x \\<le> ?y2\n\ngoal (1 subgoal):\n 1. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)", "by cases auto"], ["proof (state)\nthis:\n  lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n\ngoal (1 subgoal):\n 1. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "assume ?rhs"], ["proof (state)\nthis:\n  lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n\ngoal (1 subgoal):\n 1. lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y) \\<Longrightarrow>\n    lsorted (LCons x xs)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lsorted xs \\<and> (\\<forall>y\\<in>lset xs. x \\<le> y)\n\ngoal (1 subgoal):\n 1. lsorted (LCons x xs)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  lsorted (LCons x xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsorted_coinduct [consumes 1, case_names lsorted, case_conclusion lsorted lhd ltl, coinduct pred: lsorted]:\n  assumes major: \"X xs\"\n  and step: \"\\<And>xs. \\<lbrakk> X xs; \\<not> lnull xs \\<rbrakk> \\<Longrightarrow> (\\<forall>x \\<in> lset (ltl xs). lhd xs \\<le> x) \\<and> (X (ltl xs) \\<or> lsorted (ltl xs))\"\n  shows \"lsorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs", "using major"], ["proof (prove)\nusing this:\n  X xs\n\ngoal (1 subgoal):\n 1. lsorted xs", "by(coinduct rule: lsorted_coinduct')(auto dest: step)"], ["", "lemma lsortedD: \"\\<lbrakk> lsorted xs; \\<not> lnull xs; y \\<in> lset (ltl xs) \\<rbrakk> \\<Longrightarrow> lhd xs \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsorted xs; \\<not> lnull xs; y \\<in> lset (ltl xs)\\<rbrakk>\n    \\<Longrightarrow> lhd xs \\<le> y", "by(clarsimp simp add: not_lnull_conv lsorted_LCons)"], ["", "end"], ["", "lemma lsorted_lmap':\n  assumes \"ord.lsorted orda xs\" \"monotone orda ordb f\"\n  shows \"ord.lsorted ordb (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.lsorted ordb (lmap f xs)", "using \\<open>ord.lsorted orda xs\\<close>"], ["proof (prove)\nusing this:\n  ord.lsorted orda xs\n\ngoal (1 subgoal):\n 1. ord.lsorted ordb (lmap f xs)", "by(coinduction arbitrary: xs rule: ord.lsorted_coinduct')(auto intro: monotoneD[OF \\<open>monotone orda ordb f\\<close>] ord.lsorted_lhdD ord.lsorted_ltlI)"], ["", "lemma lsorted_lmap:\n  assumes \"lsorted xs\" \"monotone (\\<le>) (\\<le>) f\"\n  shows \"lsorted (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (lmap f xs)", "using \\<open>lsorted xs\\<close>"], ["proof (prove)\nusing this:\n  lsorted xs\n\ngoal (1 subgoal):\n 1. lsorted (lmap f xs)", "by(coinduction arbitrary: xs rule: lsorted_coinduct')(auto intro: monotoneD[OF \\<open>monotone (\\<le>) (\\<le>) f\\<close>] lsorted_lhdD lsorted_ltlI)"], ["", "context linorder begin"], ["", "lemma lsorted_ldistinct_lset_unique:\n  \"\\<lbrakk> lsorted xs; ldistinct xs; lsorted ys; ldistinct ys; lset xs = lset ys \\<rbrakk>\n  \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n     lset xs = lset ys\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n        lset xs = lset ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              lsorted xsa \\<and>\n                              ldistinct xsa \\<and>\n                              lsorted ysa \\<and>\n                              ldistinct ysa \\<and> lset xsa = lset ysa))", "case (Eq_llist xs ys)"], ["proof (state)\nthis:\n  lsorted xs\n  ldistinct xs\n  lsorted ys\n  ldistinct ys\n  lset xs = lset ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n        lset xs = lset ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              lsorted xsa \\<and>\n                              ldistinct xsa \\<and>\n                              lsorted ysa \\<and>\n                              ldistinct ysa \\<and> lset xsa = lset ysa))", "hence ?lnull"], ["proof (prove)\nusing this:\n  lsorted xs\n  ldistinct xs\n  lsorted ys\n  ldistinct ys\n  lset xs = lset ys\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys", "by(cases ys)(auto simp add: lset_lnull)"], ["proof (state)\nthis:\n  lnull xs = lnull ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n        lset xs = lset ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              lsorted xsa \\<and>\n                              ldistinct xsa \\<and>\n                              lsorted ysa \\<and>\n                              ldistinct ysa \\<and> lset xsa = lset ysa))", "moreover"], ["proof (state)\nthis:\n  lnull xs = lnull ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n        lset xs = lset ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              lsorted xsa \\<and>\n                              ldistinct xsa \\<and>\n                              lsorted ysa \\<and>\n                              ldistinct ysa \\<and> lset xsa = lset ysa))", "from Eq_llist"], ["proof (chain)\npicking this:\n  lsorted xs\n  ldistinct xs\n  lsorted ys\n  ldistinct ys\n  lset xs = lset ys", "have ?LCons"], ["proof (prove)\nusing this:\n  lsorted xs\n  ldistinct xs\n  lsorted ys\n  ldistinct ys\n  lset xs = lset ys\n\ngoal (1 subgoal):\n 1. \\<not> lnull xs \\<longrightarrow>\n    \\<not> lnull ys \\<longrightarrow>\n    lhd xs = lhd ys \\<and>\n    (\\<exists>xs ys.\n        ltl xs = xs \\<and>\n        ltl ys = ys \\<and>\n        lsorted xs \\<and>\n        ldistinct xs \\<and>\n        lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys)", "by(auto 4 3 intro: lsorted_ltlI ldistinct_ltlI simp add: not_lnull_conv insert_eq_iff lsorted_LCons split: if_split_asm)"], ["proof (state)\nthis:\n  \\<not> lnull xs \\<longrightarrow>\n  \\<not> lnull ys \\<longrightarrow>\n  lhd xs = lhd ys \\<and>\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and>\n      ltl ys = ys \\<and>\n      lsorted xs \\<and>\n      ldistinct xs \\<and>\n      lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>lsorted xs; ldistinct xs; lsorted ys; ldistinct ys;\n        lset xs = lset ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              lsorted xsa \\<and>\n                              ldistinct xsa \\<and>\n                              lsorted ysa \\<and>\n                              ldistinct ysa \\<and> lset xsa = lset ysa))", "ultimately"], ["proof (chain)\npicking this:\n  lnull xs = lnull ys\n  \\<not> lnull xs \\<longrightarrow>\n  \\<not> lnull ys \\<longrightarrow>\n  lhd xs = lhd ys \\<and>\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and>\n      ltl ys = ys \\<and>\n      lsorted xs \\<and>\n      ldistinct xs \\<and>\n      lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys)", "show ?case"], ["proof (prove)\nusing this:\n  lnull xs = lnull ys\n  \\<not> lnull xs \\<longrightarrow>\n  \\<not> lnull ys \\<longrightarrow>\n  lhd xs = lhd ys \\<and>\n  (\\<exists>xs ys.\n      ltl xs = xs \\<and>\n      ltl ys = ys \\<and>\n      lsorted xs \\<and>\n      ldistinct xs \\<and>\n      lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys)\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         lsorted xs \\<and>\n         ldistinct xs \\<and>\n         lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys))", ".."], ["proof (state)\nthis:\n  lnull xs = lnull ys \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (\\<exists>xs ys.\n       ltl xs = xs \\<and>\n       ltl ys = ys \\<and>\n       lsorted xs \\<and>\n       ldistinct xs \\<and>\n       lsorted ys \\<and> ldistinct ys \\<and> lset xs = lset ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lsorted_llist_of[simp]: \"lsorted (llist_of xs) \\<longleftrightarrow> sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (llist_of xs) = sorted xs", "by(induct xs)(auto simp: lsorted_LCons)"], ["", "subsection \\<open>Lexicographic order on lazy lists: @{term \"llexord\"}\\<close>"], ["", "lemma llexord_coinduct [consumes 1, case_names llexord, coinduct pred: llexord]:\n  assumes X: \"X xs ys\"\n  and step: \"\\<And>xs ys. \\<lbrakk> X xs ys; \\<not> lnull xs \\<rbrakk>\n    \\<Longrightarrow> \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow> r (lhd xs) (lhd ys) \\<or>\n                     lhd xs = lhd ys \\<and> (X (ltl xs) (ltl ys) \\<or> llexord r (ltl xs) (ltl ys)))\"\n  shows \"llexord r xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs ys", "using X"], ["proof (prove)\nusing this:\n  X xs ys\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       X x1 x2 \\<Longrightarrow>\n       (\\<exists>xs ys x.\n           x1 = LCons x xs \\<and>\n           x2 = LCons x ys \\<and> (X xs ys \\<or> llexord r xs ys)) \\<or>\n       (\\<exists>x y xs ys.\n           x1 = LCons x xs \\<and> x2 = LCons y ys \\<and> r x y) \\<or>\n       (\\<exists>ys. x1 = LNil \\<and> x2 = ys)", "case (llexord xs ys)"], ["proof (state)\nthis:\n  X xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       X x1 x2 \\<Longrightarrow>\n       (\\<exists>xs ys x.\n           x1 = LCons x xs \\<and>\n           x2 = LCons x ys \\<and> (X xs ys \\<or> llexord r xs ys)) \\<or>\n       (\\<exists>x y xs ys.\n           x1 = LCons x xs \\<and> x2 = LCons y ys \\<and> r x y) \\<or>\n       (\\<exists>ys. x1 = LNil \\<and> x2 = ys)", "thus ?case"], ["proof (prove)\nusing this:\n  X xs ys\n\ngoal (1 subgoal):\n 1. (\\<exists>xs ys x.\n        xs = LCons x xs \\<and>\n        ys = LCons x ys \\<and> (X xs ys \\<or> llexord r xs ys)) \\<or>\n    (\\<exists>x y xs ys.\n        xs = LCons x xs \\<and> ys = LCons y ys \\<and> r x y) \\<or>\n    (\\<exists>ys. xs = LNil \\<and> ys = ys)", "by(cases xs ys rule: llist.exhaust[case_product llist.exhaust])(auto dest: step)"], ["proof (state)\nthis:\n  (\\<exists>xs ys x.\n      xs = LCons x xs \\<and>\n      ys = LCons x ys \\<and> (X xs ys \\<or> llexord r xs ys)) \\<or>\n  (\\<exists>x y xs ys.\n      xs = LCons x xs \\<and> ys = LCons y ys \\<and> r x y) \\<or>\n  (\\<exists>ys. xs = LNil \\<and> ys = ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_refl [simp, intro!]:\n  \"llexord r xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llexord r xs xs", "define ys where \"ys = xs\""], ["proof (state)\nthis:\n  ys = xs\n\ngoal (1 subgoal):\n 1. llexord r xs xs", "hence \"xs = ys\""], ["proof (prove)\nusing this:\n  ys = xs\n\ngoal (1 subgoal):\n 1. xs = ys", "by simp"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. llexord r xs xs", "thus \"llexord r xs ys\""], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "by(coinduct xs ys) auto"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_LCons_LCons [simp]:\n  \"llexord r (LCons x xs) (LCons y ys) \\<longleftrightarrow> (x = y \\<and> llexord r xs ys \\<or> r x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r (LCons x xs) (LCons y ys) =\n    (x = y \\<and> llexord r xs ys \\<or> r x y)", "by(auto intro: llexord.intros(1,2) elim: llexord.cases)"], ["", "lemma lnull_llexord [simp]: \"lnull xs \\<Longrightarrow> llexord r xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull xs \\<Longrightarrow> llexord r xs ys", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow> llexord r xs ys", "by simp"], ["", "lemma llexord_LNil_right [simp]:\n  \"lnull ys \\<Longrightarrow> llexord r xs ys \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull ys \\<Longrightarrow> llexord r xs ys = lnull xs", "by(auto elim: llexord.cases)"], ["", "lemma llexord_LCons_left:\n  \"llexord r (LCons x xs) ys \\<longleftrightarrow>\n   (\\<exists>y ys'. ys = LCons y ys' \\<and> (x = y \\<and> llexord r xs ys' \\<or> r x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r (LCons x xs) ys =\n    (\\<exists>y ys'.\n        ys = LCons y ys' \\<and> (x = y \\<and> llexord r xs ys' \\<or> r x y))", "by(cases ys)(auto elim: llexord.cases)"], ["", "lemma lprefix_imp_llexord:\n  assumes \"xs \\<sqsubseteq> ys\"\n  shows \"llexord r xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs ys", "using assms"], ["proof (prove)\nusing this:\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "by(coinduct)(auto simp add: not_lnull_conv LCons_lprefix_conv)"], ["", "lemma llexord_empty:\n  \"llexord (\\<lambda>x y. False) xs ys = xs \\<sqsubseteq> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord (\\<lambda>x y. False) xs ys = xs \\<sqsubseteq> ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llexord (\\<lambda>x y. False) xs ys \\<Longrightarrow>\n    xs \\<sqsubseteq> ys\n 2. xs \\<sqsubseteq> ys \\<Longrightarrow>\n    llexord (\\<lambda>x y. False) xs ys", "assume \"llexord (\\<lambda>x y. False) xs ys\""], ["proof (state)\nthis:\n  llexord (\\<lambda>x y. False) xs ys\n\ngoal (2 subgoals):\n 1. llexord (\\<lambda>x y. False) xs ys \\<Longrightarrow>\n    xs \\<sqsubseteq> ys\n 2. xs \\<sqsubseteq> ys \\<Longrightarrow>\n    llexord (\\<lambda>x y. False) xs ys", "thus \"xs \\<sqsubseteq> ys\""], ["proof (prove)\nusing this:\n  llexord (\\<lambda>x y. False) xs ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys", "by(coinduct)(auto elim: llexord.cases)"], ["proof (state)\nthis:\n  xs \\<sqsubseteq> ys\n\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow>\n    llexord (\\<lambda>x y. False) xs ys", "qed(rule lprefix_imp_llexord)"], ["", "lemma llexord_append_right:\n  \"llexord r xs (lappend xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs (lappend xs ys)", "by(rule lprefix_imp_llexord)(auto simp add: lprefix_conv_lappend)"], ["", "lemma llexord_lappend_leftI:\n  assumes \"llexord r ys zs\"\n  shows \"llexord r (lappend xs ys) (lappend xs zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r (lappend xs ys) (lappend xs zs)", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> llexord r (lappend xs ys) (lappend xs zs)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llexord r (lappend xs ys) (lappend xs zs)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> llexord r (lappend xs ys) (lappend xs zs)\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llexord r (lappend xs ys) (lappend xs zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. llexord r (lappend xs ys) (lappend xs zs)", "by induct (simp_all add: assms)"], ["proof (state)\nthis:\n  llexord r (lappend xs ys) (lappend xs zs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llexord r (lappend xs ys) (lappend xs zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llexord r (lappend xs ys) (lappend xs zs)", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llexord r (lappend xs ys) (lappend xs zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. llexord r (lappend xs ys) (lappend xs zs)", "by(simp add: lappend_inf)"], ["proof (state)\nthis:\n  llexord r (lappend xs ys) (lappend xs zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_lappend_leftD:\n  assumes lex: \"llexord r (lappend xs ys) (lappend xs zs)\"\n  and fin: \"lfinite xs\"\n  and irrefl: \"!!x. x \\<in> lset xs \\<Longrightarrow> \\<not> r x x\"\n  shows \"llexord r ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r ys zs", "using fin lex irrefl"], ["proof (prove)\nusing this:\n  lfinite xs\n  llexord r (lappend xs ys) (lappend xs zs)\n  ?x \\<in> lset xs \\<Longrightarrow> \\<not> r ?x ?x\n\ngoal (1 subgoal):\n 1. llexord r ys zs", "by(induct) simp_all"], ["", "lemma llexord_lappend_left:\n  \"\\<lbrakk> lfinite xs; !!x. x \\<in> lset xs \\<Longrightarrow> \\<not> r x x \\<rbrakk>\n  \\<Longrightarrow> llexord r (lappend xs ys) (lappend xs zs) \\<longleftrightarrow> llexord r ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite xs;\n     \\<And>x. x \\<in> lset xs \\<Longrightarrow> \\<not> r x x\\<rbrakk>\n    \\<Longrightarrow> llexord r (lappend xs ys) (lappend xs zs) =\n                      llexord r ys zs", "by(blast intro: llexord_lappend_leftI llexord_lappend_leftD)"], ["", "lemma antisym_llexord:\n  assumes r: \"antisymp r\"\n  and irrefl: \"\\<And>x. \\<not> r x x\"\n  shows \"antisymp (llexord r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymp (llexord r)", "proof(rule antisympI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>llexord r x y; llexord r y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>llexord r x y; llexord r y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"llexord r xs ys\"\n    and \"llexord r ys xs\""], ["proof (state)\nthis:\n  llexord r xs ys\n  llexord r ys xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>llexord r x y; llexord r y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"llexord r xs ys \\<and> llexord r ys xs\""], ["proof (prove)\nusing this:\n  llexord r xs ys\n  llexord r ys xs\n\ngoal (1 subgoal):\n 1. llexord r xs ys \\<and> llexord r ys xs", "by auto"], ["proof (state)\nthis:\n  llexord r xs ys \\<and> llexord r ys xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>llexord r x y; llexord r y x\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"xs = ys\""], ["proof (prove)\nusing this:\n  llexord r xs ys \\<and> llexord r ys xs\n\ngoal (1 subgoal):\n 1. xs = ys", "by (coinduct rule: llist.coinduct)\n      (auto 4 3 simp add: not_lnull_conv irrefl dest: antisympD[OF r, simplified])"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_antisym:\n  \"\\<lbrakk> llexord r xs ys; llexord r ys xs;\n    !!a b. \\<lbrakk> r a b; r b a \\<rbrakk> \\<Longrightarrow> False \\<rbrakk>\n  \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llexord r xs ys; llexord r ys xs;\n     \\<And>a b.\n        \\<lbrakk>r a b; r b a\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "using antisympD[OF antisym_llexord, of r xs ys]"], ["proof (prove)\nusing this:\n  \\<lbrakk>antisymp r; \\<And>x. \\<not> r x x; llexord r xs ys;\n   llexord r ys xs\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>llexord r xs ys; llexord r ys xs;\n     \\<And>a b.\n        \\<lbrakk>r a b; r b a\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by(auto intro: antisympI)"], ["", "lemma llexord_trans:\n  assumes 1: \"llexord r xs ys\"\n  and 2: \"llexord r ys zs\"\n  and trans: \"!!a b c. \\<lbrakk> r a b; r b c \\<rbrakk> \\<Longrightarrow> r a c\"\n  shows \"llexord r xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llexord r xs zs", "from 1 2"], ["proof (chain)\npicking this:\n  llexord r xs ys\n  llexord r ys zs", "have \"\\<exists>ys. llexord r xs ys \\<and> llexord r ys zs\""], ["proof (prove)\nusing this:\n  llexord r xs ys\n  llexord r ys zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys. llexord r xs ys \\<and> llexord r ys zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys. llexord r xs ys \\<and> llexord r ys zs\n\ngoal (1 subgoal):\n 1. llexord r xs zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ys. llexord r xs ys \\<and> llexord r ys zs\n\ngoal (1 subgoal):\n 1. llexord r xs zs", "by(coinduct)(auto 4 3 simp add: not_lnull_conv llexord_LCons_left dest: trans)"], ["proof (state)\nthis:\n  llexord r xs zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_llexord:\n  \"transp r \\<Longrightarrow> transp (llexord r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp r \\<Longrightarrow> transp (llexord r)", "by(auto intro!: transpI elim: llexord_trans dest: transpD)"], ["", "lemma llexord_linear:\n  assumes linear: \"!!x y. r x y \\<or> x = y \\<or> r y x\"\n  shows \"llexord r xs ys \\<or> llexord r ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs ys \\<or> llexord r ys xs", "proof(rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> llexord r ys xs \\<Longrightarrow> llexord r xs ys", "assume \"\\<not> llexord r ys xs\""], ["proof (state)\nthis:\n  \\<not> llexord r ys xs\n\ngoal (1 subgoal):\n 1. \\<not> llexord r ys xs \\<Longrightarrow> llexord r xs ys", "thus \"llexord r xs ys\""], ["proof (prove)\nusing this:\n  \\<not> llexord r ys xs\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "proof(coinduct rule: llexord_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<not> llexord r ys xs; \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "case (llexord xs ys)"], ["proof (state)\nthis:\n  \\<not> llexord r ys xs\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>\\<not> llexord r ys xs; \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "case LNil"], ["proof (state)\nthis:\n  xs = LNil\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = LNil\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))", "using llexord"], ["proof (prove)\nusing this:\n  xs = LNil\n  \\<not> llexord r ys xs\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))", "by simp"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "case (LCons x xs')"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "with \\<open>\\<not> llexord r ys xs\\<close>"], ["proof (chain)\npicking this:\n  \\<not> llexord r ys xs\n  xs = LCons x xs'", "obtain y ys'\n        where ys: \"ys = LCons y ys'\" \"\\<not> r y x\" \"y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\""], ["proof (prove)\nusing this:\n  \\<not> llexord r ys xs\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = LCons y ys'; \\<not> r y x;\n         y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ys) auto"], ["proof (state)\nthis:\n  ys = LCons y ys'\n  \\<not> r y x\n  y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        (\\<not> llexord r (ltl ys) (ltl xs) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "with \\<open>\\<not> r y x\\<close> linear[of x y] ys LCons"], ["proof (chain)\npicking this:\n  \\<not> r y x\n  r x y \\<or> x = y \\<or> r y x\n  ys = LCons y ys'\n  \\<not> r y x\n  y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\n  xs = LCons x xs'\n  ys = LCons y ys'\n  \\<not> r y x\n  y \\<noteq> x \\<or> \\<not> llexord r ys' xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> r y x\n  r x y \\<or> x = y \\<or> r y x\n  ys = LCons y ys'\n  \\<not> r y x\n  y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\n  xs = LCons x xs'\n  ys = LCons y ys'\n  \\<not> r y x\n  y \\<noteq> x \\<or> \\<not> llexord r ys' xs'\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   (\\<not> llexord r (ltl ys) (ltl xs) \\<or> llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_code [code]:\n  \"llexord r LNil ys = True\"\n  \"llexord r (LCons x xs) LNil = False\"\n  \"llexord r (LCons x xs) (LCons y ys) = (r x y \\<or> x = y \\<and> llexord r xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r LNil ys = True &&&\n    llexord r (LCons x xs) LNil = False &&&\n    llexord r (LCons x xs) (LCons y ys) =\n    (r x y \\<or> x = y \\<and> llexord r xs ys)", "by auto"], ["", "lemma llexord_conv:\n \"llexord r xs ys \\<longleftrightarrow>\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'. lfinite zs \\<and> xs = lappend zs xs' \\<and> ys = lappend zs (LCons y ys') \\<and>\n                  (xs' = LNil \\<or> r (lhd xs') y))\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs ys =\n    (xs = ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         xs = lappend zs xs' \\<and>\n         ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llexord r xs ys \\<Longrightarrow>\n    xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y))\n 2. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y)) \\<Longrightarrow>\n    llexord r xs ys", "assume ?lhs"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal (2 subgoals):\n 1. llexord r xs ys \\<Longrightarrow>\n    xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y))\n 2. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y)) \\<Longrightarrow>\n    llexord r xs ys", "show ?rhs (is \"_ \\<or> ?prefix\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y))", "proof(rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    xs = ys", "assume \"\\<not> ?prefix\""], ["proof (state)\nthis:\n  \\<nexists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. \\<nexists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    xs = ys", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  llexord r xs ys\n  \\<nexists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  llexord r xs ys\n  \\<nexists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. xs = ys", "proof(coinduction arbitrary: xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>llexord r xs ys;\n        \\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y)\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              llexord r xsa ysa \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xsa = lappend zs xs' \\<and>\n                                  ysa = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))", "case (Eq_llist xs ys)"], ["proof (state)\nthis:\n  llexord r xs ys\n  \\<nexists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>llexord r xs ys;\n        \\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y)\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              llexord r xsa ysa \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xsa = lappend zs xs' \\<and>\n                                  ysa = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))", "hence \"llexord r xs ys\"\n        and prefix: \"\\<And>zs xs' y ys'. \\<lbrakk> lfinite zs; xs = lappend zs xs';\n                                      ys = lappend zs (LCons y ys') \\<rbrakk>\n                                     \\<Longrightarrow> xs' \\<noteq> LNil \\<and> \\<not> r (lhd xs') y\""], ["proof (prove)\nusing this:\n  llexord r xs ys\n  \\<nexists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. llexord r xs ys &&&\n    (\\<And>zs xs' y ys'.\n        \\<lbrakk>lfinite zs; xs = lappend zs xs';\n         ys = lappend zs (LCons y ys')\\<rbrakk>\n        \\<Longrightarrow> xs' \\<noteq> LNil \\<and> \\<not> r (lhd xs') y)", "by auto"], ["proof (state)\nthis:\n  llexord r xs ys\n  \\<lbrakk>lfinite ?zs; xs = lappend ?zs ?xs';\n   ys = lappend ?zs (LCons ?y ?ys')\\<rbrakk>\n  \\<Longrightarrow> ?xs' \\<noteq> LNil \\<and> \\<not> r (lhd ?xs') ?y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>llexord r xs ys;\n        \\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y)\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xsa ysa.\n                              ltl xs = xsa \\<and>\n                              ltl ys = ysa \\<and>\n                              llexord r xsa ysa \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xsa = lappend zs xs' \\<and>\n                                  ysa = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))", "from \\<open>llexord r xs ys\\<close>"], ["proof (chain)\npicking this:\n  llexord r xs ys", "show ?case"], ["proof (prove)\nusing this:\n  llexord r xs ys\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "case (llexord_LCons_eq xs' ys' x)"], ["proof (state)\nthis:\n  xs = LCons x xs'\n  ys = LCons x ys'\n  llexord r xs' ys'\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "{"], ["proof (state)\nthis:\n  xs = LCons x xs'\n  ys = LCons x ys'\n  llexord r xs' ys'\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "fix zs xs'' y ys''"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "assume \"lfinite zs\" \"xs' = lappend zs xs''\"\n            and \"ys' = lappend zs (LCons y ys'')\""], ["proof (state)\nthis:\n  lfinite zs\n  xs' = lappend zs xs''\n  ys' = lappend zs (LCons y ys'')\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "hence \"lfinite (LCons x zs)\" \"xs = lappend (LCons x zs) xs''\"\n            and \"ys = lappend (LCons x zs) (LCons y ys'')\""], ["proof (prove)\nusing this:\n  lfinite zs\n  xs' = lappend zs xs''\n  ys' = lappend zs (LCons y ys'')\n\ngoal (1 subgoal):\n 1. (lfinite (LCons x zs) &&& xs = lappend (LCons x zs) xs'') &&&\n    ys = lappend (LCons x zs) (LCons y ys'')", "using llexord_LCons_eq"], ["proof (prove)\nusing this:\n  lfinite zs\n  xs' = lappend zs xs''\n  ys' = lappend zs (LCons y ys'')\n  xs = LCons x xs'\n  ys = LCons x ys'\n  llexord r xs' ys'\n\ngoal (1 subgoal):\n 1. (lfinite (LCons x zs) &&& xs = lappend (LCons x zs) xs'') &&&\n    ys = lappend (LCons x zs) (LCons y ys'')", "by simp_all"], ["proof (state)\nthis:\n  lfinite (LCons x zs)\n  xs = lappend (LCons x zs) xs''\n  ys = lappend (LCons x zs) (LCons y ys'')\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "hence \"xs'' \\<noteq> LNil \\<and> \\<not> r (lhd xs'') y\""], ["proof (prove)\nusing this:\n  lfinite (LCons x zs)\n  xs = lappend (LCons x zs) xs''\n  ys = lappend (LCons x zs) (LCons y ys'')\n\ngoal (1 subgoal):\n 1. xs'' \\<noteq> LNil \\<and> \\<not> r (lhd xs'') y", "by(rule prefix)"], ["proof (state)\nthis:\n  xs'' \\<noteq> LNil \\<and> \\<not> r (lhd xs'') y\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lfinite ?zs2; xs' = lappend ?zs2 ?xs''2;\n   ys' = lappend ?zs2 (LCons ?y2 ?ys''2)\\<rbrakk>\n  \\<Longrightarrow> ?xs''2 \\<noteq> LNil \\<and> \\<not> r (lhd ?xs''2) ?y2\n\ngoal (3 subgoals):\n 1. \\<And>xs ys x.\n       \\<lbrakk>xs = LCons x xs; ys = LCons x ys; llexord r xs ys\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 3. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "with llexord_LCons_eq"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  ys = LCons x ys'\n  llexord r xs' ys'\n  \\<lbrakk>lfinite ?zs2; xs' = lappend ?zs2 ?xs''2;\n   ys' = lappend ?zs2 (LCons ?y2 ?ys''2)\\<rbrakk>\n  \\<Longrightarrow> ?xs''2 \\<noteq> LNil \\<and> \\<not> r (lhd ?xs''2) ?y2", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  ys = LCons x ys'\n  llexord r xs' ys'\n  \\<lbrakk>lfinite ?zs2; xs' = lappend ?zs2 ?xs''2;\n   ys' = lappend ?zs2 (LCons ?y2 ?ys''2)\\<rbrakk>\n  \\<Longrightarrow> ?xs''2 \\<noteq> LNil \\<and> \\<not> r (lhd ?xs''2) ?y2\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "by auto"], ["proof (state)\nthis:\n  lnull xs = lnull ys \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (\\<exists>xs ys.\n       ltl xs = xs \\<and>\n       ltl ys = ys \\<and>\n       llexord r xs ys \\<and>\n       (\\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "case (llexord_LCons_less x y xs' ys')"], ["proof (state)\nthis:\n  xs = LCons x xs'\n  ys = LCons y ys'\n  r x y\n\ngoal (2 subgoals):\n 1. \\<And>x y xs ys.\n       \\<lbrakk>xs = LCons x xs; ys = LCons y ys; r x y\\<rbrakk>\n       \\<Longrightarrow> lnull xs = lnull ys \\<and>\n                         (\\<not> lnull xs \\<longrightarrow>\n                          \\<not> lnull ys \\<longrightarrow>\n                          lhd xs = lhd ys \\<and>\n                          (\\<exists>xs ys.\n                              ltl xs = xs \\<and>\n                              ltl ys = ys \\<and>\n                              llexord r xs ys \\<and>\n                              (\\<nexists>zs xs' y ys'.\n                                  lfinite zs \\<and>\n                                  xs = lappend zs xs' \\<and>\n                                  ys = lappend zs (LCons y ys') \\<and>\n                                  (xs' = LNil \\<or> r (lhd xs') y))))\n 2. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "with prefix[of LNil xs y ys']"], ["proof (chain)\npicking this:\n  \\<lbrakk>lfinite LNil; xs = lappend LNil xs;\n   ys = lappend LNil (LCons y ys')\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> LNil \\<and> \\<not> r (lhd xs) y\n  xs = LCons x xs'\n  ys = LCons y ys'\n  r x y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite LNil; xs = lappend LNil xs;\n   ys = lappend LNil (LCons y ys')\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> LNil \\<and> \\<not> r (lhd xs) y\n  xs = LCons x xs'\n  ys = LCons y ys'\n  r x y\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "by simp"], ["proof (state)\nthis:\n  lnull xs = lnull ys \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (\\<exists>xs ys.\n       ltl xs = xs \\<and>\n       ltl ys = ys \\<and>\n       llexord r xs ys \\<and>\n       (\\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))))\n\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "case llexord_LNil"], ["proof (state)\nthis:\n  xs = LNil\n\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow>\n    lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = LNil\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "using prefix[of LNil xs \"lhd ys\" \"ltl ys\"]"], ["proof (prove)\nusing this:\n  xs = LNil\n  \\<lbrakk>lfinite LNil; xs = lappend LNil xs;\n   ys = lappend LNil (LCons (lhd ys) (ltl ys))\\<rbrakk>\n  \\<Longrightarrow> xs \\<noteq> LNil \\<and> \\<not> r (lhd xs) (lhd ys)\n\ngoal (1 subgoal):\n 1. lnull xs = lnull ys \\<and>\n    (\\<not> lnull xs \\<longrightarrow>\n     \\<not> lnull ys \\<longrightarrow>\n     lhd xs = lhd ys \\<and>\n     (\\<exists>xs ys.\n         ltl xs = xs \\<and>\n         ltl ys = ys \\<and>\n         llexord r xs ys \\<and>\n         (\\<nexists>zs xs' y ys'.\n             lfinite zs \\<and>\n             xs = lappend zs xs' \\<and>\n             ys = lappend zs (LCons y ys') \\<and>\n             (xs' = LNil \\<or> r (lhd xs') y))))", "by(cases ys) simp_all"], ["proof (state)\nthis:\n  lnull xs = lnull ys \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (\\<exists>xs ys.\n       ltl xs = xs \\<and>\n       ltl ys = ys \\<and>\n       llexord r xs ys \\<and>\n       (\\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lnull xs = lnull ys \\<and>\n  (\\<not> lnull xs \\<longrightarrow>\n   \\<not> lnull ys \\<longrightarrow>\n   lhd xs = lhd ys \\<and>\n   (\\<exists>xs ys.\n       ltl xs = xs \\<and>\n       ltl ys = ys \\<and>\n       llexord r xs ys \\<and>\n       (\\<nexists>zs xs' y ys'.\n           lfinite zs \\<and>\n           xs = lappend zs xs' \\<and>\n           ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y)) \\<Longrightarrow>\n    llexord r xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y)) \\<Longrightarrow>\n    llexord r xs ys", "assume ?rhs"], ["proof (state)\nthis:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y)) \\<Longrightarrow>\n    llexord r xs ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "proof(coinduct xs ys)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs = ys \\<or>\n                (\\<exists>zs xs' y ys'.\n                    lfinite zs \\<and>\n                    xs = lappend zs xs' \\<and>\n                    ys = lappend zs (LCons y ys') \\<and>\n                    (xs' = LNil \\<or> r (lhd xs') y));\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          ((ltl xs = ltl ys \\<or>\n                            (\\<exists>zs xs' y ys'.\n                                lfinite zs \\<and>\n                                ltl xs = lappend zs xs' \\<and>\n                                ltl ys = lappend zs (LCons y ys') \\<and>\n                                (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "case (llexord xs ys)"], ["proof (state)\nthis:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs = ys \\<or>\n                (\\<exists>zs xs' y ys'.\n                    lfinite zs \\<and>\n                    xs = lappend zs xs' \\<and>\n                    ys = lappend zs (LCons y ys') \\<and>\n                    (xs' = LNil \\<or> r (lhd xs') y));\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          ((ltl xs = ltl ys \\<or>\n                            (\\<exists>zs xs' y ys'.\n                                lfinite zs \\<and>\n                                ltl xs = lappend zs xs' \\<and>\n                                ltl ys = lappend zs (LCons y ys') \\<and>\n                                (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "case LNil"], ["proof (state)\nthis:\n  xs = LNil\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = LNil\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "using llexord"], ["proof (prove)\nusing this:\n  xs = LNil\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "by simp"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "case (LCons x xs')"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "with llexord"], ["proof (chain)\npicking this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n  xs = LCons x xs'", "obtain y ys' where \"ys = LCons y ys'\""], ["proof (prove)\nusing this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        ys = LCons y ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ys)(auto dest: sym simp add: LNil_eq_lappend_iff)"], ["proof (state)\nthis:\n  ys = LCons y ys'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       \\<not> lnull ys \\<and>\n       (\\<not> lnull ys \\<longrightarrow>\n        r (lhd xs) (lhd ys) \\<or>\n        lhd xs = lhd ys \\<and>\n        ((ltl xs = ltl ys \\<or>\n          (\\<exists>zs xs' y ys'.\n              lfinite zs \\<and>\n              ltl xs = lappend zs xs' \\<and>\n              ltl ys = lappend zs (LCons y ys') \\<and>\n              (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n         llexord r (ltl xs) (ltl ys)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "from llexord(1)"], ["proof (chain)\npicking this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "assume \"xs = ys\""], ["proof (state)\nthis:\n  xs = ys\n\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))\n 2. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "with True LCons \\<open>ys = LCons y ys'\\<close>"], ["proof (chain)\npicking this:\n  x = y\n  xs = LCons x xs'\n  ys = LCons y ys'\n  xs = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  xs = LCons x xs'\n  ys = LCons y ys'\n  xs = ys\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "by simp"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "assume \"\\<exists>zs xs' y ys'. lfinite zs \\<and> xs = lappend zs xs' \\<and>\n                                 ys = lappend zs (LCons y ys') \\<and>\n                                 (xs' = LNil \\<or> r (lhd xs') y)\""], ["proof (state)\nthis:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)", "obtain zs xs' y' ys''\n            where \"lfinite zs\" \"xs = lappend zs xs'\"\n            and \"ys = lappend zs (LCons y' ys'')\"\n            and \"xs' = LNil \\<or> r (lhd xs') y'\""], ["proof (prove)\nusing this:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. (\\<And>zs xs' y' ys''.\n        \\<lbrakk>lfinite zs; xs = lappend zs xs';\n         ys = lappend zs (LCons y' ys'');\n         xs' = LNil \\<or> r (lhd xs') y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lfinite zs\n  xs = lappend zs xs'\n  ys = lappend zs (LCons y' ys'')\n  xs' = LNil \\<or> r (lhd xs') y'\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "with True LCons \\<open>ys = LCons y ys'\\<close>"], ["proof (chain)\npicking this:\n  x = y\n  xs = LCons x xs'__\n  ys = LCons y ys'\n  lfinite zs\n  xs = lappend zs xs'\n  ys = lappend zs (LCons y' ys'')\n  xs' = LNil \\<or> r (lhd xs') y'", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  xs = LCons x xs'__\n  ys = LCons y ys'\n  lfinite zs\n  xs = lappend zs xs'\n  ys = lappend zs (LCons y' ys'')\n  xs' = LNil \\<or> r (lhd xs') y'\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "by(cases zs) auto"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "with LCons llexord \\<open>ys = LCons y ys'\\<close>"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n  ys = LCons y ys'\n  x \\<noteq> y", "have \"r x y\""], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n  \\<not> lnull xs\n  ys = LCons y ys'\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. r x y", "by(fastforce elim: lfinite.cases)"], ["proof (state)\nthis:\n  r x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "with LCons \\<open>ys = LCons y ys'\\<close>"], ["proof (chain)\npicking this:\n  xs = LCons x xs'\n  ys = LCons y ys'\n  r x y", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons x xs'\n  ys = LCons y ys'\n  r x y\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     ((ltl xs = ltl ys \\<or>\n       (\\<exists>zs xs' y ys'.\n           lfinite zs \\<and>\n           ltl xs = lappend zs xs' \\<and>\n           ltl ys = lappend zs (LCons y ys') \\<and>\n           (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n      llexord r (ltl xs) (ltl ys)))", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   ((ltl xs = ltl ys \\<or>\n     (\\<exists>zs xs' y ys'.\n         lfinite zs \\<and>\n         ltl xs = lappend zs xs' \\<and>\n         ltl ys = lappend zs (LCons y ys') \\<and>\n         (xs' = LNil \\<or> r (lhd xs') y))) \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_conv_ltake_index:\n  \"llexord r xs ys \\<longleftrightarrow>\n   (llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs) \\<or>\n   (\\<exists>n. enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n))\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r xs ys =\n    (llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n     (\\<exists>n.\n         enat n < min (llength xs) (llength ys) \\<and>\n         ltake (enat n) xs = ltake (enat n) ys \\<and>\n         r (lnth xs n) (lnth ys n)))", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. llexord r xs ys \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n)) \\<Longrightarrow>\n    llexord r xs ys", "assume ?lhs"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal (2 subgoals):\n 1. llexord r xs ys \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n)) \\<Longrightarrow>\n    llexord r xs ys", "thus ?rhs (is \"?A \\<or> ?B\")"], ["proof (prove)\nusing this:\n  llexord r xs ys\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "unfolding llexord_conv"], ["proof (prove)\nusing this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      xs = lappend zs xs' \\<and>\n      ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y))\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "assume \"xs = ys\""], ["proof (state)\nthis:\n  xs = ys\n\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "by(simp add: ltake_all)"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "assume \"\\<exists>zs xs' y ys'. lfinite zs \\<and> xs = lappend zs xs' \\<and>\n                           ys = lappend zs (LCons y ys') \\<and>\n                           (xs' = LNil \\<or> r (lhd xs') y)\""], ["proof (state)\nthis:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "then"], ["proof (chain)\npicking this:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)", "obtain zs xs' y ys'\n      where \"lfinite zs\" \"xs' = LNil \\<or> r (lhd xs') y\"\n      and [simp]: \"xs = lappend zs xs'\" \"ys = lappend zs (LCons y ys')\""], ["proof (prove)\nusing this:\n  \\<exists>zs xs' y ys'.\n     lfinite zs \\<and>\n     xs = lappend zs xs' \\<and>\n     ys = lappend zs (LCons y ys') \\<and> (xs' = LNil \\<or> r (lhd xs') y)\n\ngoal (1 subgoal):\n 1. (\\<And>zs xs' y ys'.\n        \\<lbrakk>lfinite zs; xs' = LNil \\<or> r (lhd xs') y;\n         xs = lappend zs xs'; ys = lappend zs (LCons y ys')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lfinite zs\n  xs' = LNil \\<or> r (lhd xs') y\n  xs = lappend zs xs'\n  ys = lappend zs (LCons y ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs xs' y ys'.\n       lfinite zs \\<and>\n       xs = lappend zs xs' \\<and>\n       ys = lappend zs (LCons y ys') \\<and>\n       (xs' = LNil \\<or> r (lhd xs') y) \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", "proof(cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = LNil \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "case LNil"], ["proof (state)\nthis:\n  xs' = LNil\n\ngoal (2 subgoals):\n 1. xs' = LNil \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "hence ?A"], ["proof (prove)\nusing this:\n  xs' = LNil\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs", "by(auto intro: enat_le_plus_same simp add: ltake_lappend1 ltake_all)"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n\ngoal (2 subgoals):\n 1. xs' = LNil \\<Longrightarrow>\n    llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))\n 2. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", ".."], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "case LCons"], ["proof (state)\nthis:\n  xs' = LCons x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "with \\<open>xs' = LNil \\<or> r (lhd xs') y\\<close>"], ["proof (chain)\npicking this:\n  xs' = LNil \\<or> r (lhd xs') y\n  xs' = LCons x21_ x22_", "have \"r (lhd xs') y\""], ["proof (prove)\nusing this:\n  xs' = LNil \\<or> r (lhd xs') y\n  xs' = LCons x21_ x22_\n\ngoal (1 subgoal):\n 1. r (lhd xs') y", "by simp"], ["proof (state)\nthis:\n  r (lhd xs') y\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "from \\<open>lfinite zs\\<close>"], ["proof (chain)\npicking this:\n  lfinite zs", "obtain zs' where [simp]: \"zs = llist_of zs'\""], ["proof (prove)\nusing this:\n  lfinite zs\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = llist_of zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  zs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = llist_of zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zs = llist_of zs'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "with LCons"], ["proof (chain)\npicking this:\n  xs' = LCons x21_ x22_\n  zs = llist_of zs'", "have \"enat (length zs') < min (llength xs) (llength ys)\""], ["proof (prove)\nusing this:\n  xs' = LCons x21_ x22_\n  zs = llist_of zs'\n\ngoal (1 subgoal):\n 1. enat (length zs') < min (llength xs) (llength ys)", "by(auto simp add: less_enat_def eSuc_def split: enat.split)"], ["proof (state)\nthis:\n  enat (length zs') < min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "moreover"], ["proof (state)\nthis:\n  enat (length zs') < min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "have \"ltake (enat (length zs')) xs = ltake (enat (length zs')) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (length zs')) xs = ltake (enat (length zs')) ys", "by(simp add: ltake_lappend1)"], ["proof (state)\nthis:\n  ltake (enat (length zs')) xs = ltake (enat (length zs')) ys\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "moreover"], ["proof (state)\nthis:\n  ltake (enat (length zs')) xs = ltake (enat (length zs')) ys\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "have \"r (lnth xs (length zs')) (lnth ys (length zs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (lnth xs (length zs')) (lnth ys (length zs'))", "using LCons \\<open>r (lhd xs') y\\<close>"], ["proof (prove)\nusing this:\n  xs' = LCons x21_ x22_\n  r (lhd xs') y\n\ngoal (1 subgoal):\n 1. r (lnth xs (length zs')) (lnth ys (length zs'))", "by(simp add: lappend_llist_of_LCons lnth_lappend1)"], ["proof (state)\nthis:\n  r (lnth xs (length zs')) (lnth ys (length zs'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "ultimately"], ["proof (chain)\npicking this:\n  enat (length zs') < min (llength xs) (llength ys)\n  ltake (enat (length zs')) xs = ltake (enat (length zs')) ys\n  r (lnth xs (length zs')) (lnth ys (length zs'))", "have ?B"], ["proof (prove)\nusing this:\n  enat (length zs') < min (llength xs) (llength ys)\n  ltake (enat (length zs')) xs = ltake (enat (length zs')) ys\n  r (lnth xs (length zs')) (lnth ys (length zs'))\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     enat n < min (llength xs) (llength ys) \\<and>\n     ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n       (\\<exists>n.\n           enat n < min (llength xs) (llength ys) \\<and>\n           ltake (enat n) xs = ltake (enat n) ys \\<and>\n           r (lnth xs n) (lnth ys n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     enat n < min (llength xs) (llength ys) \\<and>\n     ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n))", ".."], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n)) \\<Longrightarrow>\n    llexord r xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n)) \\<Longrightarrow>\n    llexord r xs ys", "assume ?rhs (is \"?A \\<or> ?B\")"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal (1 subgoal):\n 1. llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n    (\\<exists>n.\n        enat n < min (llength xs) (llength ys) \\<and>\n        ltake (enat n) xs = ltake (enat n) ys \\<and>\n        r (lnth xs n) (lnth ys n)) \\<Longrightarrow>\n    llexord r xs ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs \\<or>\n  (\\<exists>n.\n      enat n < min (llength xs) (llength ys) \\<and>\n      ltake (enat n) xs = ltake (enat n) ys \\<and>\n      r (lnth xs n) (lnth ys n))\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llength xs \\<le> llength ys \\<and>\n    ltake (llength xs) ys = xs \\<Longrightarrow>\n    llexord r xs ys\n 2. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "assume ?A"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n\ngoal (2 subgoals):\n 1. llength xs \\<le> llength ys \\<and>\n    ltake (llength xs) ys = xs \\<Longrightarrow>\n    llexord r xs ys\n 2. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "proof(coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>llength xs \\<le> llength ys \\<and>\n                ltake (llength xs) ys = xs;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          (llength (ltl xs) \\<le> llength (ltl ys) \\<and>\n                           ltake (llength (ltl xs)) (ltl ys) = ltl xs \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "case (llexord xs ys)"], ["proof (state)\nthis:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>llength xs \\<le> llength ys \\<and>\n                ltake (llength xs) ys = xs;\n        \\<not> lnull xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> lnull ys \\<and>\n                         (\\<not> lnull ys \\<longrightarrow>\n                          r (lhd xs) (lhd ys) \\<or>\n                          lhd xs = lhd ys \\<and>\n                          (llength (ltl xs) \\<le> llength (ltl ys) \\<and>\n                           ltake (llength (ltl xs)) (ltl ys) = ltl xs \\<or>\n                           llexord r (ltl xs) (ltl ys)))", "thus ?case"], ["proof (prove)\nusing this:\n  llength xs \\<le> llength ys \\<and> ltake (llength xs) ys = xs\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<and>\n    (\\<not> lnull ys \\<longrightarrow>\n     r (lhd xs) (lhd ys) \\<or>\n     lhd xs = lhd ys \\<and>\n     (llength (ltl xs) \\<le> llength (ltl ys) \\<and>\n      ltake (llength (ltl xs)) (ltl ys) = ltl xs \\<or>\n      llexord r (ltl xs) (ltl ys)))", "by(cases xs, simp)(cases ys, auto)"], ["proof (state)\nthis:\n  \\<not> lnull ys \\<and>\n  (\\<not> lnull ys \\<longrightarrow>\n   r (lhd xs) (lhd ys) \\<or>\n   lhd xs = lhd ys \\<and>\n   (llength (ltl xs) \\<le> llength (ltl ys) \\<and>\n    ltake (llength (ltl xs)) (ltl ys) = ltl xs \\<or>\n    llexord r (ltl xs) (ltl ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "assume \"?B\""], ["proof (state)\nthis:\n  \\<exists>n.\n     enat n < min (llength xs) (llength ys) \\<and>\n     ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     enat n < min (llength xs) (llength ys) \\<and>\n     ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n)", "obtain n where len: \"enat n < min (llength xs) (llength ys)\"\n      and takexs: \"ltake (enat n) xs = ltake (enat n) ys\"\n      and r: \"r (lnth xs n) (lnth ys n)\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     enat n < min (llength xs) (llength ys) \\<and>\n     ltake (enat n) xs = ltake (enat n) ys \\<and> r (lnth xs n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < min (llength xs) (llength ys);\n         ltake (enat n) xs = ltake (enat n) ys;\n         r (lnth xs n) (lnth ys n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enat n < min (llength xs) (llength ys)\n  ltake (enat n) xs = ltake (enat n) ys\n  r (lnth xs n) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "have \"xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)", "by(simp only: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "moreover"], ["proof (state)\nthis:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "from takexs len"], ["proof (chain)\npicking this:\n  ltake (enat n) xs = ltake (enat n) ys\n  enat n < min (llength xs) (llength ys)", "have \"ys = lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\""], ["proof (prove)\nusing this:\n  ltake (enat n) xs = ltake (enat n) ys\n  enat n < min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. ys =\n    lappend (ltake (enat n) xs)\n     (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))", "by(simp add: ldropn_Suc_conv_ldropn ldrop_enat)"], ["proof (state)\nthis:\n  ys =\n  lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "moreover"], ["proof (state)\nthis:\n  ys =\n  lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "from r len"], ["proof (chain)\npicking this:\n  r (lnth xs n) (lnth ys n)\n  enat n < min (llength xs) (llength ys)", "have \"r (lhd (ldrop (enat n) xs)) (lnth ys n)\""], ["proof (prove)\nusing this:\n  r (lnth xs n) (lnth ys n)\n  enat n < min (llength xs) (llength ys)\n\ngoal (1 subgoal):\n 1. r (lhd (ldrop (enat n) xs)) (lnth ys n)", "by(simp add: lhd_ldrop)"], ["proof (state)\nthis:\n  r (lhd (ldrop (enat n) xs)) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "moreover"], ["proof (state)\nthis:\n  r (lhd (ldrop (enat n) xs)) (lnth ys n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "have \"lfinite (ltake (enat n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltake (enat n) xs)", "by simp"], ["proof (state)\nthis:\n  lfinite (ltake (enat n) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < min (llength xs) (llength ys) \\<and>\n       ltake (enat n) xs = ltake (enat n) ys \\<and>\n       r (lnth xs n) (lnth ys n) \\<Longrightarrow>\n    llexord r xs ys", "ultimately"], ["proof (chain)\npicking this:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n  ys =\n  lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\n  r (lhd (ldrop (enat n) xs)) (lnth ys n)\n  lfinite (ltake (enat n) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n  ys =\n  lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\n  r (lhd (ldrop (enat n) xs)) (lnth ys n)\n  lfinite (ltake (enat n) xs)\n\ngoal (1 subgoal):\n 1. llexord r xs ys", "unfolding llexord_conv"], ["proof (prove)\nusing this:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n  ys =\n  lappend (ltake (enat n) xs) (LCons (lnth ys n) (ldrop (enat (Suc n)) ys))\n  r (lhd (ldrop (enat n) xs)) (lnth ys n)\n  lfinite (ltake (enat n) xs)\n\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (\\<exists>zs xs' y ys'.\n        lfinite zs \\<and>\n        xs = lappend zs xs' \\<and>\n        ys = lappend zs (LCons y ys') \\<and>\n        (xs' = LNil \\<or> r (lhd xs') y))", "by blast"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llexord r xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llexord_llist_of:\n  \"llexord r (llist_of xs) (llist_of ys) \\<longleftrightarrow>\n   xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r (llist_of xs) (llist_of ys) =\n    (xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "assume ?lhs"], ["proof (state)\nthis:\n  llexord r (llist_of xs) (llist_of ys)\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "{"], ["proof (state)\nthis:\n  llexord r (llist_of xs) (llist_of ys)\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "fix zs xs' y ys'"], ["proof (state)\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "assume \"lfinite zs\" \"llist_of xs = lappend zs xs'\"\n      and \"llist_of ys = lappend zs (LCons y ys')\"\n      and \"xs' = LNil \\<or> r (lhd xs') y\""], ["proof (state)\nthis:\n  lfinite zs\n  llist_of xs = lappend zs xs'\n  llist_of ys = lappend zs (LCons y ys')\n  xs' = LNil \\<or> r (lhd xs') y\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "from \\<open>lfinite zs\\<close>"], ["proof (chain)\npicking this:\n  lfinite zs", "obtain zs' where [simp]: \"zs = llist_of zs'\""], ["proof (prove)\nusing this:\n  lfinite zs\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = llist_of zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  zs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        zs = llist_of zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zs = llist_of zs'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "have \"lfinite (llist_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (llist_of xs)", "by simp"], ["proof (state)\nthis:\n  lfinite (llist_of xs)\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "hence \"lfinite xs'\""], ["proof (prove)\nusing this:\n  lfinite (llist_of xs)\n\ngoal (1 subgoal):\n 1. lfinite xs'", "unfolding \\<open>llist_of xs = lappend zs xs'\\<close>"], ["proof (prove)\nusing this:\n  lfinite (lappend zs xs')\n\ngoal (1 subgoal):\n 1. lfinite xs'", "by simp"], ["proof (state)\nthis:\n  lfinite xs'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "then"], ["proof (chain)\npicking this:\n  lfinite xs'", "obtain XS' where [simp]: \"xs' = llist_of XS'\""], ["proof (prove)\nusing this:\n  lfinite xs'\n\ngoal (1 subgoal):\n 1. (\\<And>XS'.\n        xs' = llist_of XS' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  xs' \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>XS'.\n        xs' = llist_of XS' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs' = llist_of XS'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "from \\<open>llist_of xs = lappend zs xs'\\<close>"], ["proof (chain)\npicking this:\n  llist_of xs = lappend zs xs'", "have [simp]: \"xs = zs' @ XS'\""], ["proof (prove)\nusing this:\n  llist_of xs = lappend zs xs'\n\ngoal (1 subgoal):\n 1. xs = zs' @ XS'", "by(simp add: lappend_llist_of_llist_of)"], ["proof (state)\nthis:\n  xs = zs' @ XS'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "have \"lfinite (llist_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (llist_of ys)", "by simp"], ["proof (state)\nthis:\n  lfinite (llist_of ys)\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "hence \"lfinite ys'\""], ["proof (prove)\nusing this:\n  lfinite (llist_of ys)\n\ngoal (1 subgoal):\n 1. lfinite ys'", "unfolding \\<open>llist_of ys = lappend zs (LCons y ys')\\<close>"], ["proof (prove)\nusing this:\n  lfinite (lappend zs (LCons y ys'))\n\ngoal (1 subgoal):\n 1. lfinite ys'", "by simp"], ["proof (state)\nthis:\n  lfinite ys'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "then"], ["proof (chain)\npicking this:\n  lfinite ys'", "obtain YS' where [simp]: \"ys' = llist_of YS'\""], ["proof (prove)\nusing this:\n  lfinite ys'\n\ngoal (1 subgoal):\n 1. (\\<And>YS'.\n        ys' = llist_of YS' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  ys' \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>YS'.\n        ys' = llist_of YS' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ys' = llist_of YS'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "from \\<open>llist_of ys = lappend zs (LCons y ys')\\<close>"], ["proof (chain)\npicking this:\n  llist_of ys = lappend zs (LCons y ys')", "have [simp]: \"ys = zs' @ y # YS'\""], ["proof (prove)\nusing this:\n  llist_of ys = lappend zs (LCons y ys')\n\ngoal (1 subgoal):\n 1. ys = zs' @ y # YS'", "by(auto simp add: llist_of.simps(2)[symmetric] lappend_llist_of_llist_of simp del: llist_of.simps(2))"], ["proof (state)\nthis:\n  ys = zs' @ y # YS'\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "have \"(\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n          (\\<exists>zs a b. r a b \\<and> (\\<exists>xs'. xs = zs @ a # xs') \\<and> (\\<exists>ys'. ys = zs @ b # ys'))\"\n      (is \"?A \\<or> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n    (\\<exists>zs a b.\n        r a b \\<and>\n        (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n        (\\<exists>ys'. ys = zs @ b # ys'))", "proof(cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = LNil \\<Longrightarrow>\n    (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n    (\\<exists>zs a b.\n        r a b \\<and>\n        (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n        (\\<exists>ys'. ys = zs @ b # ys'))\n 2. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "case LNil"], ["proof (state)\nthis:\n  xs' = LNil\n\ngoal (2 subgoals):\n 1. xs' = LNil \\<Longrightarrow>\n    (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n    (\\<exists>zs a b.\n        r a b \\<and>\n        (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n        (\\<exists>ys'. ys = zs @ b # ys'))\n 2. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = LNil\n\ngoal (1 subgoal):\n 1. (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n    (\\<exists>zs a b.\n        r a b \\<and>\n        (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n        (\\<exists>ys'. ys = zs @ b # ys'))", "by(auto simp add: llist_of_eq_LNil_conv)"], ["proof (state)\nthis:\n  (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n  (\\<exists>zs a b.\n      r a b \\<and>\n      (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n      (\\<exists>ys'. ys = zs @ b # ys'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "case (LCons x xs'')"], ["proof (state)\nthis:\n  xs' = LCons x xs''\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "with \\<open>xs' = LNil \\<or> r (lhd xs') y\\<close>"], ["proof (chain)\npicking this:\n  xs' = LNil \\<or> r (lhd xs') y\n  xs' = LCons x xs''", "have \"r (lhd xs') y\""], ["proof (prove)\nusing this:\n  xs' = LNil \\<or> r (lhd xs') y\n  xs' = LCons x xs''\n\ngoal (1 subgoal):\n 1. r (lhd xs') y", "by(auto simp add: llist_of_eq_LCons_conv)"], ["proof (state)\nthis:\n  r (lhd xs') y\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "with LCons"], ["proof (chain)\npicking this:\n  xs' = LCons x xs''\n  r (lhd xs') y", "have ?B"], ["proof (prove)\nusing this:\n  xs' = LCons x xs''\n  r (lhd xs') y\n\ngoal (1 subgoal):\n 1. \\<exists>zs a b.\n       r a b \\<and>\n       (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n       (\\<exists>ys'. ys = zs @ b # ys')", "by(auto simp add: llist_of_eq_LCons_conv) fastforce"], ["proof (state)\nthis:\n  \\<exists>zs a b.\n     r a b \\<and>\n     (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n     (\\<exists>ys'. ys = zs @ b # ys')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xs' = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n       (\\<exists>zs a b.\n           r a b \\<and>\n           (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n           (\\<exists>ys'. ys = zs @ b # ys'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>zs a b.\n     r a b \\<and>\n     (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n     (\\<exists>ys'. ys = zs @ b # ys')\n\ngoal (1 subgoal):\n 1. (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n    (\\<exists>zs a b.\n        r a b \\<and>\n        (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n        (\\<exists>ys'. ys = zs @ b # ys'))", ".."], ["proof (state)\nthis:\n  (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n  (\\<exists>zs a b.\n      r a b \\<and>\n      (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n      (\\<exists>ys'. ys = zs @ b # ys'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n  (\\<exists>zs a b.\n      r a b \\<and>\n      (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n      (\\<exists>ys'. ys = zs @ b # ys'))\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "hence \"(xs, ys) \\<in> {(x, y). \\<exists>a v. y = x @ a # v \\<or>\n                                    (\\<exists>u a b v w. (a, b) \\<in> {(x, y). r x y} \\<and>\n                                                 x = u @ a # v \\<and> y = u @ b # w)}\""], ["proof (prove)\nusing this:\n  (\\<exists>a ys'. ys = xs @ a # ys') \\<or>\n  (\\<exists>zs a b.\n      r a b \\<and>\n      (\\<exists>xs'. xs = zs @ a # xs') \\<and>\n      (\\<exists>ys'. ys = zs @ b # ys'))\n\ngoal (1 subgoal):\n 1. (xs, ys)\n    \\<in> {(x, y).\n           \\<exists>a v.\n              y = x @ a # v \\<or>\n              (\\<exists>u a b v w.\n                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                  x = u @ a # v \\<and> y = u @ b # w)}", "by auto"], ["proof (state)\nthis:\n  (xs, ys)\n  \\<in> {(x, y).\n         \\<exists>a v.\n            y = x @ a # v \\<or>\n            (\\<exists>u a b v w.\n                (a, b) \\<in> {(x, y). r x y} \\<and>\n                x = u @ a # v \\<and> y = u @ b # w)}\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lfinite ?zs2; llist_of xs = lappend ?zs2 ?xs'2;\n   llist_of ys = lappend ?zs2 (LCons ?y2 ?ys'2);\n   ?xs'2 = LNil \\<or> r (lhd ?xs'2) ?y2\\<rbrakk>\n  \\<Longrightarrow> (xs, ys)\n                    \\<in> {(x, y).\n                           \\<exists>a v.\n                              y = x @ a # v \\<or>\n                              (\\<exists>u a b v w.\n                                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                                  x = u @ a # v \\<and> y = u @ b # w)}\n\ngoal (2 subgoals):\n 1. llexord r (llist_of xs) (llist_of ys) \\<Longrightarrow>\n    xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n 2. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  llexord r (llist_of xs) (llist_of ys)\n  \\<lbrakk>lfinite ?zs2; llist_of xs = lappend ?zs2 ?xs'2;\n   llist_of ys = lappend ?zs2 (LCons ?y2 ?ys'2);\n   ?xs'2 = LNil \\<or> r (lhd ?xs'2) ?y2\\<rbrakk>\n  \\<Longrightarrow> (xs, ys)\n                    \\<in> {(x, y).\n                           \\<exists>a v.\n                              y = x @ a # v \\<or>\n                              (\\<exists>u a b v w.\n                                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                                  x = u @ a # v \\<and> y = u @ b # w)}", "show ?rhs"], ["proof (prove)\nusing this:\n  llexord r (llist_of xs) (llist_of ys)\n  \\<lbrakk>lfinite ?zs2; llist_of xs = lappend ?zs2 ?xs'2;\n   llist_of ys = lappend ?zs2 (LCons ?y2 ?ys'2);\n   ?xs'2 = LNil \\<or> r (lhd ?xs'2) ?y2\\<rbrakk>\n  \\<Longrightarrow> (xs, ys)\n                    \\<in> {(x, y).\n                           \\<exists>a v.\n                              y = x @ a # v \\<or>\n                              (\\<exists>u a b v w.\n                                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                                  x = u @ a # v \\<and> y = u @ b # w)}\n\ngoal (1 subgoal):\n 1. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}", "unfolding lexord_def llexord_conv llist_of_inject"], ["proof (prove)\nusing this:\n  xs = ys \\<or>\n  (\\<exists>zs xs' y ys'.\n      lfinite zs \\<and>\n      llist_of xs = lappend zs xs' \\<and>\n      llist_of ys = lappend zs (LCons y ys') \\<and>\n      (xs' = LNil \\<or> r (lhd xs') y))\n  \\<lbrakk>lfinite ?zs2; llist_of xs = lappend ?zs2 ?xs'2;\n   llist_of ys = lappend ?zs2 (LCons ?y2 ?ys'2);\n   ?xs'2 = LNil \\<or> r (lhd ?xs'2) ?y2\\<rbrakk>\n  \\<Longrightarrow> (xs, ys)\n                    \\<in> {(x, y).\n                           \\<exists>a v.\n                              y = x @ a # v \\<or>\n                              (\\<exists>u a b v w.\n                                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                                  x = u @ a # v \\<and> y = u @ b # w)}\n\ngoal (1 subgoal):\n 1. xs = ys \\<or>\n    (xs, ys)\n    \\<in> {(x, y).\n           \\<exists>a v.\n              y = x @ a # v \\<or>\n              (\\<exists>u a b v w.\n                  (a, b) \\<in> {(x, y). r x y} \\<and>\n                  x = u @ a # v \\<and> y = u @ b # w)}", "by blast"], ["proof (state)\nthis:\n  xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "assume \"?rhs\""], ["proof (state)\nthis:\n  xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "thus ?lhs"], ["proof (prove)\nusing this:\n  xs = ys \\<or> (xs, ys) \\<in> lexord {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. llexord r (llist_of xs) (llist_of ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow> llexord r (llist_of xs) (llist_of ys)\n 2. (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "assume \"xs = ys\""], ["proof (state)\nthis:\n  xs = ys\n\ngoal (2 subgoals):\n 1. xs = ys \\<Longrightarrow> llexord r (llist_of xs) (llist_of ys)\n 2. (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. llexord r (llist_of xs) (llist_of ys)", "by simp"], ["proof (state)\nthis:\n  llexord r (llist_of xs) (llist_of ys)\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "assume \"(xs, ys) \\<in> lexord {(x, y). r x y}\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> lexord {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> lexord {(x, y). r x y} \\<Longrightarrow>\n    llexord r (llist_of xs) (llist_of ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> lexord {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. llexord r (llist_of xs) (llist_of ys)", "by(coinduction arbitrary: xs ys)(auto, auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  llexord r (llist_of xs) (llist_of ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llexord r (llist_of xs) (llist_of ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The filter functional on lazy lists: @{term \"lfilter\"}\\<close>"], ["", "lemma lfilter_code [simp, code]:\n  shows lfilter_LNil: \"lfilter P LNil = LNil\"\n  and lfilter_LCons: \"lfilter P (LCons x xs) = (if P x then LCons x (lfilter P xs) else lfilter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P LNil = LNil &&&\n    lfilter P (LCons x xs) =\n    (if P x then LCons x (lfilter P xs) else lfilter P xs)", "by(simp_all add: lfilter.simps)"], ["", "declare lfilter.mono[cont_intro]"], ["", "lemma mono2mono_lfilter[THEN llist.mono2mono, simp, cont_intro]:\n  shows monotone_lfilter: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lfilter P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) (lfilter P)", "by(rule llist.fixp_preserves_mono1[OF lfilter.mono lfilter_def]) simp"], ["", "lemma mcont2mcont_lfilter[THEN llist.mcont2mcont, simp, cont_intro]:\n  shows mcont_lfilter: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lfilter P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) (lfilter P)", "by(rule llist.fixp_preserves_mcont1[OF lfilter.mono lfilter_def]) simp"], ["", "lemma lfilter_mono [partial_function_mono]:\n  \"mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lfilter P (A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_llist A \\<Longrightarrow> mono_llist (\\<lambda>f. lfilter P (A f))", "by(rule mono2mono_lfilter)"], ["", "lemma lfilter_LCons_seek: \"~ (p x) ==> lfilter p (LCons x l) = lfilter p l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p x \\<Longrightarrow> lfilter p (LCons x l) = lfilter p l", "by simp"], ["", "lemma lfilter_LCons_found:\n  \"P x \\<Longrightarrow> lfilter P (LCons x xs) = LCons x (lfilter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow> lfilter P (LCons x xs) = LCons x (lfilter P xs)", "by simp"], ["", "lemma lfilter_eq_LNil: \"lfilter P xs = LNil \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "by(induction xs) simp_all"], ["", "notepad begin"], ["proof (state)", "fix P xs"], ["proof (state)", "have \"(lfilter P xs = LNil) \\<longleftrightarrow> (\\<forall>x \\<in> lset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "proof(intro iffI strip)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x\n 2. \\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil", "assume \"\\<forall>x \\<in> lset xs. \\<not> P x\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>lset xs. \\<not> P x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x\n 2. \\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil", "hence \"lfilter P xs \\<sqsubseteq> LNil\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. lfilter P xs \\<sqsubseteq> LNil", "by(induction arbitrary: xs rule: lfilter.fixp_induct)(simp_all split: llist.split del: lprefix_LNil)"], ["proof (state)\nthis:\n  lfilter P xs \\<sqsubseteq> LNil\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x\n 2. \\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil", "thus \"lfilter P xs = LNil\""], ["proof (prove)\nusing this:\n  lfilter P xs \\<sqsubseteq> LNil\n\ngoal (1 subgoal):\n 1. lfilter P xs = LNil", "by simp"], ["proof (state)\nthis:\n  lfilter P xs = LNil\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x", "assume \"x \\<in> lset xs\" \"lfilter P xs = LNil\""], ["proof (state)\nthis:\n  x \\<in> lset xs\n  lfilter P xs = LNil\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lfilter P xs = LNil; x \\<in> lset xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P x", "thus \"\\<not> P x\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  lfilter P xs = LNil\n\ngoal (1 subgoal):\n 1. \\<not> P x", "by induction(simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lfilter P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "end"], ["", "lemma diverge_lfilter_LNil [simp]: \"\\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. \\<not> P x \\<Longrightarrow> lfilter P xs = LNil", "by(simp add: lfilter_eq_LNil)"], ["", "lemmas lfilter_False = diverge_lfilter_LNil"], ["", "lemma lnull_lfilter [simp]: \"lnull (lfilter P xs) \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. \\<not> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lfilter P xs) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter P xs = LNil) = (\\<forall>x\\<in>lset xs. \\<not> P x)", "by(simp add: lfilter_eq_LNil)"], ["", "lemmas lfilter_empty_conv = lfilter_eq_LNil"], ["", "lemma lhd_lfilter [simp]: \"lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "proof(cases \"\\<exists>x\\<in>lset xs. P x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. P x \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\n 2. \\<not> (\\<exists>x\\<in>lset xs. P x) \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "case True"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. P x \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\n 2. \\<not> (\\<exists>x\\<in>lset xs. P x) \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. P x", "obtain x where \"x \\<in> lset xs\" and \"P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> lset xs; P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  P x\n\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>lset xs. P x \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\n 2. \\<not> (\\<exists>x\\<in>lset xs. P x) \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "from \\<open>x \\<in> lset xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> lset xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n\ngoal (1 subgoal):\n 1. lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "by induct(simp_all add: \\<open>P x\\<close>)"], ["proof (state)\nthis:\n  lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>lset xs. P x) \\<Longrightarrow>\n    lhd (lfilter P xs) = lhd (ldropWhile (Not \\<circ> P) xs)", "qed(simp add: o_def)"], ["", "lemma ltl_lfilter: \"ltl (lfilter P xs) = lfilter P (ltl (ldropWhile (Not \\<circ> P) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lfilter P xs) = lfilter P (ltl (ldropWhile (Not \\<circ> P) xs))", "by(induct xs) simp_all"], ["", "lemma lfilter_eq_LCons:\n  \"lfilter P xs = LCons x xs' \\<Longrightarrow>\n   \\<exists>xs''. xs' = lfilter P xs'' \\<and> ldropWhile (Not \\<circ> P) xs = LCons x xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P xs = LCons x xs' \\<Longrightarrow>\n    \\<exists>xs''.\n       xs' = lfilter P xs'' \\<and>\n       ldropWhile (Not \\<circ> P) xs = LCons x xs''", "by(drule eq_LConsD)(auto intro!: exI simp add: ltl_lfilter o_def ldropWhile_eq_LNil_iff intro: llist.expand)"], ["", "lemma lfilter_K_True [simp]: \"lfilter (%_. True) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter (\\<lambda>_. True) xs = xs", "by(induct xs) simp_all"], ["", "lemma lfitler_K_False [simp]: \"lfilter (\\<lambda>_. False) xs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter (\\<lambda>_. False) xs = LNil", "by simp"], ["", "lemma lfilter_lappend_lfinite [simp]:\n  \"lfinite xs \\<Longrightarrow> lfilter P (lappend xs ys) = lappend (lfilter P xs) (lfilter P ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow>\n    lfilter P (lappend xs ys) = lappend (lfilter P xs) (lfilter P ys)", "by(induct rule: lfinite.induct) auto"], ["", "lemma lfinite_lfilterI [simp]: \"lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)", "by(induct rule: lfinite.induct) simp_all"], ["", "lemma lset_lfilter [simp]: \"lset (lfilter P xs) = {x \\<in> lset xs. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lfilter P xs) = {x \\<in> lset xs. P x}", "by induct(auto simp add: Collect_conj_eq)"], ["", "notepad begin \\<comment> \\<open>show @{thm [source] lset_lfilter} by fixpoint induction\\<close>"], ["proof (state)", "note [simp del] = lset_lfilter"], ["proof (state)\nthis:\n  lset (lfilter ?P ?xs) = {x \\<in> lset ?xs. ?P x}", "fix P xs"], ["proof (state)", "have \"lset (lfilter P xs) = lset xs \\<inter> {x. P x}\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lfilter P xs) = lset xs \\<inter> {x. P x}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lset (lfilter P xs) \\<subseteq> lset xs \\<inter> {x. P x}\n 2. lset xs \\<inter> {x. P x} \\<subseteq> lset (lfilter P xs)", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lfilter P xs) \\<subseteq> lset xs \\<inter> {x. P x}", "by(induct arbitrary: xs rule: lfilter.fixp_induct)(auto split: llist.split)"], ["proof (state)\nthis:\n  lset (lfilter P xs) \\<subseteq> lset xs \\<inter> {x. P x}\n\ngoal (1 subgoal):\n 1. lset xs \\<inter> {x. P x} \\<subseteq> lset (lfilter P xs)", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset xs \\<inter> {x. P x} \\<subseteq> lset (lfilter P xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lset xs \\<inter> {x. P x} \\<Longrightarrow>\n       x \\<in> lset (lfilter P xs)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lset xs \\<inter> {x. P x} \\<Longrightarrow>\n       x \\<in> lset (lfilter P xs)", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> lset xs \\<inter> {x. P x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lset xs \\<inter> {x. P x} \\<Longrightarrow>\n       x \\<in> lset (lfilter P xs)", "hence \"x \\<in> lset xs\" \"P x\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs \\<inter> {x. P x}\n\ngoal (1 subgoal):\n 1. x \\<in> lset xs &&& P x", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> lset xs\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lset xs \\<inter> {x. P x} \\<Longrightarrow>\n       x \\<in> lset (lfilter P xs)", "thus \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  x \\<in> lset xs\n  P x\n\ngoal (1 subgoal):\n 1. x \\<in> lset (lfilter P xs)", "by induction simp_all"], ["proof (state)\nthis:\n  x \\<in> lset (lfilter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lset xs \\<inter> {x. P x} \\<subseteq> lset (lfilter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lset (lfilter P xs) = lset xs \\<inter> {x. P x}", "end"], ["", "lemma lfilter_lfilter: \"lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs", "by(induction xs) simp_all"], ["", "notepad begin \\<comment> \\<open>show @{thm [source] lfilter_lfilter} by fixpoint induction\\<close>"], ["proof (state)", "fix P Q xs"], ["proof (state)", "have \"\\<forall>xs. lfilter P (lfilter Q xs) \\<sqsubseteq> lfilter (\\<lambda>x. P x \\<and> Q x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       lfilter P (lfilter Q xs) \\<sqsubseteq>\n       lfilter (\\<lambda>x. P x \\<and> Q x) xs", "by(rule lfilter.fixp_induct)(auto split: llist.split)"], ["proof (state)\nthis:\n  \\<forall>xs.\n     lfilter P (lfilter Q xs) \\<sqsubseteq>\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs", "moreover"], ["proof (state)\nthis:\n  \\<forall>xs.\n     lfilter P (lfilter Q xs) \\<sqsubseteq>\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs", "have \"\\<forall>xs. lfilter (\\<lambda>x. P x \\<and> Q x) xs \\<sqsubseteq> lfilter P (lfilter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       lfilter (\\<lambda>x. P x \\<and> Q x) xs \\<sqsubseteq>\n       lfilter P (lfilter Q xs)", "by(rule lfilter.fixp_induct)(auto split: llist.split)"], ["proof (state)\nthis:\n  \\<forall>xs.\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs \\<sqsubseteq>\n     lfilter P (lfilter Q xs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>xs.\n     lfilter P (lfilter Q xs) \\<sqsubseteq>\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs\n  \\<forall>xs.\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs \\<sqsubseteq>\n     lfilter P (lfilter Q xs)", "have \"lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs.\n     lfilter P (lfilter Q xs) \\<sqsubseteq>\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs\n  \\<forall>xs.\n     lfilter (\\<lambda>x. P x \\<and> Q x) xs \\<sqsubseteq>\n     lfilter P (lfilter Q xs)\n\ngoal (1 subgoal):\n 1. lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs", "by(blast intro: lprefix_antisym)"], ["proof (state)\nthis:\n  lfilter P (lfilter Q xs) = lfilter (\\<lambda>x. P x \\<and> Q x) xs", "end"], ["", "lemma lfilter_idem [simp]: \"lfilter P (lfilter P xs) = lfilter P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (lfilter P xs) = lfilter P xs", "by(simp add: lfilter_lfilter)"], ["", "lemma lfilter_lmap: \"lfilter P (lmap f xs) = lmap f (lfilter (P o f) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (lmap f xs) = lmap f (lfilter (P \\<circ> f) xs)", "by(induct xs) simp_all"], ["", "lemma lfilter_llist_of [simp]:\n  \"lfilter P (llist_of xs) = llist_of (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (llist_of xs) = llist_of (filter P xs)", "by(induct xs) simp_all"], ["", "lemma lfilter_cong [cong]:\n  assumes xsys: \"xs = ys\"\n  and set: \"\\<And>x. x \\<in> lset ys \\<Longrightarrow> P x = Q x\"\n  shows \"lfilter P xs = lfilter Q ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P xs = lfilter Q ys", "using set"], ["proof (prove)\nusing this:\n  ?x \\<in> lset ys \\<Longrightarrow> P ?x = Q ?x\n\ngoal (1 subgoal):\n 1. lfilter P xs = lfilter Q ys", "unfolding xsys"], ["proof (prove)\nusing this:\n  ?x \\<in> lset ys \\<Longrightarrow> P ?x = Q ?x\n\ngoal (1 subgoal):\n 1. lfilter P ys = lfilter Q ys", "by(induction ys)(simp_all add: Bex_def[symmetric])"], ["", "lemma llength_lfilter_ile:\n  \"llength (lfilter P xs) \\<le> llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lfilter P xs) \\<le> llength xs", "by(induct xs)(auto intro: order_trans)"], ["", "lemma lfinite_lfilter:\n  \"lfinite (lfilter P xs) \\<longleftrightarrow>\n   lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs) =\n    (lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume \"lfinite (lfilter P xs)\""], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "{"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume \"\\<not> lfinite xs\""], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "with \\<open>lfinite (lfilter P xs)\\<close>"], ["proof (chain)\npicking this:\n  lfinite (lfilter P xs)\n  \\<not> lfinite xs", "have \"finite {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (prove)\nusing this:\n  lfinite (lfilter P xs)\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. finite {n. enat n < llength xs \\<and> P (lnth xs n)}", "proof(induct ys\\<equiv>\"lfilter P xs\" arbitrary: xs rule: lfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>lnull (lfilter P xs); \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "case LNil"], ["proof (state)\nthis:\n  lnull (lfilter P xs)\n  \\<not> lfinite xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>lnull (lfilter P xs); \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"\\<forall>x\\<in>lset xs. \\<not> P x\""], ["proof (prove)\nusing this:\n  lnull (lfilter P xs)\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. \\<not> P x", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>lset xs. \\<not> P x\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>lnull (lfilter P xs); \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence eq: \"{n. enat n < llength xs \\<and> P (lnth xs n)} = {}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>lset xs. \\<not> P x\n\ngoal (1 subgoal):\n 1. {n. enat n < llength xs \\<and> P (lnth xs n)} = {}", "by(auto simp add: lset_conv_lnth)"], ["proof (state)\nthis:\n  {n. enat n < llength xs \\<and> P (lnth xs n)} = {}\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>lnull (lfilter P xs); \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {n. enat n < llength xs \\<and> P (lnth xs n)}", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {}", ".."], ["proof (state)\nthis:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "case (LCons xs)"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n  \\<not> lnull (lfilter P xs)\n  \\<lbrakk>ltl (lfilter P xs) = lfilter P ?xs; \\<not> lfinite ?xs\\<rbrakk>\n  \\<Longrightarrow> finite {n. enat n < llength ?xs \\<and> P (lnth ?xs n)}\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "from \\<open>\\<not> lnull (lfilter P xs)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> lnull (lfilter P xs)", "have exP: \"\\<exists>x\\<in>lset xs. P x\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lfilter P xs)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset xs. P x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "let ?xs = \"ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "let ?xs' = \"ltakeWhile (\\<lambda>x. \\<not> P x) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "from exP"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset xs. P x", "obtain n where n: \"llength ?xs' = enat n\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) =\n        enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using lfinite_conv_llength_enat[of ?xs']"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. P x\n  lfinite (ltakeWhile (\\<lambda>x. \\<not> P x) xs) =\n  (\\<exists>n. llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) = enat n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) =\n        enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: lfinite_ltakeWhile)"], ["proof (state)\nthis:\n  llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) = enat n\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "have \"finite ({n. enat n < llength ?xs} \\<inter> {n. P (lnth ?xs n)})\" (is \"finite ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({n. enat n\n          < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n      {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)})", "using LCons [[simproc add: finite_Collect]]"], ["proof (prove)\nusing this:\n  lfinite (lfilter P xs)\n  \\<not> lnull (lfilter P xs)\n  \\<lbrakk>ltl (lfilter P xs) = lfilter P ?xs; \\<not> lfinite ?xs\\<rbrakk>\n  \\<Longrightarrow> finite {n. enat n < llength ?xs \\<and> P (lnth ?xs n)}\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. finite\n     ({n. enat n\n          < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n      {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)})", "by(auto simp add: ltl_lfilter lfinite_ldropWhile)"], ["proof (state)\nthis:\n  finite\n   ({n. enat n\n        < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n    {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)})\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"finite ((\\<lambda>m. n + 1 + m) ` ({n. enat n < llength ?xs} \\<inter> {n. P (lnth ?xs n)}))\"\n        (is \"finite (?f ` _)\")"], ["proof (prove)\nusing this:\n  finite\n   ({n. enat n\n        < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n    {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)})\n\ngoal (1 subgoal):\n 1. finite\n     ((+) (n + 1) `\n      ({n. enat n\n           < llength\n              (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n       {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)}))", "by(rule finite_imageI)"], ["proof (state)\nthis:\n  finite\n   ((+) (n + 1) `\n    ({n. enat n\n         < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n     {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)}))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "moreover"], ["proof (state)\nthis:\n  finite\n   ((+) (n + 1) `\n    ({n. enat n\n         < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n     {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)}))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "have xs: \"xs = lappend ?xs' (LCons (lhd (ldropWhile (\\<lambda>x. \\<not> P x) xs)) ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    lappend (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n     (LCons (lhd (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n       (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)))", "using exP"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. xs =\n    lappend (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n     (LCons (lhd (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n       (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)))", "by simp"], ["proof (state)\nthis:\n  xs =\n  lappend (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n   (LCons (lhd (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n     (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "{"], ["proof (state)\nthis:\n  xs =\n  lappend (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n   (LCons (lhd (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n     (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"lnth ?xs' m \\<in> lset ?xs'\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m\n    \\<in> lset (ltakeWhile (\\<lambda>x. \\<not> P x) xs)", "using n"], ["proof (prove)\nusing this:\n  m < n\n  llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) = enat n\n\ngoal (1 subgoal):\n 1. lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m\n    \\<in> lset (ltakeWhile (\\<lambda>x. \\<not> P x) xs)", "unfolding in_lset_conv_lnth"], ["proof (prove)\nusing this:\n  m < n\n  llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) = enat n\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) \\<and>\n       lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) n =\n       lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m", "by auto"], ["proof (state)\nthis:\n  lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m\n  \\<in> lset (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"\\<not> P (lnth ?xs' m)\""], ["proof (prove)\nusing this:\n  lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m\n  \\<in> lset (ltakeWhile (\\<lambda>x. \\<not> P x) xs)\n\ngoal (1 subgoal):\n 1. \\<not> P (lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m)", "by(auto dest: lset_ltakeWhileD)"], ["proof (state)\nthis:\n  \\<not> P (lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) m)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "}"], ["proof (state)\nthis:\n  ?m2 < n \\<Longrightarrow>\n  \\<not> P (lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) ?m2)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"{n. enat n < llength xs \\<and> P (lnth xs n)} \\<subseteq> insert (the_enat (llength ?xs')) (?f ` ?A)\""], ["proof (prove)\nusing this:\n  ?m2 < n \\<Longrightarrow>\n  \\<not> P (lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) ?m2)\n\ngoal (1 subgoal):\n 1. {n. enat n < llength xs \\<and> P (lnth xs n)}\n    \\<subseteq> insert\n                 (the_enat\n                   (llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs)))\n                 ((+) (n + 1) `\n                  ({n. enat n\n                       < llength\n                          (ltl (ldropWhile (\\<lambda>x. \\<not> P x)\n                                 xs))} \\<inter>\n                   {n. P (lnth\n                           (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n                           n)}))", "using n"], ["proof (prove)\nusing this:\n  ?m2 < n \\<Longrightarrow>\n  \\<not> P (lnth (ltakeWhile (\\<lambda>x. \\<not> P x) xs) ?m2)\n  llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs) = enat n\n\ngoal (1 subgoal):\n 1. {n. enat n < llength xs \\<and> P (lnth xs n)}\n    \\<subseteq> insert\n                 (the_enat\n                   (llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs)))\n                 ((+) (n + 1) `\n                  ({n. enat n\n                       < llength\n                          (ltl (ldropWhile (\\<lambda>x. \\<not> P x)\n                                 xs))} \\<inter>\n                   {n. P (lnth\n                           (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n                           n)}))", "by(subst (1 2) xs)(cases \"llength ?xs\", auto simp add: lnth_lappend not_less not_le lnth_LCons' eSuc_enat split: if_split_asm intro!: rev_image_eqI)"], ["proof (state)\nthis:\n  {n. enat n < llength xs \\<and> P (lnth xs n)}\n  \\<subseteq> insert\n               (the_enat (llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs)))\n               ((+) (n + 1) `\n                ({n. enat n\n                     < llength\n                        (ltl (ldropWhile (\\<lambda>x. \\<not> P x)\n                               xs))} \\<inter>\n                 {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n                         n)}))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lfilter P xs); \\<not> lnull (lfilter P xs);\n        \\<And>xsa.\n           \\<lbrakk>ltl (lfilter P xs) = lfilter P xsa;\n            \\<not> lfinite xsa\\<rbrakk>\n           \\<Longrightarrow> finite\n                              {n. enat n < llength xsa \\<and>\n                                  P (lnth xsa n)};\n        \\<not> lfinite xs\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {n. enat n < llength xs \\<and> P (lnth xs n)}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   ((+) (n + 1) `\n    ({n. enat n\n         < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n     {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)}))\n  {n. enat n < llength xs \\<and> P (lnth xs n)}\n  \\<subseteq> insert\n               (the_enat (llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs)))\n               ((+) (n + 1) `\n                ({n. enat n\n                     < llength\n                        (ltl (ldropWhile (\\<lambda>x. \\<not> P x)\n                               xs))} \\<inter>\n                 {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n                         n)}))", "show ?case"], ["proof (prove)\nusing this:\n  finite\n   ((+) (n + 1) `\n    ({n. enat n\n         < llength (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))} \\<inter>\n     {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs)) n)}))\n  {n. enat n < llength xs \\<and> P (lnth xs n)}\n  \\<subseteq> insert\n               (the_enat (llength (ltakeWhile (\\<lambda>x. \\<not> P x) xs)))\n               ((+) (n + 1) `\n                ({n. enat n\n                     < llength\n                        (ltl (ldropWhile (\\<lambda>x. \\<not> P x)\n                               xs))} \\<inter>\n                 {n. P (lnth (ltl (ldropWhile (\\<lambda>x. \\<not> P x) xs))\n                         n)}))\n\ngoal (1 subgoal):\n 1. finite {n. enat n < llength xs \\<and> P (lnth xs n)}", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "}"], ["proof (state)\nthis:\n  \\<not> lfinite xs \\<Longrightarrow>\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (2 subgoals):\n 1. lfinite (lfilter P xs) \\<Longrightarrow>\n    lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n 2. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "thus \"lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs \\<Longrightarrow>\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}", "by blast"], ["proof (state)\nthis:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume \"lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (state)\nthis:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "moreover"], ["proof (state)\nthis:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "{"], ["proof (state)\nthis:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "with llength_lfilter_ile[of P xs]"], ["proof (chain)\npicking this:\n  llength (lfilter P xs) \\<le> llength xs\n  lfinite xs", "have \"lfinite (lfilter P xs)\""], ["proof (prove)\nusing this:\n  llength (lfilter P xs) \\<le> llength xs\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs)", "by(auto simp add: lfinite_eq_range_llist_of)"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "}"], ["proof (state)\nthis:\n  lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "moreover"], ["proof (state)\nthis:\n  lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "{"], ["proof (state)\nthis:\n  lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume nfin: \"\\<not> lfinite xs\""], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "hence len: \"llength xs = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. llength xs = \\<infinity>", "by(rule not_lfinite_llength)"], ["proof (state)\nthis:\n  llength xs = \\<infinity>\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "assume fin: \"finite {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (state)\nthis:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "then"], ["proof (chain)\npicking this:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}", "obtain m where \"{n. enat n < llength xs \\<and> P (lnth xs n)} \\<subseteq> {..<m}\""], ["proof (prove)\nusing this:\n  finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        {n. enat n < llength xs \\<and> P (lnth xs n)}\n        \\<subseteq> {..<m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finite_nat_iff_bounded"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     {n. enat n < llength xs \\<and> P (lnth xs n)} \\<subseteq> {..<k}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        {n. enat n < llength xs \\<and> P (lnth xs n)}\n        \\<subseteq> {..<m} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {n. enat n < llength xs \\<and> P (lnth xs n)} \\<subseteq> {..<m}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "hence \"\\<And>n. \\<lbrakk> m \\<le> n; enat n < llength xs \\<rbrakk> \\<Longrightarrow> \\<not> P (lnth xs n)\""], ["proof (prove)\nusing this:\n  {n. enat n < llength xs \\<and> P (lnth xs n)} \\<subseteq> {..<m}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> P (lnth xs n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "hence \"lfinite (lfilter P xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs)", "proof(induct m arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (\\<And>n.\n           \\<lbrakk>0 \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)) \\<Longrightarrow>\n       lfinite (lfilter P xs)\n 2. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "case 0"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (\\<And>n.\n           \\<lbrakk>0 \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)) \\<Longrightarrow>\n       lfinite (lfilter P xs)\n 2. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "hence \"lnull (lfilter P xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (1 subgoal):\n 1. lnull (lfilter P xs)", "by(auto simp add: in_lset_conv_lnth)"], ["proof (state)\nthis:\n  lnull (lfilter P xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       (\\<And>n.\n           \\<lbrakk>0 \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)) \\<Longrightarrow>\n       lfinite (lfilter P xs)\n 2. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "thus ?case"], ["proof (prove)\nusing this:\n  lnull (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs)", "by simp"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "case (Suc m)"], ["proof (state)\nthis:\n  (\\<And>n.\n      \\<lbrakk>m \\<le> n; enat n < llength ?xs\\<rbrakk>\n      \\<Longrightarrow> \\<not> P (lnth ?xs n)) \\<Longrightarrow>\n  lfinite (lfilter P ?xs)\n  \\<lbrakk>Suc m \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "{"], ["proof (state)\nthis:\n  (\\<And>n.\n      \\<lbrakk>m \\<le> n; enat n < llength ?xs\\<rbrakk>\n      \\<Longrightarrow> \\<not> P (lnth ?xs n)) \\<Longrightarrow>\n  lfinite (lfilter P ?xs)\n  \\<lbrakk>Suc m \\<le> ?n; enat ?n < llength xs\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth xs ?n)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "assume \"m \\<le> n\" \"enat n < llength (ltl xs)\""], ["proof (state)\nthis:\n  m \\<le> n\n  enat n < llength (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "hence \"Suc m \\<le> Suc n\" \"enat (Suc n) < llength xs\""], ["proof (prove)\nusing this:\n  m \\<le> n\n  enat n < llength (ltl xs)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> Suc n &&& enat (Suc n) < llength xs", "by(case_tac [!] xs)(auto simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  Suc m \\<le> Suc n\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "hence \"\\<not> P (lnth xs (Suc n))\""], ["proof (prove)\nusing this:\n  Suc m \\<le> Suc n\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. \\<not> P (lnth xs (Suc n))", "by(rule Suc)"], ["proof (state)\nthis:\n  \\<not> P (lnth xs (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "hence \"\\<not> P (lnth (ltl xs) n)\""], ["proof (prove)\nusing this:\n  \\<not> P (lnth xs (Suc n))\n\ngoal (1 subgoal):\n 1. \\<not> P (lnth (ltl xs) n)", "using \\<open>enat n < llength (ltl xs)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> P (lnth xs (Suc n))\n  enat n < llength (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<not> P (lnth (ltl xs) n)", "by(cases xs) (simp_all)"], ["proof (state)\nthis:\n  \\<not> P (lnth (ltl xs) n)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> ?n2; enat ?n2 < llength (ltl xs)\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth (ltl xs) ?n2)\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "hence \"lfinite (lfilter P (ltl xs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> ?n2; enat ?n2 < llength (ltl xs)\\<rbrakk>\n  \\<Longrightarrow> \\<not> P (lnth (ltl xs) ?n2)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P (ltl xs))", "by(rule Suc)"], ["proof (state)\nthis:\n  lfinite (lfilter P (ltl xs))\n\ngoal (1 subgoal):\n 1. \\<And>m xs.\n       \\<lbrakk>\\<And>xs.\n                   (\\<And>n.\n                       \\<lbrakk>m \\<le> n; enat n < llength xs\\<rbrakk>\n                       \\<Longrightarrow> \\<not> P\n           (lnth xs n)) \\<Longrightarrow>\n                   lfinite (lfilter P xs);\n        \\<And>n.\n           \\<lbrakk>Suc m \\<le> n; enat n < llength xs\\<rbrakk>\n           \\<Longrightarrow> \\<not> P (lnth xs n)\\<rbrakk>\n       \\<Longrightarrow> lfinite (lfilter P xs)", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite (lfilter P (ltl xs))\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs)", "by(cases xs) simp_all"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> lfinite xs;\n   finite {n. enat n < llength xs \\<and> P (lnth xs n)}\\<rbrakk>\n  \\<Longrightarrow> lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite {n. enat n < llength xs \\<and> P (lnth xs n)} \\<Longrightarrow>\n    lfinite (lfilter P xs)", "ultimately"], ["proof (chain)\npicking this:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n  lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\n  \\<lbrakk>\\<not> lfinite xs;\n   finite {n. enat n < llength xs \\<and> P (lnth xs n)}\\<rbrakk>\n  \\<Longrightarrow> lfinite (lfilter P xs)", "show \"lfinite (lfilter P xs)\""], ["proof (prove)\nusing this:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> P (lnth xs n)}\n  lfinite xs \\<Longrightarrow> lfinite (lfilter P xs)\n  \\<lbrakk>\\<not> lfinite xs;\n   finite {n. enat n < llength xs \\<and> P (lnth xs n)}\\<rbrakk>\n  \\<Longrightarrow> lfinite (lfilter P xs)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter P xs)", "by blast"], ["proof (state)\nthis:\n  lfinite (lfilter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfilter_eq_LConsD:\n  assumes \"lfilter P ys = LCons x xs\"\n  shows \"\\<exists>us vs. ys = lappend us (LCons x vs) \\<and> lfinite us \\<and>\n                      (\\<forall>u\\<in>lset us. \\<not> P u) \\<and> P x \\<and> xs = lfilter P vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "let ?us = \"ltakeWhile (Not \\<circ> P) ys\"\n    and ?vs = \"ltl (ldropWhile (Not \\<circ> P) ys)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "from assms"], ["proof (chain)\npicking this:\n  lfilter P ys = LCons x xs", "have \"\\<not> lnull (lfilter P ys)\""], ["proof (prove)\nusing this:\n  lfilter P ys = LCons x xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lfilter P ys)", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lfilter P ys)\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "hence exP: \"\\<exists>x\\<in>lset ys. P x\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lfilter P ys)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>lset ys. P x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x\\<in>lset ys. P x\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "from eq_LConsD[OF assms]"], ["proof (chain)\npicking this:\n  lfilter P ys \\<noteq> LNil \\<and>\n  lhd (lfilter P ys) = x \\<and> ltl (lfilter P ys) = xs", "have x: \"x = lhd (ldropWhile (Not \\<circ> P) ys)\"\n    and xs: \"xs = ltl (lfilter P ys)\""], ["proof (prove)\nusing this:\n  lfilter P ys \\<noteq> LNil \\<and>\n  lhd (lfilter P ys) = x \\<and> ltl (lfilter P ys) = xs\n\ngoal (1 subgoal):\n 1. x = lhd (ldropWhile (Not \\<circ> P) ys) &&& xs = ltl (lfilter P ys)", "by auto"], ["proof (state)\nthis:\n  x = lhd (ldropWhile (Not \\<circ> P) ys)\n  xs = ltl (lfilter P ys)\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "from exP"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>lset ys. P x", "have \"ys = lappend ?us (LCons x ?vs)\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset ys. P x\n\ngoal (1 subgoal):\n 1. ys =\n    lappend (ltakeWhile (Not \\<circ> P) ys)\n     (LCons x (ltl (ldropWhile (Not \\<circ> P) ys)))", "unfolding x"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset ys. P x\n\ngoal (1 subgoal):\n 1. ys =\n    lappend (ltakeWhile (Not \\<circ> P) ys)\n     (LCons (lhd (ldropWhile (Not \\<circ> P) ys))\n       (ltl (ldropWhile (Not \\<circ> P) ys)))", "by simp"], ["proof (state)\nthis:\n  ys =\n  lappend (ltakeWhile (Not \\<circ> P) ys)\n   (LCons x (ltl (ldropWhile (Not \\<circ> P) ys)))\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "moreover"], ["proof (state)\nthis:\n  ys =\n  lappend (ltakeWhile (Not \\<circ> P) ys)\n   (LCons x (ltl (ldropWhile (Not \\<circ> P) ys)))\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "have \"lfinite ?us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile (Not \\<circ> P) ys)", "using exP"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset ys. P x\n\ngoal (1 subgoal):\n 1. lfinite (ltakeWhile (Not \\<circ> P) ys)", "by(simp add: lfinite_ltakeWhile)"], ["proof (state)\nthis:\n  lfinite (ltakeWhile (Not \\<circ> P) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "moreover"], ["proof (state)\nthis:\n  lfinite (ltakeWhile (Not \\<circ> P) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "have \"\\<forall>u\\<in>lset ?us. \\<not> P u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>lset (ltakeWhile (Not \\<circ> P) ys). \\<not> P u", "by(auto dest: lset_ltakeWhileD)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>lset (ltakeWhile (Not \\<circ> P) ys). \\<not> P u\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>lset (ltakeWhile (Not \\<circ> P) ys). \\<not> P u\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "have \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "unfolding x o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (lhd (ldropWhile (\\<lambda>x. \\<not> P x) ys))", "using exP"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>lset ys. P x\n\ngoal (1 subgoal):\n 1. P (lhd (ldropWhile (\\<lambda>x. \\<not> P x) ys))", "by(rule lhd_ldropWhile[where P=\"Not \\<circ> P\", simplified])"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "moreover"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "have \"xs = lfilter P ?vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = lfilter P (ltl (ldropWhile (Not \\<circ> P) ys))", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lfilter P ys) = lfilter P (ltl (ldropWhile (Not \\<circ> P) ys))", "by(simp add: ltl_lfilter)"], ["proof (state)\nthis:\n  xs = lfilter P (ltl (ldropWhile (Not \\<circ> P) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "ultimately"], ["proof (chain)\npicking this:\n  ys =\n  lappend (ltakeWhile (Not \\<circ> P) ys)\n   (LCons x (ltl (ldropWhile (Not \\<circ> P) ys)))\n  lfinite (ltakeWhile (Not \\<circ> P) ys)\n  \\<forall>u\\<in>lset (ltakeWhile (Not \\<circ> P) ys). \\<not> P u\n  P x\n  xs = lfilter P (ltl (ldropWhile (Not \\<circ> P) ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  ys =\n  lappend (ltakeWhile (Not \\<circ> P) ys)\n   (LCons x (ltl (ldropWhile (Not \\<circ> P) ys)))\n  lfinite (ltakeWhile (Not \\<circ> P) ys)\n  \\<forall>u\\<in>lset (ltakeWhile (Not \\<circ> P) ys). \\<not> P u\n  P x\n  xs = lfilter P (ltl (ldropWhile (Not \\<circ> P) ys))\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       ys = lappend us (LCons x vs) \\<and>\n       lfinite us \\<and>\n       (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n       P x \\<and> xs = lfilter P vs", "by blast"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     ys = lappend us (LCons x vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n     P x \\<and> xs = lfilter P vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfilter_eq_lappend_lfiniteD:\n  assumes \"lfilter P xs = lappend ys zs\" and \"lfinite ys\"\n  shows \"\\<exists>us vs. xs = lappend us vs \\<and> lfinite us \\<and>\n                      ys = lfilter P us \\<and> zs = lfilter P vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = lappend us vs \\<and>\n       lfinite us \\<and> ys = lfilter P us \\<and> zs = lfilter P vs", "using \\<open>lfinite ys\\<close> \\<open>lfilter P xs = lappend ys zs\\<close>"], ["proof (prove)\nusing this:\n  lfinite ys\n  lfilter P xs = lappend ys zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = lappend us vs \\<and>\n       lfinite us \\<and> ys = lfilter P us \\<and> zs = lfilter P vs", "proof(induct arbitrary: xs zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       lfilter P xs = lappend LNil zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = lappend us vs \\<and>\n          lfinite us \\<and> LNil = lfilter P us \\<and> zs = lfilter P vs\n 2. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "case lfinite_LNil"], ["proof (state)\nthis:\n  lfilter P xs = lappend LNil zs\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       lfilter P xs = lappend LNil zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = lappend us vs \\<and>\n          lfinite us \\<and> LNil = lfilter P us \\<and> zs = lfilter P vs\n 2. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "hence \"xs = lappend LNil xs\" \"LNil = lfilter P LNil\" \"zs = lfilter P xs\""], ["proof (prove)\nusing this:\n  lfilter P xs = lappend LNil zs\n\ngoal (1 subgoal):\n 1. xs = lappend LNil xs &&& LNil = lfilter P LNil &&& zs = lfilter P xs", "by simp_all"], ["proof (state)\nthis:\n  xs = lappend LNil xs\n  LNil = lfilter P LNil\n  zs = lfilter P xs\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       lfilter P xs = lappend LNil zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = lappend us vs \\<and>\n          lfinite us \\<and> LNil = lfilter P us \\<and> zs = lfilter P vs\n 2. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "thus ?case"], ["proof (prove)\nusing this:\n  xs = lappend LNil xs\n  LNil = lfilter P LNil\n  zs = lfilter P xs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = lappend us vs \\<and>\n       lfinite us \\<and> LNil = lfilter P us \\<and> zs = lfilter P vs", "by blast"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = lappend us vs \\<and>\n     lfinite us \\<and> LNil = lfilter P us \\<and> zs = lfilter P vs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "case (lfinite_LConsI ys y)"], ["proof (state)\nthis:\n  lfinite ys\n  lfilter P ?xs = lappend ys ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     ?xs = lappend us vs \\<and>\n     lfinite us \\<and> ys = lfilter P us \\<and> ?zs = lfilter P vs\n  lfilter P xs = lappend (LCons y ys) zs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "note IH = \\<open>\\<And>xs zs. lfilter P xs = lappend ys zs \\<Longrightarrow>\n            \\<exists>us vs. xs = lappend us vs \\<and> lfinite us \\<and>\n                    ys = lfilter P us \\<and> zs = lfilter P vs\\<close>"], ["proof (state)\nthis:\n  lfilter P ?xs = lappend ys ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     ?xs = lappend us vs \\<and>\n     lfinite us \\<and> ys = lfilter P us \\<and> ?zs = lfilter P vs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "from \\<open>lfilter P xs = lappend (LCons y ys) zs\\<close>"], ["proof (chain)\npicking this:\n  lfilter P xs = lappend (LCons y ys) zs", "have \"lfilter P xs = LCons y (lappend ys zs)\""], ["proof (prove)\nusing this:\n  lfilter P xs = lappend (LCons y ys) zs\n\ngoal (1 subgoal):\n 1. lfilter P xs = LCons y (lappend ys zs)", "by simp"], ["proof (state)\nthis:\n  lfilter P xs = LCons y (lappend ys zs)\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "from lfilter_eq_LConsD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     xs = lappend us (LCons y vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n     P y \\<and> lappend ys zs = lfilter P vs", "obtain us vs\n    where xs: \"xs = lappend us (LCons y vs)\" \"lfinite us\"\n              \"P y\" \"\\<forall>u\\<in>lset us. \\<not> P u\"\n    and vs: \"lfilter P vs = lappend ys zs\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xs = lappend us (LCons y vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> P u) \\<and>\n     P y \\<and> lappend ys zs = lfilter P vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = lappend us (LCons y vs); lfinite us; P y;\n         \\<forall>u\\<in>lset us. \\<not> P u;\n         lfilter P vs = lappend ys zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = lappend us (LCons y vs)\n  lfinite us\n  P y\n  \\<forall>u\\<in>lset us. \\<not> P u\n  lfilter P vs = lappend ys zs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "from IH[OF vs]"], ["proof (chain)\npicking this:\n  \\<exists>us vsa.\n     vs = lappend us vsa \\<and>\n     lfinite us \\<and> ys = lfilter P us \\<and> zs = lfilter P vsa", "obtain us' vs' where \"vs = lappend us' vs'\" \"lfinite us'\"\n    and \"ys = lfilter P us'\" \"zs = lfilter P vs'\""], ["proof (prove)\nusing this:\n  \\<exists>us vsa.\n     vs = lappend us vsa \\<and>\n     lfinite us \\<and> ys = lfilter P us \\<and> zs = lfilter P vsa\n\ngoal (1 subgoal):\n 1. (\\<And>us' vs'.\n        \\<lbrakk>vs = lappend us' vs'; lfinite us'; ys = lfilter P us';\n         zs = lfilter P vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs = lappend us' vs'\n  lfinite us'\n  ys = lfilter P us'\n  zs = lfilter P vs'\n\ngoal (1 subgoal):\n 1. \\<And>xs x xsa zs.\n       \\<lbrakk>lfinite xs;\n        \\<And>xsa zs.\n           lfilter P xsa = lappend xs zs \\<Longrightarrow>\n           \\<exists>us vs.\n              xsa = lappend us vs \\<and>\n              lfinite us \\<and> xs = lfilter P us \\<and> zs = lfilter P vs;\n        lfilter P xsa = lappend (LCons x xs) zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = lappend us vs \\<and>\n                            lfinite us \\<and>\n                            LCons x xs = lfilter P us \\<and>\n                            zs = lfilter P vs", "with xs"], ["proof (chain)\npicking this:\n  xs = lappend us (LCons y vs)\n  lfinite us\n  P y\n  \\<forall>u\\<in>lset us. \\<not> P u\n  vs = lappend us' vs'\n  lfinite us'\n  ys = lfilter P us'\n  zs = lfilter P vs'", "show ?case"], ["proof (prove)\nusing this:\n  xs = lappend us (LCons y vs)\n  lfinite us\n  P y\n  \\<forall>u\\<in>lset us. \\<not> P u\n  vs = lappend us' vs'\n  lfinite us'\n  ys = lfilter P us'\n  zs = lfilter P vs'\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = lappend us vs \\<and>\n       lfinite us \\<and> LCons y ys = lfilter P us \\<and> zs = lfilter P vs", "by(fastforce simp add: lappend_snocL1_conv_LCons2[symmetric, where ys=\"lappend us' vs'\"]\n                           lappend_assoc[symmetric])"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = lappend us vs \\<and>\n     lfinite us \\<and> LCons y ys = lfilter P us \\<and> zs = lfilter P vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lfilterI: \"ldistinct xs \\<Longrightarrow> ldistinct (lfilter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct xs \\<Longrightarrow> ldistinct (lfilter P xs)", "by(induction xs) simp_all"], ["", "notepad begin"], ["proof (state)", "fix P xs"], ["proof (state)", "assume *: \"ldistinct xs\""], ["proof (state)\nthis:\n  ldistinct xs", "from *"], ["proof (chain)\npicking this:\n  ldistinct xs", "have \"ldistinct (lfilter P xs) \\<and> lset (lfilter P xs) \\<subseteq> lset xs\""], ["proof (prove)\nusing this:\n  ldistinct xs\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P xs) \\<and> lset (lfilter P xs) \\<subseteq> lset xs", "by(induction arbitrary: xs rule: lfilter.fixp_induct)(simp_all split: llist.split, fastforce)"], ["proof (state)\nthis:\n  ldistinct (lfilter P xs) \\<and> lset (lfilter P xs) \\<subseteq> lset xs", "from *"], ["proof (chain)\npicking this:\n  ldistinct xs", "have \"ldistinct (lfilter P xs)\"\n    \\<comment> \\<open>only works because we use strong fixpoint induction\\<close>"], ["proof (prove)\nusing this:\n  ldistinct xs\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P xs)", "by(induction arbitrary: xs rule: lfilter.fixp_induct)(simp_all split: llist.split, auto 4 4 dest: monotone_lset[THEN monotoneD] simp add: fun_ord_def)"], ["proof (state)\nthis:\n  ldistinct (lfilter P xs)", "end"], ["", "lemma ldistinct_lfilterD:\n  \"\\<lbrakk> ldistinct (lfilter P xs); enat n < llength xs; enat m < llength xs; P a; lnth xs n = a; lnth xs m = a \\<rbrakk> \\<Longrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ldistinct (lfilter P xs); enat n < llength xs;\n     enat m < llength xs; P a; lnth xs n = a; lnth xs m = a\\<rbrakk>\n    \\<Longrightarrow> m = n", "proof(induct n m rule: wlog_linorder_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<le> b; ldistinct (lfilter P xs); enat aa < llength xs;\n        enat b < llength xs; P a; lnth xs aa = a; lnth xs b = a\\<rbrakk>\n       \\<Longrightarrow> b = aa\n 2. \\<lbrakk>\\<lbrakk>ldistinct (lfilter P xs); enat m < llength xs;\n              enat n < llength xs; P a; lnth xs m = a;\n              lnth xs n = a\\<rbrakk>\n             \\<Longrightarrow> n = m;\n     ldistinct (lfilter P xs); enat n < llength xs; enat m < llength xs;\n     P a; lnth xs n = a; lnth xs m = a\\<rbrakk>\n    \\<Longrightarrow> m = n", "case symmetry"], ["proof (state)\nthis:\n  \\<lbrakk>ldistinct (lfilter P xs); enat m < llength xs;\n   enat n < llength xs; P a; lnth xs m = a; lnth xs n = a\\<rbrakk>\n  \\<Longrightarrow> n = m\n  ldistinct (lfilter P xs)\n  enat n < llength xs\n  enat m < llength xs\n  P a\n  lnth xs n = a\n  lnth xs m = a\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<le> b; ldistinct (lfilter P xs); enat aa < llength xs;\n        enat b < llength xs; P a; lnth xs aa = a; lnth xs b = a\\<rbrakk>\n       \\<Longrightarrow> b = aa\n 2. \\<lbrakk>\\<lbrakk>ldistinct (lfilter P xs); enat m < llength xs;\n              enat n < llength xs; P a; lnth xs m = a;\n              lnth xs n = a\\<rbrakk>\n             \\<Longrightarrow> n = m;\n     ldistinct (lfilter P xs); enat n < llength xs; enat m < llength xs;\n     P a; lnth xs n = a; lnth xs m = a\\<rbrakk>\n    \\<Longrightarrow> m = n", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>ldistinct (lfilter P xs); enat m < llength xs;\n   enat n < llength xs; P a; lnth xs m = a; lnth xs n = a\\<rbrakk>\n  \\<Longrightarrow> n = m\n  ldistinct (lfilter P xs)\n  enat n < llength xs\n  enat m < llength xs\n  P a\n  lnth xs n = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. m = n", "by simp"], ["proof (state)\nthis:\n  m = n\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<le> b; ldistinct (lfilter P xs); enat aa < llength xs;\n        enat b < llength xs; P a; lnth xs aa = a; lnth xs b = a\\<rbrakk>\n       \\<Longrightarrow> b = aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<le> b; ldistinct (lfilter P xs); enat aa < llength xs;\n        enat b < llength xs; P a; lnth xs aa = a; lnth xs b = a\\<rbrakk>\n       \\<Longrightarrow> b = aa", "case (le n m)"], ["proof (state)\nthis:\n  n \\<le> m\n  ldistinct (lfilter P xs)\n  enat n < llength xs\n  enat m < llength xs\n  P a\n  lnth xs n = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>aa \\<le> b; ldistinct (lfilter P xs); enat aa < llength xs;\n        enat b < llength xs; P a; lnth xs aa = a; lnth xs b = a\\<rbrakk>\n       \\<Longrightarrow> b = aa", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<le> m\n  ldistinct (lfilter P xs)\n  enat n < llength xs\n  enat m < llength xs\n  P a\n  lnth xs n = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. m = n", "proof(induct n arbitrary: xs m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs m.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = 0\n 2. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "case 0"], ["proof (state)\nthis:\n  0 \\<le> m\n  ldistinct (lfilter P xs)\n  enat 0 < llength xs\n  enat m < llength xs\n  P a\n  lnth xs 0 = a\n  lnth xs m = a\n\ngoal (2 subgoals):\n 1. \\<And>xs m.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = 0\n 2. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  ldistinct (lfilter P xs)\n  enat 0 < llength xs\n  enat m < llength xs\n  P a\n  lnth xs 0 = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. m = 0", "proof(cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n     enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a; m = 0\\<rbrakk>\n    \\<Longrightarrow> m = 0\n 2. \\<And>nat.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> m = 0", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n     enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a; m = 0\\<rbrakk>\n    \\<Longrightarrow> m = 0\n 2. \\<And>nat.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> m = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. m = 0", "."], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> m = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> m = 0", "case (Suc m')"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 \\<le> m; ldistinct (lfilter P xs); enat 0 < llength xs;\n        enat m < llength xs; P a; lnth xs 0 = a; lnth xs m = a;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> m = 0", "with 0"], ["proof (chain)\npicking this:\n  0 \\<le> m\n  ldistinct (lfilter P xs)\n  enat 0 < llength xs\n  enat m < llength xs\n  P a\n  lnth xs 0 = a\n  lnth xs m = a\n  m = Suc m'", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  ldistinct (lfilter P xs)\n  enat 0 < llength xs\n  enat m < llength xs\n  P a\n  lnth xs 0 = a\n  lnth xs m = a\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. m = 0", "by(cases xs)(simp_all add: Suc_ile_eq, auto simp add: lset_conv_lnth)"], ["proof (state)\nthis:\n  m = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m; ldistinct (lfilter P ?xs); enat n < llength ?xs;\n   enat ?m < llength ?xs; P a; lnth ?xs n = a; lnth ?xs ?m = a\\<rbrakk>\n  \\<Longrightarrow> ?m = n\n  Suc n \\<le> m\n  ldistinct (lfilter P xs)\n  enat (Suc n) < llength xs\n  enat m < llength xs\n  P a\n  lnth xs (Suc n) = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "from \\<open>Suc n \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  Suc n \\<le> m", "obtain m' where m [simp]: \"m = Suc m'\""], ["proof (prove)\nusing this:\n  Suc n \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = Suc m' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases m) simp"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "with \\<open>Suc n \\<le> m\\<close>"], ["proof (chain)\npicking this:\n  Suc n \\<le> m\n  m = Suc m'", "have \"n \\<le> m'\""], ["proof (prove)\nusing this:\n  Suc n \\<le> m\n  m = Suc m'\n\ngoal (1 subgoal):\n 1. n \\<le> m'", "by simp"], ["proof (state)\nthis:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "moreover"], ["proof (state)\nthis:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "from \\<open>enat (Suc n) < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs", "obtain x xs' where xs [simp]: \"xs = LCons x xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'.\n        xs = LCons x xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xs) simp"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "from \\<open>ldistinct (lfilter P xs)\\<close>"], ["proof (chain)\npicking this:\n  ldistinct (lfilter P xs)", "have \"ldistinct (lfilter P xs')\""], ["proof (prove)\nusing this:\n  ldistinct (lfilter P xs)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P xs')", "by(simp split: if_split_asm)"], ["proof (state)\nthis:\n  ldistinct (lfilter P xs')\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "moreover"], ["proof (state)\nthis:\n  ldistinct (lfilter P xs')\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "from \\<open>enat (Suc n) < llength xs\\<close> \\<open>enat m < llength xs\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength xs\n  enat m < llength xs", "have \"enat n < llength xs'\" \"enat m' < llength xs'\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength xs\n  enat m < llength xs\n\ngoal (1 subgoal):\n 1. enat n < llength xs' &&& enat m' < llength xs'", "by(simp_all add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat n < llength xs'\n  enat m' < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "moreover"], ["proof (state)\nthis:\n  enat n < llength xs'\n  enat m' < llength xs'\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "note \\<open>P a\\<close>"], ["proof (state)\nthis:\n  P a\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "moreover"], ["proof (state)\nthis:\n  P a\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "have \"lnth xs' n = a\" \"lnth xs' m' = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth xs' n = a &&& lnth xs' m' = a", "using \\<open>lnth xs (Suc n) = a\\<close> \\<open>lnth xs m = a\\<close>"], ["proof (prove)\nusing this:\n  lnth xs (Suc n) = a\n  lnth xs m = a\n\ngoal (1 subgoal):\n 1. lnth xs' n = a &&& lnth xs' m' = a", "by simp_all"], ["proof (state)\nthis:\n  lnth xs' n = a\n  lnth xs' m' = a\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> m'\n  ldistinct (lfilter P xs')\n  enat n < llength xs'\n  enat m' < llength xs'\n  P a\n  lnth xs' n = a\n  lnth xs' m' = a", "have \"m' = n\""], ["proof (prove)\nusing this:\n  n \\<le> m'\n  ldistinct (lfilter P xs')\n  enat n < llength xs'\n  enat m' < llength xs'\n  P a\n  lnth xs' n = a\n  lnth xs' m' = a\n\ngoal (1 subgoal):\n 1. m' = n", "by(rule Suc)"], ["proof (state)\nthis:\n  m' = n\n\ngoal (1 subgoal):\n 1. \\<And>n xs m.\n       \\<lbrakk>\\<And>xs m.\n                   \\<lbrakk>n \\<le> m; ldistinct (lfilter P xs);\n                    enat n < llength xs; enat m < llength xs; P a;\n                    lnth xs n = a; lnth xs m = a\\<rbrakk>\n                   \\<Longrightarrow> m = n;\n        Suc n \\<le> m; ldistinct (lfilter P xs); enat (Suc n) < llength xs;\n        enat m < llength xs; P a; lnth xs (Suc n) = a;\n        lnth xs m = a\\<rbrakk>\n       \\<Longrightarrow> m = Suc n", "thus ?case"], ["proof (prove)\nusing this:\n  m' = n\n\ngoal (1 subgoal):\n 1. m = Suc n", "by simp"], ["proof (state)\nthis:\n  m = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas lfilter_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    lfilter.mono lfilter.mono lfilter_def lfilter_def, case_names adm LNil step]"], ["", "lemma llist_all2_lfilterI:\n  assumes *: \"llist_all2 P xs ys\"\n  and Q: \"\\<And>x y. P x y \\<Longrightarrow> Q1 x \\<longleftrightarrow> Q2 y\"\n  shows \"llist_all2 P (lfilter Q1 xs) (lfilter Q2 ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (lfilter Q1 xs) (lfilter Q2 ys)", "using *"], ["proof (prove)\nusing this:\n  llist_all2 P xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 P (lfilter Q1 xs) (lfilter Q2 ys)", "by(induction arbitrary: xs ys rule: lfilter_fixp_parallel_induct)(auto split: llist.split dest: Q)"], ["", "lemma distinct_filterD:\n  \"\\<lbrakk> distinct (filter P xs); n < length xs; m < length xs; P x; xs ! n = x; xs ! m = x \\<rbrakk> \\<Longrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (filter P xs); n < length xs; m < length xs; P x;\n     xs ! n = x; xs ! m = x\\<rbrakk>\n    \\<Longrightarrow> m = n", "using ldistinct_lfilterD[of P \"llist_of xs\" n m x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ldistinct (lfilter P (llist_of xs));\n   enat n < llength (llist_of xs); enat m < llength (llist_of xs); P x;\n   lnth (llist_of xs) n = x; lnth (llist_of xs) m = x\\<rbrakk>\n  \\<Longrightarrow> m = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (filter P xs); n < length xs; m < length xs; P x;\n     xs ! n = x; xs ! m = x\\<rbrakk>\n    \\<Longrightarrow> m = n", "by simp"], ["", "lemma lprefix_lfilterI:\n  \"xs \\<sqsubseteq> ys \\<Longrightarrow> lfilter P xs \\<sqsubseteq> lfilter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<sqsubseteq> ys \\<Longrightarrow>\n    lfilter P xs \\<sqsubseteq> lfilter P ys", "by(rule monotoneD[OF monotone_lfilter])"], ["", "context preorder begin"], ["", "lemma lsorted_lfilterI:\n  \"lsorted xs \\<Longrightarrow> lsorted (lfilter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted xs \\<Longrightarrow> lsorted (lfilter P xs)", "by(induct xs)(simp_all add: lsorted_LCons)"], ["", "lemma lsorted_lfilter_same:\n  \"lsorted (lfilter (\\<lambda>x. x = c) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsorted (lfilter (\\<lambda>x. x = c) xs)", "by(induct xs)(auto simp add: lsorted_LCons)"], ["", "end"], ["", "lemma lfilter_id_conv: \"lfilter P xs = xs \\<longleftrightarrow> (\\<forall>x\\<in>lset xs. P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lfilter P xs = xs) = (\\<forall>x\\<in>lset xs. P x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfilter P xs = xs \\<Longrightarrow> \\<forall>x\\<in>lset xs. P x\n 2. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lfilter P xs = xs", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>x\\<in>lset xs. P x\n\ngoal (2 subgoals):\n 1. lfilter P xs = xs \\<Longrightarrow> \\<forall>x\\<in>lset xs. P x\n 2. \\<forall>x\\<in>lset xs. P x \\<Longrightarrow> lfilter P xs = xs", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>lset xs. P x\n\ngoal (1 subgoal):\n 1. lfilter P xs = xs", "by(induct xs) auto"], ["proof (state)\nthis:\n  lfilter P xs = xs\n\ngoal (1 subgoal):\n 1. lfilter P xs = xs \\<Longrightarrow> \\<forall>x\\<in>lset xs. P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfilter P xs = xs \\<Longrightarrow> \\<forall>x\\<in>lset xs. P x", "assume ?lhs"], ["proof (state)\nthis:\n  lfilter P xs = xs\n\ngoal (1 subgoal):\n 1. lfilter P xs = xs \\<Longrightarrow> \\<forall>x\\<in>lset xs. P x", "with lset_lfilter[of P xs]"], ["proof (chain)\npicking this:\n  lset (lfilter P xs) = {x \\<in> lset xs. P x}\n  lfilter P xs = xs", "show ?rhs"], ["proof (prove)\nusing this:\n  lset (lfilter P xs) = {x \\<in> lset xs. P x}\n  lfilter P xs = xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lset xs. P x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>lset xs. P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfilter_repeat [simp]: \"lfilter P (repeat x) = (if P x then repeat x else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (repeat x) = (if P x then repeat x else LNil)", "by(simp add: lfilter_id_conv)"], ["", "subsection \\<open>Concatenating all lazy lists in a lazy list: @{term \"lconcat\"}\\<close>"], ["", "lemma lconcat_simps [simp, code]:\n  shows lconcat_LNil: \"lconcat LNil = LNil\"\n  and lconcat_LCons: \"lconcat (LCons xs xss) = lappend xs (lconcat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat LNil = LNil &&&\n    lconcat (LCons xs xss) = lappend xs (lconcat xss)", "by(simp_all add: lconcat.simps)"], ["", "declare lconcat.mono[cont_intro]"], ["", "lemma mono2mono_lconcat[THEN llist.mono2mono, cont_intro, simp]:\n  shows monotone_lconcat: \"monotone (\\<sqsubseteq>) (\\<sqsubseteq>) lconcat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (\\<sqsubseteq>) (\\<sqsubseteq>) lconcat", "by(rule llist.fixp_preserves_mono1[OF lconcat.mono lconcat_def]) simp"], ["", "lemma mcont2mcont_lconcat[THEN llist.mcont2mcont, cont_intro, simp]:\n  shows mcont_lconcat: \"mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) lconcat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lSup (\\<sqsubseteq>) lSup (\\<sqsubseteq>) lconcat", "by(rule llist.fixp_preserves_mcont1[OF lconcat.mono lconcat_def]) simp"], ["", "lemma lconcat_eq_LNil: \"lconcat xss = LNil \\<longleftrightarrow> lset xss \\<subseteq> {LNil}\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lconcat xss = LNil) = (lset xss \\<subseteq> {LNil})", "by(induction xss)(auto simp add: lappend_eq_LNil_iff)"], ["", "lemma lnull_lconcat [simp]: \"lnull (lconcat xss) \\<longleftrightarrow> lset xss \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (lconcat xss) = (lset xss \\<subseteq> {xs. lnull xs})", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lconcat xss = LNil) = (lset xss \\<subseteq> {xs. xs = LNil})", "by(simp add: lconcat_eq_LNil)"], ["", "lemma lconcat_llist_of:\n  \"lconcat (llist_of (map llist_of xs)) = llist_of (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (llist_of (map llist_of xs)) = llist_of (concat xs)", "by(induct xs)(simp_all add: lappend_llist_of_llist_of)"], ["", "lemma lhd_lconcat [simp]:\n  \"\\<lbrakk> \\<not> lnull xss; \\<not> lnull (lhd xss) \\<rbrakk> \\<Longrightarrow> lhd (lconcat xss) = lhd (lhd xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull xss; \\<not> lnull (lhd xss)\\<rbrakk>\n    \\<Longrightarrow> lhd (lconcat xss) = lhd (lhd xss)", "by(clarsimp simp add: not_lnull_conv)"], ["", "lemma ltl_lconcat [simp]:\n  \"\\<lbrakk> \\<not> lnull xss; \\<not> lnull (lhd xss) \\<rbrakk> \\<Longrightarrow> ltl (lconcat xss) = lappend (ltl (lhd xss)) (lconcat (ltl xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lnull xss; \\<not> lnull (lhd xss)\\<rbrakk>\n    \\<Longrightarrow> ltl (lconcat xss) =\n                      lappend (ltl (lhd xss)) (lconcat (ltl xss))", "by(clarsimp simp add: not_lnull_conv)"], ["", "lemma lmap_lconcat:\n  \"lmap f (lconcat xss) = lconcat (lmap (lmap f) xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (lconcat xss) = lconcat (lmap (lmap f) xss)", "by(induct xss)(simp_all add: lmap_lappend_distrib)"], ["", "lemma lconcat_lappend [simp]:\n  assumes \"lfinite xss\"\n  shows \"lconcat (lappend xss yss) = lappend (lconcat xss) (lconcat yss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (lappend xss yss) = lappend (lconcat xss) (lconcat yss)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xss\n\ngoal (1 subgoal):\n 1. lconcat (lappend xss yss) = lappend (lconcat xss) (lconcat yss)", "by induct (simp_all add: lappend_assoc)"], ["", "lemma lconcat_eq_LCons_conv:\n  \"lconcat xss = LCons x xs \\<longleftrightarrow>\n  (\\<exists>xs' xss' xss''. xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n                    xs = lappend xs' (lconcat xss'') \\<and> set xss' \\<subseteq> {xs. lnull xs})\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lconcat xss = LCons x xs) =\n    (\\<exists>xs' xss' xss''.\n        xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n        xs = lappend xs' (lconcat xss'') \\<and>\n        set xss' \\<subseteq> {xs. lnull xs})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}\n 2. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs} \\<Longrightarrow>\n    lconcat xss = LCons x xs", "assume \"?rhs\""], ["proof (state)\nthis:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (2 subgoals):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}\n 2. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs} \\<Longrightarrow>\n    lconcat xss = LCons x xs", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> {xs. lnull xs}", "obtain xs' xss' xss''\n    where \"xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\"\n    and \"xs = lappend xs' (lconcat xss'')\"\n    and \"set xss' \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (2 subgoals):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}\n 2. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs} \\<Longrightarrow>\n    lconcat xss = LCons x xs", "moreover"], ["proof (state)\nthis:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (2 subgoals):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}\n 2. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs} \\<Longrightarrow>\n    lconcat xss = LCons x xs", "from \\<open>set xss' \\<subseteq> {xs. lnull xs}\\<close>"], ["proof (chain)\npicking this:\n  set xss' \\<subseteq> {xs. lnull xs}", "have \"lnull (lconcat (llist_of xss'))\""], ["proof (prove)\nusing this:\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lnull (lconcat (llist_of xss'))", "by simp"], ["proof (state)\nthis:\n  lnull (lconcat (llist_of xss'))\n\ngoal (2 subgoals):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}\n 2. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs} \\<Longrightarrow>\n    lconcat xss = LCons x xs", "ultimately"], ["proof (chain)\npicking this:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n  lnull (lconcat (llist_of xss'))", "show ?lhs"], ["proof (prove)\nusing this:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n  lnull (lconcat (llist_of xss'))\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs", "by(simp add: lappend_lnull1)"], ["proof (state)\nthis:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "assume \"?lhs\""], ["proof (state)\nthis:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "hence \"\\<not> lnull (lconcat xss)\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lconcat xss)", "by simp"], ["proof (state)\nthis:\n  \\<not> lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "hence \"\\<not> lset xss \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<not> lset xss \\<subseteq> {xs. lnull xs}", "by simp"], ["proof (state)\nthis:\n  \\<not> lset xss \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "hence \"\\<not> lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\""], ["proof (prove)\nusing this:\n  \\<not> lset xss \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)", "by(auto)"], ["proof (state)\nthis:\n  \\<not> lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "then"], ["proof (chain)\npicking this:\n  \\<not> lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)", "obtain y ys where yys: \"lfilter (\\<lambda>xs. \\<not> lnull xs) xss = LCons y ys\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        lfilter (\\<lambda>xs. \\<not> lnull xs) xss =\n        LCons y ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding not_lnull_conv"], ["proof (prove)\nusing this:\n  \\<exists>x xs'.\n     lfilter (\\<lambda>xs. \\<exists>x xs'. xs = LCons x xs') xss =\n     LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        lfilter (\\<lambda>xs. \\<exists>x xs'. xs = LCons x xs') xss =\n        LCons y ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lfilter (\\<lambda>xs. \\<not> lnull xs) xss = LCons y ys\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from lfilter_eq_LConsD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     xss = lappend us (LCons y vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> \\<not> lnull u) \\<and>\n     \\<not> lnull y \\<and> ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs", "obtain us vs where xss: \"xss = lappend us (LCons y vs)\"\n    and \"lfinite us\"\n    and \"lset us \\<subseteq> {xs. lnull xs}\" \"\\<not> lnull y\"\n    and ys: \"ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xss = lappend us (LCons y vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> \\<not> lnull u) \\<and>\n     \\<not> lnull y \\<and> ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xss = lappend us (LCons y vs); lfinite us;\n         lset us \\<subseteq> {xs. lnull xs}; \\<not> lnull y;\n         ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend us (LCons y vs)\n  lfinite us\n  lset us \\<subseteq> {xs. lnull xs}\n  \\<not> lnull y\n  ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from \\<open>lfinite us\\<close>"], ["proof (chain)\npicking this:\n  lfinite us", "obtain us' where [simp]: \"us = llist_of us'\""], ["proof (prove)\nusing this:\n  lfinite us\n\ngoal (1 subgoal):\n 1. (\\<And>us'.\n        us = llist_of us' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  us \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>us'.\n        us = llist_of us' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  us = llist_of us'\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from \\<open>lset us \\<subseteq> {xs. lnull xs}\\<close>"], ["proof (chain)\npicking this:\n  lset us \\<subseteq> {xs. lnull xs}", "have us: \"lnull (lconcat us)\""], ["proof (prove)\nusing this:\n  lset us \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lnull (lconcat us)", "unfolding lnull_lconcat"], ["proof (prove)\nusing this:\n  lset us \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lset us \\<subseteq> Collect lnull", "."], ["proof (state)\nthis:\n  lnull (lconcat us)\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from \\<open>\\<not> lnull y\\<close>"], ["proof (chain)\npicking this:\n  \\<not> lnull y", "obtain y' ys' where y: \"y = LCons y' ys'\""], ["proof (prove)\nusing this:\n  \\<not> lnull y\n\ngoal (1 subgoal):\n 1. (\\<And>y' ys'.\n        y = LCons y' ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding not_lnull_conv"], ["proof (prove)\nusing this:\n  \\<exists>x xs'. y = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>y' ys'.\n        y = LCons y' ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = LCons y' ys'\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from \\<open>?lhs\\<close> us"], ["proof (chain)\npicking this:\n  lconcat xss = LCons x xs\n  lnull (lconcat us)", "have [simp]: \"y' = x\" \"xs = lappend ys' (lconcat vs)\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n  lnull (lconcat us)\n\ngoal (1 subgoal):\n 1. y' = x &&& xs = lappend ys' (lconcat vs)", "unfolding xss y"], ["proof (prove)\nusing this:\n  lconcat (lappend us (LCons (LCons y' ys') vs)) = LCons x xs\n  lnull (lconcat us)\n\ngoal (1 subgoal):\n 1. y' = x &&& xs = lappend ys' (lconcat vs)", "by(simp_all add: lappend_lnull1)"], ["proof (state)\nthis:\n  y' = x\n  xs = lappend ys' (lconcat vs)\n\ngoal (1 subgoal):\n 1. lconcat xss = LCons x xs \\<Longrightarrow>\n    \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "from \\<open>lset us \\<subseteq> {xs. lnull xs}\\<close> ys"], ["proof (chain)\npicking this:\n  lset us \\<subseteq> {xs. lnull xs}\n  ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs", "show ?rhs"], ["proof (prove)\nusing this:\n  lset us \\<subseteq> {xs. lnull xs}\n  ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xss' xss''.\n       xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "unfolding xss y"], ["proof (prove)\nusing this:\n  lset us \\<subseteq> {xs. lnull xs}\n  ys = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xss' xss''.\n       lappend us (LCons (LCons y' ys') vs) =\n       lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n       xs = lappend xs' (lconcat xss'') \\<and>\n       set xss' \\<subseteq> {xs. lnull xs}", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> {xs. lnull xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llength_lconcat_lfinite_conv_sum:\n  assumes \"lfinite xss\"\n  shows \"llength (lconcat xss) = (\\<Sum>i | enat i < llength xss. llength (lnth xss i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lconcat xss) =\n    (\\<Sum>i | enat i < llength xss. llength (lnth xss i))", "using assms"], ["proof (prove)\nusing this:\n  lfinite xss\n\ngoal (1 subgoal):\n 1. llength (lconcat xss) =\n    (\\<Sum>i | enat i < llength xss. llength (lnth xss i))", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. llength (lconcat LNil) =\n    (\\<Sum>i | enat i < llength LNil. llength (lnth LNil i))\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "case lfinite_LNil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. llength (lconcat LNil) =\n    (\\<Sum>i | enat i < llength LNil. llength (lnth LNil i))\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lconcat LNil) =\n    (\\<Sum>i | enat i < llength LNil. llength (lnth LNil i))", "by simp"], ["proof (state)\nthis:\n  llength (lconcat LNil) =\n  (\\<Sum>i | enat i < llength LNil. llength (lnth LNil i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "case (lfinite_LConsI xss xs)"], ["proof (state)\nthis:\n  lfinite xss\n  llength (lconcat xss) =\n  (\\<Sum>i | enat i < llength xss. llength (lnth xss i))\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "have \"{i. enat i \\<le> llength xss} = insert 0 {Suc i|i. enat i < llength xss}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. enat i \\<le> llength xss} =\n    insert 0 {Suc i |i. enat i < llength xss}", "by(auto simp add: zero_enat_def[symmetric] Suc_ile_eq gr0_conv_Suc)"], ["proof (state)\nthis:\n  {i. enat i \\<le> llength xss} = insert 0 {Suc i |i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "also"], ["proof (state)\nthis:\n  {i. enat i \\<le> llength xss} = insert 0 {Suc i |i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "have \"\\<dots> = insert 0 (Suc ` {i. enat i < llength xss})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert 0 {Suc i |i. enat i < llength xss} =\n    insert 0 (Suc ` {i. enat i < llength xss})", "by auto"], ["proof (state)\nthis:\n  insert 0 {Suc i |i. enat i < llength xss} =\n  insert 0 (Suc ` {i. enat i < llength xss})\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "also"], ["proof (state)\nthis:\n  insert 0 {Suc i |i. enat i < llength xss} =\n  insert 0 (Suc ` {i. enat i < llength xss})\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "have \"0 \\<notin> Suc ` {i. enat i < llength xss}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> Suc ` {i. enat i < llength xss}", "by auto"], ["proof (state)\nthis:\n  0 \\<notin> Suc ` {i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "moreover"], ["proof (state)\nthis:\n  0 \\<notin> Suc ` {i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "from \\<open>lfinite xss\\<close>"], ["proof (chain)\npicking this:\n  lfinite xss", "have \"finite {i. enat i < llength xss}\""], ["proof (prove)\nusing this:\n  lfinite xss\n\ngoal (1 subgoal):\n 1. finite {i. enat i < llength xss}", "by(rule lfinite_finite_index)"], ["proof (state)\nthis:\n  finite {i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        llength (lconcat xs) =\n        (\\<Sum>i | enat i < llength xs. llength (lnth xs i))\\<rbrakk>\n       \\<Longrightarrow> llength (lconcat (LCons x xs)) =\n                         (\\<Sum>i | enat i < llength (LCons x xs).\n                            llength (lnth (LCons x xs) i))", "ultimately"], ["proof (chain)\npicking this:\n  {i. enat i \\<le> llength xss} = insert 0 (Suc ` {i. enat i < llength xss})\n  0 \\<notin> Suc ` {i. enat i < llength xss}\n  finite {i. enat i < llength xss}", "show ?case"], ["proof (prove)\nusing this:\n  {i. enat i \\<le> llength xss} = insert 0 (Suc ` {i. enat i < llength xss})\n  0 \\<notin> Suc ` {i. enat i < llength xss}\n  finite {i. enat i < llength xss}\n\ngoal (1 subgoal):\n 1. llength (lconcat (LCons xs xss)) =\n    (\\<Sum>i | enat i < llength (LCons xs xss).\n       llength (lnth (LCons xs xss) i))", "using lfinite_LConsI"], ["proof (prove)\nusing this:\n  {i. enat i \\<le> llength xss} = insert 0 (Suc ` {i. enat i < llength xss})\n  0 \\<notin> Suc ` {i. enat i < llength xss}\n  finite {i. enat i < llength xss}\n  lfinite xss\n  llength (lconcat xss) =\n  (\\<Sum>i | enat i < llength xss. llength (lnth xss i))\n\ngoal (1 subgoal):\n 1. llength (lconcat (LCons xs xss)) =\n    (\\<Sum>i | enat i < llength (LCons xs xss).\n       llength (lnth (LCons xs xss) i))", "by(simp add: sum.reindex)"], ["proof (state)\nthis:\n  llength (lconcat (LCons xs xss)) =\n  (\\<Sum>i | enat i < llength (LCons xs xss).\n     llength (lnth (LCons xs xss) i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lconcat_lfilter_neq_LNil:\n  \"lconcat (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) = lconcat xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) = lconcat xss", "by(induct xss)(simp_all add: lappend_lnull1)"], ["", "lemmas lconcat_fixp_parallel_induct =\n  parallel_fixp_induct_1_1[OF llist_partial_function_definitions llist_partial_function_definitions\n    lconcat.mono lconcat.mono lconcat_def lconcat_def, case_names adm LNil step]"], ["", "lemma llist_all2_lconcatI:\n  \"llist_all2 (llist_all2 A) xss yss\n  \\<Longrightarrow> llist_all2 A (lconcat xss) (lconcat yss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (llist_all2 A) xss yss \\<Longrightarrow>\n    llist_all2 A (lconcat xss) (lconcat yss)", "by(induct arbitrary: xss yss rule: lconcat_fixp_parallel_induct)(auto split: llist.split intro: llist_all2_lappendI)"], ["", "lemma llength_lconcat_eqI:\n  fixes xss :: \"'a llist llist\" and yss :: \"'b llist llist\"\n  assumes \"llist_all2 (\\<lambda>xs ys. llength xs = llength ys) xss yss\"\n  shows \"llength (lconcat xss) = llength (lconcat yss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lconcat xss) = llength (lconcat yss)", "apply(rule llist_all2_llengthD[where P=\"\\<lambda>_ _. True\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>_ _. True) (lconcat xss) (lconcat yss)", "apply(rule llist_all2_lconcatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (llist_all2 (\\<lambda>_ _. True)) xss yss", "apply(simp add: llist_all2_True[abs_def] assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lset_lconcat_lfinite:\n  \"\\<forall>xs \\<in> lset xss. lfinite xs \\<Longrightarrow> lset (lconcat xss) = (\\<Union>xs\\<in>lset xss. lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>lset xss. lfinite xs \\<Longrightarrow>\n    lset (lconcat xss) = \\<Union> (lset ` lset xss)", "by(induction xss) auto"], ["", "lemma lconcat_ltake:\n  \"lconcat (ltake (enat n) xss) = ltake (\\<Sum>i<n. llength (lnth xss i)) (lconcat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (ltake (enat n) xss) =\n    ltake (\\<Sum>i<n. llength (lnth xss i)) (lconcat xss)", "proof(induct n arbitrary: xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xss.\n       lconcat (ltake (enat 0) xss) =\n       ltake (\\<Sum>i<0. llength (lnth xss i)) (lconcat xss)\n 2. \\<And>n xss.\n       (\\<And>xss.\n           lconcat (ltake (enat n) xss) =\n           ltake (\\<Sum>i<n. llength (lnth xss i))\n            (lconcat xss)) \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       lconcat (ltake (enat 0) xss) =\n       ltake (\\<Sum>i<0. llength (lnth xss i)) (lconcat xss)\n 2. \\<And>n xss.\n       (\\<And>xss.\n           lconcat (ltake (enat n) xss) =\n           ltake (\\<Sum>i<n. llength (lnth xss i))\n            (lconcat xss)) \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (ltake (enat 0) xss) =\n    ltake (\\<Sum>i<0. llength (lnth xss i)) (lconcat xss)", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  lconcat (ltake (enat 0) xss) =\n  ltake (\\<Sum>i<0. llength (lnth xss i)) (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       (\\<And>xss.\n           lconcat (ltake (enat n) xss) =\n           ltake (\\<Sum>i<n. llength (lnth xss i))\n            (lconcat xss)) \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       (\\<And>xss.\n           lconcat (ltake (enat n) xss) =\n           ltake (\\<Sum>i<n. llength (lnth xss i))\n            (lconcat xss)) \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "case (Suc n)"], ["proof (state)\nthis:\n  lconcat (ltake (enat n) ?xss) =\n  ltake (\\<Sum>i<n. llength (lnth ?xss i)) (lconcat ?xss)\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       (\\<And>xss.\n           lconcat (ltake (enat n) xss) =\n           ltake (\\<Sum>i<n. llength (lnth xss i))\n            (lconcat xss)) \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "proof(cases xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. xss = LNil \\<Longrightarrow>\n    lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)\n 2. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "case LNil"], ["proof (state)\nthis:\n  xss = LNil\n\ngoal (2 subgoals):\n 1. xss = LNil \\<Longrightarrow>\n    lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)\n 2. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "thus ?thesis"], ["proof (prove)\nusing this:\n  xss = LNil\n\ngoal (1 subgoal):\n 1. lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "by simp"], ["proof (state)\nthis:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "case (LCons xs xss')"], ["proof (state)\nthis:\n  xss = LCons xs xss'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "hence \"lconcat (ltake (enat (Suc n)) xss) = lappend xs (lconcat (ltake (enat n) xss'))\""], ["proof (prove)\nusing this:\n  xss = LCons xs xss'\n\ngoal (1 subgoal):\n 1. lconcat (ltake (enat (Suc n)) xss) =\n    lappend xs (lconcat (ltake (enat n) xss'))", "by(simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  lconcat (ltake (enat (Suc n)) xss) =\n  lappend xs (lconcat (ltake (enat n) xss'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "also"], ["proof (state)\nthis:\n  lconcat (ltake (enat (Suc n)) xss) =\n  lappend xs (lconcat (ltake (enat n) xss'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "have \"lconcat (ltake (enat n) xss') = ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (ltake (enat n) xss') =\n    ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')", "by(rule Suc)"], ["proof (state)\nthis:\n  lconcat (ltake (enat n) xss') =\n  ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "also"], ["proof (state)\nthis:\n  lconcat (ltake (enat n) xss') =\n  ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "have \"lappend xs \\<dots> = ltake (llength xs + (\\<Sum>i<n. llength (lnth xss' i))) (lappend xs (lconcat xss'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend xs (ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')) =\n    ltake (llength xs + (\\<Sum>i<n. llength (lnth xss' i)))\n     (lappend xs (lconcat xss'))", "by(cases \"llength xs\")(simp_all add: ltake_plus_conv_lappend ltake_lappend1 ltake_all ldropn_lappend2 lappend_inf lfinite_conv_llength_enat ldrop_enat)"], ["proof (state)\nthis:\n  lappend xs (ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')) =\n  ltake (llength xs + (\\<Sum>i<n. llength (lnth xss' i)))\n   (lappend xs (lconcat xss'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "also"], ["proof (state)\nthis:\n  lappend xs (ltake (\\<Sum>i<n. llength (lnth xss' i)) (lconcat xss')) =\n  ltake (llength xs + (\\<Sum>i<n. llength (lnth xss' i)))\n   (lappend xs (lconcat xss'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "have \"(\\<Sum>i<n. llength (lnth xss' i)) = (\\<Sum>i=1..<Suc n. llength (lnth xss i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. llength (lnth xss' i)) =\n    (\\<Sum>i = 1..<Suc n. llength (lnth xss i))", "by (rule sum.reindex_cong [symmetric, of Suc])\n        (auto simp add: LCons image_iff less_Suc_eq_0_disj)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. llength (lnth xss' i)) =\n  (\\<Sum>i = 1..<Suc n. llength (lnth xss i))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. llength (lnth xss' i)) =\n  (\\<Sum>i = 1..<Suc n. llength (lnth xss i))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "have \"llength xs + \\<dots> = (\\<Sum>i<Suc n. llength (lnth xss i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs + (\\<Sum>i = 1..<Suc n. llength (lnth xss i)) =\n    (\\<Sum>i<Suc n. llength (lnth xss i))", "unfolding atLeast0LessThan[symmetric] LCons"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength xs + (\\<Sum>i = 1..<Suc n. llength (lnth (LCons xs xss') i)) =\n    (\\<Sum>i = 0..<Suc n. llength (lnth (LCons xs xss') i))", "by(subst (2) sum.atLeast_Suc_lessThan) simp_all"], ["proof (state)\nthis:\n  llength xs + (\\<Sum>i = 1..<Suc n. llength (lnth xss i)) =\n  (\\<Sum>i<Suc n. llength (lnth xss i))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       xss = LCons x21 x22 \\<Longrightarrow>\n       lconcat (ltake (enat (Suc n)) xss) =\n       ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "finally"], ["proof (chain)\npicking this:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lappend xs (lconcat xss'))", "show ?thesis"], ["proof (prove)\nusing this:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lappend xs (lconcat xss'))\n\ngoal (1 subgoal):\n 1. lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "using LCons"], ["proof (prove)\nusing this:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lappend xs (lconcat xss'))\n  xss = LCons xs xss'\n\ngoal (1 subgoal):\n 1. lconcat (ltake (enat (Suc n)) xss) =\n    ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)", "by simp"], ["proof (state)\nthis:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lconcat (ltake (enat (Suc n)) xss) =\n  ltake (\\<Sum>i<Suc n. llength (lnth xss i)) (lconcat xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_lconcat_conv:\n  assumes \"enat n < llength (lconcat xss)\"\n  shows \"\\<exists>m n'. lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and> enat n' < llength (lnth xss m) \\<and>\n                enat m < llength xss \\<and> enat n = (\\<Sum>i<m . llength (lnth xss i)) + enat n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "using assms"], ["proof (prove)\nusing this:\n  enat n < llength (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "proof(induct n arbitrary: xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength (lconcat xss)\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"\\<not> lnull (lconcat xss)\""], ["proof (prove)\nusing this:\n  enat 0 < llength (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lconcat xss)", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lconcat xss)\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  \\<not> lnull (lconcat xss)", "obtain x xs where concat_xss: \"lconcat xss = LCons x xs\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        lconcat xss = LCons x xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding not_lnull_conv"], ["proof (prove)\nusing this:\n  \\<exists>x xs'. lconcat xss = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        lconcat xss = LCons x xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lconcat xss = LCons x xs\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  lconcat xss = LCons x xs", "obtain xs' xss' xss''\n    where xss: \"xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\"\n    and xs: \"xs = lappend xs' (lconcat xss'')\"\n    and LNil: \"set xss' \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lconcat_eq_LCons_conv"], ["proof (prove)\nusing this:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> Collect lnull\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from LNil"], ["proof (chain)\npicking this:\n  set xss' \\<subseteq> {xs. lnull xs}", "have \"lnull (lconcat (llist_of xss'))\""], ["proof (prove)\nusing this:\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lnull (lconcat (llist_of xss'))", "by simp"], ["proof (state)\nthis:\n  lnull (lconcat (llist_of xss'))\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  lnull (lconcat (llist_of xss'))\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have [simp]: \"lnth xss (length xss') = LCons x xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth xss (length xss') = LCons x xs'", "unfolding xss"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n     (length xss') =\n    LCons x xs'", "by(simp add: lnth_lappend2)"], ["proof (state)\nthis:\n  lnth xss (length xss') = LCons x xs'\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "ultimately"], ["proof (chain)\npicking this:\n  lnull (lconcat (llist_of xss'))\n  lnth xss (length xss') = LCons x xs'", "have \"lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0\""], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  lnth xss (length xss') = LCons x xs'\n\ngoal (1 subgoal):\n 1. lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0", "using concat_xss xss"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  lnth xss (length xss') = LCons x xs'\n  lconcat xss = LCons x xs\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n\ngoal (1 subgoal):\n 1. lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0", "by(simp)"], ["proof (state)\nthis:\n  lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat 0 < llength (lnth xss (length xss'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat 0 < llength (lnth xss (length xss'))", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  enat 0 < llength (lnth xss (length xss'))\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat 0 < llength (lnth xss (length xss'))\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat (length xss') < llength xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length xss') < llength xss", "unfolding xss"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length xss')\n    < llength (lappend (llist_of xss') (LCons (LCons x xs') xss''))", "by simp"], ["proof (state)\nthis:\n  enat (length xss') < llength xss\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat (length xss') < llength xss\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"(\\<Sum>i < length xss'. llength (lnth xss i)) = (\\<Sum>i < length xss'. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xss'. llength (lnth xss i)) = (\\<Sum>i<length xss'. 0)", "proof(rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..<length xss'} = {..<length xss'}\n 2. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "show \"{..< length xss'} = {..< length xss'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<length xss'} = {..<length xss'}", "by simp"], ["proof (state)\nthis:\n  {..<length xss'} = {..<length xss'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "assume \"i \\<in> {..< length xss'}\""], ["proof (state)\nthis:\n  i \\<in> {..<length xss'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "hence \"xss' ! i \\<in> set xss'\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length xss'}\n\ngoal (1 subgoal):\n 1. xss' ! i \\<in> set xss'", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  i \\<in> {..<length xss'}\n\ngoal (1 subgoal):\n 1. \\<exists>ia<length xss'. xss' ! ia = xss' ! i", "by blast"], ["proof (state)\nthis:\n  xss' ! i \\<in> set xss'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "with LNil"], ["proof (chain)\npicking this:\n  set xss' \\<subseteq> {xs. lnull xs}\n  xss' ! i \\<in> set xss'", "have \"xss' ! i = LNil\""], ["proof (prove)\nusing this:\n  set xss' \\<subseteq> {xs. lnull xs}\n  xss' ! i \\<in> set xss'\n\ngoal (1 subgoal):\n 1. xss' ! i = LNil", "by auto"], ["proof (state)\nthis:\n  xss' ! i = LNil\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "moreover"], ["proof (state)\nthis:\n  xss' ! i = LNil\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "from \\<open>i \\<in> {..< length xss'}\\<close>"], ["proof (chain)\npicking this:\n  i \\<in> {..<length xss'}", "have \"lnth xss i = xss' ! i\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length xss'}\n\ngoal (1 subgoal):\n 1. lnth xss i = xss' ! i", "unfolding xss"], ["proof (prove)\nusing this:\n  i \\<in> {..<length xss'}\n\ngoal (1 subgoal):\n 1. lnth (lappend (llist_of xss') (LCons (LCons x xs') xss'')) i = xss' ! i", "by(simp add: lnth_lappend1)"], ["proof (state)\nthis:\n  lnth xss i = xss' ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xss'} \\<Longrightarrow> llength (lnth xss x) = 0", "ultimately"], ["proof (chain)\npicking this:\n  xss' ! i = LNil\n  lnth xss i = xss' ! i", "show \"llength (lnth xss i) = 0\""], ["proof (prove)\nusing this:\n  xss' ! i = LNil\n  lnth xss i = xss' ! i\n\ngoal (1 subgoal):\n 1. llength (lnth xss i) = 0", "by simp"], ["proof (state)\nthis:\n  llength (lnth xss i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = (\\<Sum>i<length xss'. 0)\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"enat 0 = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = (\\<Sum>i<length xss'. 0)\n\ngoal (1 subgoal):\n 1. enat 0 = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat 0", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  enat 0 = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat 0\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       enat 0 < llength (lconcat xss) \\<Longrightarrow>\n       \\<exists>m n'.\n          lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n          enat n' < llength (lnth xss m) \\<and>\n          enat m < llength xss \\<and>\n          enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "ultimately"], ["proof (chain)\npicking this:\n  lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0\n  enat 0 < llength (lnth xss (length xss'))\n  enat (length xss') < llength xss\n  enat 0 = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat 0", "show ?case"], ["proof (prove)\nusing this:\n  lnth (lconcat xss) 0 = lnth (lnth xss (length xss')) 0\n  enat 0 < llength (lnth xss (length xss'))\n  enat (length xss') < llength xss\n  enat 0 = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat 0\n\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>m n'.\n     lnth (lconcat xss) 0 = lnth (lnth xss m) n' \\<and>\n     enat n' < llength (lnth xss m) \\<and>\n     enat m < llength xss \\<and>\n     enat 0 = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "case (Suc n)"], ["proof (state)\nthis:\n  enat n < llength (lconcat ?xss) \\<Longrightarrow>\n  \\<exists>m n'.\n     lnth (lconcat ?xss) n = lnth (lnth ?xss m) n' \\<and>\n     enat n' < llength (lnth ?xss m) \\<and>\n     enat m < llength ?xss \\<and>\n     enat n = (\\<Sum>i<m. llength (lnth ?xss i)) + enat n'\n  enat (Suc n) < llength (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from \\<open>enat (Suc n) < llength (lconcat xss)\\<close>"], ["proof (chain)\npicking this:\n  enat (Suc n) < llength (lconcat xss)", "have \"\\<not> lnull (lconcat xss)\""], ["proof (prove)\nusing this:\n  enat (Suc n) < llength (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lconcat xss)", "by auto"], ["proof (state)\nthis:\n  \\<not> lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  \\<not> lnull (lconcat xss)", "obtain x xs where concat_xss: \"lconcat xss = LCons x xs\""], ["proof (prove)\nusing this:\n  \\<not> lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        lconcat xss = LCons x xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding not_lnull_conv"], ["proof (prove)\nusing this:\n  \\<exists>x xs'. lconcat xss = LCons x xs'\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        lconcat xss = LCons x xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  lconcat xss = LCons x xs", "obtain xs' xss' xss'' where xss: \"xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\"\n    and xs: \"xs = lappend xs' (lconcat xss'')\"\n    and LNil: \"set xss' \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lconcat_eq_LCons_conv"], ["proof (prove)\nusing this:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> Collect lnull\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from LNil"], ["proof (chain)\npicking this:\n  set xss' \\<subseteq> {xs. lnull xs}", "have concat_xss': \"lnull (lconcat (llist_of xss'))\""], ["proof (prove)\nusing this:\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lnull (lconcat (llist_of xss'))", "by simp"], ["proof (state)\nthis:\n  lnull (lconcat (llist_of xss'))\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from xs"], ["proof (chain)\npicking this:\n  xs = lappend xs' (lconcat xss'')", "have \"xs = lconcat (LCons xs' xss'')\""], ["proof (prove)\nusing this:\n  xs = lappend xs' (lconcat xss'')\n\ngoal (1 subgoal):\n 1. xs = lconcat (LCons xs' xss'')", "by simp"], ["proof (state)\nthis:\n  xs = lconcat (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "with concat_xss \\<open>enat (Suc n) < llength (lconcat xss)\\<close>"], ["proof (chain)\npicking this:\n  lconcat xss = LCons x xs\n  enat (Suc n) < llength (lconcat xss)\n  xs = lconcat (LCons xs' xss'')", "have \"enat n < llength (lconcat (LCons xs' xss''))\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n  enat (Suc n) < llength (lconcat xss)\n  xs = lconcat (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. enat n < llength (lconcat (LCons xs' xss''))", "by(simp add: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat n < llength (lconcat (LCons xs' xss''))\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from Suc.hyps[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>m n'.\n     lnth (lconcat (LCons xs' xss'')) n =\n     lnth (lnth (LCons xs' xss'') m) n' \\<and>\n     enat n' < llength (lnth (LCons xs' xss'') m) \\<and>\n     enat m < llength (LCons xs' xss'') \\<and>\n     enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'", "obtain m n'\n    where nth_n: \"lnth (lconcat (LCons xs' xss'')) n = lnth (lnth (LCons xs' xss'') m) n'\"\n    and n': \"enat n' < llength (lnth (LCons xs' xss'') m)\"\n    and m': \"enat m < llength (LCons xs' xss'')\"\n    and n_eq: \"enat n = (\\<Sum>i < m. llength (lnth (LCons xs' xss'') i)) + enat n'\""], ["proof (prove)\nusing this:\n  \\<exists>m n'.\n     lnth (lconcat (LCons xs' xss'')) n =\n     lnth (lnth (LCons xs' xss'') m) n' \\<and>\n     enat n' < llength (lnth (LCons xs' xss'') m) \\<and>\n     enat m < llength (LCons xs' xss'') \\<and>\n     enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n\ngoal (1 subgoal):\n 1. (\\<And>m n'.\n        \\<lbrakk>lnth (lconcat (LCons xs' xss'')) n =\n                 lnth (lnth (LCons xs' xss'') m) n';\n         enat n' < llength (lnth (LCons xs' xss'') m);\n         enat m < llength (LCons xs' xss'');\n         enat n =\n         (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lnth (lconcat (LCons xs' xss'')) n = lnth (lnth (LCons xs' xss'') m) n'\n  enat n' < llength (lnth (LCons xs' xss'') m)\n  enat m < llength (LCons xs' xss'')\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from n_eq"], ["proof (chain)\npicking this:\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'", "obtain N where N: \"(\\<Sum>i < m. llength (lnth (LCons xs' xss'') i)) = enat N\"\n    and n: \"n = N + n'\""], ["proof (prove)\nusing this:\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>(\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) = enat N;\n         n = N + n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"\\<Sum>i < m. llength (lnth (LCons xs' xss'') i)\") simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) = enat N\n  n = N + n'\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "{"], ["proof (state)\nthis:\n  (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) = enat N\n  n = N + n'\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "assume i: \"i < length xss'\""], ["proof (state)\nthis:\n  i < length xss'\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"xss' ! i = LNil\""], ["proof (prove)\nusing this:\n  i < length xss'\n\ngoal (1 subgoal):\n 1. xss' ! i = LNil", "using LNil"], ["proof (prove)\nusing this:\n  i < length xss'\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. xss' ! i = LNil", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  i < length xss'\n  {xss' ! i |i. i < length xss'} \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. xss' ! i = LNil", "by auto"], ["proof (state)\nthis:\n  xss' ! i = LNil\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"lnth xss i = LNil\""], ["proof (prove)\nusing this:\n  xss' ! i = LNil\n\ngoal (1 subgoal):\n 1. lnth xss i = LNil", "using i"], ["proof (prove)\nusing this:\n  xss' ! i = LNil\n  i < length xss'\n\ngoal (1 subgoal):\n 1. lnth xss i = LNil", "unfolding xss"], ["proof (prove)\nusing this:\n  xss' ! i = LNil\n  i < length xss'\n\ngoal (1 subgoal):\n 1. lnth (lappend (llist_of xss') (LCons (LCons x xs') xss'')) i = LNil", "by(simp add: lnth_lappend1)"], ["proof (state)\nthis:\n  lnth xss i = LNil\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "}"], ["proof (state)\nthis:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "note lnth_prefix = this"], ["proof (state)\nthis:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil\n\ngoal (1 subgoal):\n 1. \\<And>n xss.\n       \\<lbrakk>\\<And>xss.\n                   enat n < llength (lconcat xss) \\<Longrightarrow>\n                   \\<exists>m n'.\n                      lnth (lconcat xss) n = lnth (lnth xss m) n' \\<and>\n                      enat n' < llength (lnth xss m) \\<and>\n                      enat m < llength xss \\<and>\n                      enat n = (\\<Sum>i<m. llength (lnth xss i)) + enat n';\n        enat (Suc n) < llength (lconcat xss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m n'.\n                            lnth (lconcat xss) (Suc n) =\n                            lnth (lnth xss m) n' \\<and>\n                            enat n' < llength (lnth xss m) \\<and>\n                            enat m < llength xss \\<and>\n                            enat (Suc n) =\n                            (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "proof(cases \"m > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "case True"], ["proof (state)\nthis:\n  0 < m\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  0 < m", "obtain m' where [simp]: \"m = Suc m'\""], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (1 subgoal):\n 1. (\\<And>m'. m = Suc m' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases m) auto"], ["proof (state)\nthis:\n  m = Suc m'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'", "using concat_xss' nth_n"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  lnth (lconcat (LCons xs' xss'')) n = lnth (lnth (LCons xs' xss'') m) n'\n\ngoal (1 subgoal):\n 1. lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'", "unfolding xss"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  lnth (lconcat (LCons xs' xss'')) n = lnth (lnth (LCons xs' xss'') m) n'\n\ngoal (1 subgoal):\n 1. lnth (lconcat (lappend (llist_of xss') (LCons (LCons x xs') xss'')))\n     (Suc n) =\n    lnth\n     (lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n       (m + length xss'))\n     n'", "by(simp add: lnth_lappend2 lappend_lnull1)"], ["proof (state)\nthis:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat n' < llength (lnth xss (m + length xss'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat n' < llength (lnth xss (m + length xss'))", "using concat_xss' n'"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. enat n' < llength (lnth xss (m + length xss'))", "unfolding xss"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. enat n'\n    < llength\n       (lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n         (m + length xss'))", "by(simp add: lnth_lappend2)"], ["proof (state)\nthis:\n  enat n' < llength (lnth xss (m + length xss'))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat n' < llength (lnth xss (m + length xss'))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat (m + length xss') < llength xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (m + length xss') < llength xss", "using concat_xss' m'"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  enat m < llength (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. enat (m + length xss') < llength xss", "unfolding xss"], ["proof (prove)\nusing this:\n  lnull (lconcat (llist_of xss'))\n  enat m < llength (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. enat (m + length xss')\n    < llength (lappend (llist_of xss') (LCons (LCons x xs') xss''))", "apply (simp add: Suc_ile_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xss' \\<subseteq> {xs. lnull xs};\n     enat m' < llength xss''\\<rbrakk>\n    \\<Longrightarrow> enat (Suc (m' + length xss'))\n                      < enat (length xss') + eSuc (llength xss'')", "apply (simp add: eSuc_enat[symmetric] eSuc_plus_1\n        plus_enat_simps(1)[symmetric] del: plus_enat_simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enat (m + length xss') < llength xss\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat (m + length xss') < llength xss\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat (m + length xss') < llength xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (m + length xss') < llength xss", "using m'"], ["proof (prove)\nusing this:\n  enat m < llength (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. enat (m + length xss') < llength xss", "unfolding xss"], ["proof (prove)\nusing this:\n  enat m < llength (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. enat (m + length xss')\n    < llength (lappend (llist_of xss') (LCons (LCons x xs') xss''))", "apply(simp add: Suc_ile_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat m' < llength xss'' \\<Longrightarrow>\n    enat (Suc (m' + length xss'))\n    < enat (length xss') + eSuc (llength xss'')", "apply (simp add: eSuc_enat[symmetric] eSuc_plus_1\n        plus_enat_simps(1)[symmetric] del: plus_enat_simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enat (m + length xss') < llength xss\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat (m + length xss') < llength xss\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "{"], ["proof (state)\nthis:\n  enat (m + length xss') < llength xss\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"(\\<Sum>i < m + length xss'. llength (lnth xss i)) =\n            (\\<Sum>i < length xss'. llength (lnth xss i)) +\n            (\\<Sum>i = length xss'..<m + length xss'. llength (lnth xss i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n    (\\<Sum>i<length xss'. llength (lnth xss i)) +\n    (\\<Sum>i = length xss'..<m + length xss'. llength (lnth xss i))", "by(subst (1 2) atLeast0LessThan[symmetric])(subst sum.atLeastLessThan_concat, simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n  (\\<Sum>i<length xss'. llength (lnth xss i)) +\n  (\\<Sum>i = length xss'..<m + length xss'. llength (lnth xss i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n  (\\<Sum>i<length xss'. llength (lnth xss i)) +\n  (\\<Sum>i = length xss'..<m + length xss'. llength (lnth xss i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from lnth_prefix"], ["proof (chain)\npicking this:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil", "have \"(\\<Sum>i < length xss'. llength (lnth xss i)) = 0\""], ["proof (prove)\nusing this:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xss'. llength (lnth xss i)) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = 0\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = 0\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"{length xss'..<m + length xss'} = {0+length xss'..<m+length xss'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length xss'..<m + length xss'} = {0 + length xss'..<m + length xss'}", "by auto"], ["proof (state)\nthis:\n  {length xss'..<m + length xss'} = {0 + length xss'..<m + length xss'}\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  {length xss'..<m + length xss'} = {0 + length xss'..<m + length xss'}\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"(\\<Sum>i = 0 + length xss'..<m + length xss'. llength (lnth xss i)) =\n                (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0 + length xss'..<m + length xss'. llength (lnth xss i)) =\n    (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss')))", "by(rule sum.shift_bounds_nat_ivl)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0 + length xss'..<m + length xss'. llength (lnth xss i)) =\n  (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss')))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0 + length xss'..<m + length xss'. llength (lnth xss i)) =\n  (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss')))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"\\<dots> = (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss'))) =\n    (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))", "unfolding xss"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m.\n        llength\n         (lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n           (i + length xss'))) =\n    (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))", "by(subst lnth_lappend2) simp+"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss'))) =\n  (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m. llength (lnth xss (i + length xss'))) =\n  (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"\\<dots> = eSuc (llength xs') + (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n    eSuc (llength xs') +\n    (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))", "by(subst sum.atLeast_Suc_lessThan) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n  eSuc (llength xs') +\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n  eSuc (llength xs') +\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "{"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n  eSuc (llength xs') +\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "assume \"i \\<in> {Suc 0..<m}\""], ["proof (state)\nthis:\n  i \\<in> {Suc 0..<m}\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "then"], ["proof (chain)\npicking this:\n  i \\<in> {Suc 0..<m}", "obtain i' where \"i = Suc i'\""], ["proof (prove)\nusing this:\n  i \\<in> {Suc 0..<m}\n\ngoal (1 subgoal):\n 1. (\\<And>i'. i = Suc i' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(cases i) auto"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"llength (lnth (LCons (LCons x xs') xss'') i) = llength (lnth (LCons xs' xss'') i)\""], ["proof (prove)\nusing this:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. llength (lnth (LCons (LCons x xs') xss'') i) =\n    llength (lnth (LCons xs' xss'') i)", "by simp"], ["proof (state)\nthis:\n  llength (lnth (LCons (LCons x xs') xss'') i) =\n  llength (lnth (LCons xs' xss'') i)\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {Suc 0..<m} \\<Longrightarrow>\n  llength (lnth (LCons (LCons x xs') xss'') ?i2) =\n  llength (lnth (LCons xs' xss'') ?i2)\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"(\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n             (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i))\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> {Suc 0..<m} \\<Longrightarrow>\n  llength (lnth (LCons (LCons x xs') xss'') ?i2) =\n  llength (lnth (LCons xs' xss'') ?i2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n    (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i))", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons (LCons x xs') xss'') i)) =\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"eSuc (llength xs') + \\<dots> = 1 + (llength (lnth (LCons xs' xss'') 0) + \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eSuc (llength xs') +\n    (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)) =\n    1 +\n    (llength (lnth (LCons xs' xss'') 0) +\n     (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)))", "by(simp add: eSuc_plus_1 ac_simps)"], ["proof (state)\nthis:\n  eSuc (llength xs') +\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)) =\n  1 +\n  (llength (lnth (LCons xs' xss'') 0) +\n   (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "also"], ["proof (state)\nthis:\n  eSuc (llength xs') +\n  (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)) =\n  1 +\n  (llength (lnth (LCons xs' xss'') 0) +\n   (\\<Sum>i = Suc 0..<m. llength (lnth (LCons xs' xss'') i)))\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "note sum.atLeast_Suc_lessThan[symmetric, OF \\<open>0 < m\\<close>]"], ["proof (state)\nthis:\n  ?g 0 + sum ?g {Suc 0..<m} = sum ?g {0..<m}\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n  0 + (1 + (\\<Sum>i = 0..<m. llength (lnth (LCons xs' xss'') i)))", "have \"enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n  0 + (1 + (\\<Sum>i = 0..<m. llength (lnth (LCons xs' xss'') i)))\n\ngoal (1 subgoal):\n 1. enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'", "unfolding eSuc_enat[symmetric] n_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>i<m + length xss'. llength (lnth xss i)) =\n  0 + (1 + (\\<Sum>i = 0..<m. llength (lnth (LCons xs' xss'') i)))\n\ngoal (1 subgoal):\n 1. eSuc ((\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n') =\n    (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'", "by(simp add: eSuc_plus_1 ac_simps atLeast0LessThan)"], ["proof (state)\nthis:\n  enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "}"], ["proof (state)\nthis:\n  enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'\n\ngoal (2 subgoals):\n 1. 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n 2. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "ultimately"], ["proof (chain)\npicking this:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'\n  enat n' < llength (lnth xss (m + length xss'))\n  enat (m + length xss') < llength xss\n  enat (m + length xss') < llength xss\n  enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'", "show ?thesis"], ["proof (prove)\nusing this:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (m + length xss')) n'\n  enat n' < llength (lnth xss (m + length xss'))\n  enat (m + length xss') < llength xss\n  enat (m + length xss') < llength xss\n  enat (Suc n) = (\\<Sum>i<m + length xss'. llength (lnth xss i)) + enat n'\n\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>m n'.\n     lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n     enat n' < llength (lnth xss m) \\<and>\n     enat m < llength xss \\<and>\n     enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence [simp]: \"m = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < m\n\ngoal (1 subgoal):\n 1. m = 0", "by auto"], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')", "using concat_xss n_eq xs n'"], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n  xs = lappend xs' (lconcat xss'')\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')", "unfolding xss"], ["proof (prove)\nusing this:\n  lconcat (lappend (llist_of xss') (LCons (LCons x xs') xss'')) = LCons x xs\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n  xs = lappend xs' (lconcat xss'')\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. lnth (lconcat (lappend (llist_of xss') (LCons (LCons x xs') xss'')))\n     (Suc n) =\n    lnth\n     (lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n       (length xss'))\n     (Suc n')", "by(simp add: lnth_lappend1 lnth_lappend2)"], ["proof (state)\nthis:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat (Suc n') < llength (lnth xss (length xss'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (Suc n') < llength (lnth xss (length xss'))", "using concat_xss n'"], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. enat (Suc n') < llength (lnth xss (length xss'))", "unfolding xss"], ["proof (prove)\nusing this:\n  lconcat (lappend (llist_of xss') (LCons (LCons x xs') xss'')) = LCons x xs\n  enat n' < llength (lnth (LCons xs' xss'') m)\n\ngoal (1 subgoal):\n 1. enat (Suc n')\n    < llength\n       (lnth (lappend (llist_of xss') (LCons (LCons x xs') xss''))\n         (length xss'))", "by(simp add: lnth_lappend2 Suc_ile_eq)"], ["proof (state)\nthis:\n  enat (Suc n') < llength (lnth xss (length xss'))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat (Suc n') < llength (lnth xss (length xss'))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "have \"enat (length xss') < llength xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length xss') < llength xss", "unfolding xss"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length xss')\n    < llength (lappend (llist_of xss') (LCons (LCons x xs') xss''))", "by simp"], ["proof (state)\nthis:\n  enat (length xss') < llength xss\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "moreover"], ["proof (state)\nthis:\n  enat (length xss') < llength xss\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "from lnth_prefix"], ["proof (chain)\npicking this:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil", "have \"(\\<Sum>i<length xss'. llength (lnth xss i)) = 0\""], ["proof (prove)\nusing this:\n  ?i2 < length xss' \\<Longrightarrow> lnth xss ?i2 = LNil\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xss'. llength (lnth xss i)) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "hence \"enat (Suc n) = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = 0\n\ngoal (1 subgoal):\n 1. enat (Suc n) =\n    (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')", "using n_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>i<length xss'. llength (lnth xss i)) = 0\n  enat n = (\\<Sum>i<m. llength (lnth (LCons xs' xss'') i)) + enat n'\n\ngoal (1 subgoal):\n 1. enat (Suc n) =\n    (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')", "by simp"], ["proof (state)\nthis:\n  enat (Suc n) = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')\n\ngoal (1 subgoal):\n 1. \\<not> 0 < m \\<Longrightarrow>\n    \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "ultimately"], ["proof (chain)\npicking this:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')\n  enat (Suc n') < llength (lnth xss (length xss'))\n  enat (length xss') < llength xss\n  enat (Suc n) = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')", "show ?thesis"], ["proof (prove)\nusing this:\n  lnth (lconcat xss) (Suc n) = lnth (lnth xss (length xss')) (Suc n')\n  enat (Suc n') < llength (lnth xss (length xss'))\n  enat (length xss') < llength xss\n  enat (Suc n) = (\\<Sum>i<length xss'. llength (lnth xss i)) + enat (Suc n')\n\ngoal (1 subgoal):\n 1. \\<exists>m n'.\n       lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n       enat n' < llength (lnth xss m) \\<and>\n       enat m < llength xss \\<and>\n       enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>m n'.\n     lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n     enat n' < llength (lnth xss m) \\<and>\n     enat m < llength xss \\<and>\n     enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m n'.\n     lnth (lconcat xss) (Suc n) = lnth (lnth xss m) n' \\<and>\n     enat n' < llength (lnth xss m) \\<and>\n     enat m < llength xss \\<and>\n     enat (Suc n) = (\\<Sum>i<m. llength (lnth xss i)) + enat n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lprefix_lconcatI:\n  \"xss \\<sqsubseteq> yss \\<Longrightarrow> lconcat xss \\<sqsubseteq> lconcat yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xss \\<sqsubseteq> yss \\<Longrightarrow>\n    lconcat xss \\<sqsubseteq> lconcat yss", "by(rule monotoneD[OF monotone_lconcat])"], ["", "lemma lnth_lconcat_ltake:\n  assumes \"enat w < llength (lconcat (ltake (enat n) xss))\"\n  shows \"lnth (lconcat (ltake (enat n) xss)) w = lnth (lconcat xss) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (lconcat (ltake (enat n) xss)) w = lnth (lconcat xss) w", "using assms"], ["proof (prove)\nusing this:\n  enat w < llength (lconcat (ltake (enat n) xss))\n\ngoal (1 subgoal):\n 1. lnth (lconcat (ltake (enat n) xss)) w = lnth (lconcat xss) w", "by(auto intro: lprefix_lnthD lprefix_lconcatI)"], ["", "lemma lfinite_lconcat [simp]:\n  \"lfinite (lconcat xss) \\<longleftrightarrow> lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and> (\\<forall>xs \\<in> lset xss. lfinite xs)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lconcat xss) =\n    (lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n     (\\<forall>xs\\<in>lset xss. lfinite xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lconcat xss) \\<Longrightarrow>\n    lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs)\n 2. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "assume \"?lhs\""], ["proof (state)\nthis:\n  lfinite (lconcat xss)\n\ngoal (2 subgoals):\n 1. lfinite (lconcat xss) \\<Longrightarrow>\n    lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs)\n 2. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "thus \"?rhs\" (is \"?concl xss\")"], ["proof (prove)\nusing this:\n  lfinite (lconcat xss)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs)", "proof(induct \"lconcat xss\" arbitrary: xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xss.\n       LNil = lconcat xss \\<Longrightarrow>\n       lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n       (\\<forall>a\\<in>lset xss. lfinite a)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "case [symmetric]: lfinite_LNil"], ["proof (state)\nthis:\n  lconcat xss = LNil\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       LNil = lconcat xss \\<Longrightarrow>\n       lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n       (\\<forall>a\\<in>lset xss. lfinite a)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "moreover"], ["proof (state)\nthis:\n  lconcat xss = LNil\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       LNil = lconcat xss \\<Longrightarrow>\n       lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n       (\\<forall>a\\<in>lset xss. lfinite a)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "hence \"lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\""], ["proof (prove)\nusing this:\n  lconcat xss = LNil\n\ngoal (1 subgoal):\n 1. lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)", "by(auto simp add: lconcat_eq_LNil)"], ["proof (state)\nthis:\n  lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       LNil = lconcat xss \\<Longrightarrow>\n       lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n       (\\<forall>a\\<in>lset xss. lfinite a)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "ultimately"], ["proof (chain)\npicking this:\n  lconcat xss = LNil\n  lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)", "show ?case"], ["proof (prove)\nusing this:\n  lconcat xss = LNil\n  lnull (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>a\\<in>lset xss. lfinite a)", "by(auto)"], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  (\\<forall>a\\<in>lset xss. lfinite a)\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  xs = lconcat ?xss \\<Longrightarrow>\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) ?xss) \\<and>\n  Ball (lset ?xss) lfinite\n  LCons x xs = lconcat xss\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "from \\<open>LCons x xs = lconcat xss\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  lconcat xss = LCons x xs", "obtain xs' xss' xss'' where xss [simp]: \"xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\"\n      and xs [simp]: \"xs = lappend xs' (lconcat xss'')\"\n      and xss': \"set xss' \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  lconcat xss = LCons x xs\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lconcat_eq_LCons_conv"], ["proof (prove)\nusing this:\n  \\<exists>xs' xss' xss''.\n     xss = lappend (llist_of xss') (LCons (LCons x xs') xss'') \\<and>\n     xs = lappend xs' (lconcat xss'') \\<and>\n     set xss' \\<subseteq> Collect lnull\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xs' xss''.\n        \\<lbrakk>xss = lappend (llist_of xss') (LCons (LCons x xs') xss'');\n         xs = lappend xs' (lconcat xss'');\n         set xss' \\<subseteq> {xs. lnull xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend (llist_of xss') (LCons (LCons x xs') xss'')\n  xs = lappend xs' (lconcat xss'')\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "have \"xs = lconcat (LCons xs' xss'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = lconcat (LCons xs' xss'')", "by simp"], ["proof (state)\nthis:\n  xs = lconcat (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "hence \"?concl (LCons xs' xss'')\""], ["proof (prove)\nusing this:\n  xs = lconcat (LCons xs' xss'')\n\ngoal (1 subgoal):\n 1. lfinite\n     (lfilter (\\<lambda>xs. \\<not> lnull xs) (LCons xs' xss'')) \\<and>\n    (\\<forall>xs\\<in>lset (LCons xs' xss''). lfinite xs)", "by(rule lfinite_LConsI)"], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) (LCons xs' xss'')) \\<and>\n  (\\<forall>xs\\<in>lset (LCons xs' xss''). lfinite xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           xs = lconcat xss \\<Longrightarrow>\n           lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n           Ball (lset xss) lfinite;\n        LCons x xs = lconcat xss\\<rbrakk>\n       \\<Longrightarrow> lfinite\n                          (lfilter (\\<lambda>xs. \\<not> lnull xs)\n                            xss) \\<and>\n                         Ball (lset xss) lfinite", "thus ?case"], ["proof (prove)\nusing this:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) (LCons xs' xss'')) \\<and>\n  (\\<forall>xs\\<in>lset (LCons xs' xss''). lfinite xs)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    Ball (lset xss) lfinite", "using \\<open>lfinite xs\\<close> xss'"], ["proof (prove)\nusing this:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) (LCons xs' xss'')) \\<and>\n  (\\<forall>xs\\<in>lset (LCons xs' xss''). lfinite xs)\n  lfinite xs\n  set xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    Ball (lset xss) lfinite", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  Ball (lset xss) lfinite\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  (\\<forall>xs\\<in>lset xss. lfinite xs)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "assume \"?rhs\""], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  (\\<forall>xs\\<in>lset xss. lfinite xs)\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "then"], ["proof (chain)\npicking this:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  (\\<forall>xs\\<in>lset xss. lfinite xs)", "obtain \"lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\"\n    and \"\\<forall>xs\\<in>lset xss. lfinite xs\""], ["proof (prove)\nusing this:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n  (\\<forall>xs\\<in>lset xss. lfinite xs)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss);\n      \\<forall>xs\\<in>lset xss. lfinite xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n  \\<forall>xs\\<in>lset xss. lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss) \\<and>\n    (\\<forall>xs\\<in>lset xss. lfinite xs) \\<Longrightarrow>\n    lfinite (lconcat xss)", "thus ?lhs"], ["proof (prove)\nusing this:\n  lfinite (lfilter (\\<lambda>xs. \\<not> lnull xs) xss)\n  \\<forall>xs\\<in>lset xss. lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lconcat xss)", "proof(induct \"lfilter (\\<lambda>xs. \\<not> lnull xs) xss\" arbitrary: xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xss.\n       \\<lbrakk>LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "case lfinite_LNil"], ["proof (state)\nthis:\n  LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss\n  \\<forall>a\\<in>lset xss. lfinite a\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       \\<lbrakk>LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "from \\<open>LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss\\<close>[symmetric]"], ["proof (chain)\npicking this:\n  lfilter (\\<lambda>xs. \\<not> lnull xs) xss = LNil", "have \"lset xss \\<subseteq> {xs. lnull xs}\""], ["proof (prove)\nusing this:\n  lfilter (\\<lambda>xs. \\<not> lnull xs) xss = LNil\n\ngoal (1 subgoal):\n 1. lset xss \\<subseteq> {xs. lnull xs}", "unfolding lfilter_empty_conv"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>lset xss. \\<not> \\<not> lnull x\n\ngoal (1 subgoal):\n 1. lset xss \\<subseteq> {xs. lnull xs}", "by blast"], ["proof (state)\nthis:\n  lset xss \\<subseteq> {xs. lnull xs}\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       \\<lbrakk>LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "hence \"lnull (lconcat xss)\""], ["proof (prove)\nusing this:\n  lset xss \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. lnull (lconcat xss)", "by(simp)"], ["proof (state)\nthis:\n  lnull (lconcat xss)\n\ngoal (2 subgoals):\n 1. \\<And>xss.\n       \\<lbrakk>LNil = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)\n 2. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "thus ?case"], ["proof (prove)\nusing this:\n  lnull (lconcat xss)\n\ngoal (1 subgoal):\n 1. lfinite (lconcat xss)", "by(simp)"], ["proof (state)\nthis:\n  lfinite (lconcat xss)\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) ?xss;\n   Ball (lset ?xss) lfinite\\<rbrakk>\n  \\<Longrightarrow> lfinite (lconcat ?xss)\n  LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss\n  Ball (lset xss) lfinite\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "from lfilter_eq_LConsD[OF \\<open>LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss\\<close>[symmetric]]"], ["proof (chain)\npicking this:\n  \\<exists>us vs.\n     xss = lappend us (LCons x vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> \\<not> lnull u) \\<and>\n     \\<not> lnull x \\<and> xs = lfilter (\\<lambda>xs. \\<not> lnull xs) vs", "obtain xss' xss'' where xss [simp]: \"xss = lappend xss' (LCons x xss'')\"\n      and xss': \"lfinite xss'\" \"lset xss' \\<subseteq> {xs. lnull xs}\"\n      and x: \"\\<not> lnull x\"\n      and xs [simp]: \"xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\""], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xss = lappend us (LCons x vs) \\<and>\n     lfinite us \\<and>\n     (\\<forall>u\\<in>lset us. \\<not> \\<not> lnull u) \\<and>\n     \\<not> lnull x \\<and> xs = lfilter (\\<lambda>xs. \\<not> lnull xs) vs\n\ngoal (1 subgoal):\n 1. (\\<And>xss' xss''.\n        \\<lbrakk>xss = lappend xss' (LCons x xss''); lfinite xss';\n         lset xss' \\<subseteq> {xs. lnull xs}; \\<not> lnull x;\n         xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xss = lappend xss' (LCons x xss'')\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n  \\<not> lnull x\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "moreover"], ["proof (state)\nthis:\n  xss = lappend xss' (LCons x xss'')\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n  \\<not> lnull x\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "from \\<open>\\<forall>xs\\<in>lset xss. lfinite xs\\<close> xss'"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>lset xss. lfinite xs\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}", "have \"\\<forall>xs\\<in>lset xss''. lfinite xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>lset xss. lfinite xs\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>lset xss''. lfinite xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>lset xss''. lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "with xs"], ["proof (chain)\npicking this:\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n  \\<forall>xs\\<in>lset xss''. lfinite xs", "have \"lfinite (lconcat xss'')\""], ["proof (prove)\nusing this:\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n  \\<forall>xs\\<in>lset xss''. lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lconcat xss'')", "by(rule lfinite_LConsI)"], ["proof (state)\nthis:\n  lfinite (lconcat xss'')\n\ngoal (1 subgoal):\n 1. \\<And>xs x xss.\n       \\<lbrakk>lfinite xs;\n        \\<And>xss.\n           \\<lbrakk>xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n            Ball (lset xss) lfinite\\<rbrakk>\n           \\<Longrightarrow> lfinite (lconcat xss);\n        LCons x xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss;\n        Ball (lset xss) lfinite\\<rbrakk>\n       \\<Longrightarrow> lfinite (lconcat xss)", "ultimately"], ["proof (chain)\npicking this:\n  xss = lappend xss' (LCons x xss'')\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n  \\<not> lnull x\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n  lfinite (lconcat xss'')", "show ?case"], ["proof (prove)\nusing this:\n  xss = lappend xss' (LCons x xss'')\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n  \\<not> lnull x\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n  lfinite (lconcat xss'')\n\ngoal (1 subgoal):\n 1. lfinite (lconcat xss)", "using \\<open>\\<forall>xs\\<in>lset xss. lfinite xs\\<close>"], ["proof (prove)\nusing this:\n  xss = lappend xss' (LCons x xss'')\n  lfinite xss'\n  lset xss' \\<subseteq> {xs. lnull xs}\n  \\<not> lnull x\n  xs = lfilter (\\<lambda>xs. \\<not> lnull xs) xss''\n  lfinite (lconcat xss'')\n  \\<forall>xs\\<in>lset xss. lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lconcat xss)", "by(simp)"], ["proof (state)\nthis:\n  lfinite (lconcat xss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite (lconcat xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_lconcat:\n  assumes \"lfinite xss\"\n  and \"\\<forall>xs \\<in> lset xss. lfinite xs\"\n  shows \"list_of (lconcat xss) = concat (list_of (lmap list_of xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (lconcat xss) = concat (list_of (lmap list_of xss))", "using assms"], ["proof (prove)\nusing this:\n  lfinite xss\n  \\<forall>xs\\<in>lset xss. lfinite xs\n\ngoal (1 subgoal):\n 1. list_of (lconcat xss) = concat (list_of (lmap list_of xss))", "by induct(simp_all add: list_of_lappend)"], ["", "lemma lfilter_lconcat_lfinite:\n  \"\\<forall>xs\\<in>lset xss. lfinite xs\n  \\<Longrightarrow> lfilter P (lconcat xss) = lconcat (lmap (lfilter P) xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>lset xss. lfinite xs \\<Longrightarrow>\n    lfilter P (lconcat xss) = lconcat (lmap (lfilter P) xss)", "by(induct xss) simp_all"], ["", "lemma lconcat_repeat_LNil [simp]: \"lconcat (repeat LNil) = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (repeat LNil) = LNil", "by(simp add: lconcat_eq_LNil)"], ["", "lemma lconcat_lmap_singleton [simp]: \"lconcat (lmap (\\<lambda>x. LCons (f x) LNil) xs) = lmap f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (lmap (\\<lambda>x. LCons (f x) LNil) xs) = lmap f xs", "by(induct xs) simp_all"], ["", "lemma lset_lconcat_subset: \"lset (lconcat xss) \\<subseteq> (\\<Union>xs\\<in>lset xss. lset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lconcat xss) \\<subseteq> \\<Union> (lset ` lset xss)", "by(induct xss)(auto dest: subsetD[OF lset_lappend])"], ["", "lemma ldistinct_lconcat:\n  \"\\<lbrakk> ldistinct xss; \\<And>ys. ys \\<in> lset xss \\<Longrightarrow> ldistinct ys;\n     \\<And>ys zs. \\<lbrakk> ys \\<in> lset xss; zs \\<in> lset xss; ys \\<noteq> zs \\<rbrakk> \\<Longrightarrow> lset ys \\<inter> lset zs = {} \\<rbrakk>\n  \\<Longrightarrow> ldistinct (lconcat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ldistinct xss;\n     \\<And>ys. ys \\<in> lset xss \\<Longrightarrow> ldistinct ys;\n     \\<And>ys zs.\n        \\<lbrakk>ys \\<in> lset xss; zs \\<in> lset xss;\n         ys \\<noteq> zs\\<rbrakk>\n        \\<Longrightarrow> lset ys \\<inter> lset zs = {}\\<rbrakk>\n    \\<Longrightarrow> ldistinct (lconcat xss)", "apply(induction arbitrary: xss rule: lconcat.fixp_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. llist.admissible\n     (\\<lambda>lconcat.\n         \\<forall>x.\n            ldistinct x \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> lset x \\<longrightarrow>\n                ldistinct xa) \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> lset x \\<longrightarrow>\n                (\\<forall>xb.\n                    xb \\<in> lset x \\<longrightarrow>\n                    xa \\<noteq> xb \\<longrightarrow>\n                    lset xa \\<inter> lset xb = {})) \\<longrightarrow>\n            ldistinct (lconcat x))\n 2. \\<And>xss.\n       \\<lbrakk>ldistinct xss;\n        \\<And>ys. ys \\<in> lset xss \\<Longrightarrow> ldistinct ys;\n        \\<And>ys zs.\n           \\<lbrakk>ys \\<in> lset xss; zs \\<in> lset xss;\n            ys \\<noteq> zs\\<rbrakk>\n           \\<Longrightarrow> lset ys \\<inter> lset zs = {}\\<rbrakk>\n       \\<Longrightarrow> ldistinct LNil\n 3. \\<And>xss xssa.\n       \\<lbrakk>\\<And>xssa.\n                   \\<lbrakk>ldistinct xssa;\n                    \\<And>ys.\n                       ys \\<in> lset xssa \\<Longrightarrow> ldistinct ys;\n                    \\<And>ys zs.\n                       \\<lbrakk>ys \\<in> lset xssa; zs \\<in> lset xssa;\n                        ys \\<noteq> zs\\<rbrakk>\n                       \\<Longrightarrow> lset ys \\<inter> lset zs =\n   {}\\<rbrakk>\n                   \\<Longrightarrow> ldistinct (xss xssa);\n        llist.le_fun xss lconcat; ldistinct xssa;\n        \\<And>ys. ys \\<in> lset xssa \\<Longrightarrow> ldistinct ys;\n        \\<And>ys zs.\n           \\<lbrakk>ys \\<in> lset xssa; zs \\<in> lset xssa;\n            ys \\<noteq> zs\\<rbrakk>\n           \\<Longrightarrow> lset ys \\<inter> lset zs = {}\\<rbrakk>\n       \\<Longrightarrow> ldistinct\n                          (case xssa of LNil \\<Rightarrow> LNil\n                           | LCons xs xss' \\<Rightarrow>\n                               lappend xs (xss xss'))", "apply(auto simp add: ldistinct_lappend fun_ord_def split: llist.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xss x21 x22 x.\n       \\<lbrakk>\\<And>xssa.\n                   \\<lbrakk>ldistinct xssa;\n                    \\<And>ys.\n                       ys \\<in> lset xssa \\<Longrightarrow> ldistinct ys;\n                    \\<And>ys zs.\n                       \\<lbrakk>ys \\<in> lset xssa; zs \\<in> lset xssa;\n                        ys \\<noteq> zs\\<rbrakk>\n                       \\<Longrightarrow> lset ys \\<inter> lset zs =\n   {}\\<rbrakk>\n                   \\<Longrightarrow> ldistinct (xss xssa);\n        \\<forall>x. xss x \\<sqsubseteq> lconcat x;\n        \\<And>ys.\n           ys = x21 \\<or> ys \\<in> lset x22 \\<Longrightarrow> ldistinct ys;\n        \\<And>ys zs.\n           \\<lbrakk>ys = x21 \\<or> ys \\<in> lset x22;\n            zs = x21 \\<or> zs \\<in> lset x22; ys \\<noteq> zs\\<rbrakk>\n           \\<Longrightarrow> lset ys \\<inter> lset zs = {};\n        lfinite x21; x \\<in> lset x21; x \\<in> lset (xss x22);\n        x21 \\<notin> lset x22; ldistinct x22\\<rbrakk>\n       \\<Longrightarrow> False", "apply(blast dest!: subsetD[OF lprefix_lsetD] subsetD[OF lset_lconcat_subset])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Sublist view of a lazy list: @{term \"lnths\"}\\<close>"], ["", "lemma lnths_empty [simp]: \"lnths xs {} = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs {} = LNil", "by(auto simp add: lnths_def split_def lfilter_empty_conv)"], ["", "lemma lnths_LNil [simp]: \"lnths LNil A = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths LNil A = LNil", "by(simp add: lnths_def)"], ["", "lemma lnths_LCons:\n  \"lnths (LCons x xs) A =\n  (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A}) else lnths xs {n. Suc n \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "let ?it = \"iterates Suc\""], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "let ?f = \"\\<lambda>(x, y). (x, Suc y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "have \"lzip xs (?it (Suc n)) = lmap ?f (lzip xs (?it n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs (iterates Suc (Suc n)) =\n    lmap (\\<lambda>(x, y). (x, Suc y)) (lzip xs (iterates Suc n))", "by(coinduction arbitrary: xs n)(auto)"], ["proof (state)\nthis:\n  lzip xs (iterates Suc (Suc n)) =\n  lmap (\\<lambda>(x, y). (x, Suc y)) (lzip xs (iterates Suc n))\n\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "hence \"lmap fst (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (?it (Suc n)))) =\n           lmap fst (lfilter (\\<lambda>(x, y). Suc y \\<in> A) (lzip xs (?it n)))\""], ["proof (prove)\nusing this:\n  lzip xs (iterates Suc (Suc n)) =\n  lmap (\\<lambda>(x, y). (x, Suc y)) (lzip xs (iterates Suc n))\n\ngoal (1 subgoal):\n 1. lmap fst\n     (lfilter (\\<lambda>(x, y). y \\<in> A)\n       (lzip xs (iterates Suc (Suc n)))) =\n    lmap fst\n     (lfilter (\\<lambda>(x, y). Suc y \\<in> A) (lzip xs (iterates Suc n)))", "by(simp add: lfilter_lmap o_def split_def llist.map_comp)"], ["proof (state)\nthis:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc (Suc n)))) =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). Suc y \\<in> A) (lzip xs (iterates Suc n)))\n\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "}"], ["proof (state)\nthis:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> A)\n     (lzip xs (iterates Suc (Suc ?n3)))) =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). Suc y \\<in> A) (lzip xs (iterates Suc ?n3)))\n\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "thus ?thesis"], ["proof (prove)\nusing this:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> A)\n     (lzip xs (iterates Suc (Suc ?n3)))) =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). Suc y \\<in> A) (lzip xs (iterates Suc ?n3)))\n\ngoal (1 subgoal):\n 1. lnths (LCons x xs) A =\n    (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n     else lnths xs {n. Suc n \\<in> A})", "by(auto simp add: lnths_def)(subst iterates, simp)+"], ["proof (state)\nthis:\n  lnths (LCons x xs) A =\n  (if 0 \\<in> A then LCons x (lnths xs {n. Suc n \\<in> A})\n   else lnths xs {n. Suc n \\<in> A})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lset_lnths:\n  \"lset (lnths xs I) = {lnth xs i|i. enat i<llength xs \\<and> i \\<in> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lnths xs I) = {lnth xs i |i. enat i < llength xs \\<and> i \\<in> I}", "apply(auto simp add: lnths_def lset_lzip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength xs; i \\<in> I\\<rbrakk>\n       \\<Longrightarrow> lnth xs i\n                         \\<in> fst `\n                               {x. (\\<exists>n.\n x = (lnth xs n, n) \\<and> enat n < llength xs) \\<and>\n                                   (case x of\n                                    (x, y) \\<Rightarrow> y \\<in> I)}", "apply(rule_tac x=\"(lnth xs i, i)\" in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>enat i < llength xs; i \\<in> I\\<rbrakk>\n       \\<Longrightarrow> lnth xs i = fst (lnth xs i, i)\n 2. \\<And>i.\n       \\<lbrakk>enat i < llength xs; i \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (lnth xs i, i)\n                         \\<in> {x. (\\<exists>n.\n x = (lnth xs n, n) \\<and> enat n < llength xs) \\<and>\n                                   (case x of\n                                    (x, y) \\<Rightarrow> y \\<in> I)}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lset_lnths_subset: \"lset (lnths xs I) \\<subseteq> lset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (lnths xs I) \\<subseteq> lset xs", "by(auto simp add: lset_lnths in_lset_conv_lnth)"], ["", "lemma lnths_singleton [simp]:\n  \"lnths (LCons x LNil) A = (if 0 : A then LCons x LNil else LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (LCons x LNil) A = (if 0 \\<in> A then LCons x LNil else LNil)", "by (simp add: lnths_LCons)"], ["", "lemma lnths_upt_eq_ltake [simp]:\n  \"lnths xs {..<n} = ltake (enat n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs {..<n} = ltake (enat n) xs", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat n) xs = lnths xs {..<n}", "proof(induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. ltake (enat 0) xs = lnths xs {..<0}\n 2. \\<And>n xs.\n       (\\<And>xs. ltake (enat n) xs = lnths xs {..<n}) \\<Longrightarrow>\n       ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs. ltake (enat 0) xs = lnths xs {..<0}\n 2. \\<And>n xs.\n       (\\<And>xs. ltake (enat n) xs = lnths xs {..<n}) \\<Longrightarrow>\n       ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) xs = lnths xs {..<0}", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  ltake (enat 0) xs = lnths xs {..<0}\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltake (enat n) xs = lnths xs {..<n}) \\<Longrightarrow>\n       ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltake (enat n) xs = lnths xs {..<n}) \\<Longrightarrow>\n       ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "case (Suc n)"], ["proof (state)\nthis:\n  ltake (enat n) ?xs = lnths ?xs {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs. ltake (enat n) xs = lnths xs {..<n}) \\<Longrightarrow>\n       ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "thus ?case"], ["proof (prove)\nusing this:\n  ltake (enat n) ?xs = lnths ?xs {..<n}\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) xs = lnths xs {..<Suc n}", "by(cases xs)(simp_all add: eSuc_enat[symmetric] lnths_LCons lessThan_def)"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) xs = lnths xs {..<Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_llist_of [simp]:\n  \"lnths (llist_of xs) A = llist_of (nths xs A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (llist_of xs) A = llist_of (nths xs A)", "by(induct xs arbitrary: A)(simp_all add: lnths_LCons nths_Cons)"], ["", "lemma llength_lnths_ile: \"llength (lnths xs A) \\<le> llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lnths xs A) \\<le> llength xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llength (lnths xs A) \\<le> llength xs", "have \"llength (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0))) \\<le>\n        llength (lzip xs (iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0)))\n    \\<le> llength (lzip xs (iterates Suc 0))", "by(rule llength_lfilter_ile)"], ["proof (state)\nthis:\n  llength (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0)))\n  \\<le> llength (lzip xs (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. llength (lnths xs A) \\<le> llength xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  llength (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0)))\n  \\<le> llength (lzip xs (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. llength (lnths xs A) \\<le> llength xs", "by(simp add: lnths_def)"], ["proof (state)\nthis:\n  llength (lnths xs A) \\<le> llength xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_lmap [simp]:\n  \"lnths (lmap f xs) A = lmap f (lnths xs A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (lmap f xs) A = lmap f (lnths xs A)", "by(simp add: lnths_def lzip_lmap1 llist.map_comp lfilter_lmap o_def split_def)"], ["", "lemma lfilter_conv_lnths:\n  \"lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "have \"lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} =\n        lmap fst (lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n                          (lzip xs (iterates Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} =\n    lmap fst\n     (lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n       (lzip xs (iterates Suc 0)))", "by(simp add: lnths_def)"], ["proof (state)\nthis:\n  lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n     (lzip xs (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "also"], ["proof (state)\nthis:\n  lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n     (lzip xs (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "have \"\\<forall>(x, y)\\<in>lset (lzip xs (iterates Suc 0)). enat y < llength xs \\<and> x = lnth xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>lset (lzip xs (iterates Suc 0)).\n       enat y < llength xs \\<and> x = lnth xs y", "by(auto simp add: lset_lzip)"], ["proof (state)\nthis:\n  \\<forall>(x, y)\\<in>lset (lzip xs (iterates Suc 0)).\n     enat y < llength xs \\<and> x = lnth xs y\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "hence \"lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y)) (lzip xs (iterates Suc 0)) =\n         lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))\""], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\\<in>lset (lzip xs (iterates Suc 0)).\n     enat y < llength xs \\<and> x = lnth xs y\n\ngoal (1 subgoal):\n 1. lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n     (lzip xs (iterates Suc 0)) =\n    lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))", "by -(rule lfilter_cong[OF refl], auto)"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n   (lzip xs (iterates Suc 0)) =\n  lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "also"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(x, y). enat y < llength xs \\<and> P (lnth xs y))\n   (lzip xs (iterates Suc 0)) =\n  lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "have \"lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))) =\n            lfilter P (lmap fst (lzip xs (iterates Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))) =\n    lfilter P (lmap fst (lzip xs (iterates Suc 0)))", "unfolding lfilter_lmap"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))) =\n    lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0)))", ".."], ["proof (state)\nthis:\n  lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))) =\n  lfilter P (lmap fst (lzip xs (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "also"], ["proof (state)\nthis:\n  lmap fst (lfilter (P \\<circ> fst) (lzip xs (iterates Suc 0))) =\n  lfilter P (lmap fst (lzip xs (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "have \"lmap fst (lzip xs (iterates Suc 0)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap fst (lzip xs (iterates Suc 0)) = xs", "by(simp add: lmap_fst_lzip_conv_ltake ltake_all)"], ["proof (state)\nthis:\n  lmap fst (lzip xs (iterates Suc 0)) = xs\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", "finally"], ["proof (chain)\npicking this:\n  lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} = lfilter P xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)} = lfilter P xs\n\ngoal (1 subgoal):\n 1. lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}", ".."], ["proof (state)\nthis:\n  lfilter P xs = lnths xs {n. enat n < llength xs \\<and> P (lnth xs n)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_iterates_Suc:\n  \"ltake (enat n) (iterates Suc m) = llist_of [m..<n + m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat n) (iterates Suc m) = llist_of [m..<n + m]", "proof(induct n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. ltake (enat 0) (iterates Suc m) = llist_of [m..<0 + m]\n 2. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>m. ltake (enat 0) (iterates Suc m) = llist_of [m..<0 + m]\n 2. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) (iterates Suc m) = llist_of [m..<0 + m]", "by(simp add: zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  ltake (enat 0) (iterates Suc m) = llist_of [m..<0 + m]\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "case (Suc n)"], ["proof (state)\nthis:\n  ltake (enat n) (iterates Suc ?m) = llist_of [?m..<n + ?m]\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "have \"ltake (enat (Suc n)) (iterates Suc m) =\n        LCons m (ltake (enat n) (iterates Suc (Suc m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (iterates Suc m) =\n    LCons m (ltake (enat n) (iterates Suc (Suc m)))", "by(subst iterates)(simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (iterates Suc m) =\n  LCons m (ltake (enat n) (iterates Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "also"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (iterates Suc m) =\n  LCons m (ltake (enat n) (iterates Suc (Suc m)))\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "note Suc"], ["proof (state)\nthis:\n  ltake (enat n) (iterates Suc ?m) = llist_of [?m..<n + ?m]\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "also"], ["proof (state)\nthis:\n  ltake (enat n) (iterates Suc ?m) = llist_of [?m..<n + ?m]\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "have \"LCons m (llist_of [Suc m..<n + Suc m]) = llist_of [m..<Suc n+m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons m (llist_of [Suc m..<n + Suc m]) = llist_of [m..<Suc n + m]", "unfolding llist_of.simps[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of (m # [Suc m..<n + Suc m]) = llist_of [m..<Suc n + m]", "by(auto simp del: llist_of.simps simp add: upt_conv_Cons)"], ["proof (state)\nthis:\n  LCons m (llist_of [Suc m..<n + Suc m]) = llist_of [m..<Suc n + m]\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<And>m.\n           ltake (enat n) (iterates Suc m) =\n           llist_of [m..<n + m]) \\<Longrightarrow>\n       ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "finally"], ["proof (chain)\npicking this:\n  ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "show ?case"], ["proof (prove)\nusing this:\n  ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]", "."], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (iterates Suc m) = llist_of [m..<Suc n + m]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_lappend_lfinite:\n  assumes len: \"llength xs = enat k\"\n  shows \"lnths (lappend xs ys) A =\n         lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "let ?it = \"iterates Suc\""], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "from assms"], ["proof (chain)\npicking this:\n  llength xs = enat k", "have fin: \"lfinite xs\""], ["proof (prove)\nusing this:\n  llength xs = enat k\n\ngoal (1 subgoal):\n 1. lfinite xs", "by(rule llength_eq_enat_lfiniteD)"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"lnths (lappend xs ys) A =\n    lmap fst (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip (lappend xs ys) (?it 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lmap fst\n     (lfilter (\\<lambda>(x, y). y \\<in> A)\n       (lzip (lappend xs ys) (iterates Suc 0)))", "by(simp add: lnths_def)"], ["proof (state)\nthis:\n  lnths (lappend xs ys) A =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> A)\n     (lzip (lappend xs ys) (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lnths (lappend xs ys) A =\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> A)\n     (lzip (lappend xs ys) (iterates Suc 0)))\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"?it 0 = lappend (ltake (enat k) (?it 0)) (ldrop (enat k) (?it 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterates Suc 0 =\n    lappend (ltake (enat k) (iterates Suc 0))\n     (ldrop (enat k) (iterates Suc 0))", "by(simp only: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  iterates Suc 0 =\n  lappend (ltake (enat k) (iterates Suc 0))\n   (ldrop (enat k) (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  iterates Suc 0 =\n  lappend (ltake (enat k) (iterates Suc 0))\n   (ldrop (enat k) (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lzip_lappend"], ["proof (state)\nthis:\n  llength ?xs = llength ?us \\<Longrightarrow>\n  lzip (lappend ?xs ?ys) (lappend ?us ?vs) =\n  lappend (lzip ?xs ?us) (lzip ?ys ?vs)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  llength ?xs = llength ?us \\<Longrightarrow>\n  lzip (lappend ?xs ?ys) (lappend ?us ?vs) =\n  lappend (lzip ?xs ?us) (lzip ?ys ?vs)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lfilter_lappend_lfinite"], ["proof (state)\nthis:\n  lfinite ?xs \\<Longrightarrow>\n  lfilter ?P (lappend ?xs ?ys) = lappend (lfilter ?P ?xs) (lfilter ?P ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lfinite ?xs \\<Longrightarrow>\n  lfilter ?P (lappend ?xs ?ys) = lappend (lfilter ?P ?xs) (lfilter ?P ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lmap_lappend_distrib"], ["proof (state)\nthis:\n  lmap ?f (lappend ?xs ?ys) = lappend (lmap ?f ?xs) (lmap ?f ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lmap ?f (lappend ?xs ?ys) = lappend (lmap ?f ?xs) (lmap ?f ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"lzip xs (ltake (enat k) (?it 0)) = lzip xs (?it 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip xs (ltake (enat k) (iterates Suc 0)) = lzip xs (iterates Suc 0)", "using len"], ["proof (prove)\nusing this:\n  llength xs = enat k\n\ngoal (1 subgoal):\n 1. lzip xs (ltake (enat k) (iterates Suc 0)) = lzip xs (iterates Suc 0)", "by(subst (1 2) lzip_conv_lzip_ltake_min_llength) simp"], ["proof (state)\nthis:\n  lzip xs (ltake (enat k) (iterates Suc 0)) = lzip xs (iterates Suc 0)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lzip xs (ltake (enat k) (iterates Suc 0)) = lzip xs (iterates Suc 0)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lnths_def[symmetric]"], ["proof (state)\nthis:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> ?A) (lzip ?xs (iterates Suc 0))) =\n  lnths ?xs ?A\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> ?A) (lzip ?xs (iterates Suc 0))) =\n  lnths ?xs ?A\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"ldrop (enat k) (?it 0) = ?it k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat k) (iterates Suc 0) = iterates Suc k", "by(simp add: ldrop_iterates)"], ["proof (state)\nthis:\n  ldrop (enat k) (iterates Suc 0) = iterates Suc k\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  ldrop (enat k) (iterates Suc 0) = iterates Suc k\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "{"], ["proof (state)\nthis:\n  ldrop (enat k) (iterates Suc 0) = iterates Suc k\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "fix n m"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"?it (n + m) = lmap (\\<lambda>n. n + m) (?it n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterates Suc (n + m) = lmap (\\<lambda>n. n + m) (iterates Suc n)", "by(coinduction arbitrary: n)(force)+"], ["proof (state)\nthis:\n  iterates Suc (n + m) = lmap (\\<lambda>n. n + m) (iterates Suc n)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "}"], ["proof (state)\nthis:\n  iterates Suc (?n2 + ?m2) = lmap (\\<lambda>n. n + ?m2) (iterates Suc ?n2)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "from this[of 0 k]"], ["proof (chain)\npicking this:\n  iterates Suc (0 + k) = lmap (\\<lambda>n. n + k) (iterates Suc 0)", "have \"?it k = lmap (\\<lambda>n. n + k) (?it 0)\""], ["proof (prove)\nusing this:\n  iterates Suc (0 + k) = lmap (\\<lambda>n. n + k) (iterates Suc 0)\n\ngoal (1 subgoal):\n 1. iterates Suc k = lmap (\\<lambda>n. n + k) (iterates Suc 0)", "by simp"], ["proof (state)\nthis:\n  iterates Suc k = lmap (\\<lambda>n. n + k) (iterates Suc 0)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  iterates Suc k = lmap (\\<lambda>n. n + k) (iterates Suc 0)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lzip_lmap2"], ["proof (state)\nthis:\n  lzip ?xs (lmap ?f ?ys) = lmap (\\<lambda>(x, y). (x, ?f y)) (lzip ?xs ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lzip ?xs (lmap ?f ?ys) = lmap (\\<lambda>(x, y). (x, ?f y)) (lzip ?xs ?ys)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lfilter_lmap"], ["proof (state)\nthis:\n  lfilter ?P (lmap ?f ?xs) = lmap ?f (lfilter (?P \\<circ> ?f) ?xs)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lfilter ?P (lmap ?f ?xs) = lmap ?f (lfilter (?P \\<circ> ?f) ?xs)\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note llist.map_comp"], ["proof (state)\nthis:\n  lmap ?g (lmap ?f ?v) = lmap (?g \\<circ> ?f) ?v\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  lmap ?g (lmap ?f ?v) = lmap (?g \\<circ> ?f) ?v\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"fst \\<circ> (\\<lambda>(x, y). (x, y + k)) = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> (\\<lambda>(x, y). (x, y + k)) = fst", "by(simp add: o_def split_def)"], ["proof (state)\nthis:\n  fst \\<circ> (\\<lambda>(x, y). (x, y + k)) = fst\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  fst \\<circ> (\\<lambda>(x, y). (x, y + k)) = fst\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "have \"(\\<lambda>(x, y). y \\<in> A) \\<circ> (\\<lambda>(x, y). (x, y + k)) = (\\<lambda>(x, y). y \\<in> {n. n + k \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). y \\<in> A) \\<circ> (\\<lambda>(x, y). (x, y + k)) =\n    (\\<lambda>(x, y). y \\<in> {n. n + k \\<in> A})", "by(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). y \\<in> A) \\<circ> (\\<lambda>(x, y). (x, y + k)) =\n  (\\<lambda>(x, y). y \\<in> {n. n + k \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "also"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). y \\<in> A) \\<circ> (\\<lambda>(x, y). (x, y + k)) =\n  (\\<lambda>(x, y). y \\<in> {n. n + k \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "note lnths_def[symmetric]"], ["proof (state)\nthis:\n  lmap fst\n   (lfilter (\\<lambda>(x, y). y \\<in> ?A) (lzip ?xs (iterates Suc 0))) =\n  lnths ?xs ?A\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>llength xs = llength (ltake (enat k) (iterates Suc 0));\n   lfinite (lzip xs (ltake (enat k) (iterates Suc 0)))\\<rbrakk>\n  \\<Longrightarrow> lnths (lappend xs ys) A =\n                    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>llength xs = llength (ltake (enat k) (iterates Suc 0));\n   lfinite (lzip xs (ltake (enat k) (iterates Suc 0)))\\<rbrakk>\n  \\<Longrightarrow> lnths (lappend xs ys) A =\n                    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "using len"], ["proof (prove)\nusing this:\n  \\<lbrakk>llength xs = llength (ltake (enat k) (iterates Suc 0));\n   lfinite (lzip xs (ltake (enat k) (iterates Suc 0)))\\<rbrakk>\n  \\<Longrightarrow> lnths (lappend xs ys) A =\n                    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})\n  llength xs = enat k\n\ngoal (1 subgoal):\n 1. lnths (lappend xs ys) A =\n    lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})", "by simp"], ["proof (state)\nthis:\n  lnths (lappend xs ys) A =\n  lappend (lnths xs A) (lnths ys {n. n + k \\<in> A})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_split:\n  \"lnths xs A =\n   lappend (lnths (ltake (enat n) xs) A) (lnths (ldropn n xs) {m. n + m \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "proof(cases \"enat n \\<le> llength xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})\n 2. \\<not> enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "case False"], ["proof (state)\nthis:\n  \\<not> enat n \\<le> llength xs\n\ngoal (2 subgoals):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})\n 2. \\<not> enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> enat n \\<le> llength xs\n\ngoal (1 subgoal):\n 1. lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "by(auto simp add: ltake_all ldropn_all)"], ["proof (state)\nthis:\n  lnths xs A =\n  lappend (lnths (ltake (enat n) xs) A)\n   (lnths (ldropn n xs) {m. n + m \\<in> A})\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "case True"], ["proof (state)\nthis:\n  enat n \\<le> llength xs\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "have \"xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)", "by(simp only: lappend_ltake_ldrop)"], ["proof (state)\nthis:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "hence \"xs = lappend (ltake (enat n) xs) (ldropn n xs)\""], ["proof (prove)\nusing this:\n  xs = lappend (ltake (enat n) xs) (ldrop (enat n) xs)\n\ngoal (1 subgoal):\n 1. xs = lappend (ltake (enat n) xs) (ldropn n xs)", "by simp"], ["proof (state)\nthis:\n  xs = lappend (ltake (enat n) xs) (ldropn n xs)\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "hence \"lnths xs A = lnths (lappend (ltake (enat n) xs) (ldropn n xs)) A\""], ["proof (prove)\nusing this:\n  xs = lappend (ltake (enat n) xs) (ldropn n xs)\n\ngoal (1 subgoal):\n 1. lnths xs A = lnths (lappend (ltake (enat n) xs) (ldropn n xs)) A", "by(simp)"], ["proof (state)\nthis:\n  lnths xs A = lnths (lappend (ltake (enat n) xs) (ldropn n xs)) A\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "also"], ["proof (state)\nthis:\n  lnths xs A = lnths (lappend (ltake (enat n) xs) (ldropn n xs)) A\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "note lnths_lappend_lfinite[where k=n]"], ["proof (state)\nthis:\n  llength ?xs = enat n \\<Longrightarrow>\n  lnths (lappend ?xs ?ys) ?A =\n  lappend (lnths ?xs ?A) (lnths ?ys {na. na + n \\<in> ?A})\n\ngoal (1 subgoal):\n 1. enat n \\<le> llength xs \\<Longrightarrow>\n    lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "finally"], ["proof (chain)\npicking this:\n  llength (ltake (enat n) xs) = enat n \\<Longrightarrow>\n  lnths xs A =\n  lappend (lnths (ltake (enat n) xs) A)\n   (lnths (ldropn n xs) {na. na + n \\<in> A})", "show ?thesis"], ["proof (prove)\nusing this:\n  llength (ltake (enat n) xs) = enat n \\<Longrightarrow>\n  lnths xs A =\n  lappend (lnths (ltake (enat n) xs) A)\n   (lnths (ldropn n xs) {na. na + n \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "using True"], ["proof (prove)\nusing this:\n  llength (ltake (enat n) xs) = enat n \\<Longrightarrow>\n  lnths xs A =\n  lappend (lnths (ltake (enat n) xs) A)\n   (lnths (ldropn n xs) {na. na + n \\<in> A})\n  enat n \\<le> llength xs\n\ngoal (1 subgoal):\n 1. lnths xs A =\n    lappend (lnths (ltake (enat n) xs) A)\n     (lnths (ldropn n xs) {m. n + m \\<in> A})", "by(simp add: min_def ac_simps)"], ["proof (state)\nthis:\n  lnths xs A =\n  lappend (lnths (ltake (enat n) xs) A)\n   (lnths (ldropn n xs) {m. n + m \\<in> A})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_cong:\n  assumes \"xs = ys\" and A: \"\\<And>n. enat n < llength ys \\<Longrightarrow> n \\<in> A \\<longleftrightarrow> n \\<in> B\"\n  shows \"lnths xs A = lnths ys B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs A = lnths ys B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths xs A = lnths ys B", "have \"lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0)) =\n        lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0)) =\n    lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0))", "by(rule lfilter_cong[OF refl])(auto simp add: lset_lzip A)"], ["proof (state)\nthis:\n  lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0)) =\n  lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lnths xs A = lnths ys B", "thus ?thesis"], ["proof (prove)\nusing this:\n  lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0)) =\n  lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lnths xs A = lnths ys B", "unfolding \\<open>xs = ys\\<close> lnths_def"], ["proof (prove)\nusing this:\n  lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0)) =\n  lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0))\n\ngoal (1 subgoal):\n 1. lmap fst\n     (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip ys (iterates Suc 0))) =\n    lmap fst\n     (lfilter (\\<lambda>(x, y). y \\<in> B) (lzip ys (iterates Suc 0)))", "by simp"], ["proof (state)\nthis:\n  lnths xs A = lnths ys B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnths_insert:\n  assumes n: \"enat n < llength xs\"\n  shows \"lnths xs (insert n A) =\n         lappend (lnths (ltake (enat n) xs) A) (LCons (lnth xs n)\n                 (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "have \"lnths xs (insert n A) =\n        lappend (lnths (ltake (enat n) xs) (insert n A))\n                (lnths (ldropn n xs) {m. n + m \\<in> (insert n A)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) (insert n A))\n     (lnths (ldropn n xs) {m. n + m \\<in> insert n A})", "by(rule lnths_split)"], ["proof (state)\nthis:\n  lnths xs (insert n A) =\n  lappend (lnths (ltake (enat n) xs) (insert n A))\n   (lnths (ldropn n xs) {m. n + m \\<in> insert n A})\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "also"], ["proof (state)\nthis:\n  lnths xs (insert n A) =\n  lappend (lnths (ltake (enat n) xs) (insert n A))\n   (lnths (ldropn n xs) {m. n + m \\<in> insert n A})\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "have \"lnths (ltake (enat n) xs) (insert n A) =\n            lnths (ltake (enat n) xs) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnths (ltake (enat n) xs) (insert n A) = lnths (ltake (enat n) xs) A", "by(rule lnths_cong[OF refl]) simp"], ["proof (state)\nthis:\n  lnths (ltake (enat n) xs) (insert n A) = lnths (ltake (enat n) xs) A\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "also"], ["proof (state)\nthis:\n  lnths (ltake (enat n) xs) (insert n A) = lnths (ltake (enat n) xs) A\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "{"], ["proof (state)\nthis:\n  lnths (ltake (enat n) xs) (insert n A) = lnths (ltake (enat n) xs) A\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "from n"], ["proof (chain)\npicking this:\n  enat n < llength xs", "obtain X XS where \"ldropn n xs = LCons X XS\""], ["proof (prove)\nusing this:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. (\\<And>X XS.\n        ldropn n xs = LCons X XS \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"ldropn n xs\")(auto simp add: ldropn_eq_LNil)"], ["proof (state)\nthis:\n  ldropn n xs = LCons X XS\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "moreover"], ["proof (state)\nthis:\n  ldropn n xs = LCons X XS\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "have \"lnth (ldropn n xs) 0 = lnth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (ldropn n xs) 0 = lnth xs n", "using n"], ["proof (prove)\nusing this:\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. lnth (ldropn n xs) 0 = lnth xs n", "by(simp)"], ["proof (state)\nthis:\n  lnth (ldropn n xs) 0 = lnth xs n\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "moreover"], ["proof (state)\nthis:\n  lnth (ldropn n xs) 0 = lnth xs n\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "have \"ltl (ldropn n xs) = ldropn (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (ldropn n xs) = ldropn (Suc n) xs", "by(cases xs)(simp_all add: ltl_ldropn)"], ["proof (state)\nthis:\n  ltl (ldropn n xs) = ldropn (Suc n) xs\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "ultimately"], ["proof (chain)\npicking this:\n  ldropn n xs = LCons X XS\n  lnth (ldropn n xs) 0 = lnth xs n\n  ltl (ldropn n xs) = ldropn (Suc n) xs", "have \"ldropn n xs = LCons (lnth xs n) (ldropn (Suc n) xs)\""], ["proof (prove)\nusing this:\n  ldropn n xs = LCons X XS\n  lnth (ldropn n xs) 0 = lnth xs n\n  ltl (ldropn n xs) = ldropn (Suc n) xs\n\ngoal (1 subgoal):\n 1. ldropn n xs = LCons (lnth xs n) (ldropn (Suc n) xs)", "by simp"], ["proof (state)\nthis:\n  ldropn n xs = LCons (lnth xs n) (ldropn (Suc n) xs)\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "hence \"lnths (ldropn n xs) {m. n + m \\<in> insert n A} =\n           LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A})\""], ["proof (prove)\nusing this:\n  ldropn n xs = LCons (lnth xs n) (ldropn (Suc n) xs)\n\ngoal (1 subgoal):\n 1. lnths (ldropn n xs) {m. n + m \\<in> insert n A} =\n    LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A})", "by(simp add: lnths_LCons)"], ["proof (state)\nthis:\n  lnths (ldropn n xs) {m. n + m \\<in> insert n A} =\n  LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "}"], ["proof (state)\nthis:\n  lnths (ldropn n xs) {m. n + m \\<in> insert n A} =\n  LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A})\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "finally"], ["proof (chain)\npicking this:\n  lnths xs (insert n A) =\n  lappend (lnths (ltake (enat n) xs) A)\n   (LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "show ?thesis"], ["proof (prove)\nusing this:\n  lnths xs (insert n A) =\n  lappend (lnths (ltake (enat n) xs) A)\n   (LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))\n\ngoal (1 subgoal):\n 1. lnths xs (insert n A) =\n    lappend (lnths (ltake (enat n) xs) A)\n     (LCons (lnth xs n)\n       (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))", "."], ["proof (state)\nthis:\n  lnths xs (insert n A) =\n  lappend (lnths (ltake (enat n) xs) A)\n   (LCons (lnth xs n) (lnths (ldropn (Suc n) xs) {m. Suc (n + m) \\<in> A}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfinite_lnths [simp]:\n  \"lfinite (lnths xs A) \\<longleftrightarrow> lfinite xs \\<or> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lnths xs A) = (lfinite xs \\<or> finite A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite (lnths xs A) \\<Longrightarrow> lfinite xs \\<or> finite A\n 2. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "assume \"lfinite (lnths xs A)\""], ["proof (state)\nthis:\n  lfinite (lnths xs A)\n\ngoal (2 subgoals):\n 1. lfinite (lnths xs A) \\<Longrightarrow> lfinite xs \\<or> finite A\n 2. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "hence \"lfinite xs \\<or>\n         finite {n. enat n < llength xs \\<and> (\\<lambda>(x, y). y \\<in> A) (lnth (lzip xs (iterates Suc 0)) n)}\""], ["proof (prove)\nusing this:\n  lfinite (lnths xs A)\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or>\n    finite\n     {n. enat n < llength xs \\<and>\n         (case lnth (lzip xs (iterates Suc 0)) n of\n          (x, y) \\<Rightarrow> y \\<in> A)}", "by(simp add: lnths_def lfinite_lfilter)"], ["proof (state)\nthis:\n  lfinite xs \\<or>\n  finite\n   {n. enat n < llength xs \\<and>\n       (case lnth (lzip xs (iterates Suc 0)) n of\n        (x, y) \\<Rightarrow> y \\<in> A)}\n\ngoal (2 subgoals):\n 1. lfinite (lnths xs A) \\<Longrightarrow> lfinite xs \\<or> finite A\n 2. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "also"], ["proof (state)\nthis:\n  lfinite xs \\<or>\n  finite\n   {n. enat n < llength xs \\<and>\n       (case lnth (lzip xs (iterates Suc 0)) n of\n        (x, y) \\<Rightarrow> y \\<in> A)}\n\ngoal (2 subgoals):\n 1. lfinite (lnths xs A) \\<Longrightarrow> lfinite xs \\<or> finite A\n 2. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "have \"{n. enat n < llength xs \\<and> (\\<lambda>(x, y). y \\<in> A) (lnth (lzip xs (iterates Suc 0)) n)} =\n            {n. enat n < llength xs \\<and> n \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. enat n < llength xs \\<and>\n        (case lnth (lzip xs (iterates Suc 0)) n of\n         (x, y) \\<Rightarrow> y \\<in> A)} =\n    {n. enat n < llength xs \\<and> n \\<in> A}", "by(auto simp add: lnth_lzip)"], ["proof (state)\nthis:\n  {n. enat n < llength xs \\<and>\n      (case lnth (lzip xs (iterates Suc 0)) n of\n       (x, y) \\<Rightarrow> y \\<in> A)} =\n  {n. enat n < llength xs \\<and> n \\<in> A}\n\ngoal (2 subgoals):\n 1. lfinite (lnths xs A) \\<Longrightarrow> lfinite xs \\<or> finite A\n 2. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "finally"], ["proof (chain)\npicking this:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> n \\<in> A}", "show \"lfinite xs \\<or> finite A\""], ["proof (prove)\nusing this:\n  lfinite xs \\<or> finite {n. enat n < llength xs \\<and> n \\<in> A}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A", "by(auto simp add: not_lfinite_llength elim: contrapos_np)"], ["proof (state)\nthis:\n  lfinite xs \\<or> finite A\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "assume \"lfinite xs \\<or> finite A\""], ["proof (state)\nthis:\n  lfinite xs \\<or> finite A\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "moreover"], ["proof (state)\nthis:\n  lfinite xs \\<or> finite A\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "have \"{n. enat n < llength xs \\<and> (\\<lambda>(x, y). y \\<in> A) (lnth (lzip xs (iterates Suc 0)) n)} =\n        {n. enat n < llength xs \\<and> n \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. enat n < llength xs \\<and>\n        (case lnth (lzip xs (iterates Suc 0)) n of\n         (x, y) \\<Rightarrow> y \\<in> A)} =\n    {n. enat n < llength xs \\<and> n \\<in> A}", "by(auto simp add: lnth_lzip)"], ["proof (state)\nthis:\n  {n. enat n < llength xs \\<and>\n      (case lnth (lzip xs (iterates Suc 0)) n of\n       (x, y) \\<Rightarrow> y \\<in> A)} =\n  {n. enat n < llength xs \\<and> n \\<in> A}\n\ngoal (1 subgoal):\n 1. lfinite xs \\<or> finite A \\<Longrightarrow> lfinite (lnths xs A)", "ultimately"], ["proof (chain)\npicking this:\n  lfinite xs \\<or> finite A\n  {n. enat n < llength xs \\<and>\n      (case lnth (lzip xs (iterates Suc 0)) n of\n       (x, y) \\<Rightarrow> y \\<in> A)} =\n  {n. enat n < llength xs \\<and> n \\<in> A}", "show \"lfinite (lnths xs A)\""], ["proof (prove)\nusing this:\n  lfinite xs \\<or> finite A\n  {n. enat n < llength xs \\<and>\n      (case lnth (lzip xs (iterates Suc 0)) n of\n       (x, y) \\<Rightarrow> y \\<in> A)} =\n  {n. enat n < llength xs \\<and> n \\<in> A}\n\ngoal (1 subgoal):\n 1. lfinite (lnths xs A)", "by(auto simp add: lnths_def lfinite_lfilter)"], ["proof (state)\nthis:\n  lfinite (lnths xs A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{const \"lsum_list\"}\\<close>"], ["", "context monoid_add begin"], ["", "lemma lsum_list_0 [simp]: \"lsum_list (lmap (\\<lambda>_. 0) xs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsum_list (lmap (\\<lambda>_. 0::'a) xs) = (0::'a)", "by(simp add: lsum_list_def)"], ["", "lemma lsum_list_llist_of [simp]: \"lsum_list (llist_of xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsum_list (llist_of xs) = sum_list xs", "by(simp add: lsum_list_def)"], ["", "lemma lsum_list_lappend: \"\\<lbrakk> lfinite xs; lfinite ys \\<rbrakk> \\<Longrightarrow> lsum_list (lappend xs ys) = lsum_list xs + lsum_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite xs; lfinite ys\\<rbrakk>\n    \\<Longrightarrow> lsum_list (lappend xs ys) =\n                      lsum_list xs + lsum_list ys", "by(simp add: lsum_list_def list_of_lappend)"], ["", "lemma lsum_list_LNil [simp]: \"lsum_list LNil = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsum_list LNil = (0::'a)", "by(simp add: lsum_list_def)"], ["", "lemma lsum_list_LCons [simp]: \"lfinite xs \\<Longrightarrow> lsum_list (LCons x xs) = x + lsum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs \\<Longrightarrow> lsum_list (LCons x xs) = x + lsum_list xs", "by(simp add: lsum_list_def)"], ["", "lemma lsum_list_inf [simp]: \"\\<not> lfinite xs \\<Longrightarrow> lsum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lsum_list xs = (0::'a)", "by(simp add: lsum_list_def)"], ["", "end"], ["", "lemma lsum_list_mono:\n  fixes f :: \"'a \\<Rightarrow> 'b :: {monoid_add, ordered_ab_semigroup_add}\"\n  assumes \"\\<And>x. x \\<in> lset xs \\<Longrightarrow> f x \\<le> g x\"\n  shows \"lsum_list (lmap f xs) \\<le> lsum_list (lmap g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsum_list (lmap f xs) \\<le> lsum_list (lmap g xs)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> lset xs \\<Longrightarrow> f ?x \\<le> g ?x\n\ngoal (1 subgoal):\n 1. lsum_list (lmap f xs) \\<le> lsum_list (lmap g xs)", "by(auto simp add: lsum_list_def intro: sum_list_mono)"], ["", "subsection \\<open>\n  Alternative view on @{typ \"'a llist\"} as datatype\n  with constructors @{term \"llist_of\"} and @{term \"inf_llist\"}\n\\<close>"], ["", "lemma lnull_inf_llist [simp]: \"\\<not> lnull (inf_llist f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull (inf_llist f)", "by(simp add: inf_llist_def)"], ["", "lemma inf_llist_neq_LNil: \"inf_llist f \\<noteq> LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_llist f \\<noteq> LNil", "using lnull_inf_llist"], ["proof (prove)\nusing this:\n  \\<not> lnull (inf_llist ?f)\n\ngoal (1 subgoal):\n 1. inf_llist f \\<noteq> LNil", "unfolding lnull_def"], ["proof (prove)\nusing this:\n  inf_llist ?f \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. inf_llist f \\<noteq> LNil", "."], ["", "lemmas LNil_neq_inf_llist = inf_llist_neq_LNil[symmetric]"], ["", "lemma lhd_inf_llist [simp]: \"lhd (inf_llist f) = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (inf_llist f) = f 0", "by(simp add: inf_llist_def)"], ["", "lemma ltl_inf_llist [simp]: \"ltl (inf_llist f) = inf_llist (\\<lambda>n. f (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (inf_llist f) = inf_llist (\\<lambda>n. f (Suc n))", "by(simp add: inf_llist_def lmap_iterates[symmetric] llist.map_comp)"], ["", "lemma inf_llist_rec [code, nitpick_simp]:\n  \"inf_llist f = LCons (f 0) (inf_llist (\\<lambda>n. f (Suc n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_llist f = LCons (f 0) (inf_llist (\\<lambda>n. f (Suc n)))", "by(rule llist.expand) simp_all"], ["", "lemma lfinite_inf_llist [iff]: \"\\<not> lfinite (inf_llist f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (inf_llist f)", "by(simp add: inf_llist_def)"], ["", "lemma iterates_conv_inf_llist:\n  \"iterates f a = inf_llist (\\<lambda>n. (f ^^ n) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterates f a = inf_llist (\\<lambda>n. (f ^^ n) a)", "by(coinduction arbitrary: a)(auto simp add: funpow_swap1)"], ["", "lemma inf_llist_neq_llist_of [simp]:\n  \"llist_of xs \\<noteq> inf_llist f\"\n   \"inf_llist f \\<noteq> llist_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of xs \\<noteq> inf_llist f &&& inf_llist f \\<noteq> llist_of xs", "using lfinite_llist_of[of xs] lfinite_inf_llist[of f]"], ["proof (prove)\nusing this:\n  lfinite (llist_of xs)\n  \\<not> lfinite (inf_llist f)\n\ngoal (1 subgoal):\n 1. llist_of xs \\<noteq> inf_llist f &&& inf_llist f \\<noteq> llist_of xs", "by fastforce+"], ["", "lemma lnth_inf_llist [simp]: \"lnth (inf_llist f) n = f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (inf_llist f) n = f n", "proof(induct n arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. lnth (inf_llist f) 0 = f 0\n 2. \\<And>n f.\n       (\\<And>f. lnth (inf_llist f) n = f n) \\<Longrightarrow>\n       lnth (inf_llist f) (Suc n) = f (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f. lnth (inf_llist f) 0 = f 0\n 2. \\<And>n f.\n       (\\<And>f. lnth (inf_llist f) n = f n) \\<Longrightarrow>\n       lnth (inf_llist f) (Suc n) = f (Suc n)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (inf_llist f) 0 = f 0", "by(subst inf_llist_rec) simp"], ["proof (state)\nthis:\n  lnth (inf_llist f) 0 = f 0\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f. lnth (inf_llist f) n = f n) \\<Longrightarrow>\n       lnth (inf_llist f) (Suc n) = f (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f. lnth (inf_llist f) n = f n) \\<Longrightarrow>\n       lnth (inf_llist f) (Suc n) = f (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  lnth (inf_llist ?f) n = ?f n\n\ngoal (1 subgoal):\n 1. \\<And>n f.\n       (\\<And>f. lnth (inf_llist f) n = f n) \\<Longrightarrow>\n       lnth (inf_llist f) (Suc n) = f (Suc n)", "from Suc[of \"\\<lambda>n. f (Suc n)\"]"], ["proof (chain)\npicking this:\n  lnth (inf_llist (\\<lambda>a. f (Suc a))) n = f (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  lnth (inf_llist (\\<lambda>a. f (Suc a))) n = f (Suc n)\n\ngoal (1 subgoal):\n 1. lnth (inf_llist f) (Suc n) = f (Suc n)", "by(subst inf_llist_rec) simp"], ["proof (state)\nthis:\n  lnth (inf_llist f) (Suc n) = f (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_llist_lprefix [simp]: \"inf_llist f \\<sqsubseteq> xs \\<longleftrightarrow> xs = inf_llist f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_llist f \\<sqsubseteq> xs = (xs = inf_llist f)", "by(auto simp add: not_lfinite_lprefix_conv_eq)"], ["", "lemma llength_inf_llist [simp]: \"llength (inf_llist f) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (inf_llist f) = \\<infinity>", "by(simp add: inf_llist_def)"], ["", "lemma lset_inf_llist [simp]: \"lset (inf_llist f) = range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (inf_llist f) = range f", "by(auto simp add: lset_conv_lnth)"], ["", "lemma inf_llist_inj [simp]:\n  \"inf_llist f = inf_llist g \\<longleftrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inf_llist f = inf_llist g) = (f = g)", "unfolding inf_llist_def lmap_eq_lmap_conv_llist_all2"], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 (\\<lambda>x y. f x = g y) (iterates Suc 0) (iterates Suc 0) =\n    (f = g)", "by(simp add: iterates_conv_inf_llist fun_eq_iff)"], ["", "lemma inf_llist_lnth [simp]: \"\\<not> lfinite xs \\<Longrightarrow> inf_llist (lnth xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> inf_llist (lnth xs) = xs", "by(coinduction arbitrary: xs)(auto simp add: lnth_0_conv_lhd fun_eq_iff lnth_ltl)"], ["", "lemma llist_exhaust:\n  obtains (llist_of) ys where \"xs = llist_of ys\"\n       | (inf_llist) f where \"xs = inf_llist f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis; lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis; lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "obtain ys where \"xs = llist_of ys\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lfinite_eq_range_llist_of"], ["proof (prove)\nusing this:\n  xs \\<in> range llist_of\n\ngoal (1 subgoal):\n 1. (\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = llist_of ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis; lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = llist_of ys\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"xs = inf_llist (lnth xs)\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. xs = inf_llist (lnth xs)", "by simp"], ["proof (state)\nthis:\n  xs = inf_llist (lnth xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys. xs = llist_of ys \\<Longrightarrow> thesis;\n     \\<And>f. xs = inf_llist f \\<Longrightarrow> thesis;\n     \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  xs = inf_llist (lnth xs)\n\ngoal (1 subgoal):\n 1. thesis", "by(rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lappend_inf_llist [simp]: \"lappend (inf_llist f) xs = inf_llist f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (inf_llist f) xs = inf_llist f", "by(simp add: lappend_inf)"], ["", "lemma lmap_inf_llist [simp]:\n  \"lmap f (inf_llist g) = inf_llist (f o g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (inf_llist g) = inf_llist (f \\<circ> g)", "by(simp add: inf_llist_def llist.map_comp)"], ["", "lemma ltake_enat_inf_llist [simp]:\n  \"ltake (enat n) (inf_llist f) = llist_of (map f [0..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat n) (inf_llist f) = llist_of (map f [0..<n])", "by(simp add: inf_llist_def ltake_iterates_Suc)"], ["", "lemma ldropn_inf_llist [simp]:\n  \"ldropn n (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))", "unfolding inf_llist_def ldropn_lmap ldropn_iterates"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (iterates Suc ((Suc ^^ n) 0)) =\n    lmap (\\<lambda>m. f (m + n)) (iterates Suc 0)", "by(simp add: iterates_conv_inf_llist o_def)"], ["", "lemma ldrop_enat_inf_llist:\n  \"ldrop (enat n) (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat n) (inf_llist f) = inf_llist (\\<lambda>m. f (m + n))", "proof(induct n arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       ldrop (enat 0) (inf_llist f) = inf_llist (\\<lambda>m. f (m + 0))\n 2. \\<And>n f.\n       (\\<And>f.\n           ldrop (enat n) (inf_llist f) =\n           inf_llist (\\<lambda>m. f (m + n))) \\<Longrightarrow>\n       ldrop (enat (Suc n)) (inf_llist f) =\n       inf_llist (\\<lambda>m. f (m + Suc n))", "case Suc"], ["proof (state)\nthis:\n  ldrop (enat n_) (inf_llist ?f) = inf_llist (\\<lambda>m. ?f (m + n_))\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       ldrop (enat 0) (inf_llist f) = inf_llist (\\<lambda>m. f (m + 0))\n 2. \\<And>n f.\n       (\\<And>f.\n           ldrop (enat n) (inf_llist f) =\n           inf_llist (\\<lambda>m. f (m + n))) \\<Longrightarrow>\n       ldrop (enat (Suc n)) (inf_llist f) =\n       inf_llist (\\<lambda>m. f (m + Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  ldrop (enat n_) (inf_llist ?f) = inf_llist (\\<lambda>m. ?f (m + n_))\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc n_)) (inf_llist f) =\n    inf_llist (\\<lambda>m. f (m + Suc n_))", "by(subst inf_llist_rec)(simp add: eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  ldrop (enat (Suc n_)) (inf_llist f) =\n  inf_llist (\\<lambda>m. f (m + Suc n_))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       ldrop (enat 0) (inf_llist f) = inf_llist (\\<lambda>m. f (m + 0))", "qed(simp add: zero_enat_def[symmetric])"], ["", "lemma lzip_inf_llist_inf_llist [simp]:\n  \"lzip (inf_llist f) (inf_llist g) = inf_llist (\\<lambda>n. (f n, g n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (inf_llist f) (inf_llist g) = inf_llist (\\<lambda>n. (f n, g n))", "by(coinduction arbitrary: f g) auto"], ["", "lemma lzip_llist_of_inf_llist [simp]:\n  \"lzip (llist_of xs) (inf_llist f) = llist_of (zip xs (map f [0..<length xs]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (llist_of xs) (inf_llist f) =\n    llist_of (zip xs (map f [0..<length xs]))", "proof(induct xs arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       lzip (llist_of []) (inf_llist f) =\n       llist_of (zip [] (map f [0..<length []]))\n 2. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f.\n       lzip (llist_of []) (inf_llist f) =\n       llist_of (zip [] (map f [0..<length []]))\n 2. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (llist_of []) (inf_llist f) =\n    llist_of (zip [] (map f [0..<length []]))", "by simp"], ["proof (state)\nthis:\n  lzip (llist_of []) (inf_llist f) =\n  llist_of (zip [] (map f [0..<length []]))\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "case (Cons x xs)"], ["proof (state)\nthis:\n  lzip (llist_of xs) (inf_llist ?f) =\n  llist_of (zip xs (map ?f [0..<length xs]))\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "have \"map f [0..<length (x # xs)] = f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<length (x # xs)] =\n    f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]", "by(simp add: upt_conv_Cons map_Suc_upt[symmetric] del: upt_Suc)"], ["proof (state)\nthis:\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (llist_of xs) (inf_llist f) =\n           llist_of (zip xs (map f [0..<length xs]))) \\<Longrightarrow>\n       lzip (llist_of (a # xs)) (inf_llist f) =\n       llist_of (zip (a # xs) (map f [0..<length (a # xs)]))", "with Cons[of \"\\<lambda>n. f (Suc n)\"]"], ["proof (chain)\npicking this:\n  lzip (llist_of xs) (inf_llist (\\<lambda>a. f (Suc a))) =\n  llist_of (zip xs (map (\\<lambda>a. f (Suc a)) [0..<length xs]))\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]", "show ?case"], ["proof (prove)\nusing this:\n  lzip (llist_of xs) (inf_llist (\\<lambda>a. f (Suc a))) =\n  llist_of (zip xs (map (\\<lambda>a. f (Suc a)) [0..<length xs]))\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. lzip (llist_of (x # xs)) (inf_llist f) =\n    llist_of (zip (x # xs) (map f [0..<length (x # xs)]))", "by(subst inf_llist_rec)(simp)"], ["proof (state)\nthis:\n  lzip (llist_of (x # xs)) (inf_llist f) =\n  llist_of (zip (x # xs) (map f [0..<length (x # xs)]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lzip_inf_llist_llist_of [simp]:\n  \"lzip (inf_llist f) (llist_of xs) = llist_of (zip (map f [0..<length xs]) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (inf_llist f) (llist_of xs) =\n    llist_of (zip (map f [0..<length xs]) xs)", "proof(induct xs arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       lzip (inf_llist f) (llist_of []) =\n       llist_of (zip (map f [0..<length []]) [])\n 2. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f.\n       lzip (inf_llist f) (llist_of []) =\n       llist_of (zip (map f [0..<length []]) [])\n 2. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (inf_llist f) (llist_of []) =\n    llist_of (zip (map f [0..<length []]) [])", "by simp"], ["proof (state)\nthis:\n  lzip (inf_llist f) (llist_of []) =\n  llist_of (zip (map f [0..<length []]) [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  lzip (inf_llist ?f) (llist_of xs) =\n  llist_of (zip (map ?f [0..<length xs]) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "have \"map f [0..<length (x # xs)] = f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<length (x # xs)] =\n    f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]", "by(simp add: upt_conv_Cons map_Suc_upt[symmetric] del: upt_Suc)"], ["proof (state)\nthis:\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       (\\<And>f.\n           lzip (inf_llist f) (llist_of xs) =\n           llist_of (zip (map f [0..<length xs]) xs)) \\<Longrightarrow>\n       lzip (inf_llist f) (llist_of (a # xs)) =\n       llist_of (zip (map f [0..<length (a # xs)]) (a # xs))", "with Cons[of \"\\<lambda>n. f (Suc n)\"]"], ["proof (chain)\npicking this:\n  lzip (inf_llist (\\<lambda>a. f (Suc a))) (llist_of xs) =\n  llist_of (zip (map (\\<lambda>a. f (Suc a)) [0..<length xs]) xs)\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]", "show ?case"], ["proof (prove)\nusing this:\n  lzip (inf_llist (\\<lambda>a. f (Suc a))) (llist_of xs) =\n  llist_of (zip (map (\\<lambda>a. f (Suc a)) [0..<length xs]) xs)\n  map f [0..<length (x # xs)] =\n  f 0 # map (\\<lambda>n. f (Suc n)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. lzip (inf_llist f) (llist_of (x # xs)) =\n    llist_of (zip (map f [0..<length (x # xs)]) (x # xs))", "by(subst inf_llist_rec)(simp)"], ["proof (state)\nthis:\n  lzip (inf_llist f) (llist_of (x # xs)) =\n  llist_of (zip (map f [0..<length (x # xs)]) (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_inf_llist [simp]:\n  \"llist_all2 P (inf_llist f) (inf_llist g) \\<longleftrightarrow> (\\<forall>n. P (f n) (g n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (inf_llist f) (inf_llist g) = (\\<forall>n. P (f n) (g n))", "by(simp add: llist_all2_conv_lzip)"], ["", "lemma llist_all2_llist_of_inf_llist [simp]:\n  \"\\<not> llist_all2 P (llist_of xs) (inf_llist f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> llist_all2 P (llist_of xs) (inf_llist f)", "by(simp add: llist_all2_conv_lzip)"], ["", "lemma llist_all2_inf_llist_llist_of [simp]:\n  \"\\<not> llist_all2 P (inf_llist f) (llist_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> llist_all2 P (inf_llist f) (llist_of xs)", "by(simp add: llist_all2_conv_lzip)"], ["", "lemma (in monoid_add) lsum_list_infllist: \"lsum_list (inf_llist f) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsum_list (inf_llist f) = (0::'a)", "by simp"], ["", "subsection \\<open>Setup for lifting and transfer\\<close>"], ["", "subsubsection \\<open>Relator and predicator properties\\<close>"], ["", "abbreviation \"llist_all == pred_llist\""], ["", "subsubsection \\<open>Transfer rules for the Transfer package\\<close>"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma set1_pre_llist_transfer [transfer_rule]:\n  \"(rel_pre_llist A B ===> rel_set A) set1_pre_llist set1_pre_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pre_llist A B ===> rel_set A) set1_pre_llist set1_pre_llist", "by(auto simp add: rel_pre_llist_def vimage2p_def rel_fun_def set1_pre_llist_def rel_set_def collect_def sum_set_defs prod_set_defs elim: rel_sum.cases split: sum.split_asm)"], ["", "lemma set2_pre_llist_transfer [transfer_rule]:\n  \"(rel_pre_llist A B ===> rel_set B) set2_pre_llist set2_pre_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pre_llist A B ===> rel_set B) set2_pre_llist set2_pre_llist", "by(auto simp add: rel_pre_llist_def vimage2p_def rel_fun_def set2_pre_llist_def rel_set_def collect_def sum_set_defs prod_set_defs elim: rel_sum.cases split: sum.split_asm)"], ["", "lemma LNil_transfer [transfer_rule]: \"llist_all2 P LNil LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P LNil LNil", "by simp"], ["", "lemma LCons_transfer [transfer_rule]:\n  \"(A ===> llist_all2 A ===> llist_all2 A) LCons LCons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> llist_all2 A ===> llist_all2 A) LCons LCons", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       A x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           llist_all2 A xa ya \\<longrightarrow>\n           llist_all2 A (LCons x xa) (LCons y ya))", "by simp"], ["", "lemma case_llist_transfer [transfer_rule]:\n  \"(B ===> (A ===> llist_all2 A ===> B) ===> llist_all2 A ===> B)\n    case_llist case_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> (A ===> llist_all2 A ===> B) ===> llist_all2 A ===> B)\n     case_llist case_llist", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       B x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               A x y \\<longrightarrow>\n               (\\<forall>xaa yaa.\n                   llist_all2 A xaa yaa \\<longrightarrow>\n                   B (xa x xaa) (ya y yaa))) \\<longrightarrow>\n           (\\<forall>xaa yaa.\n               llist_all2 A xaa yaa \\<longrightarrow>\n               B (case xaa of LNil \\<Rightarrow> x\n                  | LCons x xb \\<Rightarrow> xa x xb)\n                (case yaa of LNil \\<Rightarrow> y\n                 | LCons x xa \\<Rightarrow> ya x xa)))", "by (simp split: llist.split)"], ["", "lemma unfold_llist_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> A) ===> A ===> llist_all2 B) unfold_llist unfold_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> (A ===> B) ===> (A ===> A) ===> A ===> llist_all2 B)\n     unfold_llist unfold_llist", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> A) xb yb;\n        A xc yc\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (unfold_llist x xa xb xc)\n                          (unfold_llist y ya yb yc)", "fix IS_LNIL1 :: \"'a \\<Rightarrow> bool\" and IS_LNIL2 LHD1 LHD2 LTL1 LTL2 x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> A) xb yb;\n        A xc yc\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (unfold_llist x xa xb xc)\n                          (unfold_llist y ya yb yc)", "assume rel: \"(A ===> (=)) IS_LNIL1 IS_LNIL2\" \"(A ===> B) LHD1 LHD2\" \"(A ===> A) LTL1 LTL2\"\n    and \"A x y\""], ["proof (state)\nthis:\n  (A ===> (=)) IS_LNIL1 IS_LNIL2\n  (A ===> B) LHD1 LHD2\n  (A ===> A) LTL1 LTL2\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> A) xb yb;\n        A xc yc\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (unfold_llist x xa xb xc)\n                          (unfold_llist y ya yb yc)", "from \\<open>A x y\\<close>"], ["proof (chain)\npicking this:\n  A x y", "show \"llist_all2 B (unfold_llist IS_LNIL1 LHD1 LTL1 x) (unfold_llist IS_LNIL2 LHD2 LTL2 y)\""], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. llist_all2 B (unfold_llist IS_LNIL1 LHD1 LTL1 x)\n     (unfold_llist IS_LNIL2 LHD2 LTL2 y)", "apply(coinduction arbitrary: x y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       lnull (unfold_llist IS_LNIL1 LHD1 LTL1 x) =\n       lnull (unfold_llist IS_LNIL2 LHD2 LTL2 y)\n 2. \\<And>x y.\n       \\<lbrakk>A x y; \\<not> lnull (unfold_llist IS_LNIL1 LHD1 LTL1 x);\n        \\<not> lnull (unfold_llist IS_LNIL2 LHD2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (unfold_llist IS_LNIL1 LHD1 LTL1 x))\n                          (lhd (unfold_llist IS_LNIL2 LHD2 LTL2 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (unfold_llist IS_LNIL1 LHD1 LTL1 x) =\n                              unfold_llist IS_LNIL1 LHD1 LTL1 xa \\<and>\n                              ltl (unfold_llist IS_LNIL2 LHD2 LTL2 y) =\n                              unfold_llist IS_LNIL2 LHD2 LTL2 ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (unfold_llist IS_LNIL1 LHD1 LTL1 x))\n                           (ltl (unfold_llist IS_LNIL2 LHD2 LTL2 y)))", "using rel"], ["proof (prove)\nusing this:\n  (A ===> (=)) IS_LNIL1 IS_LNIL2\n  (A ===> B) LHD1 LHD2\n  (A ===> A) LTL1 LTL2\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       lnull (unfold_llist IS_LNIL1 LHD1 LTL1 x) =\n       lnull (unfold_llist IS_LNIL2 LHD2 LTL2 y)\n 2. \\<And>x y.\n       \\<lbrakk>A x y; \\<not> lnull (unfold_llist IS_LNIL1 LHD1 LTL1 x);\n        \\<not> lnull (unfold_llist IS_LNIL2 LHD2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (unfold_llist IS_LNIL1 LHD1 LTL1 x))\n                          (lhd (unfold_llist IS_LNIL2 LHD2 LTL2 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (unfold_llist IS_LNIL1 LHD1 LTL1 x) =\n                              unfold_llist IS_LNIL1 LHD1 LTL1 xa \\<and>\n                              ltl (unfold_llist IS_LNIL2 LHD2 LTL2 y) =\n                              unfold_llist IS_LNIL2 LHD2 LTL2 ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (unfold_llist IS_LNIL1 LHD1 LTL1 x))\n                           (ltl (unfold_llist IS_LNIL2 LHD2 LTL2 y)))", "by(auto 4 4 elim: rel_funE)"], ["proof (state)\nthis:\n  llist_all2 B (unfold_llist IS_LNIL1 LHD1 LTL1 x)\n   (unfold_llist IS_LNIL2 LHD2 LTL2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_corec_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> (A ===> B) ===> (A ===> (=)) ===> (A ===> llist_all2 B) ===> (A ===> A) ===> A ===> llist_all2 B) corec_llist corec_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===>\n     (A ===> B) ===>\n     (A ===> (=)) ===>\n     (A ===> llist_all2 B) ===> (A ===> A) ===> A ===> llist_all2 B)\n     corec_llist corec_llist", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> (=)) xb yb;\n        (A ===> llist_all2 B) xc yc; (A ===> A) xd yd; A xe ye\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (corec_llist x xa xb xc xd xe)\n                          (corec_llist y ya yb yc yd ye)", "fix IS_LNIL1 :: \"'a \\<Rightarrow> bool\" and IS_LNIL2 LHD1 LHD2\n    and STOP1 :: \"'a \\<Rightarrow> bool\" and STOP2 MORE1 MORE2 LTL1 LTL2 x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> (=)) xb yb;\n        (A ===> llist_all2 B) xc yc; (A ===> A) xd yd; A xe ye\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (corec_llist x xa xb xc xd xe)\n                          (corec_llist y ya yb yc yd ye)", "assume [transfer_rule]: \"(A ===> (=)) IS_LNIL1 IS_LNIL2 \" \"(A ===> B) LHD1 LHD2\"\n    \"(A ===> (=)) STOP1 STOP2\" \"(A ===> llist_all2 B) MORE1 MORE2\" \"(A ===> A) LTL1 LTL2\""], ["proof (state)\nthis:\n  (A ===> (=)) IS_LNIL1 IS_LNIL2\n  (A ===> B) LHD1 LHD2\n  (A ===> (=)) STOP1 STOP2\n  (A ===> llist_all2 B) MORE1 MORE2\n  (A ===> A) LTL1 LTL2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> (=)) xb yb;\n        (A ===> llist_all2 B) xc yc; (A ===> A) xd yd; A xe ye\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (corec_llist x xa xb xc xd xe)\n                          (corec_llist y ya yb yc yd ye)", "assume \"A x y\""], ["proof (state)\nthis:\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye.\n       \\<lbrakk>(A ===> (=)) x y; (A ===> B) xa ya; (A ===> (=)) xb yb;\n        (A ===> llist_all2 B) xc yc; (A ===> A) xd yd; A xe ye\\<rbrakk>\n       \\<Longrightarrow> llist_all2 B (corec_llist x xa xb xc xd xe)\n                          (corec_llist y ya yb yc yd ye)", "thus \"llist_all2 B (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\""], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. llist_all2 B (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x)\n     (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)", "proof(coinduction arbitrary: x y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n       lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\n 2. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "case [transfer_rule]: (LNil x y)"], ["proof (state)\nthis:\n  A x y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       A x y \\<Longrightarrow>\n       lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n       lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\n 2. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n    lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)", "by simp transfer_prover"], ["proof (state)\nthis:\n  lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n  lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "case (LCons x y)"], ["proof (state)\nthis:\n  A x y\n  \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x)\n  \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "note [transfer_rule] = \\<open>A x y\\<close>"], ["proof (state)\nthis:\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "have ?lhd"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n     (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))", "by(simp add: LCons[simplified]) transfer_prover"], ["proof (state)\nthis:\n  B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "moreover"], ["proof (state)\nthis:\n  B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "have \"STOP1 x = STOP2 y\" \"llist_all2 B (MORE1 x) (MORE2 y)\" \"A (LTL1 x) (LTL2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STOP1 x = STOP2 y &&&\n    llist_all2 B (MORE1 x) (MORE2 y) &&& A (LTL1 x) (LTL2 y)", "by transfer_prover+"], ["proof (state)\nthis:\n  STOP1 x = STOP2 y\n  llist_all2 B (MORE1 x) (MORE2 y)\n  A (LTL1 x) (LTL2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "hence ?ltl"], ["proof (prove)\nusing this:\n  STOP1 x = STOP2 y\n  llist_all2 B (MORE1 x) (MORE2 y)\n  A (LTL1 x) (LTL2 y)\n\ngoal (1 subgoal):\n 1. (\\<exists>x y.\n        ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n        corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n        ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n        corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n        A x y) \\<or>\n    llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n     (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))", "by(auto simp add: LCons[simplified])"], ["proof (state)\nthis:\n  (\\<exists>x y.\n      ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n      corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n      ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n      corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n      A x y) \\<or>\n  llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>A x y;\n        \\<not> lnull (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x);\n        \\<not> lnull (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\\<rbrakk>\n       \\<Longrightarrow> B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                          (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                 y)) \\<and>\n                         ((\\<exists>xa ya.\n                              ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1\n                                    LTL1 x) =\n                              corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                               xa \\<and>\n                              ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2\n                                    LTL2 y) =\n                              corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                               ya \\<and>\n                              A xa ya) \\<or>\n                          llist_all2 B\n                           (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1\n                                  x))\n                           (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2\n                                  y)))", "ultimately"], ["proof (chain)\npicking this:\n  B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n  (\\<exists>x y.\n      ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n      corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n      ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n      corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n      A x y) \\<or>\n  llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))", "show ?case"], ["proof (prove)\nusing this:\n  B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n  (\\<exists>x y.\n      ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n      corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n      ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n      corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n      A x y) \\<or>\n  llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y))\n\ngoal (1 subgoal):\n 1. B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n     (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)) \\<and>\n    ((\\<exists>x y.\n         ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n         corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n         ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n         corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n         A x y) \\<or>\n     llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n      (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)))", ".."], ["proof (state)\nthis:\n  B (lhd (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n   (lhd (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)) \\<and>\n  ((\\<exists>x y.\n       ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x) =\n       corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x \\<and>\n       ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y) =\n       corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y \\<and>\n       A x y) \\<or>\n   llist_all2 B (ltl (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x))\n    (ltl (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llist_all2 B (corec_llist IS_LNIL1 LHD1 STOP1 MORE1 LTL1 x)\n   (corec_llist IS_LNIL2 LHD2 STOP2 MORE2 LTL2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltl_transfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 A) ltl ltl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> llist_all2 A) ltl ltl", "unfolding ltl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> llist_all2 A)\n     (\\<lambda>llist.\n         case llist of LNil \\<Rightarrow> LNil\n         | LCons x21 x22 \\<Rightarrow> x22)\n     (\\<lambda>llist.\n         case llist of LNil \\<Rightarrow> LNil\n         | LCons x21 x22 \\<Rightarrow> x22)", "by transfer_prover"], ["", "lemma lset_transfer [transfer_rule]:\n  \"(llist_all2 A ===> rel_set A) lset lset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> rel_set A) lset lset", "by (intro rel_funI rel_setI) (auto simp only: in_lset_conv_lnth llist_all2_conv_all_lnth Bex_def)"], ["", "lemma lmap_transfer [transfer_rule]:\n  \"((A ===> B) ===> llist_all2 A ===> llist_all2 B) lmap lmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> llist_all2 A ===> llist_all2 B) lmap lmap", "by(auto simp add: rel_fun_def llist_all2_lmap1 llist_all2_lmap2 elim: llist_all2_mono)"], ["", "lemma lappend_transfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 A ===> llist_all2 A) lappend lappend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> llist_all2 A ===> llist_all2 A) lappend lappend", "by(auto simp add: rel_fun_def intro: llist_all2_lappendI)"], ["", "lemma iterates_transfer [transfer_rule]:\n  \"((A ===> A) ===> A ===> llist_all2 A) iterates iterates\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A) ===> A ===> llist_all2 A) iterates iterates", "unfolding iterates_def split_def corec_llist_never_stop"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A) ===> A ===> llist_all2 A)\n     (\\<lambda>uu uua.\n         unfold_llist (\\<lambda>p. False) snd\n          (\\<lambda>p. (fst p, fst p (snd p))) (uu, uua))\n     (\\<lambda>uu uua.\n         unfold_llist (\\<lambda>p. False) snd\n          (\\<lambda>p. (fst p, fst p (snd p))) (uu, uua))", "by transfer_prover"], ["", "lemma lfinite_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=)) lfinite lfinite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> (=)) lfinite lfinite", "by(auto dest: llist_all2_lfiniteD)"], ["", "lemma llist_of_transfer [transfer_rule]:\n  \"(list_all2 A ===> llist_all2 A) llist_of llist_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 A ===> llist_all2 A) llist_of llist_of", "unfolding llist_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 A ===> llist_all2 A) (rec_list LNil (\\<lambda>x xs. LCons x))\n     (rec_list LNil (\\<lambda>x xs. LCons x))", "by transfer_prover"], ["", "lemma llength_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=)) llength llength\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> (=)) llength llength", "by(auto dest: llist_all2_llengthD)"], ["", "lemma ltake_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ltake ltake\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> llist_all2 A ===> llist_all2 A) ltake ltake", "by(auto intro: llist_all2_ltakeI)"], ["", "lemma ldropn_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ldropn ldropn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> llist_all2 A ===> llist_all2 A) ldropn ldropn", "unfolding ldropn_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> llist_all2 A ===> llist_all2 A) ((^^) ltl) ((^^) ltl)", "by transfer_prover"], ["", "lemma ldrop_transfer [transfer_rule]:\n  \"((=) ===> llist_all2 A ===> llist_all2 A) ldrop ldrop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> llist_all2 A ===> llist_all2 A) ldrop ldrop", "by(auto intro: llist_all2_ldropI)"], ["", "lemma ltakeWhile_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ltakeWhile ltakeWhile\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ltakeWhile ltakeWhile", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(A ===> (=)) x y; llist_all2 A xa ya\\<rbrakk>\n       \\<Longrightarrow> llist_all2 A (ltakeWhile x xa) (ltakeWhile y ya)", "fix P :: \"'a \\<Rightarrow> bool\" and Q :: \"'b \\<Rightarrow> bool\" and xs :: \"'a llist\" and ys :: \"'b llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(A ===> (=)) x y; llist_all2 A xa ya\\<rbrakk>\n       \\<Longrightarrow> llist_all2 A (ltakeWhile x xa) (ltakeWhile y ya)", "assume PQ: \"(A ===> (=)) P Q\""], ["proof (state)\nthis:\n  (A ===> (=)) P Q\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(A ===> (=)) x y; llist_all2 A xa ya\\<rbrakk>\n       \\<Longrightarrow> llist_all2 A (ltakeWhile x xa) (ltakeWhile y ya)", "assume \"llist_all2 A xs ys\""], ["proof (state)\nthis:\n  llist_all2 A xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(A ===> (=)) x y; llist_all2 A xa ya\\<rbrakk>\n       \\<Longrightarrow> llist_all2 A (ltakeWhile x xa) (ltakeWhile y ya)", "thus \"llist_all2 A (ltakeWhile P xs) (ltakeWhile Q ys)\""], ["proof (prove)\nusing this:\n  llist_all2 A xs ys\n\ngoal (1 subgoal):\n 1. llist_all2 A (ltakeWhile P xs) (ltakeWhile Q ys)", "apply(coinduction arbitrary: xs ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xsa__ ysa__.\n       llist_all2 A xsa__ ysa__ \\<Longrightarrow>\n       lnull (ltakeWhile P xsa__) = lnull (ltakeWhile Q ysa__)\n 2. \\<And>xsa__ ysa__.\n       \\<lbrakk>llist_all2 A xsa__ ysa__; \\<not> lnull (ltakeWhile P xsa__);\n        \\<not> lnull (ltakeWhile Q ysa__)\\<rbrakk>\n       \\<Longrightarrow> A (lhd (ltakeWhile P xsa__))\n                          (lhd (ltakeWhile Q ysa__)) \\<and>\n                         ((\\<exists>xs__ ys__.\n                              ltl (ltakeWhile P xsa__) =\n                              ltakeWhile P xs__ \\<and>\n                              ltl (ltakeWhile Q ysa__) =\n                              ltakeWhile Q ys__ \\<and>\n                              llist_all2 A xs__ ys__) \\<or>\n                          llist_all2 A (ltl (ltakeWhile P xsa__))\n                           (ltl (ltakeWhile Q ysa__)))", "using PQ"], ["proof (prove)\nusing this:\n  (A ===> (=)) P Q\n\ngoal (2 subgoals):\n 1. \\<And>xsa__ ysa__.\n       llist_all2 A xsa__ ysa__ \\<Longrightarrow>\n       lnull (ltakeWhile P xsa__) = lnull (ltakeWhile Q ysa__)\n 2. \\<And>xsa__ ysa__.\n       \\<lbrakk>llist_all2 A xsa__ ysa__; \\<not> lnull (ltakeWhile P xsa__);\n        \\<not> lnull (ltakeWhile Q ysa__)\\<rbrakk>\n       \\<Longrightarrow> A (lhd (ltakeWhile P xsa__))\n                          (lhd (ltakeWhile Q ysa__)) \\<and>\n                         ((\\<exists>xs__ ys__.\n                              ltl (ltakeWhile P xsa__) =\n                              ltakeWhile P xs__ \\<and>\n                              ltl (ltakeWhile Q ysa__) =\n                              ltakeWhile Q ys__ \\<and>\n                              llist_all2 A xs__ ys__) \\<or>\n                          llist_all2 A (ltl (ltakeWhile P xsa__))\n                           (ltl (ltakeWhile Q ysa__)))", "by(auto 4 4 elim: rel_funE simp add: not_lnull_conv llist_all2_LCons2 llist_all2_LCons1)"], ["proof (state)\nthis:\n  llist_all2 A (ltakeWhile P xs) (ltakeWhile Q ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldropWhile_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ldropWhile ldropWhile\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) ldropWhile ldropWhile", "unfolding ldropWhile_eq_ldrop[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> llist_all2 A)\n     (\\<lambda>P xs. ldrop (llength (ltakeWhile P xs)) xs)\n     (\\<lambda>P xs. ldrop (llength (ltakeWhile P xs)) xs)", "by transfer_prover"], ["", "lemma lzip_ltransfer [transfer_rule]:\n  \"(llist_all2 A ===> llist_all2 B ===> llist_all2 (rel_prod A B)) lzip lzip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> llist_all2 B ===> llist_all2 (rel_prod A B)) lzip\n     lzip", "by(auto intro: llist_all2_lzipI)"], ["", "lemma inf_llist_transfer [transfer_rule]:\n  \"(((=) ===> A) ===> llist_all2 A) inf_llist inf_llist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> A) ===> llist_all2 A) inf_llist inf_llist", "unfolding inf_llist_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> A) ===> llist_all2 A) (\\<lambda>f. lmap f (iterates Suc 0))\n     (\\<lambda>f. lmap f (iterates Suc 0))", "by transfer_prover"], ["", "lemma lfilter_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) lfilter lfilter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> llist_all2 A) lfilter lfilter", "by(auto simp add: rel_fun_def intro: llist_all2_lfilterI)"], ["", "lemma lconcat_transfer [transfer_rule]:\n  \"(llist_all2 (llist_all2 A) ===> llist_all2 A) lconcat lconcat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 (llist_all2 A) ===> llist_all2 A) lconcat lconcat", "by(auto intro: llist_all2_lconcatI)"], ["", "lemma lnths_transfer [transfer_rule]:\n  \"(llist_all2 A ===> (=) ===> llist_all2 A) lnths lnths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> (=) ===> llist_all2 A) lnths lnths", "unfolding lnths_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llist_all2 A ===> (=) ===> llist_all2 A)\n     (\\<lambda>xs A.\n         lmap fst\n          (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0))))\n     (\\<lambda>xs A.\n         lmap fst\n          (lfilter (\\<lambda>(x, y). y \\<in> A) (lzip xs (iterates Suc 0))))", "by transfer_prover"], ["", "lemma llist_all_transfer [transfer_rule]:\n  \"((A ===> (=)) ===> llist_all2 A ===> (=)) llist_all llist_all\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> (=)) llist_all llist_all", "unfolding pred_llist_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> llist_all2 A ===> (=))\n     (\\<lambda>P x. Ball (lset x) P) (\\<lambda>P x. Ball (lset x) P)", "by transfer_prover"], ["", "lemma llist_all2_rsp:\n  assumes r: \"\\<forall>x y. R x y \\<longrightarrow> (\\<forall>a b. R a b \\<longrightarrow> S x a = T y b)\"\n  and l1: \"llist_all2 R x y\"\n  and l2: \"llist_all2 R a b\"\n  shows \"llist_all2 S x a = llist_all2 T y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 S x a = llist_all2 T y b", "proof(cases \"llength x = llength a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. llength x = llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b\n 2. llength x \\<noteq> llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b", "case True"], ["proof (state)\nthis:\n  llength x = llength a\n\ngoal (2 subgoals):\n 1. llength x = llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b\n 2. llength x \\<noteq> llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b", "thus ?thesis"], ["proof (prove)\nusing this:\n  llength x = llength a\n\ngoal (1 subgoal):\n 1. llist_all2 S x a = llist_all2 T y b", "using l1 l2"], ["proof (prove)\nusing this:\n  llength x = llength a\n  llist_all2 R x y\n  llist_all2 R a b\n\ngoal (1 subgoal):\n 1. llist_all2 S x a = llist_all2 T y b", "by(simp add: llist_all2_conv_all_lnth)(blast dest: r[rule_format])"], ["proof (state)\nthis:\n  llist_all2 S x a = llist_all2 T y b\n\ngoal (1 subgoal):\n 1. llength x \\<noteq> llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. llength x \\<noteq> llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b", "case False"], ["proof (state)\nthis:\n  llength x \\<noteq> llength a\n\ngoal (1 subgoal):\n 1. llength x \\<noteq> llength a \\<Longrightarrow>\n    llist_all2 S x a = llist_all2 T y b", "with llist_all2_llengthD[OF l1] llist_all2_llengthD[OF l2]"], ["proof (chain)\npicking this:\n  llength x = llength y\n  llength a = llength b\n  llength x \\<noteq> llength a", "show ?thesis"], ["proof (prove)\nusing this:\n  llength x = llength y\n  llength a = llength b\n  llength x \\<noteq> llength a\n\ngoal (1 subgoal):\n 1. llist_all2 S x a = llist_all2 T y b", "by(simp add: llist_all2_conv_all_lnth)"], ["proof (state)\nthis:\n  llist_all2 S x a = llist_all2 T y b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma llist_all2_transfer [transfer_rule]:\n  \"((R ===> R ===> (=)) ===> llist_all2 R ===> llist_all2 R ===> (=)) llist_all2 llist_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> R ===> (=)) ===> llist_all2 R ===> llist_all2 R ===> (=))\n     llist_all2 llist_all2", "by (simp add: llist_all2_rsp rel_fun_def)"], ["", "end"], ["", "no_notation lprefix (infix \"\\<sqsubseteq>\" 65)"], ["", "end"]]}