{"file_name": "/home/qj213/afp-2021-10-22/thys/Coinductive/Lazy_LList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Coinductive", "problem_names": ["lemma partial_term_of_llist_code [code]:\n  fixes tytok :: \"'a :: partial_term_of llist itself\" shows\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_variable p tt) \\<equiv>\n   Code_Evaluation.Free (STR ''_'') (Typerep.typerep TYPE('a llist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 0 []) \\<equiv>\n   Code_Evaluation.Const (STR ''Coinductive_List.llist.LNil'') (Typerep.typerep TYPE('a llist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 1 [head, tail]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.App\n        (Code_Evaluation.Const\n           (STR ''Coinductive_List.llist.LCons'')\n           (Typerep.typerep TYPE('a \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist)))\n        (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE('a llist) tail)\"", "lemma Lazy_llist_inject [simp]:\n  \"Lazy_llist xs = Lazy_llist ys \\<longleftrightarrow> xs = ys\"", "lemma Lazy_llist_inverse [code, simp]:\n  \"force (Lazy_llist xs) = xs ()\"", "lemma force_inverse [simp]:\n  \"Lazy_llist (\\<lambda>_. force xs) = xs\"", "lemma LNil_Lazy_llist [code]: \"LNil = Lazy_llist (\\<lambda>_. None)\"", "lemma LCons_Lazy_llist [code, code_unfold]: \"LCons x xs = Lazy_llist (\\<lambda>_. Some (x, xs))\"", "lemma lnull_lazy [code]: \"lnull = Option.is_none \\<circ> force\"", "lemma equal_llist_Lazy_llist [code]:\n  \"equal_class.equal (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n   (case xs () of None \\<Rightarrow> (case ys () of None \\<Rightarrow> True | _ \\<Rightarrow> False)\n    | Some (x, xs') \\<Rightarrow> \n       (case ys () of None \\<Rightarrow> False \n        | Some (y, ys') \\<Rightarrow> if x = y then equal_class.equal xs' ys' else False))\"", "lemma corec_llist_Lazy_llist [code]:\n  \"corec_llist IS_LNIL LHD endORmore LTL_end LTL_more b =\n  Lazy_llist (\\<lambda>_. if IS_LNIL b then None \n     else Some (LHD b,\n       if endORmore b then LTL_end b\n       else corec_llist IS_LNIL LHD endORmore LTL_end LTL_more (LTL_more b)))\"", "lemma unfold_llist_Lazy_llist [code]:\n  \"unfold_llist IS_LNIL LHD LTL b =\n  Lazy_llist (\\<lambda>_. if IS_LNIL b then None else Some (LHD b, unfold_llist IS_LNIL LHD LTL (LTL b)))\"", "lemma case_llist_Lazy_llist [code]:\n  \"case_llist n c (Lazy_llist xs) = (case xs () of None \\<Rightarrow> n | Some (x, ys) \\<Rightarrow> c x ys)\"", "lemma lappend_Lazy_llist [code]:\n  \"lappend (Lazy_llist xs) ys = \n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> force ys | Some (x, xs') \\<Rightarrow> Some (x, lappend xs' ys))\"", "lemma lmap_Lazy_llist [code]:\n  \"lmap f (Lazy_llist xs) = Lazy_llist (\\<lambda>_. map_option (map_prod f (lmap f)) (xs ()))\"", "lemma lfinite_Lazy_llist [code]:\n  \"lfinite (Lazy_llist xs) = (case xs () of None \\<Rightarrow> True | Some (x, ys) \\<Rightarrow> lfinite ys)\"", "lemma list_of_aux_Lazy_llist [code]:\n  \"list_of_aux xs (Lazy_llist ys) = \n  (case ys () of None \\<Rightarrow> rev xs | Some (y, ys) \\<Rightarrow> list_of_aux (y # xs) ys)\"", "lemma gen_llength_Lazy_llist [code]:\n  \"gen_llength n (Lazy_llist xs) = (case xs () of None \\<Rightarrow> enat n | Some (_, ys) \\<Rightarrow> gen_llength (n + 1) ys)\"", "lemma ltake_Lazy_llist [code]:\n  \"ltake n (Lazy_llist xs) =\n  Lazy_llist (\\<lambda>_. if n = 0 then None else case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> Some (x, ltake (n - 1) ys))\"", "lemma ldropn_Lazy_llist [code]:\n  \"ldropn n (Lazy_llist xs) = \n   Lazy_llist (\\<lambda>_. if n = 0 then xs () else\n                   case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> force (ldropn (n - 1) ys))\"", "lemma ltakeWhile_Lazy_llist [code]:\n  \"ltakeWhile P (Lazy_llist xs) = \n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> if P x then Some (x, ltakeWhile P ys) else None)\"", "lemma ldropWhile_Lazy_llist [code]:\n  \"ldropWhile P (Lazy_llist xs) = \n   Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> if P x then force (ldropWhile P ys) else Some (x, ys))\"", "lemma lzip_Lazy_llist [code]:\n  \"lzip (Lazy_llist xs) (Lazy_llist ys) =\n  Lazy_llist (\\<lambda>_. Option.bind (xs ()) (\\<lambda>(x, xs'). map_option (\\<lambda>(y, ys'). ((x, y), lzip xs' ys')) (ys ())))\"", "lemma lset_Lazy_llist [code]:\n  \"gen_lset A (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> A | Some (y, ys) \\<Rightarrow> gen_lset (insert y A) ys)\"", "lemma lmember_Lazy_llist [code]: \n  \"lmember x (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> False | Some (y, ys) \\<Rightarrow> x = y \\<or> lmember x ys)\"", "lemma llist_all2_Lazy_llist [code]:\n  \"llist_all2 P (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of None \\<Rightarrow> ys () = None \n      | Some (x, xs') \\<Rightarrow> (case ys () of None \\<Rightarrow> False \n                            | Some (y, ys') \\<Rightarrow> P x y \\<and> llist_all2 P xs' ys'))\"", "lemma lhd_Lazy_llist [code]:\n  \"lhd (Lazy_llist xs) = (case xs () of None \\<Rightarrow> undefined | Some (x, xs') \\<Rightarrow> x)\"", "lemma ltl_Lazy_llist [code]:\n  \"ltl (Lazy_llist xs) = Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> force ys)\"", "lemma llast_Lazy_llist [code]:\n  \"llast (Lazy_llist xs) =\n  (case xs () of \n    None \\<Rightarrow> undefined \n  | Some (x, xs') \\<Rightarrow> \n    (case force xs' of None \\<Rightarrow> x | Some (x', xs'') \\<Rightarrow> llast (LCons x' xs'')))\"", "lemma ldistinct_Lazy_llist [code]:\n  \"ldistinct (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> True | Some (x, ys) \\<Rightarrow> x \\<notin> lset ys \\<and> ldistinct ys)\"", "lemma lprefix_Lazy_llist [code]:\n  \"lprefix (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of \n    None \\<Rightarrow> True\n  | Some (x, xs') \\<Rightarrow> \n    (case ys () of None \\<Rightarrow> False | Some (y, ys') \\<Rightarrow> x = y \\<and> lprefix xs' ys'))\"", "lemma lstrict_prefix_Lazy_llist [code]:\n  \"lstrict_prefix (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n  (case ys () of\n    None \\<Rightarrow> False \n  | Some (y, ys') \\<Rightarrow> \n    (case xs () of None \\<Rightarrow> True | Some (x, xs') \\<Rightarrow> x = y \\<and> lstrict_prefix xs' ys'))\"", "lemma llcp_Lazy_llist [code]:\n  \"llcp (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of None \\<Rightarrow> 0 \n   | Some (x, xs') \\<Rightarrow> (case ys () of None \\<Rightarrow> 0\n                     | Some (y, ys') \\<Rightarrow> if x = y then eSuc (llcp xs' ys') else 0))\"", "lemma llexord_Lazy_llist [code]:\n  \"llexord r (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n  (case xs () of \n    None \\<Rightarrow> True \n  | Some (x, xs') \\<Rightarrow> \n    (case ys () of None \\<Rightarrow> False | Some (y, ys') \\<Rightarrow> r x y \\<or> x = y \\<and> llexord r xs' ys'))\"", "lemma lfilter_Lazy_llist [code]:\n  \"lfilter P (Lazy_llist xs) =\n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None \n                  | Some (x, ys) \\<Rightarrow> if P x then Some (x, lfilter P ys) else force (lfilter P ys))\"", "lemma lconcat_Lazy_llist [code]:\n  \"lconcat (Lazy_llist xss) =\n  Lazy_llist (\\<lambda>_. case xss () of None \\<Rightarrow> None | Some (xs, xss') \\<Rightarrow> force (lappend xs (lconcat xss')))\""], "translations": [["", "lemma partial_term_of_llist_code [code]:\n  fixes tytok :: \"'a :: partial_term_of llist itself\" shows\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_variable p tt) \\<equiv>\n   Code_Evaluation.Free (STR ''_'') (Typerep.typerep TYPE('a llist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 0 []) \\<equiv>\n   Code_Evaluation.Const (STR ''Coinductive_List.llist.LNil'') (Typerep.typerep TYPE('a llist))\"\n  \"partial_term_of tytok (Quickcheck_Narrowing.Narrowing_constructor 1 [head, tail]) \\<equiv>\n   Code_Evaluation.App\n     (Code_Evaluation.App\n        (Code_Evaluation.Const\n           (STR ''Coinductive_List.llist.LCons'')\n           (Typerep.typerep TYPE('a \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist)))\n        (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE('a llist) tail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (partial_term_of tytok (narrowing_term.Narrowing_variable p tt) \\<equiv>\n     Code_Evaluation.Free STR ''_'' TYPEREP('a llist)) &&&\n    (partial_term_of tytok\n      (narrowing_term.Narrowing_constructor 0 []) \\<equiv>\n     Code_Evaluation.Const STR ''Coinductive_List.llist.LNil''\n      TYPEREP('a llist)) &&&\n    partial_term_of tytok\n     (narrowing_term.Narrowing_constructor 1 [head, tail]) \\<equiv>\n    Code_Evaluation.App\n     (Code_Evaluation.App\n       (Code_Evaluation.Const STR ''Coinductive_List.llist.LCons''\n         TYPEREP('a \\<Rightarrow> 'a llist \\<Rightarrow> 'a llist))\n       (partial_term_of TYPE('a) head))\n     (partial_term_of TYPE('a llist) tail)", "by-(rule partial_term_of_anything)+"], ["", "declare option.splits [split]"], ["", "lemma Lazy_llist_inject [simp]:\n  \"Lazy_llist xs = Lazy_llist ys \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Lazy_llist xs = Lazy_llist ys) = (xs = ys)", "by(auto simp add: fun_eq_iff)"], ["", "lemma Lazy_llist_inverse [code, simp]:\n  \"force (Lazy_llist xs) = xs ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. force (Lazy_llist xs) = xs ()", "by(auto)"], ["", "lemma force_inverse [simp]:\n  \"Lazy_llist (\\<lambda>_. force xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lazy_llist (\\<lambda>_. force xs) = xs", "by(auto split: llist.split)"], ["", "lemma LNil_Lazy_llist [code]: \"LNil = Lazy_llist (\\<lambda>_. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LNil = Lazy_llist Map.empty", "by(simp)"], ["", "lemma LCons_Lazy_llist [code, code_unfold]: \"LCons x xs = Lazy_llist (\\<lambda>_. Some (x, xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons x xs = Lazy_llist (\\<lambda>_. Some (x, xs))", "by simp"], ["", "lemma lnull_lazy [code]: \"lnull = Option.is_none \\<circ> force\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull = Option.is_none \\<circ> force", "unfolding lnull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>llist. llist = LNil) = Option.is_none \\<circ> force", "by (rule ext) (simp add: Option.is_none_def split: llist.split)"], ["", "declare [[code drop: \"equal_class.equal :: 'a :: equal llist \\<Rightarrow> _\"]]"], ["", "lemma equal_llist_Lazy_llist [code]:\n  \"equal_class.equal (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n   (case xs () of None \\<Rightarrow> (case ys () of None \\<Rightarrow> True | _ \\<Rightarrow> False)\n    | Some (x, xs') \\<Rightarrow> \n       (case ys () of None \\<Rightarrow> False \n        | Some (y, ys') \\<Rightarrow> if x = y then equal_class.equal xs' ys' else False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (Lazy_llist xs) (Lazy_llist ys) =\n    (case xs () of\n     None \\<Rightarrow>\n       case ys () of None \\<Rightarrow> True | Some a \\<Rightarrow> False\n     | Some (x, xs') \\<Rightarrow>\n         case ys () of None \\<Rightarrow> False\n         | Some (y, ys') \\<Rightarrow>\n             if x = y then equal_class.equal xs' ys' else False)", "by(auto simp add: equal_llist_def)"], ["", "declare [[code drop: corec_llist]]"], ["", "lemma corec_llist_Lazy_llist [code]:\n  \"corec_llist IS_LNIL LHD endORmore LTL_end LTL_more b =\n  Lazy_llist (\\<lambda>_. if IS_LNIL b then None \n     else Some (LHD b,\n       if endORmore b then LTL_end b\n       else corec_llist IS_LNIL LHD endORmore LTL_end LTL_more (LTL_more b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corec_llist IS_LNIL LHD endORmore LTL_end LTL_more b =\n    Lazy_llist\n     (\\<lambda>_.\n         if IS_LNIL b then None\n         else Some\n               (LHD b,\n                if endORmore b then LTL_end b\n                else corec_llist IS_LNIL LHD endORmore LTL_end LTL_more\n                      (LTL_more b)))", "by(subst llist.corec_code) simp"], ["", "declare [[code drop: unfold_llist]]"], ["", "lemma unfold_llist_Lazy_llist [code]:\n  \"unfold_llist IS_LNIL LHD LTL b =\n  Lazy_llist (\\<lambda>_. if IS_LNIL b then None else Some (LHD b, unfold_llist IS_LNIL LHD LTL (LTL b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_llist IS_LNIL LHD LTL b =\n    Lazy_llist\n     (\\<lambda>_.\n         if IS_LNIL b then None\n         else Some (LHD b, unfold_llist IS_LNIL LHD LTL (LTL b)))", "by(subst unfold_llist.code) simp"], ["", "declare [[code drop: case_llist]]"], ["", "lemma case_llist_Lazy_llist [code]:\n  \"case_llist n c (Lazy_llist xs) = (case xs () of None \\<Rightarrow> n | Some (x, ys) \\<Rightarrow> c x ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Lazy_llist xs of LNil \\<Rightarrow> n\n     | LCons x xa \\<Rightarrow> c x xa) =\n    (case xs () of None \\<Rightarrow> n | Some (x, ys) \\<Rightarrow> c x ys)", "by simp"], ["", "declare [[code drop: lappend]]"], ["", "lemma lappend_Lazy_llist [code]:\n  \"lappend (Lazy_llist xs) ys = \n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> force ys | Some (x, xs') \\<Rightarrow> Some (x, lappend xs' ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (Lazy_llist xs) ys =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> force ys\n         | Some (x, xs') \\<Rightarrow> Some (x, lappend xs' ys))", "by(auto split: llist.splits)"], ["", "declare [[code drop: lmap]]"], ["", "lemma lmap_Lazy_llist [code]:\n  \"lmap f (Lazy_llist xs) = Lazy_llist (\\<lambda>_. map_option (map_prod f (lmap f)) (xs ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (Lazy_llist xs) =\n    Lazy_llist (\\<lambda>_. map_option (map_prod f (lmap f)) (xs ()))", "by simp"], ["", "declare [[code drop: lfinite]]"], ["", "lemma lfinite_Lazy_llist [code]:\n  \"lfinite (Lazy_llist xs) = (case xs () of None \\<Rightarrow> True | Some (x, ys) \\<Rightarrow> lfinite ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (Lazy_llist xs) =\n    (case xs () of None \\<Rightarrow> True\n     | Some (x, ys) \\<Rightarrow> lfinite ys)", "by simp"], ["", "declare [[code drop: list_of_aux]]"], ["", "lemma list_of_aux_Lazy_llist [code]:\n  \"list_of_aux xs (Lazy_llist ys) = \n  (case ys () of None \\<Rightarrow> rev xs | Some (y, ys) \\<Rightarrow> list_of_aux (y # xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_aux xs (Lazy_llist ys) =\n    (case ys () of None \\<Rightarrow> rev xs\n     | Some (y, ys) \\<Rightarrow> list_of_aux (y # xs) ys)", "by(simp add: list_of_aux_code)"], ["", "declare [[code drop: gen_llength]]"], ["", "lemma gen_llength_Lazy_llist [code]:\n  \"gen_llength n (Lazy_llist xs) = (case xs () of None \\<Rightarrow> enat n | Some (_, ys) \\<Rightarrow> gen_llength (n + 1) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_llength n (Lazy_llist xs) =\n    (case xs () of None \\<Rightarrow> enat n\n     | Some (x, ys) \\<Rightarrow> gen_llength (n + 1) ys)", "by(simp add: gen_llength_code)"], ["", "declare [[code drop: ltake]]"], ["", "lemma ltake_Lazy_llist [code]:\n  \"ltake n (Lazy_llist xs) =\n  Lazy_llist (\\<lambda>_. if n = 0 then None else case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> Some (x, ltake (n - 1) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake n (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         if n = 0 then None\n         else case xs () of None \\<Rightarrow> None\n              | Some (x, ys) \\<Rightarrow> Some (x, ltake (n - 1) ys))", "by(cases n rule: enat_coexhaust) auto"], ["", "declare [[code drop: ldropn]]"], ["", "lemma ldropn_Lazy_llist [code]:\n  \"ldropn n (Lazy_llist xs) = \n   Lazy_llist (\\<lambda>_. if n = 0 then xs () else\n                   case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> force (ldropn (n - 1) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         if n = 0 then xs ()\n         else case xs () of None \\<Rightarrow> None\n              | Some (x, ys) \\<Rightarrow> force (ldropn (n - 1) ys))", "by(cases n)(auto simp add: eSuc_enat[symmetric] split: llist.split)"], ["", "declare [[code drop: ltakeWhile]]"], ["", "lemma ltakeWhile_Lazy_llist [code]:\n  \"ltakeWhile P (Lazy_llist xs) = \n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> if P x then Some (x, ltakeWhile P ys) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile P (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> None\n         | Some (x, ys) \\<Rightarrow>\n             if P x then Some (x, ltakeWhile P ys) else None)", "by auto"], ["", "declare [[code drop: ldropWhile]]"], ["", "lemma ldropWhile_Lazy_llist [code]:\n  \"ldropWhile P (Lazy_llist xs) = \n   Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> if P x then force (ldropWhile P ys) else Some (x, ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropWhile P (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> None\n         | Some (x, ys) \\<Rightarrow>\n             if P x then force (ldropWhile P ys) else Some (x, ys))", "by(auto split: llist.split)"], ["", "declare [[code drop: lzip]]"], ["", "lemma lzip_Lazy_llist [code]:\n  \"lzip (Lazy_llist xs) (Lazy_llist ys) =\n  Lazy_llist (\\<lambda>_. Option.bind (xs ()) (\\<lambda>(x, xs'). map_option (\\<lambda>(y, ys'). ((x, y), lzip xs' ys')) (ys ())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lzip (Lazy_llist xs) (Lazy_llist ys) =\n    Lazy_llist\n     (\\<lambda>_.\n         Option.bind (xs ())\n          (\\<lambda>(x, xs').\n              map_option (\\<lambda>(y, ys'). ((x, y), lzip xs' ys'))\n               (ys ())))", "by auto"], ["", "declare [[code drop: gen_lset]]"], ["", "lemma lset_Lazy_llist [code]:\n  \"gen_lset A (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> A | Some (y, ys) \\<Rightarrow> gen_lset (insert y A) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lset A (Lazy_llist xs) =\n    (case xs () of None \\<Rightarrow> A\n     | Some (y, ys) \\<Rightarrow> gen_lset (insert y A) ys)", "by(auto simp add: gen_lset_code)"], ["", "declare [[code drop: lmember]]"], ["", "lemma lmember_Lazy_llist [code]: \n  \"lmember x (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> False | Some (y, ys) \\<Rightarrow> x = y \\<or> lmember x ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmember x (Lazy_llist xs) =\n    (case xs () of None \\<Rightarrow> False\n     | Some (y, ys) \\<Rightarrow> x = y \\<or> lmember x ys)", "by(simp add: lmember_def)"], ["", "declare [[code drop: llist_all2]]"], ["", "lemma llist_all2_Lazy_llist [code]:\n  \"llist_all2 P (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of None \\<Rightarrow> ys () = None \n      | Some (x, xs') \\<Rightarrow> (case ys () of None \\<Rightarrow> False \n                            | Some (y, ys') \\<Rightarrow> P x y \\<and> llist_all2 P xs' ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_all2 P (Lazy_llist xs) (Lazy_llist ys) =\n    (case xs () of None \\<Rightarrow> ys () = None\n     | Some (x, xs') \\<Rightarrow>\n         case ys () of None \\<Rightarrow> False\n         | Some (y, ys') \\<Rightarrow> P x y \\<and> llist_all2 P xs' ys')", "by auto"], ["", "declare [[code drop: lhd]]"], ["", "lemma lhd_Lazy_llist [code]:\n  \"lhd (Lazy_llist xs) = (case xs () of None \\<Rightarrow> undefined | Some (x, xs') \\<Rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (Lazy_llist xs) = (case xs () of Some (x, xs') \\<Rightarrow> x)", "by(simp add: lhd_def)"], ["", "declare [[code drop: ltl]]"], ["", "lemma ltl_Lazy_llist [code]:\n  \"ltl (Lazy_llist xs) = Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None | Some (x, ys) \\<Rightarrow> force ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> None\n         | Some (x, ys) \\<Rightarrow> force ys)", "by(auto split: llist.split)"], ["", "declare [[code drop: llast]]"], ["", "lemma llast_Lazy_llist [code]:\n  \"llast (Lazy_llist xs) =\n  (case xs () of \n    None \\<Rightarrow> undefined \n  | Some (x, xs') \\<Rightarrow> \n    (case force xs' of None \\<Rightarrow> x | Some (x', xs'') \\<Rightarrow> llast (LCons x' xs'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (Lazy_llist xs) =\n    (case xs () of\n     Some (x, xs') \\<Rightarrow>\n       case force xs' of None \\<Rightarrow> x\n       | Some (x', xs'') \\<Rightarrow> llast (LCons x' xs''))", "by(auto simp add: llast_def zero_enat_def eSuc_def split: enat.split llist.splits)"], ["", "declare [[code drop: ldistinct]]"], ["", "lemma ldistinct_Lazy_llist [code]:\n  \"ldistinct (Lazy_llist xs) =\n  (case xs () of None \\<Rightarrow> True | Some (x, ys) \\<Rightarrow> x \\<notin> lset ys \\<and> ldistinct ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (Lazy_llist xs) =\n    (case xs () of None \\<Rightarrow> True\n     | Some (x, ys) \\<Rightarrow> x \\<notin> lset ys \\<and> ldistinct ys)", "by(auto)"], ["", "declare [[code drop: lprefix]]"], ["", "lemma lprefix_Lazy_llist [code]:\n  \"lprefix (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of \n    None \\<Rightarrow> True\n  | Some (x, xs') \\<Rightarrow> \n    (case ys () of None \\<Rightarrow> False | Some (y, ys') \\<Rightarrow> x = y \\<and> lprefix xs' ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (Lazy_llist xs) (Lazy_llist ys) =\n    (case xs () of None \\<Rightarrow> True\n     | Some (x, xs') \\<Rightarrow>\n         case ys () of None \\<Rightarrow> False\n         | Some (y, ys') \\<Rightarrow> x = y \\<and> lprefix xs' ys')", "by auto"], ["", "declare [[code drop: lstrict_prefix]]"], ["", "lemma lstrict_prefix_Lazy_llist [code]:\n  \"lstrict_prefix (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n  (case ys () of\n    None \\<Rightarrow> False \n  | Some (y, ys') \\<Rightarrow> \n    (case xs () of None \\<Rightarrow> True | Some (x, xs') \\<Rightarrow> x = y \\<and> lstrict_prefix xs' ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lstrict_prefix (Lazy_llist xs) (Lazy_llist ys) =\n    (case ys () of None \\<Rightarrow> False\n     | Some (y, ys') \\<Rightarrow>\n         case xs () of None \\<Rightarrow> True\n         | Some (x, xs') \\<Rightarrow> x = y \\<and> lstrict_prefix xs' ys')", "by auto"], ["", "declare [[code drop: llcp]]"], ["", "lemma llcp_Lazy_llist [code]:\n  \"llcp (Lazy_llist xs) (Lazy_llist ys) =\n  (case xs () of None \\<Rightarrow> 0 \n   | Some (x, xs') \\<Rightarrow> (case ys () of None \\<Rightarrow> 0\n                     | Some (y, ys') \\<Rightarrow> if x = y then eSuc (llcp xs' ys') else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llcp (Lazy_llist xs) (Lazy_llist ys) =\n    (case xs () of None \\<Rightarrow> 0\n     | Some (x, xs') \\<Rightarrow>\n         case ys () of None \\<Rightarrow> 0\n         | Some (y, ys') \\<Rightarrow>\n             if x = y then eSuc (llcp xs' ys') else 0)", "by auto"], ["", "declare [[code drop: llexord]]"], ["", "lemma llexord_Lazy_llist [code]:\n  \"llexord r (Lazy_llist xs) (Lazy_llist ys) \\<longleftrightarrow>\n  (case xs () of \n    None \\<Rightarrow> True \n  | Some (x, xs') \\<Rightarrow> \n    (case ys () of None \\<Rightarrow> False | Some (y, ys') \\<Rightarrow> r x y \\<or> x = y \\<and> llexord r xs' ys'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llexord r (Lazy_llist xs) (Lazy_llist ys) =\n    (case xs () of None \\<Rightarrow> True\n     | Some (x, xs') \\<Rightarrow>\n         case ys () of None \\<Rightarrow> False\n         | Some (y, ys') \\<Rightarrow>\n             r x y \\<or> x = y \\<and> llexord r xs' ys')", "by auto"], ["", "declare [[code drop: lfilter]]"], ["", "lemma lfilter_Lazy_llist [code]:\n  \"lfilter P (Lazy_llist xs) =\n  Lazy_llist (\\<lambda>_. case xs () of None \\<Rightarrow> None \n                  | Some (x, ys) \\<Rightarrow> if P x then Some (x, lfilter P ys) else force (lfilter P ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (Lazy_llist xs) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xs () of None \\<Rightarrow> None\n         | Some (x, ys) \\<Rightarrow>\n             if P x then Some (x, lfilter P ys) else force (lfilter P ys))", "by(auto split: llist.split)"], ["", "declare [[code drop: lconcat]]"], ["", "lemma lconcat_Lazy_llist [code]:\n  \"lconcat (Lazy_llist xss) =\n  Lazy_llist (\\<lambda>_. case xss () of None \\<Rightarrow> None | Some (xs, xss') \\<Rightarrow> force (lappend xs (lconcat xss')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconcat (Lazy_llist xss) =\n    Lazy_llist\n     (\\<lambda>_.\n         case xss () of None \\<Rightarrow> None\n         | Some (xs, xss') \\<Rightarrow> force (lappend xs (lconcat xss')))", "by(auto split: llist.split)"], ["", "declare option.splits [split del]"], ["", "declare Lazy_llist_def [simp del]"], ["", "text \\<open>Simple ML test for laziness\\<close>"], ["", "ML_val \\<open>\n  val zeros = @{code iterates} (fn x => x + 1) 0;\n  val lhd = @{code lhd} zeros;\n  val ltl = @{code ltl} zeros;\n  val ltl' = @{code force} ltl;\n  \n  val ltake = @{code ltake} (@{code eSuc} (@{code eSuc} @{code \"0::enat\"})) zeros;\n  val ldrop = @{code ldrop} (@{code eSuc} @{code \"0::enat\"}) zeros;\n  val list_of = @{code list_of} ltake;\n  \n  val ltakeWhile = @{code ltakeWhile} (fn _ => true) zeros;\n  val ldropWhile = @{code ldropWhile} (fn _ => false) zeros;\n  val hd = @{code lhd} ldropWhile;\n  \n  val lfilter = @{code lfilter} (fn _ => false) zeros;\n\\<close>"], ["", "hide_const (open) force"], ["", "end"]]}