{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Rewriting_Pterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma pruleI[intro!]: \"wellformed rhs \\<Longrightarrow> closed rhs \\<Longrightarrow> is_abs rhs \\<Longrightarrow> prule (name, rhs)\"", "lemma compile_heads: \"fst |`| compile rs = fst |`| rs\"", "lemma arity_zero_shape:\n  assumes \"arity_compatibles rs\" \"arity rs = 0\" \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  obtains t where \"rs = {| ([], t) |}\"", "lemma (in irules) compile_rules:\n  assumes \"finished rs\"\n  shows \"prules C_info (compile rs)\"", "theorem (in irules) compile_correct:\n  assumes \"compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"finished rs\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\"", "theorem (in irules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\" \"finished rs\"\n  shows \"compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\""], "translations": [["", "lemma pruleI[intro!]: \"wellformed rhs \\<Longrightarrow> closed rhs \\<Longrightarrow> is_abs rhs \\<Longrightarrow> prule (name, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_strong_term_class.wellformed rhs; closed rhs;\n     is_abs rhs\\<rbrakk>\n    \\<Longrightarrow> prule (name, rhs)", "by simp"], ["", "locale prules = constants C_info \"fst |`| rs\" for C_info and rs :: \"prule fset\" +\n  assumes all_rules: \"fBall rs prule\"\n  assumes fmap: \"is_fmap rs\"\n  assumes not_shadows: \"fBall rs (\\<lambda>(_, rhs). \\<not> shadows_consts rhs)\"\n  assumes welldefined_rs: \"fBall rs (\\<lambda>(_, rhs). welldefined rhs)\""], ["", "subsubsection \\<open>Rewriting\\<close>"], ["", "inductive prewrite :: \"prule fset \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>p/ _ \\<longrightarrow>/ _\" [50,0,50] 50) for rs where\nstep: \"(name, rhs) |\\<in>| rs \\<Longrightarrow> rs \\<turnstile>\\<^sub>p Pconst name \\<longrightarrow> rhs\" |\nbeta: \"c |\\<in>| cs \\<Longrightarrow> c \\<turnstile> t \\<rightarrow> t' \\<Longrightarrow> rs \\<turnstile>\\<^sub>p Pabs cs $\\<^sub>p t \\<longrightarrow> t'\" |\n\"fun\": \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t' \\<Longrightarrow> rs \\<turnstile>\\<^sub>p t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\" |\narg: \"rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u' \\<Longrightarrow> rs \\<turnstile>\\<^sub>p t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'\""], ["", "global_interpretation prewrite: rewriting \"prewrite rs\" for rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rewriting (prewrite rs)", "by standard (auto intro: prewrite.intros simp: app_pterm_def)+"], ["", "abbreviation prewrite_rt :: \"prule fset \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>p/ _ \\<longrightarrow>*/ _\" [50,0,50] 50) where\n\"prewrite_rt rs \\<equiv> (prewrite rs)\\<^sup>*\\<^sup>*\""], ["", "subsubsection \\<open>Translation from @{typ irule_set} to @{typ \"prule fset\"}\\<close>"], ["", "definition finished :: \"irule_set \\<Rightarrow> bool\" where\n\"finished rs = fBall rs (\\<lambda>(_, irs). arity irs = 0)\""], ["", "definition translate_rhs :: \"irules \\<Rightarrow> pterm\" where\n\"translate_rhs = snd \\<circ> fthe_elem\""], ["", "definition compile :: \"irule_set \\<Rightarrow> prule fset\" where\n\"compile = fimage (map_prod id translate_rhs)\""], ["", "lemma compile_heads: \"fst |`| compile rs = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| Rewriting_Pterm.compile rs = fst |`| rs", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| map_prod id translate_rhs |`| rs = fst |`| rs", "by simp"], ["", "subsubsection \\<open>Correctness of translation\\<close>"], ["", "lemma arity_zero_shape:\n  assumes \"arity_compatibles rs\" \"arity rs = 0\" \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  obtains t where \"rs = {| ([], t) |}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}", "obtain ppats prhs where \"(ppats, prhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. (\\<And>ppats prhs.\n        (ppats, prhs) |\\<in>| rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  (ppats, prhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (ppats, prhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  (ppats, prhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix pats rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"(pats, rhs) |\\<in>| rs\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n  (pats, rhs) |\\<in>| rs", "have \"length pats = 0\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. length pats = 0", "by (metis arity_compatible_length)"], ["proof (state)\nthis:\n  length pats = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"pats = []\""], ["proof (prove)\nusing this:\n  length pats = 0\n\ngoal (1 subgoal):\n 1. pats = []", "by simp"], ["proof (state)\nthis:\n  pats = []\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note all = this"], ["proof (state)\nthis:\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (ppats, prhs) |\\<in>| rs\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []", "have proto: \"([], prhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (ppats, prhs) |\\<in>| rs\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []\n\ngoal (1 subgoal):\n 1. ([], prhs) |\\<in>| rs", "by auto"], ["proof (state)\nthis:\n  ([], prhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"fBall rs (\\<lambda>(pats, rhs). pats = [] \\<and> rhs = prhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(pats, rhs). pats = [] \\<and> rhs = prhs)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> a = []\n 2. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> b = prhs", "fix pats rhs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> a = []\n 2. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> b = prhs", "assume cur: \"(pats, rhs) |\\<in>| rs\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| rs\n\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> a = []\n 2. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> b = prhs", "with all"], ["proof (chain)\npicking this:\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []\n  (pats, rhs) |\\<in>| rs", "show \"pats = []\""], ["proof (prove)\nusing this:\n  (?pats2, ?rhs2) |\\<in>| rs \\<Longrightarrow> ?pats2 = []\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. pats = []", "."], ["proof (state)\nthis:\n  pats = []\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> b = prhs", "with cur"], ["proof (chain)\npicking this:\n  (pats, rhs) |\\<in>| rs\n  pats = []", "have \"([], rhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| rs\n  pats = []\n\ngoal (1 subgoal):\n 1. ([], rhs) |\\<in>| rs", "by auto"], ["proof (state)\nthis:\n  ([], rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| rs \\<Longrightarrow> b = prhs", "with proto"], ["proof (chain)\npicking this:\n  ([], prhs) |\\<in>| rs\n  ([], rhs) |\\<in>| rs", "show \"rhs = prhs\""], ["proof (prove)\nusing this:\n  ([], prhs) |\\<in>| rs\n  ([], rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. rhs = prhs", "using assms"], ["proof (prove)\nusing this:\n  ([], prhs) |\\<in>| rs\n  ([], rhs) |\\<in>| rs\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. rhs = prhs", "by (auto dest: is_fmapD)"], ["proof (state)\nthis:\n  rhs = prhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fBall rs (\\<lambda>(pats, rhs). pats = [] \\<and> rhs = prhs)\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"fBall rs (\\<lambda>r. r = ([], prhs))\""], ["proof (prove)\nusing this:\n  fBall rs (\\<lambda>(pats, rhs). pats = [] \\<and> rhs = prhs)\n\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>r. r = ([], prhs))", "by blast"], ["proof (state)\nthis:\n  fBall rs (\\<lambda>r. r = ([], prhs))\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n  fBall rs (\\<lambda>r. r = ([], prhs))", "have \"rs = {| ([], prhs) |}\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles rs\n  arity rs = 0\n  is_fmap rs\n  rs \\<noteq> {||}\n  fBall rs (\\<lambda>r. r = ([], prhs))\n\ngoal (1 subgoal):\n 1. rs = {|([], prhs)|}", "by (simp add: singleton_fset_is)"], ["proof (state)\nthis:\n  rs = {|([], prhs)|}\n\ngoal (1 subgoal):\n 1. (\\<And>t. rs = {|([], t)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  rs = {|([], prhs)|}\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in irules) compile_rules:\n  assumes \"finished rs\"\n  shows \"prules C_info (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prules C_info (Rewriting_Pterm.compile rs)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt (fst |`| Rewriting_Pterm.compile rs) C\n 2. distinct all_constructors\n 3. fBall (Rewriting_Pterm.compile rs) prule\n 4. is_fmap (Rewriting_Pterm.compile rs)\n 5. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 6. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "show \"is_fmap (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (Rewriting_Pterm.compile rs)", "using fmap"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (Rewriting_Pterm.compile rs)", "unfolding compile_def map_prod_def id_apply"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, translate_rhs y)) |`| rs)", "by (rule is_fmap_image)"], ["proof (state)\nthis:\n  is_fmap (Rewriting_Pterm.compile rs)\n\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| Rewriting_Pterm.compile rs) C\n 2. distinct all_constructors\n 3. fBall (Rewriting_Pterm.compile rs) prule\n 4. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 5. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| Rewriting_Pterm.compile rs) C\n 2. distinct all_constructors\n 3. fBall (Rewriting_Pterm.compile rs) prule\n 4. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 5. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "show \"fdisjnt (fst |`| compile rs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| Rewriting_Pterm.compile rs) C", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| map_prod id translate_rhs |`| rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| map_prod id translate_rhs |`| rs) C", "by simp"], ["proof (state)\nthis:\n  fdisjnt (fst |`| Rewriting_Pterm.compile rs) C\n\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. fBall (Rewriting_Pterm.compile rs) prule\n 3. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 4. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. fBall (Rewriting_Pterm.compile rs) prule\n 3. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 4. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "have\n    \"fBall (compile rs) prule\"\n    \"fBall (compile rs) (\\<lambda>(_, rhs). \\<not> shadows_consts rhs)\"\n    \"fBall (compile rs) (\\<lambda>(_, rhs). welldefined rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (Rewriting_Pterm.compile rs) prule &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "proof (safe del: fsubsetI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "fix name rhs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "assume \"(name, rhs) |\\<in>| compile rs\""], ["proof (state)\nthis:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "(* FIXME clone of compile_correct *)"], ["proof (state)\nthis:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "then"], ["proof (chain)\npicking this:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs", "obtain irs where \"(name, irs) |\\<in>| rs\" \"rhs = translate_rhs irs\""], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>(name, irs) |\\<in>| rs; rhs = translate_rhs irs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| map_prod id translate_rhs |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>(name, irs) |\\<in>| rs; rhs = translate_rhs irs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (name, irs) |\\<in>| rs\n  rhs = translate_rhs irs\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "hence \"is_fmap irs\" \"irs \\<noteq> {||}\" \"arity irs = 0\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  rhs = translate_rhs irs\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "using assms inner"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  rhs = translate_rhs irs\n  finished rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "unfolding finished_def"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  rhs = translate_rhs irs\n  fBall rs (\\<lambda>(uu_, irs). arity irs = 0)\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "by blast+"], ["proof (state)\nthis:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "moreover"], ["proof (state)\nthis:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "have \"arity_compatibles irs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "using \\<open>(name, irs) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "ultimately"], ["proof (chain)\npicking this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n  Rewriting_Nterm.arity_compatibles irs", "obtain u where \"irs = {| ([], u) |}\""], ["proof (prove)\nusing this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (1 subgoal):\n 1. (\\<And>u. irs = {|([], u)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_zero_shape)"], ["proof (state)\nthis:\n  irs = {|([], u)|}\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "hence \"rhs = u\" and u: \"([], u) |\\<in>| irs\""], ["proof (prove)\nusing this:\n  irs = {|([], u)|}\n\ngoal (1 subgoal):\n 1. rhs = u &&& ([], u) |\\<in>| irs", "unfolding \\<open>rhs = _\\<close> translate_rhs_def"], ["proof (prove)\nusing this:\n  irs = {|([], u)|}\n\ngoal (1 subgoal):\n 1. (snd \\<circ> fthe_elem) irs = u &&& ([], u) |\\<in>| irs", "by simp+"], ["proof (state)\nthis:\n  rhs = u\n  ([], u) |\\<in>| irs\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "hence \"abs_ish [] u\""], ["proof (prove)\nusing this:\n  rhs = u\n  ([], u) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. abs_ish [] u", "using inner \\<open>(name, irs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  rhs = u\n  ([], u) |\\<in>| irs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. abs_ish [] u", "by blast"], ["proof (state)\nthis:\n  abs_ish [] u\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> is_abs b\n 4. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "thus \"is_abs rhs\""], ["proof (prove)\nusing this:\n  abs_ish [] u\n\ngoal (1 subgoal):\n 1. is_abs rhs", "unfolding abs_ish_def \\<open>rhs = u\\<close>"], ["proof (prove)\nusing this:\n  [] \\<noteq> [] \\<or> is_abs u\n\ngoal (1 subgoal):\n 1. is_abs u", "by simp"], ["proof (state)\nthis:\n  is_abs rhs\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using u \\<open>(name, irs) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  ([], u) |\\<in>| irs\n  (name, irs) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "unfolding \\<open>rhs = u\\<close>"], ["proof (prove)\nusing this:\n  ([], u) |\\<in>| irs\n  (name, irs) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed u", "by blast"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "have \"closed_except u {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "using u inner \\<open>(name, irs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  ([], u) |\\<in>| irs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. closed u", "by (metis (mono_tags, lifting) case_prod_conv fbspec freess_empty)"], ["proof (state)\nthis:\n  closed u\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow> closed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "thus \"closed rhs\""], ["proof (prove)\nusing this:\n  closed u\n\ngoal (1 subgoal):\n 1. closed rhs", "unfolding \\<open>rhs = u\\<close>"], ["proof (prove)\nusing this:\n  closed u\n\ngoal (1 subgoal):\n 1. closed u", "."], ["proof (state)\nthis:\n  closed rhs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "{"], ["proof (state)\nthis:\n  closed rhs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "assume \"shadows_consts rhs\""], ["proof (state)\nthis:\n  shadows_consts rhs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "hence \"shadows_consts u\""], ["proof (prove)\nusing this:\n  shadows_consts rhs\n\ngoal (1 subgoal):\n 1. shadows_consts u", "unfolding compile_def \\<open>rhs = u\\<close>"], ["proof (prove)\nusing this:\n  shadows_consts u\n\ngoal (1 subgoal):\n 1. shadows_consts u", "by simp"], ["proof (state)\nthis:\n  shadows_consts u\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "moreover"], ["proof (state)\nthis:\n  shadows_consts u\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "have \"\\<not> shadows_consts u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "using inner \\<open>([], u) |\\<in>| irs\\<close> \\<open>(name, irs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  ([], u) |\\<in>| irs\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "by blast"], ["proof (state)\nthis:\n  \\<not> shadows_consts u\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| Rewriting_Pterm.compile rs;\n        shadows_consts b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "ultimately"], ["proof (chain)\npicking this:\n  shadows_consts u\n  \\<not> shadows_consts u", "show False"], ["proof (prove)\nusing this:\n  shadows_consts u\n  \\<not> shadows_consts u\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "}"], ["proof (state)\nthis:\n  shadows_consts rhs \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "have \"welldefined u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "using fbspec[OF inner \\<open>(name, irs) |\\<in>| rs\\<close>, simplified] \\<open>([], u) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs \\<and>\n  is_fmap irs \\<and>\n  patterns_compatibles irs \\<and>\n  irs \\<noteq> {||} \\<and>\n  fBall irs\n   (\\<lambda>(pats, rhs).\n       linears pats \\<and>\n       abs_ish pats rhs \\<and>\n       closed_except rhs (freess pats) \\<and>\n       fdisjnt (freess pats) all_consts \\<and>\n       pre_strong_term_class.wellformed rhs \\<and>\n       \\<not> shadows_consts rhs \\<and> consts rhs |\\<subseteq>| all_consts)\n  ([], u) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "by blast"], ["proof (state)\nthis:\n  consts u |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       consts b |\\<subseteq>| all_consts", "thus \"welldefined rhs\""], ["proof (prove)\nusing this:\n  consts u |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "unfolding \\<open>rhs = u\\<close> compile_def"], ["proof (prove)\nusing this:\n  consts u |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "by simp"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fBall (Rewriting_Pterm.compile rs) prule\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. fBall (Rewriting_Pterm.compile rs) prule\n 3. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs)\n 4. fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "thus\n    \"fBall (compile rs) prule\"\n    \"fBall (compile rs) (\\<lambda>(_, rhs). \\<not> pre_constants.shadows_consts C_info (fst |`| compile rs) rhs)\"\n    \"fBall (compile rs) (\\<lambda>(_, rhs). pre_constants.welldefined C_info (fst |`| compile rs) rhs)\""], ["proof (prove)\nusing this:\n  fBall (Rewriting_Pterm.compile rs) prule\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. fBall (Rewriting_Pterm.compile rs) prule &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| Rewriting_Pterm.compile rs) rhs) &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| Rewriting_Pterm.compile rs))", "unfolding compile_heads"], ["proof (prove)\nusing this:\n  fBall (Rewriting_Pterm.compile rs) prule\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. fBall (Rewriting_Pterm.compile rs) prule &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) &&&\n    fBall (Rewriting_Pterm.compile rs)\n     (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "by auto"], ["proof (state)\nthis:\n  fBall (Rewriting_Pterm.compile rs) prule\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs).\n       \\<not> pre_constants.shadows_consts C_info\n               (fst |`| Rewriting_Pterm.compile rs) rhs)\n  fBall (Rewriting_Pterm.compile rs)\n   (\\<lambda>(uu_, rhs).\n       consts rhs |\\<subseteq>|\n       pre_constants.all_consts C_info (fst |`| Rewriting_Pterm.compile rs))\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in irules) compile_correct:\n  assumes \"compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"finished rs\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'", "using assms(1)"], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "case (step name rhs)"], ["proof (state)\nthis:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "then"], ["proof (chain)\npicking this:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs", "obtain irs where \"rhs = translate_rhs irs\" \"(name, irs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>rhs = translate_rhs irs; (name, irs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| map_prod id translate_rhs |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>rhs = translate_rhs irs; (name, irs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rhs = translate_rhs irs\n  (name, irs) |\\<in>| rs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "hence \"arity_compatibles irs\""], ["proof (prove)\nusing this:\n  rhs = translate_rhs irs\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "using inner"], ["proof (prove)\nusing this:\n  rhs = translate_rhs irs\n  (name, irs) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "have \"is_fmap irs\" \"irs \\<noteq> {||}\" \"arity irs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "using assms inner \\<open>(name, irs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n  finished rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "unfolding finished_def"], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n  fBall rs (\\<lambda>(uu_, irs). arity irs = 0)\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "by blast+"], ["proof (state)\nthis:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "then"], ["proof (chain)\npicking this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0", "obtain u where \"irs = {| ([], u) |}\""], ["proof (prove)\nusing this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (1 subgoal):\n 1. (\\<And>u. irs = {|([], u)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>arity_compatibles irs\\<close>"], ["proof (prove)\nusing this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (1 subgoal):\n 1. (\\<And>u. irs = {|([], u)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_zero_shape)"], ["proof (state)\nthis:\n  irs = {|([], u)|}\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       (name, rhs) |\\<in>| Rewriting_Pterm.compile rs \\<Longrightarrow>\n       rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> translate_rhs irs", "apply (rule irewrite.step)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (?name, ?rs) |\\<in>| rs\n 2. (?pats, ?rhs) |\\<in>| ?rs\n 3. ?name, ?pats, ?rhs \\<turnstile>\\<^sub>i Pconst name \\<rightarrow>\n    translate_rhs irs", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?pats, ?rhs) |\\<in>| irs\n 2. name, ?pats, ?rhs \\<turnstile>\\<^sub>i Pconst name \\<rightarrow>\n    translate_rhs irs", "unfolding \\<open>irs = _\\<close> translate_rhs_def irewrite_step_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?pats, ?rhs) |\\<in>| {|([], u)|}\n 2. map_option (subst ?rhs) (match (name $$ ?pats) (Pconst name)) =\n    Some ((snd \\<circ> fthe_elem) {|([], u)|})", "by (auto simp: const_term_def)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i Pconst name \\<longrightarrow> rhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 2. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow> t';\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 3. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                u \\<longrightarrow> u';\n        rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "qed (auto intro: irewrite.intros)"], ["", "theorem (in irules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\" \"finished rs\"\n  shows \"compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'", "using assms(1)"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\n\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "case (step name irs params rhs t t')"], ["proof (state)\nthis:\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "hence \"arity_compatibles irs\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "using inner"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "have \"is_fmap irs\" \"irs \\<noteq> {||}\" \"arity irs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "using assms inner step"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\n  finished rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "unfolding finished_def"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\n  fBall rs (\\<lambda>(uu_, irs). arity irs = 0)\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. is_fmap irs &&& irs \\<noteq> {||} &&& arity irs = 0", "by blast+"], ["proof (state)\nthis:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "then"], ["proof (chain)\npicking this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0", "obtain u where \"irs = {| ([], u) |}\""], ["proof (prove)\nusing this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n\ngoal (1 subgoal):\n 1. (\\<And>u. irs = {|([], u)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>arity_compatibles irs\\<close>"], ["proof (prove)\nusing this:\n  is_fmap irs\n  irs \\<noteq> {||}\n  arity irs = 0\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (1 subgoal):\n 1. (\\<And>u. irs = {|([], u)|} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_zero_shape)"], ["proof (state)\nthis:\n  irs = {|([], u)|}\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "with step"], ["proof (chain)\npicking this:\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  irs = {|([], u)|}", "have \"name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  (params, rhs) |\\<in>| irs\n  name, params, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  irs = {|([], u)|}\n\ngoal (1 subgoal):\n 1. name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'", "by simp"], ["proof (state)\nthis:\n  name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "hence \"t = Pconst name\""], ["proof (prove)\nusing this:\n  name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. t = Pconst name", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  map_option (subst u) (match (name $$ []) t) = Some t'\n\ngoal (1 subgoal):\n 1. t = Pconst name", "by (cases t) (auto split: if_splits simp: const_term_def)"], ["proof (state)\nthis:\n  t = Pconst name\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "hence \"t' = u\""], ["proof (prove)\nusing this:\n  t = Pconst name\n\ngoal (1 subgoal):\n 1. t' = u", "using \\<open>name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<close>"], ["proof (prove)\nusing this:\n  t = Pconst name\n  name, [], u \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. t' = u", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  t = Pconst name\n  map_option (subst u) (match (name $$ []) t) = Some t'\n\ngoal (1 subgoal):\n 1. t' = u", "by (cases t) (auto split: if_splits simp: const_term_def)"], ["proof (state)\nthis:\n  t' = u\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "have \"(name, t') |\\<in>| compile rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, t') |\\<in>| Rewriting_Pterm.compile rs", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, t') |\\<in>| map_prod id translate_rhs |`| rs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (name, t') = map_prod id translate_rhs ?x\n 2. ?x |\\<in>| rs", "show \"(name, t') = map_prod id translate_rhs (name, irs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, t') = map_prod id translate_rhs (name, irs)", "using \\<open>irs = _\\<close> \\<open>t' = u\\<close>"], ["proof (prove)\nusing this:\n  irs = {|([], u)|}\n  t' = u\n\ngoal (1 subgoal):\n 1. (name, t') = map_prod id translate_rhs (name, irs)", "by (simp add: split_beta translate_rhs_def)"], ["proof (state)\nthis:\n  (name, t') = map_prod id translate_rhs (name, irs)\n\ngoal (1 subgoal):\n 1. (name, irs) |\\<in>| rs", "qed fact"], ["proof (state)\nthis:\n  (name, t') |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t \\<longrightarrow> t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "thus ?case"], ["proof (prove)\nusing this:\n  (name, t') |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  (name, t') |\\<in>| Rewriting_Pterm.compile rs\n\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n    Pconst name \\<longrightarrow> t'", "by (rule prewrite.step)"], ["proof (state)\nthis:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         Pabs cs $\\<^sub>p t \\<longrightarrow> t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>\n        t'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p u \\<longrightarrow>\n        u'\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                         t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'", "qed (auto intro: prewrite.intros)"], ["", "export_code\n  compile finished\n  checking Scala"], ["", "end"]]}