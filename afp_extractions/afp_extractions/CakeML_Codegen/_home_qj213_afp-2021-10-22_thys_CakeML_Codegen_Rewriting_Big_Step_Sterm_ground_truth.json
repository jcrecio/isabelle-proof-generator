{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Big_Step_Sterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma (in constructors) seval_closed:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"closed_srules rs\" \"closed_env \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  shows \"closed u\"", "lemma (in srules) seval_wellformed:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"wellformed t\" \"wellformed_env \\<Gamma>\"\n  shows \"wellformed u\"", "lemma (in constants) seval_shadows:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"\\<not> shadows_consts t\"\n  assumes \"list_all (\\<lambda>(_, rhs). \\<not> shadows_consts rhs) rs\"\n  assumes \"not_shadows_consts_env \\<Gamma>\"\n  shows \"\\<not> shadows_consts u\"", "lemma (in constructors) seval_list_comb_abs:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s name $$ args \\<down> Sabs cs\"\n  shows \"name \\<in> dom (map_of rs)\"", "lemma (in constructors) is_value_eval_id:\n  assumes \"is_value t\" \"closed t\"\n  shows \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t\"", "lemma (in constructors) ssubst_eval:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t'\" \"\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\" \"closed_env \\<Gamma>\" \"value_env \\<Gamma>\"\n  shows \"rs, \\<Gamma> \\<turnstile>\\<^sub>s subst t \\<Gamma>' \\<down> t'\"", "lemma (in constructors) seval_agree_eq:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\" \"closed_except t S\"\n  assumes \"S |\\<subseteq>| fmdom \\<Gamma>\" \"closed_srules rs\" \"closed_env \\<Gamma>\"\n  shows \"rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> u\"", "lemma seval_correct0:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"closed_except t (fmdom \\<Gamma>)\" \"closed_env \\<Gamma>\"\n  shows \"rs \\<turnstile>\\<^sub>s subst t \\<Gamma> \\<longrightarrow>* u\""], "translations": [["", "lemma (in constructors) seval_closed:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"closed_srules rs\" \"closed_env \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  shows \"closed u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed u", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Sconst name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "case (const name rhs \\<Gamma>)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Sconst name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  closed rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "case (comb \\<Gamma> t cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed (Sabs cs)\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed u'\n  \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n  \\<Longrightarrow> closed val\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "hence \"closed (Sabs cs)\" \"closed u'\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed (Sabs cs)\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed u'\n  \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n  \\<Longrightarrow> closed val\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed (Sabs cs) &&& closed u'", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed (Sabs cs)\n  closed u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "moreover"], ["proof (state)\nthis:\n  closed (Sabs cs)\n  closed u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "have \"(pat, rhs) \\<in> set cs\" \"match pat u' = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat u' = Some env", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed (Sabs cs)\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed u'\n  \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n  \\<Longrightarrow> closed val\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat u' = Some env", "by (auto simp: find_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "ultimately"], ["proof (chain)\npicking this:\n  closed (Sabs cs)\n  closed u'\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env", "have \"closed_except rhs (frees pat)\""], ["proof (prove)\nusing this:\n  closed (Sabs cs)\n  closed u'\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "by (auto dest: closed_except_sabs)"], ["proof (state)\nthis:\n  closed_except rhs (frees pat)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n         closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n        \\<Longrightarrow> closed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n         closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n        \\<Longrightarrow> closed val;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed val", "proof (rule comb)"], ["proof (state)\ngoal (3 subgoals):\n 1. closed_srules rs\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)\n 3. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "have \"closed_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env", "by (rule closed.match) fact+"], ["proof (state)\nthis:\n  closed_env env\n\ngoal (3 subgoals):\n 1. closed_srules rs\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)\n 3. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "thus \"closed_env (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  closed_env env\n\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "using \\<open>closed_env \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  closed_env env\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "by auto"], ["proof (state)\nthis:\n  closed_env (\\<Gamma> ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "have \"closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)", "using \\<open>closed_except rhs _\\<close>"], ["proof (prove)\nusing this:\n  closed_except rhs (frees pat)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| frees pat\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| fmdom \\<Gamma> |\\<union>| frees pat", "by auto"], ["proof (state)\nthis:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)\n\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "hence \"closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)\""], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)", "using \\<open>match pat u' = Some env\\<close>"], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)", "by (metis match_dom)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)\n\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "thus \"closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "using comb"], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom env)\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed (Sabs cs)\n  \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n   closed_except u (fmdom \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> closed u'\n  \\<lbrakk>closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\\<rbrakk>\n  \\<Longrightarrow> closed val\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "by simp"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. closed_srules rs", "qed fact"], ["proof (state)\nthis:\n  closed val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (Sabs cs) (fmdom \\<Gamma>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_srules rs; closed_env \\<Gamma>;\n        closed_except (Sabs cs) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n         cs))", "apply (subst subst_sterm.simps[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst (Sabs cs) \\<Gamma>)", "apply (subst closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst (Sabs cs) \\<Gamma>) |\\<subseteq>| {||}", "apply (subst subst_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env \\<Gamma>\n 2. frees (Sabs cs) |-| fmdom \\<Gamma> |\\<subseteq>| {||}", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Sabs cs) |-| fmdom \\<Gamma> |\\<subseteq>| {||}", "apply (subst fminus_fsubset_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| {||}", "apply (subst closed_except_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma> |\\<union>| {||})", "apply (subst funion_fempty_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma>)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed\n   (Sabs\n     (map (\\<lambda>(pat, t).\n              (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n       cs))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (closed_srules rs \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow> closed x2))\n   ts us\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "have \"list_all closed us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed us", "using \\<open>list_all2 _ _ _\\<close> \\<open>closed_except (list_comb _ _) _\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (closed_srules rs \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow> closed x2))\n   ts us\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. list_all closed us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_except (name $$ []) (fmdom \\<Gamma>) \\<Longrightarrow>\n    list_all closed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow>\n                 closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                 closed b21);\n        closed_except (name $$ a22) (fmdom \\<Gamma>) \\<Longrightarrow>\n        list_all closed b22;\n        closed_except (name $$ (a21 # a22)) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> list_all closed (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (closed_srules rs \\<longrightarrow>\n   closed_env \\<Gamma> \\<longrightarrow>\n   closed_except v (fmdom \\<Gamma>) \\<longrightarrow> closed u)\n  closed_except (name $$ vs) (fmdom \\<Gamma>) \\<Longrightarrow>\n  list_all closed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n\ngoal (2 subgoals):\n 1. closed_except (name $$ []) (fmdom \\<Gamma>) \\<Longrightarrow>\n    list_all closed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow>\n                 closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                 closed b21);\n        closed_except (name $$ a22) (fmdom \\<Gamma>) \\<Longrightarrow>\n        list_all closed b22;\n        closed_except (name $$ (a21 # a22)) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> list_all closed (b21 # b22)", "thus ?case"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (closed_srules rs \\<longrightarrow>\n   closed_env \\<Gamma> \\<longrightarrow>\n   closed_except v (fmdom \\<Gamma>) \\<longrightarrow> closed u)\n  closed_except (name $$ vs) (fmdom \\<Gamma>) \\<Longrightarrow>\n  list_all closed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. list_all closed (u # us)", "using constr"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (closed_srules rs \\<longrightarrow>\n   closed_env \\<Gamma> \\<longrightarrow>\n   closed_except v (fmdom \\<Gamma>) \\<longrightarrow> closed u)\n  closed_except (name $$ vs) (fmdom \\<Gamma>) \\<Longrightarrow>\n  list_all closed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (closed_srules rs \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow> closed x2))\n   ts us__\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. list_all closed (u # us)", "unfolding closed.list_comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (closed_srules rs \\<longrightarrow>\n   closed_env \\<Gamma> \\<longrightarrow>\n   closed_except v (fmdom \\<Gamma>) \\<longrightarrow> closed u)\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>))\n   vs \\<Longrightarrow>\n  list_all closed us\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) (v # vs)\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (closed_srules rs \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow> closed x2))\n   ts us__\n  closed_srules rs\n  closed_env \\<Gamma>\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n\ngoal (1 subgoal):\n 1. list_all closed (u # us)", "by auto"], ["proof (state)\nthis:\n  list_all closed (u # us)\n\ngoal (1 subgoal):\n 1. closed_except (name $$ []) (fmdom \\<Gamma>) \\<Longrightarrow>\n    list_all closed []", "qed simp"], ["proof (state)\nthis:\n  list_all closed us\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_srules rs \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed x2))\n         ts us;\n        closed_srules rs; closed_env \\<Gamma>;\n        closed_except (name $$ ts) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all closed us\n\ngoal (1 subgoal):\n 1. closed (name $$ us)", "unfolding closed.list_comb"], ["proof (prove)\nusing this:\n  list_all closed us\n\ngoal (1 subgoal):\n 1. closed (const name) \\<and> list_all closed us", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  closed (name $$ us)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val; closed_srules rs;\n        closed_env \\<Gamma>;\n        closed_except (Svar name) (fmdom \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> closed val", "qed auto"], ["", "lemma (in srules) seval_wellformed:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"wellformed t\" \"wellformed_env \\<Gamma>\"\n  shows \"wellformed u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed u", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\n  pre_strong_term_class.wellformed t\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed u", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "case (const name rhs \\<Gamma>)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using all_rules"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_env \\<Gamma>\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "case (comb \\<Gamma> t cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs)\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "hence \"(pat, rhs) \\<in> set cs\" \"match pat u' = Some env\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs)\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat u' = Some env", "by (auto simp: find_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed val", "proof (rule comb)"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> comb"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs)\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "have \"wellformed_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_env env", "apply (rule wellformed.match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match ?pat ?t = Some env\n 2. pre_strong_term_class.wellformed ?t", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed u'", "apply (rule comb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_env \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs)\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_env \\<Gamma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_env \\<Gamma>", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_env env\n\ngoal (1 subgoal):\n 1. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "thus \"wellformed_env (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  wellformed_env env\n\ngoal (1 subgoal):\n 1. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "using comb"], ["proof (prove)\nusing this:\n  wellformed_env env\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (Sabs cs)\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_env (\\<Gamma> ++\\<^sub>f env)", "by auto"], ["proof (state)\nthis:\n  wellformed_env (\\<Gamma> ++\\<^sub>f env)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                              cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n         cs))", "by (metis subst_sterm.simps subst_wellformed)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed\n   (Sabs\n     (map (\\<lambda>(pat, t).\n              (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n       cs))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_env \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x2))\n   ts us\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "have \"list_all wellformed us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed us", "using \\<open>list_all2 _ _ _\\<close> \\<open>wellformed (list_comb _ _)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_env \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x2))\n   ts us\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all pre_strong_term_class.wellformed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_env \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed b21);\n        pre_strong_term_class.wellformed (name $$ a22) \\<Longrightarrow>\n        list_all pre_strong_term_class.wellformed b22;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all pre_strong_term_class.wellformed\n                          (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_env \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all pre_strong_term_class.wellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all pre_strong_term_class.wellformed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_env \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed b21);\n        pre_strong_term_class.wellformed (name $$ a22) \\<Longrightarrow>\n        list_all pre_strong_term_class.wellformed b22;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all pre_strong_term_class.wellformed\n                          (b21 # b22)", "thus ?case"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_env \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all pre_strong_term_class.wellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed (u # us)", "using constr"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_env \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all pre_strong_term_class.wellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_env \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x2))\n   ts us__\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed (u # us)", "by (auto simp: wellformed.list_comb app_sterm_def)"], ["proof (state)\nthis:\n  list_all pre_strong_term_class.wellformed (u # us)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all pre_strong_term_class.wellformed []", "qed simp"], ["proof (state)\nthis:\n  list_all pre_strong_term_class.wellformed us\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_env \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all pre_strong_term_class.wellformed us\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (name $$ us)", "by (simp add: wellformed.list_comb const_sterm_def)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (name $$ us)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed val", "qed auto"], ["", "lemma (in constants) seval_shadows:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"\\<not> shadows_consts t\"\n  assumes \"list_all (\\<lambda>(_, rhs). \\<not> shadows_consts rhs) rs\"\n  assumes \"not_shadows_consts_env \\<Gamma>\"\n  shows \"\\<not> shadows_consts u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\n  \\<not> shadows_consts t\n  list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<not> shadows_consts (Sconst name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "case (const name rhs \\<Gamma>)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n  \\<not> shadows_consts (Sconst name)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<not> shadows_consts (Sconst name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  \\<not> shadows_consts (Sconst name)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "unfolding srules_def"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  \\<not> shadows_consts (Sconst name)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "case (comb \\<Gamma> t cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "hence \"\\<not> shadows_consts (Sabs cs)\" \"\\<not> shadows_consts u'\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs) &&& \\<not> shadows_consts u'", "by auto"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs)\n  \\<not> shadows_consts u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "moreover"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs)\n  \\<not> shadows_consts u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "from comb"], ["proof (chain)\npicking this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>", "have \"(pat, rhs) \\<in> set cs\" \"match pat u' = Some env\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat u' = Some env", "by (auto simp: find_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> shadows_consts (Sabs cs)\n  \\<not> shadows_consts u'\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n  \\<not> shadows_consts u'\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "moreover"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "have \"not_shadows_consts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_consts_env env", "using comb \\<open>match pat u' = _\\<close>"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. not_shadows_consts_env env", "by (auto intro: shadows.match)"], ["proof (state)\nthis:\n  not_shadows_consts_env env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<not> shadows_consts t;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts (Sabs cs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<not> shadows_consts u;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<not> shadows_consts rhs;\n         list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n         not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> \\<not> shadows_consts val;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> shadows_consts rhs\n  not_shadows_consts_env env", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n  not_shadows_consts_env env\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts val", "using comb"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n  not_shadows_consts_env env\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>\\<not> shadows_consts t;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (Sabs cs)\n  \\<lbrakk>\\<not> shadows_consts u;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts u'\n  \\<lbrakk>\\<not> shadows_consts rhs;\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs;\n   not_shadows_consts_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts val\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts val", "by blast"], ["proof (state)\nthis:\n  \\<not> shadows_consts val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<not> shadows_consts (Sabs cs);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                                     cs))\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts\n            (Sabs\n              (map (\\<lambda>(pat, t).\n                       (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n                cs))", "apply (subst subst_sterm.simps[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (subst (Sabs cs) \\<Gamma>)", "apply (rule subst_shadows)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> shadows_consts (Sabs cs)\n 2. not_shadows_consts_env \\<Gamma>", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> shadows_consts\n          (Sabs\n            (map (\\<lambda>(pat, t).\n                     (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n              cs))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<not> shadows_consts x1 \\<longrightarrow>\n        list_all\n         (\\<lambda>a.\n             case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n         rs \\<longrightarrow>\n        not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x2))\n   ts us\n  \\<not> shadows_consts (name $$ ts)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "have \"list_all (Not \\<circ> shadows_consts) us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (Not \\<circ> shadows_consts) us", "using \\<open>list_all2 _ _ _\\<close> \\<open>\\<not> shadows_consts (name $$ ts)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<not> shadows_consts x1 \\<longrightarrow>\n        list_all\n         (\\<lambda>a.\n             case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n         rs \\<longrightarrow>\n        not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x2))\n   ts us\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all (Not \\<circ> shadows_consts) us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all (Not \\<circ> shadows_consts) []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (\\<not> shadows_consts a21 \\<longrightarrow>\n                 list_all\n                  (\\<lambda>a.\n                      case a of\n                      (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n                  rs \\<longrightarrow>\n                 not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts b21);\n        \\<not> shadows_consts (name $$ a22) \\<Longrightarrow>\n        list_all (Not \\<circ> shadows_consts) b22;\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all (Not \\<circ> shadows_consts) (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (\\<not> shadows_consts v \\<longrightarrow>\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs \\<longrightarrow>\n   not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all (Not \\<circ> shadows_consts) us\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all (Not \\<circ> shadows_consts) []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s a21 \\<down> b21 \\<and>\n                (\\<not> shadows_consts a21 \\<longrightarrow>\n                 list_all\n                  (\\<lambda>a.\n                      case a of\n                      (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n                  rs \\<longrightarrow>\n                 not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts b21);\n        \\<not> shadows_consts (name $$ a22) \\<Longrightarrow>\n        list_all (Not \\<circ> shadows_consts) b22;\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all (Not \\<circ> shadows_consts) (b21 # b22)", "thus ?case"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (\\<not> shadows_consts v \\<longrightarrow>\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs \\<longrightarrow>\n   not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all (Not \\<circ> shadows_consts) us\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all (Not \\<circ> shadows_consts) (u # us)", "using constr"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> u \\<and>\n  (\\<not> shadows_consts v \\<longrightarrow>\n   list_all\n    (\\<lambda>a.\n        case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n    rs \\<longrightarrow>\n   not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all (Not \\<circ> shadows_consts) us\n  \\<not> shadows_consts (name $$ (v # vs))\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<not> shadows_consts x1 \\<longrightarrow>\n        list_all\n         (\\<lambda>a.\n             case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n         rs \\<longrightarrow>\n        not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x2))\n   ts us__\n  \\<not> shadows_consts (name $$ ts)\n  list_all\n   (\\<lambda>a.\n       case a of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)\n   rs\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all (Not \\<circ> shadows_consts) (u # us)", "by (auto simp: shadows.list_comb const_sterm_def app_sterm_def)"], ["proof (state)\nthis:\n  list_all (Not \\<circ> shadows_consts) (u # us)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all (Not \\<circ> shadows_consts) []", "qed simp"], ["proof (state)\nthis:\n  list_all (Not \\<circ> shadows_consts) us\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val\n 2. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<not> shadows_consts x1 \\<longrightarrow>\n              list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n               rs \\<longrightarrow>\n              not_shadows_consts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x2))\n         ts us;\n        \\<not> shadows_consts (name $$ ts);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (name $$ us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (Not \\<circ> shadows_consts) us\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (name $$ us)", "by (auto simp: shadows.list_comb list_ex_iff list_all_iff const_sterm_def)"], ["proof (state)\nthis:\n  \\<not> shadows_consts (name $$ us)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<not> shadows_consts (Svar name);\n        list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs;\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts val", "qed auto"], ["", "lemma (in constructors) seval_list_comb_abs:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s name $$ args \\<down> Sabs cs\"\n  shows \"name \\<in> dom (map_of rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<in> dom (map_of rs)", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s name $$ args \\<down> Sabs cs\n\ngoal (1 subgoal):\n 1. name \\<in> dom (map_of rs)", "proof (induction \\<Gamma> \"name $$ args\" \"Sabs cs\" arbitrary: args cs)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 5. \\<And>namea \\<Gamma> ts us args cs.\n       \\<lbrakk>namea |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x.\n                 x1 = name $$ x \\<longrightarrow>\n                 (\\<forall>x.\n                     x2 = Sabs x \\<longrightarrow>\n                     name \\<in> dom (map_of rs))))\n         ts us;\n        namea $$ ts = name $$ args; namea $$ us = Sabs cs\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "case (constr name' _ _ us)"], ["proof (state)\nthis:\n  name' |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma>_ \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<forall>x.\n           x1 = name $$ x \\<longrightarrow>\n           (\\<forall>x.\n               x2 = Sabs x \\<longrightarrow> name \\<in> dom (map_of rs))))\n   ts_ us\n  name' $$ ts_ = name $$ args\n  name' $$ us = Sabs cs\n\ngoal (5 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 5. \\<And>namea \\<Gamma> ts us args cs.\n       \\<lbrakk>namea |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x.\n                 x1 = name $$ x \\<longrightarrow>\n                 (\\<forall>x.\n                     x2 = Sabs x \\<longrightarrow>\n                     name \\<in> dom (map_of rs))))\n         ts us;\n        namea $$ ts = name $$ args; namea $$ us = Sabs cs\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "hence \"Sabs cs = name' $$ us\""], ["proof (prove)\nusing this:\n  name' |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma>_ \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<forall>x.\n           x1 = name $$ x \\<longrightarrow>\n           (\\<forall>x.\n               x2 = Sabs x \\<longrightarrow> name \\<in> dom (map_of rs))))\n   ts_ us\n  name' $$ ts_ = name $$ args\n  name' $$ us = Sabs cs\n\ngoal (1 subgoal):\n 1. Sabs cs = name' $$ us", "by simp"], ["proof (state)\nthis:\n  Sabs cs = name' $$ us\n\ngoal (5 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 5. \\<And>namea \\<Gamma> ts us args cs.\n       \\<lbrakk>namea |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x.\n                 x1 = name $$ x \\<longrightarrow>\n                 (\\<forall>x.\n                     x2 = Sabs x \\<longrightarrow>\n                     name \\<in> dom (map_of rs))))\n         ts us;\n        namea $$ ts = name $$ args; namea $$ us = Sabs cs\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "hence False"], ["proof (prove)\nusing this:\n  Sabs cs = name' $$ us\n\ngoal (1 subgoal):\n 1. False", "by (cases rule: list_comb_cases) (auto simp: const_sterm_def app_sterm_def)"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 5. \\<And>namea \\<Gamma> ts us args cs.\n       \\<lbrakk>namea |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x.\n                 x1 = name $$ x \\<longrightarrow>\n                 (\\<forall>x.\n                     x2 = Sabs x \\<longrightarrow>\n                     name \\<in> dom (map_of rs))))\n         ts us;\n        namea $$ ts = name $$ args; namea $$ us = Sabs cs\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. name \\<in> dom (map_of rs)", ".."], ["proof (state)\nthis:\n  name \\<in> dom (map_of rs)\n\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "case (comb \\<Gamma> t cs' u u' env pat rhs)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs'\n  t = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>u = name $$ ?args; u' = Sabs ?cs\\<rbrakk>\n  \\<Longrightarrow> name \\<in> dom (map_of rs)\n  find_match cs' u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> Sabs cs\n  rhs = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  t $\\<^sub>s u = name $$ args\n\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "hence \"strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args)\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs'\n  t = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>u = name $$ ?args; u' = Sabs ?cs\\<rbrakk>\n  \\<Longrightarrow> name \\<in> dom (map_of rs)\n  find_match cs' u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> Sabs cs\n  rhs = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  t $\\<^sub>s u = name $$ args\n\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args)", "by simp"], ["proof (state)\nthis:\n  strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args)\n\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "hence \"strip_comb t = (Sconst name, butlast args)\" \"u = last args\""], ["proof (prove)\nusing this:\n  strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args)\n\ngoal (1 subgoal):\n 1. strip_comb t = (Sconst name, butlast args) &&& u = last args", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args) \\<Longrightarrow>\n    strip_comb t = (Sconst name, butlast args)\n 2. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args) \\<Longrightarrow>\n    u = last args", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args) \\<Longrightarrow>\n    strip_comb t = (Sconst name, butlast args)", "apply (simp add: strip_list_comb_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = (const name, args) \\<Longrightarrow>\n    strip_comb t = (Sconst name, butlast args)", "apply (fold app_sterm_def const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (app t u) = (const name, args) \\<Longrightarrow>\n    strip_comb t = (const name, butlast args)", "by (auto split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args) \\<Longrightarrow>\n    u = last args", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = strip_comb (name $$ args) \\<Longrightarrow>\n    u = last args", "apply (simp add: strip_list_comb_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (t $\\<^sub>s u) = (const name, args) \\<Longrightarrow>\n    u = last args", "apply (fold app_sterm_def const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (app t u) = (const name, args) \\<Longrightarrow>\n    u = last args", "by (auto split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  strip_comb t = (Sconst name, butlast args)\n  u = last args\n\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "hence \"t = name $$ butlast args\""], ["proof (prove)\nusing this:\n  strip_comb t = (Sconst name, butlast args)\n  u = last args\n\ngoal (1 subgoal):\n 1. t = name $$ butlast args", "apply (fold const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strip_comb t = (const name, butlast args);\n     u = last args\\<rbrakk>\n    \\<Longrightarrow> t = name $$ butlast args", "by (metis list_strip_comb fst_conv snd_conv)"], ["proof (state)\nthis:\n  t = name $$ butlast args\n\ngoal (4 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs args csa.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>args.\n           t = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>args cs.\n           \\<lbrakk>u = name $$ args; u' = Sabs cs\\<rbrakk>\n           \\<Longrightarrow> name \\<in> dom (map_of rs);\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down>\n        Sabs csa;\n        \\<And>args.\n           rhs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs);\n        t $\\<^sub>s u = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)", "thus ?case"], ["proof (prove)\nusing this:\n  t = name $$ butlast args\n\ngoal (1 subgoal):\n 1. name \\<in> dom (map_of rs)", "using comb"], ["proof (prove)\nusing this:\n  t = name $$ butlast args\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs'\n  t = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>u = name $$ ?args; u' = Sabs ?cs\\<rbrakk>\n  \\<Longrightarrow> name \\<in> dom (map_of rs)\n  find_match cs' u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> Sabs cs\n  rhs = name $$ ?args \\<Longrightarrow> name \\<in> dom (map_of rs)\n  t $\\<^sub>s u = name $$ args\n\ngoal (1 subgoal):\n 1. name \\<in> dom (map_of rs)", "by auto"], ["proof (state)\nthis:\n  name \\<in> dom (map_of rs)\n\ngoal (3 subgoals):\n 1. \\<And>namea \\<Gamma> args cs.\n       \\<lbrakk>(namea, Sabs cs) \\<in> set rs;\n        Sconst namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 2. \\<And>\\<Gamma> namea args cs.\n       \\<lbrakk>fmlookup \\<Gamma> namea = Some (Sabs cs);\n        Svar namea = name $$ args\\<rbrakk>\n       \\<Longrightarrow> name \\<in> dom (map_of rs)\n 3. \\<And>\\<Gamma> cs args.\n       Sabs cs = name $$ args \\<Longrightarrow> name \\<in> dom (map_of rs)", "qed (auto elim: list_comb_cases simp: const_sterm_def app_sterm_def intro: weak_map_of_SomeI)"], ["", "lemma (in constructors) is_value_eval_id:\n  assumes \"is_value t\" \"closed t\"\n  shows \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t", "using assms"], ["proof (prove)\nusing this:\n  is_value t\n  closed t\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       closed (Sabs cs) \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "case (abs cs)"], ["proof (state)\nthis:\n  closed (Sabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       closed (Sabs cs) \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "have \"rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs (map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>))) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down>\n    Sabs\n     (map (\\<lambda>(pat, t).\n              (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n       cs)", "by (rule seval.abs)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       closed (Sabs cs) \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "moreover"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       closed (Sabs cs) \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "have \"subst (Sabs cs) \\<Gamma> = Sabs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (Sabs cs) \\<Gamma> = Sabs cs", "using abs"], ["proof (prove)\nusing this:\n  closed (Sabs cs)\n\ngoal (1 subgoal):\n 1. subst (Sabs cs) \\<Gamma> = Sabs cs", "by (metis subst_closed_id)"], ["proof (state)\nthis:\n  subst (Sabs cs) \\<Gamma> = Sabs cs\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       closed (Sabs cs) \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "ultimately"], ["proof (chain)\npicking this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n  subst (Sabs cs) \\<Gamma> = Sabs cs", "show ?case"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n  subst (Sabs cs) \\<Gamma> = Sabs cs\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs", "by simp"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s Sabs cs \\<down> Sabs cs\n\ngoal (1 subgoal):\n 1. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "case (constr vs name)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>x.\n       is_value x \\<and>\n       (closed x \\<longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n        x \\<down> x))\n   vs\n  name |\\<in>| C\n  closed (name $$ vs)\n\ngoal (1 subgoal):\n 1. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "have \"list_all2 (seval rs \\<Gamma>) vs vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (seval rs \\<Gamma>) vs vs", "proof (rule list.rel_refl_strong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> z", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> z", "assume \"v \\<in> set vs\""], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> z", "moreover"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> z", "hence \"closed v\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. closed v", "using constr"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  list_all\n   (\\<lambda>x.\n       is_value x \\<and>\n       (closed x \\<longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n        x \\<down> x))\n   vs\n  name |\\<in>| C\n  closed (name $$ vs)\n\ngoal (1 subgoal):\n 1. closed v", "unfolding closed.list_comb"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  list_all\n   (\\<lambda>x.\n       is_value x \\<and>\n       (closed x \\<longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n        x \\<down> x))\n   vs\n  name |\\<in>| C\n  closed (const name) \\<and> list_all closed vs\n\ngoal (1 subgoal):\n 1. closed v", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  closed v\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> z", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set vs\n  closed v", "show \"rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> v\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  closed v\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> v", "using \\<open>list_all _ _\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  closed v\n  list_all\n   (\\<lambda>x.\n       is_value x \\<and>\n       (closed x \\<longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n        x \\<down> x))\n   vs\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> v", "by (force simp: list_all_iff)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s v \\<down> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (seval rs \\<Gamma>) vs vs\n\ngoal (1 subgoal):\n 1. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and>\n                     (closed x \\<longrightarrow> rs, \\<Gamma>\n                      \\<turnstile>\\<^sub>s x \\<down> x))\n                 vs;\n        name |\\<in>| C; closed (name $$ vs)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         name $$ vs \\<down> name $$ vs", "with \\<open>name |\\<in>| C\\<close>"], ["proof (chain)\npicking this:\n  name |\\<in>| C\n  list_all2 (seval rs \\<Gamma>) vs vs", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2 (seval rs \\<Gamma>) vs vs\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s name $$ vs \\<down> name $$ vs", "by (rule seval.constr)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s name $$ vs \\<down> name $$ vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in constructors) ssubst_eval:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t'\" \"\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\" \"closed_env \\<Gamma>\" \"value_env \\<Gamma>\"\n  shows \"rs, \\<Gamma> \\<turnstile>\\<^sub>s subst t \\<Gamma>' \\<down> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst t \\<Gamma>' \\<down> t'", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> t'\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst t \\<Gamma>' \\<down> t'", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma>' \\<down> val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "case (var \\<Gamma> name val)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> name = Some val\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma>' \\<down> val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val", "proof (cases \"fmlookup \\<Gamma>' name\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma>' name = None \\<Longrightarrow>\n    rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val\n 2. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "case None"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>' name = None\n\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma>' name = None \\<Longrightarrow>\n    rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val\n 2. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = None\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val", "using var"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = None\n  fmlookup \\<Gamma> name = Some val\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val", "by (auto intro: seval.intros)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down> val\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "case (Some val')"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>' name = Some val'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "with var"], ["proof (chain)\npicking this:\n  fmlookup \\<Gamma> name = Some val\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n  fmlookup \\<Gamma>' name = Some val'", "have \"val' = val\""], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n  fmlookup \\<Gamma>' name = Some val'\n\ngoal (1 subgoal):\n 1. val' = val", "unfolding fmsubset_alt_def"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  fmpred (\\<lambda>k v. fmlookup \\<Gamma> k = Some v) \\<Gamma>'\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n  fmlookup \\<Gamma>' name = Some val'\n\ngoal (1 subgoal):\n 1. val' = val", "by force"], ["proof (state)\nthis:\n  val' = val\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       fmlookup \\<Gamma>' name = Some a \\<Longrightarrow>\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n       val", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down>\n    val", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s\n    (case fmlookup \\<Gamma>' name of None \\<Rightarrow> Svar name\n     | Some t \\<Rightarrow> t) \\<down>\n    val", "apply (subst Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s\n    (case Some val' of None \\<Rightarrow> Svar name\n     | Some t \\<Rightarrow> t) \\<down>\n    val", "apply (subst \\<open>val' = _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s\n    (case Some val of None \\<Rightarrow> Svar name\n     | Some t \\<Rightarrow> t) \\<down>\n    val", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s val \\<down> val", "apply (rule is_value_eval_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_value val\n 2. closed val", "using var"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. is_value val\n 2. closed val", "by auto"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down> val\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Svar name) \\<Gamma>' \\<down> val\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "hence \"subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>\""], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>", "by (metis subst_twice fmsubset_pred)"], ["proof (state)\nthis:\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "moreover"], ["proof (state)\nthis:\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "have \"rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down> subst (subst (Sabs cs) \\<Gamma>') \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n    subst (subst (Sabs cs) \\<Gamma>') \\<Gamma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s\n    Sabs\n     (map (\\<lambda>(pat, rhs).\n              (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>')))\n       cs) \\<down>\n    Sabs\n     (map ((\\<lambda>(pat, rhs).\n               (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>))) \\<circ>\n           (\\<lambda>(pat, rhs).\n               (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>'))))\n       cs)", "apply (subst map_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s\n    Sabs\n     (map (\\<lambda>(pat, rhs).\n              (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>')))\n       cs) \\<down>\n    Sabs\n     (map (\\<lambda>(pat, rhs).\n              (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>)))\n       (map (\\<lambda>(pat, rhs).\n                (pat, subst rhs (fmdrop_fset (frees pat) \\<Gamma>')))\n         cs))", "apply (rule seval.abs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "ultimately"], ["proof (chain)\npicking this:\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma>", "have \"rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down> subst (Sabs cs) \\<Gamma>\""], ["proof (prove)\nusing this:\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma> = subst (Sabs cs) \\<Gamma>\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  subst (subst (Sabs cs) \\<Gamma>') \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n    subst (Sabs cs) \\<Gamma>", "by metis"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  subst (Sabs cs) \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma>' \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "thus ?case"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  subst (Sabs cs) \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n    Sabs\n     (map (\\<lambda>(pat, t).\n              (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n       cs)", "by simp"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (Sabs cs) \\<Gamma>' \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n        \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n   ts us\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "hence \"list_all2 (\\<lambda>t. seval rs \\<Gamma> (subst t \\<Gamma>')) ts us\""], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n        \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n   ts us\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>t. seval rs \\<Gamma> (subst t \\<Gamma>')) ts us", "by (blast intro: list.rel_mono_strong)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>t. seval rs \\<Gamma> (subst t \\<Gamma>')) ts us\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow>\n              value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n              \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n         ts us;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma>' \\<down> name $$ us", "with constr"], ["proof (chain)\npicking this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n        \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n   ts us\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n  list_all2 (\\<lambda>t. seval rs \\<Gamma> (subst t \\<Gamma>')) ts us", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow>\n        value_env \\<Gamma> \\<longrightarrow> rs, \\<Gamma>\n        \\<turnstile>\\<^sub>s subst x1 \\<Gamma>' \\<down> x2))\n   ts us\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n  closed_env \\<Gamma>\n  value_env \\<Gamma>\n  list_all2 (\\<lambda>t. seval rs \\<Gamma> (subst t \\<Gamma>')) ts us\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (name $$ ts) \\<Gamma>' \\<down>\n    name $$ us", "by (auto simp: subst_list_comb list_all2_map1 intro: seval.constr)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s subst (name $$ ts) \\<Gamma>' \\<down>\n  name $$ us\n\ngoal (2 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma>' \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma>' \\<down> Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>;\n         closed_env \\<Gamma>; value_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma>' \\<down> u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma> ++\\<^sub>f env;\n         closed_env (\\<Gamma> ++\\<^sub>f env);\n         value_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s\n                          subst rhs \\<Gamma>' \\<down> val;\n        \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>; closed_env \\<Gamma>;\n        value_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma> \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma>' \\<down> val", "qed (auto intro: seval.intros)"], ["", "lemma (in constructors) seval_agree_eq:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\" \"closed_except t S\"\n  assumes \"S |\\<subseteq>| fmdom \\<Gamma>\" \"closed_srules rs\" \"closed_env \\<Gamma>\"\n  shows \"rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> u", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except t S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> u", "proof (induction arbitrary: \\<Gamma>' S)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> name val \\<Gamma>' S.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Svar name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Svar name \\<down> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "case (var \\<Gamma> name val)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> name = Some val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Svar name) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> name val \\<Gamma>' S.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Svar name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Svar name \\<down> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "hence \"name |\\<in>| S\""], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Svar name) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. name |\\<in>| S", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  name |\\<in>| S\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> name val \\<Gamma>' S.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Svar name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Svar name \\<down> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "hence \"fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name\""], ["proof (prove)\nusing this:\n  name |\\<in>| S\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name", "using \\<open>fmrestrict_fset S \\<Gamma> = _\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| S\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name", "unfolding fmfilter_alt_defs"], ["proof (prove)\nusing this:\n  name |\\<in>| S\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma> =\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name", "including fmap.lifting"], ["proof (prove)\nusing this:\n  name |\\<in>| S\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma> =\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name", "by transfer' (auto simp: map_filter_def fun_eq_iff split: if_splits)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> name val \\<Gamma>' S.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Svar name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Svar name \\<down> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "with var"], ["proof (chain)\npicking this:\n  fmlookup \\<Gamma> name = Some val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Svar name) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n  fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name", "show ?case"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Svar name) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n  fmlookup \\<Gamma> name = fmlookup \\<Gamma>' name\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s Svar name \\<down> val", "by (auto intro: seval.var)"], ["proof (state)\nthis:\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s Svar name \\<down> val\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "case (abs \\<Gamma> cs)\n\n  \\<comment> \\<open>Intentionally local: not really a useful lemma outside of its scope\\<close>"], ["proof (state)\nthis:\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Sabs cs) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "have *: \"fmdrop_fset S (fmrestrict_fset T m) = fmrestrict_fset (T |\\<union>| S) (fmdrop_fset S m)\" for S T m"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdrop_fset S (fmrestrict_fset T m) =\n    fmrestrict_fset (T |\\<union>| S) (fmdrop_fset S m)", "unfolding fmfilter_alt_defs fmfilter_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmfilter (\\<lambda>x. x |\\<notin>| S \\<and> x |\\<in>| T) m =\n    fmfilter (\\<lambda>x. x |\\<in>| T |\\<union>| S \\<and> x |\\<notin>| S) m", "by (rule fmfilter_cong) auto"], ["proof (state)\nthis:\n  fmdrop_fset ?S1 (fmrestrict_fset ?T1 ?m1) =\n  fmrestrict_fset (?T1 |\\<union>| ?S1) (fmdrop_fset ?S1 ?m1)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "{"], ["proof (state)\nthis:\n  fmdrop_fset ?S1 (fmrestrict_fset ?T1 ?m1) =\n  fmrestrict_fset (?T1 |\\<union>| ?S1) (fmdrop_fset ?S1 ?m1)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "fix pat t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "assume \"(pat, t) \\<in> set cs\""], ["proof (state)\nthis:\n  (pat, t) \\<in> set cs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "with abs"], ["proof (chain)\npicking this:\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Sabs cs) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n  (pat, t) \\<in> set cs", "have \"closed_except t (S |\\<union>| frees pat)\""], ["proof (prove)\nusing this:\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Sabs cs) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except t (S |\\<union>| frees pat)", "by (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (state)\nthis:\n  closed_except t (S |\\<union>| frees pat)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "have\n      \"subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) = subst t (fmdrop_fset (frees pat) \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>)", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (S |\\<union>| frees pat)\n       (fmdrop_fset (frees pat) \\<Gamma>)) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>)", "apply (rule subst_restrict_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (S |\\<union>| frees pat)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "moreover"], ["proof (state)\nthis:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "have\n      \"subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) = subst t (fmdrop_fset (frees pat) \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>')", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (S |\\<union>| frees pat)\n       (fmdrop_fset (frees pat) \\<Gamma>')) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>')", "apply (rule subst_restrict_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (S |\\<union>| frees pat)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "ultimately"], ["proof (chain)\npicking this:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>)\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>')", "have \"subst t (fmdrop_fset (frees pat) \\<Gamma>) = subst t (fmdrop_fset (frees pat) \\<Gamma>')\""], ["proof (prove)\nusing this:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>)\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst t (fmdrop_fset (frees pat) \\<Gamma>) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>')", "using abs"], ["proof (prove)\nusing this:\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>)) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>)\n  subst t (fmdrop_fset (frees pat) (fmrestrict_fset S \\<Gamma>')) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>')\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (Sabs cs) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst t (fmdrop_fset (frees pat) \\<Gamma>) =\n    subst t (fmdrop_fset (frees pat) \\<Gamma>')", "by metis"], ["proof (state)\nthis:\n  subst t (fmdrop_fset (frees pat) \\<Gamma>) =\n  subst t (fmdrop_fset (frees pat) \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "}"], ["proof (state)\nthis:\n  (?pat3, ?ta3) \\<in> set cs \\<Longrightarrow>\n  subst ?ta3 (fmdrop_fset (frees ?pat3) \\<Gamma>) =\n  subst ?ta3 (fmdrop_fset (frees ?pat3) \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "hence \"map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>))) cs =\n         map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>'))) cs\""], ["proof (prove)\nusing this:\n  (?pat3, ?ta3) \\<in> set cs \\<Longrightarrow>\n  subst ?ta3 (fmdrop_fset (frees ?pat3) \\<Gamma>) =\n  subst ?ta3 (fmdrop_fset (frees ?pat3) \\<Gamma>')\n\ngoal (1 subgoal):\n 1. map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs =\n    map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>')))\n     cs", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n   cs =\n  map (\\<lambda>(pat, t).\n          (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>')))\n   cs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> cs \\<Gamma>' S.\n       \\<lbrakk>fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sabs cs) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "thus ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n   cs =\n  map (\\<lambda>(pat, t).\n          (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>')))\n   cs\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n    Sabs\n     (map (\\<lambda>(pat, t).\n              (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n       cs)", "by (metis seval.abs)"], ["proof (state)\nthis:\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s Sabs cs \\<down>\n  Sabs\n   (map (\\<lambda>(pat, t).\n            (pat, subst t (fmdrop_fset (frees pat) \\<Gamma>)))\n     cs)\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "case (comb \\<Gamma> t cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except t ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except u ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n           fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except rhs ?S; ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n   closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down> val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (t $\\<^sub>s u) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "have \"fmdom env = frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply (rule match_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. match pat ?t = Some env", "apply (rule find_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match ?cs2 ?t = Some (env, pat, ?rhs2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (3 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>\\<Gamma> t cs u u' env uu_ rhs val \\<Gamma>' S.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except t S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down>\n                             Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S \\<Gamma> =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except u S; S |\\<subseteq>| fmdom \\<Gamma>;\n            closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down>\n                             u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<And>\\<Gamma>' S.\n           \\<lbrakk>fmrestrict_fset S (\\<Gamma> ++\\<^sub>f env) =\n                    fmrestrict_fset S \\<Gamma>';\n            closed_except rhs S;\n            S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n            closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down>\n                             val;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (t $\\<^sub>s u) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         t $\\<^sub>s u \\<down> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t $\\<^sub>s u \\<down> val", "proof (rule seval.comb)"], ["proof (state)\ngoal (4 subgoals):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs ?cs\n 2. rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> ?u'\n 3. find_match ?cs ?u' = Some (?env, ?uu, ?rhs)\n 4. rs, \\<Gamma>' ++\\<^sub>f ?env \\<turnstile>\\<^sub>s ?rhs \\<down> val", "show \"rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\" \"rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs &&&\n    rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except t ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except u ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n           fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except rhs ?S; ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n   closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down> val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (t $\\<^sub>s u) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs &&&\n    rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'", "by (auto simp: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\n\ngoal (2 subgoals):\n 1. find_match cs u' = Some (?env, ?uu, ?rhs)\n 2. rs, \\<Gamma>' ++\\<^sub>f ?env \\<turnstile>\\<^sub>s ?rhs \\<down> val", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. find_match cs u' = Some (?env, ?uu, ?rhs)\n 2. rs, \\<Gamma>' ++\\<^sub>f ?env \\<turnstile>\\<^sub>s ?rhs \\<down> val", "show \"rs, \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val", "proof (rule comb)"], ["proof (state)\ngoal (5 subgoals):\n 1. fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset ?S (\\<Gamma>' ++\\<^sub>f env)\n 2. closed_except rhs ?S\n 3. ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 4. closed_srules rs\n 5. closed_env (\\<Gamma> ++\\<^sub>f env)", "have \"fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma> ++\\<^sub>f env) = fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma>' ++\\<^sub>f env)", "using comb(8)"], ["proof (prove)\nusing this:\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma>' ++\\<^sub>f env)", "unfolding fmfilter_alt_defs"], ["proof (prove)\nusing this:\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma> =\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmfilter (\\<lambda>a. a |\\<in>| S |\\<union>| fmdom env)\n     (\\<Gamma> ++\\<^sub>f env) =\n    fmfilter (\\<lambda>a. a |\\<in>| S |\\<union>| fmdom env)\n     (\\<Gamma>' ++\\<^sub>f env)", "including fmap.lifting fset.lifting"], ["proof (prove)\nusing this:\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma> =\n  fmfilter (\\<lambda>a. a |\\<in>| S) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmfilter (\\<lambda>a. a |\\<in>| S |\\<union>| fmdom env)\n     (\\<Gamma> ++\\<^sub>f env) =\n    fmfilter (\\<lambda>a. a |\\<in>| S |\\<union>| fmdom env)\n     (\\<Gamma>' ++\\<^sub>f env)", "by transfer' (auto simp: map_filter_def fun_eq_iff map_add_def split: option.splits if_splits)"], ["proof (state)\nthis:\n  fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma> ++\\<^sub>f env) =\n  fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (5 subgoals):\n 1. fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset ?S (\\<Gamma>' ++\\<^sub>f env)\n 2. closed_except rhs ?S\n 3. ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 4. closed_srules rs\n 5. closed_env (\\<Gamma> ++\\<^sub>f env)", "thus \"fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma> ++\\<^sub>f env) = fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma> ++\\<^sub>f env) =\n  fmrestrict_fset (S |\\<union>| fmdom env) (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma>' ++\\<^sub>f env)", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\nusing this:\n  fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma> ++\\<^sub>f env) =\n  fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma> ++\\<^sub>f env) =\n    fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma>' ++\\<^sub>f env)", "."], ["proof (state)\nthis:\n  fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma> ++\\<^sub>f env) =\n  fmrestrict_fset (S |\\<union>| frees pat) (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "have \"closed_except t S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t S", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except t ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except u ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n           fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except rhs ?S; ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n   closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down> val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (t $\\<^sub>s u) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_except t S", "by (simp add: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  closed_except t S\n\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "have \"closed (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (Sabs cs)", "apply (rule seval_closed)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?rs, ?\\<Gamma> \\<turnstile>\\<^sub>s ?t \\<down> Sabs cs\n 2. closed_srules ?rs\n 3. closed_env ?\\<Gamma>\n 4. closed_except ?t (fmdom ?\\<Gamma>)", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (fmdom \\<Gamma>)", "using \\<open>closed_except t S\\<close> \\<open>S |\\<subseteq>| fmdom \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  closed_except t S\n  S |\\<subseteq>| fmdom \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_except t (fmdom \\<Gamma>)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| S\n  S |\\<subseteq>| fmdom \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| fmdom \\<Gamma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed (Sabs cs)\n\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "using \\<open>find_match _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  find_match cs u' = Some (env, pat, rhs)\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule find_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "hence \"closed_except rhs (frees pat)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "using \\<open>closed (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  closed (Sabs cs)\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "by (auto dest: closed_except_sabs)"], ["proof (state)\nthis:\n  closed_except rhs (frees pat)\n\ngoal (4 subgoals):\n 1. closed_except rhs (S |\\<union>| frees pat)\n 2. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 3. closed_srules rs\n 4. closed_env (\\<Gamma> ++\\<^sub>f env)", "thus \"closed_except rhs (S |\\<union>| frees pat)\""], ["proof (prove)\nusing this:\n  closed_except rhs (frees pat)\n\ngoal (1 subgoal):\n 1. closed_except rhs (S |\\<union>| frees pat)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| frees pat\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| S |\\<union>| frees pat", "by auto"], ["proof (state)\nthis:\n  closed_except rhs (S |\\<union>| frees pat)\n\ngoal (3 subgoals):\n 1. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 2. closed_srules rs\n 3. closed_env (\\<Gamma> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n 2. closed_srules rs\n 3. closed_env (\\<Gamma> ++\\<^sub>f env)", "show \"S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. S |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env \\<and>\n    frees pat |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env\n 2. frees pat |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env", "using comb(10)"], ["proof (prove)\nusing this:\n  S |\\<subseteq>| fmdom \\<Gamma>\n\ngoal (2 subgoals):\n 1. S |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env\n 2. frees pat |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat |\\<subseteq>| fmdom \\<Gamma> |\\<union>| fmdom env", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat |\\<subseteq>| fmdom \\<Gamma> |\\<union>| frees pat", "by blast"], ["proof (state)\nthis:\n  S |\\<union>| frees pat |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)", "have \"closed_except u S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except u S", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except t ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  \\<lbrakk>fmrestrict_fset ?S \\<Gamma> = fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except u ?S; ?S |\\<subseteq>| fmdom \\<Gamma>; closed_srules rs;\n   closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s u \\<down> u'\n  \\<lbrakk>fmrestrict_fset ?S (\\<Gamma> ++\\<^sub>f env) =\n           fmrestrict_fset ?S ?\\<Gamma>';\n   closed_except rhs ?S; ?S |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f env);\n   closed_srules rs; closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs, ?\\<Gamma>' \\<turnstile>\\<^sub>s rhs \\<down> val\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (t $\\<^sub>s u) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_except u S", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_except u S\n\ngoal (2 subgoals):\n 1. closed_srules rs\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)", "show \"closed_env (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env \\<Gamma>\n 2. closed_env env", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env", "apply (rule closed.match[where t = u' and pat = pat])"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat u' = Some env\n 2. closed u'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. match pat u' = Some env", "by (rule find_match_elem) fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u'", "apply (rule seval_closed)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?rs, ?\\<Gamma> \\<turnstile>\\<^sub>s ?t \\<down> u'\n 2. closed_srules ?rs\n 3. closed_env ?\\<Gamma>\n 4. closed_except ?t (fmdom ?\\<Gamma>)", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except u (fmdom \\<Gamma>)", "using \\<open>closed_except u S\\<close> \\<open>S |\\<subseteq>| fmdom \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  closed_except u S\n  S |\\<subseteq>| fmdom \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_except u (fmdom \\<Gamma>)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees u |\\<subseteq>| S\n  S |\\<subseteq>| fmdom \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees u |\\<subseteq>| fmdom \\<Gamma>", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_env (\\<Gamma> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. closed_srules rs", "qed fact"], ["proof (state)\nthis:\n  rs, \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n\ngoal (1 subgoal):\n 1. find_match cs u' = Some (env, ?uu, rhs)", "qed fact"], ["proof (state)\nthis:\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s t $\\<^sub>s u \\<down> val\n\ngoal (2 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<forall>x xa.\n           fmrestrict_fset xa \\<Gamma> =\n           fmrestrict_fset xa x \\<longrightarrow>\n           closed_except x1 xa \\<longrightarrow>\n           xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n           closed_srules rs \\<longrightarrow>\n           closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n           x1 \\<down> x2))\n   ts us\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (name $$ ts) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' S.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 fmrestrict_fset xa \\<Gamma> =\n                 fmrestrict_fset xa x \\<longrightarrow>\n                 closed_except x1 xa \\<longrightarrow>\n                 xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n                 closed_srules rs \\<longrightarrow>\n                 closed_env \\<Gamma> \\<longrightarrow> rs, x\n                 \\<turnstile>\\<^sub>s x1 \\<down> x2))\n         ts us;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (name $$ ts) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         name $$ ts \\<down> name $$ us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, \\<Gamma>' \\<turnstile>\\<^sub>s name $$ ts \\<down> name $$ us", "apply (rule seval.constr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>| C\n 2. list_all2 (seval rs \\<Gamma>') ts us", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (seval rs \\<Gamma>') ts us", "apply (rule list.rel_mono_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 ?R4 ts us\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us; ?R4 z yb\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s z \\<down> yb", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb \\<and>\n        (\\<forall>x xa.\n            fmrestrict_fset xa \\<Gamma> =\n            fmrestrict_fset xa x \\<longrightarrow>\n            closed_except z xa \\<longrightarrow>\n            xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n            closed_srules rs \\<longrightarrow>\n            closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n            z \\<down> yb)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s z \\<down> yb", "using constr"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<forall>x xa.\n           fmrestrict_fset xa \\<Gamma> =\n           fmrestrict_fset xa x \\<longrightarrow>\n           closed_except x1 xa \\<longrightarrow>\n           xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n           closed_srules rs \\<longrightarrow>\n           closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n           x1 \\<down> x2))\n   ts us\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (name $$ ts) S\n  S |\\<subseteq>| fmdom \\<Gamma>\n  closed_srules rs\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb \\<and>\n        (\\<forall>x xa.\n            fmrestrict_fset xa \\<Gamma> =\n            fmrestrict_fset xa x \\<longrightarrow>\n            closed_except z xa \\<longrightarrow>\n            xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n            closed_srules rs \\<longrightarrow>\n            closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n            z \\<down> yb)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s z \\<down> yb", "unfolding closed.list_comb list_all_iff"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (\\<forall>x xa.\n           fmrestrict_fset xa \\<Gamma> =\n           fmrestrict_fset xa x \\<longrightarrow>\n           closed_except x1 xa \\<longrightarrow>\n           xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n           Ball (set rs) (closed \\<circ> snd) \\<longrightarrow>\n           closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n           x1 \\<down> x2))\n   ts us\n  fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>'\n  closed_except (const name) S \\<and>\n  (\\<forall>t\\<in>set ts. closed_except t S)\n  S |\\<subseteq>| fmdom \\<Gamma>\n  Ball (set rs) (closed \\<circ> snd)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb \\<and>\n        (\\<forall>x xa.\n            fmrestrict_fset xa \\<Gamma> =\n            fmrestrict_fset xa x \\<longrightarrow>\n            closed_except z xa \\<longrightarrow>\n            xa |\\<subseteq>| fmdom \\<Gamma> \\<longrightarrow>\n            Ball (set rs) (closed \\<circ> snd) \\<longrightarrow>\n            closed_env \\<Gamma> \\<longrightarrow> rs, x \\<turnstile>\\<^sub>s\n            z \\<down> yb)\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s z \\<down> yb", "by auto"], ["proof (state)\nthis:\n  rs, \\<Gamma>' \\<turnstile>\\<^sub>s name $$ ts \\<down> name $$ us\n\ngoal (1 subgoal):\n 1. \\<And>name rhs \\<Gamma> \\<Gamma>' S.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        fmrestrict_fset S \\<Gamma> = fmrestrict_fset S \\<Gamma>';\n        closed_except (Sconst name) S; S |\\<subseteq>| fmdom \\<Gamma>;\n        closed_srules rs; closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs, \\<Gamma>' \\<turnstile>\\<^sub>s\n                         Sconst name \\<down> rhs", "qed (auto intro: seval.intros)"], ["", "subsubsection \\<open>Correctness wrt @{const srewrite}\\<close>"], ["", "context srules begin"], ["", "context begin"], ["", "private"], ["", "lemma seval_correct0:\n  assumes \"rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\" \"closed_except t (fmdom \\<Gamma>)\" \"closed_env \\<Gamma>\"\n  shows \"rs \\<turnstile>\\<^sub>s subst t \\<Gamma> \\<longrightarrow>* u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst t \\<Gamma> \\<longrightarrow>* u", "using assms"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> u\n  closed_except t (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst t \\<Gamma> \\<longrightarrow>* u", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        closed_except (Sconst name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma> \\<longrightarrow>* rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "case (const name rhs \\<Gamma>)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        closed_except (Sconst name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma> \\<longrightarrow>* rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"srewrite_step rs name rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step rs name rhs", "by (rule srewrite_stepI) fact"], ["proof (state)\nthis:\n  srewrite_step rs name rhs\n\ngoal (5 subgoals):\n 1. \\<And>name rhs \\<Gamma>.\n       \\<lbrakk>(name, rhs) \\<in> set rs;\n        closed_except (Sconst name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sconst name) \\<Gamma> \\<longrightarrow>* rhs\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 4. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "thus ?case"], ["proof (prove)\nusing this:\n  srewrite_step rs name rhs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst (Sconst name) \\<Gamma> \\<longrightarrow>*\n    rhs", "by (auto intro: srewrite.intros)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst (Sconst name) \\<Gamma> \\<longrightarrow>*\n  rhs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "case (comb \\<Gamma> t cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "hence \"closed_except t (fmdom \\<Gamma>)\" \"closed_except u (fmdom \\<Gamma>)\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_except t (fmdom \\<Gamma>) &&& closed_except u (fmdom \\<Gamma>)", "by (simp add: Sterm.closed_except_simps)+"], ["proof (state)\nthis:\n  closed_except t (fmdom \\<Gamma>)\n  closed_except u (fmdom \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "moreover"], ["proof (state)\nthis:\n  closed_except t (fmdom \\<Gamma>)\n  closed_except u (fmdom \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"closed_srules rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_srules rs", "using all_rules"], ["proof (prove)\nusing this:\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. closed_srules rs", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  Ball (set rs) srule\n\ngoal (1 subgoal):\n 1. Ball (set rs) (closed \\<circ> snd)", "by fastforce"], ["proof (state)\nthis:\n  closed_srules rs\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "ultimately"], ["proof (chain)\npicking this:\n  closed_except t (fmdom \\<Gamma>)\n  closed_except u (fmdom \\<Gamma>)\n  closed_srules rs", "have \"closed (Sabs cs)\" \"closed u'\""], ["proof (prove)\nusing this:\n  closed_except t (fmdom \\<Gamma>)\n  closed_except u (fmdom \\<Gamma>)\n  closed_srules rs\n\ngoal (1 subgoal):\n 1. closed (Sabs cs) &&& closed u'", "using comb"], ["proof (prove)\nusing this:\n  closed_except t (fmdom \\<Gamma>)\n  closed_except u (fmdom \\<Gamma>)\n  closed_srules rs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed (Sabs cs) &&& closed u'", "by (metis seval_closed)+"], ["proof (state)\nthis:\n  closed (Sabs cs)\n  closed u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "from comb"], ["proof (chain)\npicking this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>", "have \"(pat, rhs) \\<in> set cs\" \"match pat u' = Some env\""], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat u' = Some env", "by (auto simp: find_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "hence \"closed_except rhs (frees pat)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "using \\<open>closed (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  match pat u' = Some env\n  closed (Sabs cs)\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "by (auto dest: closed_except_sabs)"], ["proof (state)\nthis:\n  closed_except rhs (frees pat)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "hence \"frees rhs |\\<subseteq>| frees pat\""], ["proof (prove)\nusing this:\n  closed_except rhs (frees pat)\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees pat\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "moreover"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees pat\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"fmdom env = frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "using \\<open>match pat u' = _\\<close>"], ["proof (prove)\nusing this:\n  match pat u' = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "by (auto simp: match_dom)"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "ultimately"], ["proof (chain)\npicking this:\n  frees rhs |\\<subseteq>| frees pat\n  fmdom env = frees pat", "have \"frees rhs |\\<subseteq>| fmdom env\""], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| frees pat\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| fmdom env", "by simp"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| fmdom env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "hence \"subst rhs (\\<Gamma> ++\\<^sub>f env) = subst rhs env\""], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| fmdom env\n\ngoal (1 subgoal):\n 1. subst rhs (\\<Gamma> ++\\<^sub>f env) = subst rhs env", "by (rule subst_add_shadowed_env)"], ["proof (state)\nthis:\n  subst rhs (\\<Gamma> ++\\<^sub>f env) = subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"rs \\<turnstile>\\<^sub>s subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>* Sabs cs $\\<^sub>s u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s\n    subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>*\n    Sabs cs $\\<^sub>s u'", "using comb"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s\n    subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>*\n    Sabs cs $\\<^sub>s u'", "by (force intro: srewrite.rt_comb[unfolded app_sterm_def] simp: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s\n  subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>*\n  Sabs cs $\\<^sub>s u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "also"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s\n  subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>*\n  Sabs cs $\\<^sub>s u'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s u' \\<longrightarrow>* subst rhs env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s u' \\<longrightarrow>*\n    subst rhs env", "using comb \\<open>closed u'\\<close>"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n  closed u'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s u' \\<longrightarrow>*\n    subst rhs env", "by (force intro: srewrite.beta find_match_rewrite_first)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s u' \\<longrightarrow>*\n  subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "also"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s u' \\<longrightarrow>*\n  subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"rs \\<turnstile>\\<^sub>s subst rhs env \\<longrightarrow>* subst rhs (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst rhs env \\<longrightarrow>*\n    subst rhs (\\<Gamma> ++\\<^sub>f env)", "unfolding \\<open>subst rhs (\\<Gamma> ++\\<^sub>f env) = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst rhs env \\<longrightarrow>* subst rhs env", "by simp"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst rhs env \\<longrightarrow>*\n  subst rhs (\\<Gamma> ++\\<^sub>f env)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "also"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst rhs env \\<longrightarrow>*\n  subst rhs (\\<Gamma> ++\\<^sub>f env)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "have \"rs \\<turnstile>\\<^sub>s subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>* val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s\n    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>* val", "proof (rule comb)"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\n 2. closed_env (\\<Gamma> ++\\<^sub>f env)", "show \"closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "using comb \\<open>match pat u' = Some env\\<close> \\<open>fmdom env = _\\<close> \\<open>frees rhs |\\<subseteq>| frees pat\\<close>"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n  match pat u' = Some env\n  fmdom env = frees pat\n  frees rhs |\\<subseteq>| frees pat\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "show \"closed_env (\\<Gamma> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "using comb \\<open>match pat u' = Some env\\<close> \\<open>closed u'\\<close>"], ["proof (prove)\nusing this:\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs\n  rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u'\n  find_match cs u' = Some (env, pat, rhs)\n  rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst t \\<Gamma> \\<longrightarrow>* Sabs cs\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst u \\<Gamma> \\<longrightarrow>* u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n   closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                    subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                    val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n  match pat u' = Some env\n  closed u'\n\ngoal (1 subgoal):\n 1. closed_env (\\<Gamma> ++\\<^sub>f env)", "by (blast intro: closed.match)"], ["proof (state)\nthis:\n  closed_env (\\<Gamma> ++\\<^sub>f env)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s\n  subst rhs (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>* val\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>\\<Gamma> t cs u u' env uu_ rhs val.\n       \\<lbrakk>rs, \\<Gamma> \\<turnstile>\\<^sub>s t \\<down> Sabs cs;\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst t \\<Gamma> \\<longrightarrow>* Sabs cs;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>);\n         closed_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst u \\<Gamma> \\<longrightarrow>* u';\n        find_match cs u' = Some (env, uu_, rhs);\n        rs, \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>s rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f env));\n         closed_env (\\<Gamma> ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                          subst rhs\n                           (\\<Gamma> ++\\<^sub>f env) \\<longrightarrow>*\n                          val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n                         val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "finally"], ["proof (chain)\npicking this:\n  rs \\<turnstile>\\<^sub>s\n  subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>* val", "show ?case"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>s\n  subst t \\<Gamma> $\\<^sub>s subst u \\<Gamma> \\<longrightarrow>* val\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s\n    subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>* val", "by simp"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst (t $\\<^sub>s u) \\<Gamma> \\<longrightarrow>*\n  val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n        subst x1 \\<Gamma> \\<longrightarrow>* x2))\n   ts us\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  closed_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             rs, \\<Gamma> \\<turnstile>\\<^sub>s x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n              subst x1 \\<Gamma> \\<longrightarrow>* x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n                         name $$ us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n    name $$ us", "apply (simp add: subst_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s\n    name $$ map (\\<lambda>t. subst t \\<Gamma>) ts \\<longrightarrow>*\n    name $$ us", "apply (rule srewrite.rt_list_comb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (srewrite_rt rs) (map (\\<lambda>t. subst t \\<Gamma>) ts) us\n 2. rs \\<turnstile>\\<^sub>s const name \\<longrightarrow>* const name", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (srewrite_rt rs) (map (\\<lambda>t. subst t \\<Gamma>) ts) us", "apply (simp add: list.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x. srewrite_rt rs (subst x \\<Gamma>)) ts us", "apply (rule list.rel_mono_strong[OF constr(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb \\<and>\n        (closed_except z (fmdom \\<Gamma>) \\<longrightarrow>\n         closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n         subst z \\<Gamma> \\<longrightarrow>* yb)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb;\n        closed_except z (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_env \\<Gamma> \\<longrightarrow> rs \\<turnstile>\\<^sub>s\n        subst z \\<Gamma> \\<longrightarrow>* yb\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "apply (elim impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> closed_except z (fmdom \\<Gamma>)\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> closed_env \\<Gamma>\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb;\n        rs \\<turnstile>\\<^sub>s subst z \\<Gamma> \\<longrightarrow>*\n        yb\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "using constr(3)"], ["proof (prove)\nusing this:\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n\ngoal (3 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> closed_except z (fmdom \\<Gamma>)\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> closed_env \\<Gamma>\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb;\n        rs \\<turnstile>\\<^sub>s subst z \\<Gamma> \\<longrightarrow>*\n        yb\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "apply (erule closed.list_combE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> closed_env \\<Gamma>\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb;\n        rs \\<turnstile>\\<^sub>s subst z \\<Gamma> \\<longrightarrow>*\n        yb\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "apply (rule constr)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us;\n        rs, \\<Gamma> \\<turnstile>\\<^sub>s z \\<down> yb;\n        rs \\<turnstile>\\<^sub>s subst z \\<Gamma> \\<longrightarrow>*\n        yb\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst z \\<Gamma> \\<longrightarrow>* yb", "apply (auto simp: const_sterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s const name \\<longrightarrow>* const name", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s const name \\<longrightarrow>* const name", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst (name $$ ts) \\<Gamma> \\<longrightarrow>*\n  name $$ us\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Svar name) \\<Gamma> \\<longrightarrow>* val\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>s\n                         subst (Sabs cs) \\<Gamma> \\<longrightarrow>*\n                         Sabs\n                          (map (\\<lambda>(pat, t).\n                                   (pat,\n                                    subst t\n                                     (fmdrop_fset (frees pat) \\<Gamma>)))\n                            cs)", "qed auto"], ["", "corollary seval_correct:\n  assumes \"rs, fmempty \\<turnstile>\\<^sub>s t \\<down> u\" \"closed t\"\n  shows \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u", "have \"closed_except t (fmdom fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (fmdom fmempty)", "using assms"], ["proof (prove)\nusing this:\n  rs, fmempty \\<turnstile>\\<^sub>s t \\<down> u\n  closed t\n\ngoal (1 subgoal):\n 1. closed_except t (fmdom fmempty)", "by simp"], ["proof (state)\nthis:\n  closed_except t (fmdom fmempty)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u", "with assms"], ["proof (chain)\npicking this:\n  rs, fmempty \\<turnstile>\\<^sub>s t \\<down> u\n  closed t\n  closed_except t (fmdom fmempty)", "have \"rs \\<turnstile>\\<^sub>s subst t fmempty \\<longrightarrow>* u\""], ["proof (prove)\nusing this:\n  rs, fmempty \\<turnstile>\\<^sub>s t \\<down> u\n  closed t\n  closed_except t (fmdom fmempty)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s subst t fmempty \\<longrightarrow>* u", "by (fastforce intro!: seval_correct0)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s subst t fmempty \\<longrightarrow>* u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u", "thus ?thesis"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>s subst t fmempty \\<longrightarrow>* u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u", "by simp"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* u\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"]]}