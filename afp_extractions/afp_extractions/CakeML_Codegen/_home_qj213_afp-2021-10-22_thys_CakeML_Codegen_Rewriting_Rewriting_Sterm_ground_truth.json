{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Rewriting_Sterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma sruleI[intro!]: \"wellformed rhs \\<Longrightarrow> closed rhs \\<Longrightarrow> is_abs rhs \\<Longrightarrow> srule (name, rhs)\"", "lemma map: \"is_map (set rs)\"", "lemma clausesE:\n  assumes \"(name, rhs) \\<in> set rs\"\n  obtains cs where \"rhs = Sabs cs\"", "lemma srewrite_stepI0:\n  assumes \"(name, rhs) \\<in> set rs\" \"is_map (set rs)\"\n  shows \"srewrite_step rs name rhs\"", "lemma (in srules) srewrite_stepI: \"(name, rhs) \\<in> set rs \\<Longrightarrow> srewrite_step rs name rhs\"", "lemma pterm_to_sterm:\n  assumes \"no_abs t\"\n  shows \"pterm_to_sterm t = convert_term t\"", "lemma pterm_to_sterm_wellformed:\n  assumes \"wellformed t\"\n  shows \"wellformed (pterm_to_sterm t)\"", "lemma pterm_to_sterm_sterm_to_pterm:\n  assumes \"wellformed t\"\n  shows \"sterm_to_pterm (pterm_to_sterm t) = t\"", "lemma compile_heads: \"fst |`| fset_of_list (compile rs) = fst |`| rs\"", "lemma compile_rules: \"srules C_info (compile rs)\"", "lemma srelated_subst:\n  assumes \"srelated.P_env penv senv\"\n  shows \"subst (sterm_to_pterm t) penv = sterm_to_pterm (subst t senv)\"", "lemma srewrite_step_non_empty: \"srewrite_step rs' name rhs \\<Longrightarrow> rs' \\<noteq> []\"", "lemma compile_consE:\n  assumes \"(name, rhs') # rest = compile rs\" \"is_fmap rs\"\n  obtains rhs where \"rhs' = pterm_to_sterm rhs\" \"(name, rhs) |\\<in>| rs\" \"rest = compile (rs - {| (name, rhs) |})\"", "lemma compile_correct_step:\n  assumes \"srewrite_step (compile rs) name rhs\" \"is_fmap rs\" \"fBall rs prule\"\n  shows \"(name, sterm_to_pterm rhs) |\\<in>| rs\"", "lemma compile_correct0:\n  assumes \"compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u'\" \"prules C rs\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow> sterm_to_pterm u'\"", "lemma (in prules) compile_correct:\n  assumes \"compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u'\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow> sterm_to_pterm u'\"", "lemma srelated_subst':\n  assumes \"srelated'.P_env penv senv\" \"wellformed t\"\n  shows \"pterm_to_sterm (subst t penv) = subst (pterm_to_sterm t) senv\"", "lemma srelated_find_match:\n  assumes \"find_match cs t = Some (penv, pat, rhs)\" \"srelated'.P_env penv senv\"\n  shows \"find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) = Some (senv, pat, pterm_to_sterm rhs)\"", "lemma (in prules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"wellformed t\"\n  shows \"compile rs \\<turnstile>\\<^sub>s pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t'\""], "translations": [["", "lemma sruleI[intro!]: \"wellformed rhs \\<Longrightarrow> closed rhs \\<Longrightarrow> is_abs rhs \\<Longrightarrow> srule (name, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_strong_term_class.wellformed rhs; closed rhs;\n     is_abs rhs\\<rbrakk>\n    \\<Longrightarrow> srule (name, rhs)", "by simp"], ["", "locale srules = constants C_info \"fst |`| fset_of_list rs\" for C_info and rs :: \"srule list\" +\n  assumes all_rules: \"list_all srule rs\"\n  assumes distinct: \"distinct (map fst rs)\"\n  assumes not_shadows: \"list_all (\\<lambda>(_, rhs). \\<not> shadows_consts rhs) rs\"\n  assumes swelldefined_rs: \"list_all (\\<lambda>(_, rhs). welldefined rhs) rs\"\nbegin"], ["", "lemma map: \"is_map (set rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map (set rs)", "using distinct"], ["proof (prove)\nusing this:\n  distinct (map fst rs)\n\ngoal (1 subgoal):\n 1. is_map (set rs)", "by (rule distinct_is_map)"], ["", "lemma clausesE:\n  assumes \"(name, rhs) \\<in> set rs\"\n  obtains cs where \"rhs = Sabs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs. rhs = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cs. rhs = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (name, rhs) \\<in> set rs", "have \"is_abs rhs\""], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n\ngoal (1 subgoal):\n 1. is_abs rhs", "using all_rules"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. is_abs rhs", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  Ball (set rs) srule\n\ngoal (1 subgoal):\n 1. is_abs rhs", "by auto"], ["proof (state)\nthis:\n  is_abs rhs\n\ngoal (1 subgoal):\n 1. (\\<And>cs. rhs = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  is_abs rhs", "obtain cs where \"rhs = Sabs cs\""], ["proof (prove)\nusing this:\n  is_abs rhs\n\ngoal (1 subgoal):\n 1. (\\<And>cs. rhs = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rhs) (auto simp: is_abs_def term_cases_def)"], ["proof (state)\nthis:\n  rhs = Sabs cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs. rhs = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  rhs = Sabs ?cs3 \\<Longrightarrow> thesis\n  rhs = Sabs cs", "show thesis"], ["proof (prove)\nusing this:\n  rhs = Sabs ?cs3 \\<Longrightarrow> thesis\n  rhs = Sabs cs\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Rewriting\\<close>"], ["", "inductive srewrite_step where\ncons_match: \"srewrite_step ((name, rhs) # rest) name rhs\" |\ncons_nomatch: \"name \\<noteq> name' \\<Longrightarrow> srewrite_step rs name rhs \\<Longrightarrow> srewrite_step ((name', rhs') # rs) name rhs\""], ["", "lemma srewrite_stepI0:\n  assumes \"(name, rhs) \\<in> set rs\" \"is_map (set rs)\"\n  shows \"srewrite_step rs name rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step rs name rhs", "using assms"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  is_map (set rs)\n\ngoal (1 subgoal):\n 1. srewrite_step rs name rhs", "proof (induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(name, rhs) \\<in> set []; is_map (set [])\\<rbrakk>\n    \\<Longrightarrow> srewrite_step [] name rhs\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n                \\<Longrightarrow> srewrite_step rs name rhs;\n        (name, rhs) \\<in> set (a # rs); is_map (set (a # rs))\\<rbrakk>\n       \\<Longrightarrow> srewrite_step (a # rs) name rhs", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n  \\<Longrightarrow> srewrite_step rs name rhs\n  (name, rhs) \\<in> set (r # rs)\n  is_map (set (r # rs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(name, rhs) \\<in> set []; is_map (set [])\\<rbrakk>\n    \\<Longrightarrow> srewrite_step [] name rhs\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n                \\<Longrightarrow> srewrite_step rs name rhs;\n        (name, rhs) \\<in> set (a # rs); is_map (set (a # rs))\\<rbrakk>\n       \\<Longrightarrow> srewrite_step (a # rs) name rhs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n  \\<Longrightarrow> srewrite_step rs name rhs\n  (name, rhs) \\<in> set (r # rs)\n  is_map (set (r # rs))", "obtain name' rhs' where \"r = (name', rhs')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n  \\<Longrightarrow> srewrite_step rs name rhs\n  (name, rhs) \\<in> set (r # rs)\n  is_map (set (r # rs))\n\ngoal (1 subgoal):\n 1. (\\<And>name' rhs'.\n        r = (name', rhs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r = (name', rhs')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(name, rhs) \\<in> set []; is_map (set [])\\<rbrakk>\n    \\<Longrightarrow> srewrite_step [] name rhs\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>(name, rhs) \\<in> set rs; is_map (set rs)\\<rbrakk>\n                \\<Longrightarrow> srewrite_step rs name rhs;\n        (name, rhs) \\<in> set (a # rs); is_map (set (a # rs))\\<rbrakk>\n       \\<Longrightarrow> srewrite_step (a # rs) name rhs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step (r # rs) name rhs", "proof (cases \"name = name'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs\n 2. name \\<noteq> name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "case False"], ["proof (state)\nthis:\n  name \\<noteq> name'\n\ngoal (2 subgoals):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs\n 2. name \\<noteq> name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step (r # rs) name rhs", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step ((name', rhs') # rs) name rhs", "apply (rule srewrite_step.cons_nomatch)"], ["proof (prove)\ngoal (2 subgoals):\n 1. name \\<noteq> name'\n 2. srewrite_step rs name rhs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<noteq> name'", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step rs name rhs", "apply (rule Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (name, rhs) \\<in> set rs\n 2. is_map (set rs)", "using False Cons(2) \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  name \\<noteq> name'\n  (name, rhs) \\<in> set (r # rs)\n  r = (name', rhs')\n\ngoal (2 subgoals):\n 1. (name, rhs) \\<in> set rs\n 2. is_map (set rs)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map (set rs)", "using Cons(3)"], ["proof (prove)\nusing this:\n  is_map (set (r # rs))\n\ngoal (1 subgoal):\n 1. is_map (set rs)", "unfolding is_map_def"], ["proof (prove)\nusing this:\n  \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>set (r # rs).\n     \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>set (r # rs).\n        a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>(a\\<^sub>1, b\\<^sub>1)\\<in>set rs.\n       \\<forall>(a\\<^sub>2, b\\<^sub>2)\\<in>set rs.\n          a\\<^sub>1 = a\\<^sub>2 \\<longrightarrow> b\\<^sub>1 = b\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  srewrite_step (r # rs) name rhs\n\ngoal (1 subgoal):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "case True"], ["proof (state)\nthis:\n  name = name'\n\ngoal (1 subgoal):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "have \"rhs = rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs = rhs'", "apply (rule is_mapD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_map ?M\n 2. (?a, rhs) \\<in> ?M\n 3. (?a, rhs') \\<in> ?M", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?a, rhs) \\<in> set (r # rs)\n 2. (?a, rhs') \\<in> set (r # rs)", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. (?a, rhs) \\<in> set ((name', rhs') # rs)\n 2. (?a, rhs') \\<in> set ((name', rhs') # rs)", "using Cons(2) \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set (r # rs)\n  r = (name', rhs')\n\ngoal (2 subgoals):\n 1. (?a, rhs) \\<in> set ((name', rhs') # rs)\n 2. (?a, rhs') \\<in> set ((name', rhs') # rs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs') \\<in> set ((name', rhs') # rs)", "using True"], ["proof (prove)\nusing this:\n  name = name'\n\ngoal (1 subgoal):\n 1. (name, rhs') \\<in> set ((name', rhs') # rs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rhs = rhs'\n\ngoal (1 subgoal):\n 1. name = name' \\<Longrightarrow> srewrite_step (r # rs) name rhs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step (r # rs) name rhs", "unfolding \\<open>r = _\\<close> \\<open>name = _\\<close> \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step ((name', rhs') # rs) name' rhs'", "by (rule srewrite_step.cons_match)"], ["proof (state)\nthis:\n  srewrite_step (r # rs) name rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  srewrite_step (r # rs) name rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(name, rhs) \\<in> set []; is_map (set [])\\<rbrakk>\n    \\<Longrightarrow> srewrite_step [] name rhs", "qed auto"], ["", "lemma (in srules) srewrite_stepI: \"(name, rhs) \\<in> set rs \\<Longrightarrow> srewrite_step rs name rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) \\<in> set rs \\<Longrightarrow> srewrite_step rs name rhs", "using map"], ["proof (prove)\nusing this:\n  is_map (set rs)\n\ngoal (1 subgoal):\n 1. (name, rhs) \\<in> set rs \\<Longrightarrow> srewrite_step rs name rhs", "by (metis srewrite_stepI0)"], ["", "hide_fact srewrite_stepI0"], ["", "inductive srewrite :: \"srule list \\<Rightarrow> sterm \\<Rightarrow> sterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>s/ _ \\<longrightarrow>/ _\" [50,0,50] 50) for rs where\nstep: \"srewrite_step rs name rhs \\<Longrightarrow> rs \\<turnstile>\\<^sub>s Sconst name \\<longrightarrow> rhs\" |\nbeta: \"rewrite_first cs t t' \\<Longrightarrow> rs \\<turnstile>\\<^sub>s Sabs cs $\\<^sub>s t \\<longrightarrow> t'\" |\n\"fun\": \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t' \\<Longrightarrow> rs \\<turnstile>\\<^sub>s t $\\<^sub>s u \\<longrightarrow> t' $\\<^sub>s u\" |\narg: \"rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u' \\<Longrightarrow> rs \\<turnstile>\\<^sub>s t $\\<^sub>s u \\<longrightarrow> t $\\<^sub>s u'\""], ["", "code_pred srewrite"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation srewrite_rt :: \"srule list \\<Rightarrow> sterm \\<Rightarrow> sterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>s/ _ \\<longrightarrow>*/ _\" [50,0,50] 50) where\n\"srewrite_rt rs \\<equiv> (srewrite rs)\\<^sup>*\\<^sup>*\""], ["", "global_interpretation srewrite: rewriting \"srewrite rs\" for rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rewriting (srewrite rs)", "by standard (auto intro: srewrite.intros simp: app_sterm_def)+"], ["", "code_pred (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) srewrite_step"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) srewrite"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsubsection \\<open>Translation from @{typ pterm} to @{typ sterm}\\<close>"], ["", "text \\<open>\n  In principle, any function of type @{typ \\<open>('a \\<times> 'b) fset \\<Rightarrow> ('a \\<times> 'b) list\\<close>} that orders\n  by keys would do here. However, For simplicity's sake, we choose a fixed one\n  (@{const ordered_fmap}) here.\n\\<close>"], ["", "primrec pterm_to_sterm :: \"pterm \\<Rightarrow> sterm\" where\n\"pterm_to_sterm (Pconst name) = Sconst name\" |\n\"pterm_to_sterm (Pvar name) = Svar name\" |\n\"pterm_to_sterm (t $\\<^sub>p u) = pterm_to_sterm t $\\<^sub>s pterm_to_sterm u\" |\n\"pterm_to_sterm (Pabs cs) = Sabs (ordered_fmap (map_prod id pterm_to_sterm |`| cs))\""], ["", "lemma pterm_to_sterm:\n  assumes \"no_abs t\"\n  shows \"pterm_to_sterm t = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm t = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. pterm_to_sterm t = convert_term t", "proof induction"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name. pterm_to_sterm (free name) = convert_term (free name)\n 2. \\<And>name. pterm_to_sterm (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (free name)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>name. pterm_to_sterm (free name) = convert_term (free name)\n 2. \\<And>name. pterm_to_sterm (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (free name) = convert_term (free name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (free name) = free name", "apply (simp add: free_sterm_def free_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pterm_to_sterm (free name) = convert_term (free name)\n\ngoal (2 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (const name)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (const name) = convert_term (const name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (const name) = const name", "apply (simp add: const_sterm_def const_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pterm_to_sterm (const name) = convert_term (const name)\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1\n  pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1\n  pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1\n  pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n\ngoal (1 subgoal):\n 1. pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n    convert_term (app t\\<^sub>1 t\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pterm_to_sterm t\\<^sub>1 = convert_term t\\<^sub>1;\n     pterm_to_sterm t\\<^sub>2 = convert_term t\\<^sub>2; no_abs t\\<^sub>1;\n     no_abs t\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                      app (convert_term t\\<^sub>1) (convert_term t\\<^sub>2)", "apply (simp add: app_sterm_def app_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n  convert_term (app t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  @{const sterm_to_pterm} has to be defined, for technical reasons, in\n  @{theory CakeML_Codegen.Pterm}.\n\\<close>"], ["", "lemma pterm_to_sterm_wellformed:\n  assumes \"wellformed t\"\n  shows \"wellformed (pterm_to_sterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (pterm_to_sterm t)", "using assms"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (pterm_to_sterm t)", "proof (induction t rule: pterm_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pconst x))\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pvar x))\n 3. \\<And>cs.\n       \\<lbrakk>\\<And>pat t.\n                   \\<lbrakk>(pat, t) |\\<in>| cs;\n                    pre_strong_term_class.wellformed t\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(pterm_to_sterm t);\n        pre_strong_term_class.wellformed (Pabs cs)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (pterm_to_sterm (Pabs cs))\n 4. \\<And>t u.\n       \\<lbrakk>pre_strong_term_class.wellformed t \\<Longrightarrow>\n                pre_strong_term_class.wellformed (pterm_to_sterm t);\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed (pterm_to_sterm u);\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (pterm_to_sterm (t $\\<^sub>p u))", "case (Pabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs;\n   pre_strong_term_class.wellformed ?t\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (pterm_to_sterm ?t)\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pconst x))\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pvar x))\n 3. \\<And>cs.\n       \\<lbrakk>\\<And>pat t.\n                   \\<lbrakk>(pat, t) |\\<in>| cs;\n                    pre_strong_term_class.wellformed t\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(pterm_to_sterm t);\n        pre_strong_term_class.wellformed (Pabs cs)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (pterm_to_sterm (Pabs cs))\n 4. \\<And>t u.\n       \\<lbrakk>pre_strong_term_class.wellformed t \\<Longrightarrow>\n                pre_strong_term_class.wellformed (pterm_to_sterm t);\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed (pterm_to_sterm u);\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (pterm_to_sterm (t $\\<^sub>p u))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (pterm_to_sterm (Pabs cs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_clauses (ordered_fmap (map_prod id pterm_to_sterm |`| cs))", "unfolding map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_clauses\n     (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)\n     (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))\n 2. distinct\n     (map fst\n       (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)))\n 3. ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)\n     (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))", "apply (subst list_all_iff_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall\n     (fset_of_list\n       (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)))\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n 2. fBall ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap cs\n 2. fBall ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)", "using Pabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs;\n   pre_strong_term_class.wellformed ?t\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (pterm_to_sterm ?t)\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (2 subgoals):\n 1. is_fmap cs\n 2. fBall ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n     (\\<lambda>(pat, t).\n         linear pat \\<and> pre_strong_term_class.wellformed t)", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>|\n       (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs \\<Longrightarrow>\n       case x of\n       (pat, t) \\<Rightarrow>\n         linear pat \\<and> pre_strong_term_class.wellformed t", "apply (erule fimageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = (case xa of (x, y) \\<Rightarrow> (x, pterm_to_sterm y));\n        xa |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (pat, t) \\<Rightarrow>\n                           linear pat \\<and>\n                           pre_strong_term_class.wellformed t", "apply auto[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba. (aa, ba) |\\<in>| cs \\<Longrightarrow> linear aa\n 2. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm ba)", "using Pabs(2)"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>aa ba. (aa, ba) |\\<in>| cs \\<Longrightarrow> linear aa\n 2. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm ba)", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm ba)", "apply (rule Pabs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow> (?pat57 aa ba, ba) |\\<in>| cs\n 2. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed ba", "using Pabs(2)"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow> (?pat57 aa ba, ba) |\\<in>| cs\n 2. \\<And>aa ba.\n       (aa, ba) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed ba", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)))\n 2. ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)))", "apply (rule ordered_fmap_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "using Pabs(2)"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (1 subgoal):\n 1. is_fmap cs", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []", "apply (subgoal_tac \"cs \\<noteq> {||}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. cs \\<noteq> {||} \\<Longrightarrow>\n    ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []\n 2. cs \\<noteq> {||}", "including fset.lifting"], ["proof (prove)\ngoal (2 subgoals):\n 1. cs \\<noteq> {||} \\<Longrightarrow>\n    ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs) \\<noteq>\n    []\n 2. cs \\<noteq> {||}", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>finite cs; cs \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ordered_map\n                          ((\\<lambda>(x, y). (x, pterm_to_sterm y)) `\n                           cs) \\<noteq>\n                         []\n 2. cs \\<noteq> {||}", "unfolding ordered_map_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>finite cs; cs \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> map (get_map\n                               ((\\<lambda>(x, y). (x, pterm_to_sterm y)) `\n                                cs))\n                          (sorted_list_of_set\n                            (fst `\n                             (\\<lambda>(x, y). (x, pterm_to_sterm y)) `\n                             cs)) \\<noteq>\n                         []\n 2. cs \\<noteq> {||}", "using Pabs(2)"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs.\n       \\<lbrakk>finite cs; cs \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> map (get_map\n                               ((\\<lambda>(x, y). (x, pterm_to_sterm y)) `\n                                cs))\n                          (sorted_list_of_set\n                            (fst `\n                             (\\<lambda>(x, y). (x, pterm_to_sterm y)) `\n                             cs)) \\<noteq>\n                         []\n 2. cs \\<noteq> {||}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (pterm_to_sterm (Pabs cs))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pconst x))\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       pre_strong_term_class.wellformed (pterm_to_sterm (Pvar x))\n 3. \\<And>t u.\n       \\<lbrakk>pre_strong_term_class.wellformed t \\<Longrightarrow>\n                pre_strong_term_class.wellformed (pterm_to_sterm t);\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed (pterm_to_sterm u);\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (pterm_to_sterm (t $\\<^sub>p u))", "qed auto"], ["", "lemma pterm_to_sterm_sterm_to_pterm:\n  assumes \"wellformed t\"\n  shows \"sterm_to_pterm (pterm_to_sterm t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (pterm_to_sterm t) = t", "using assms"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. sterm_to_pterm (pterm_to_sterm t) = t", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pconst x)) = Pconst x\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pvar x)) = Pvar x\n 3. \\<And>x.\n       \\<lbrakk>\\<And>xa xaa.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm xaa) =\n                                     xaa;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (Pabs x)) = Pabs x\n 4. \\<And>t1 t2.\n       \\<lbrakk>pre_strong_term_class.wellformed t1 \\<Longrightarrow>\n                sterm_to_pterm (pterm_to_sterm t1) = t1;\n        pre_strong_term_class.wellformed t2 \\<Longrightarrow>\n        sterm_to_pterm (pterm_to_sterm t2) = t2;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (t1 $\\<^sub>p t2)) =\n                         t1 $\\<^sub>p t2", "case (Pabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm ?xaa) = ?xaa\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pconst x)) = Pconst x\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pvar x)) = Pvar x\n 3. \\<And>x.\n       \\<lbrakk>\\<And>xa xaa.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm xaa) =\n                                     xaa;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (Pabs x)) = Pabs x\n 4. \\<And>t1 t2.\n       \\<lbrakk>pre_strong_term_class.wellformed t1 \\<Longrightarrow>\n                sterm_to_pterm (pterm_to_sterm t1) = t1;\n        pre_strong_term_class.wellformed t2 \\<Longrightarrow>\n        sterm_to_pterm (pterm_to_sterm t2) = t2;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (t1 $\\<^sub>p t2)) =\n                         t1 $\\<^sub>p t2", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pconst x)) = Pconst x\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pvar x)) = Pvar x\n 3. \\<And>x.\n       \\<lbrakk>\\<And>xa xaa.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm xaa) =\n                                     xaa;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (Pabs x)) = Pabs x\n 4. \\<And>t1 t2.\n       \\<lbrakk>pre_strong_term_class.wellformed t1 \\<Longrightarrow>\n                sterm_to_pterm (pterm_to_sterm t1) = t1;\n        pre_strong_term_class.wellformed t2 \\<Longrightarrow>\n        sterm_to_pterm (pterm_to_sterm t2) = t2;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (t1 $\\<^sub>p t2)) =\n                         t1 $\\<^sub>p t2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (pterm_to_sterm (Pabs cs)) = Pabs cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list\n     (map (map_prod id sterm_to_pterm)\n       (ordered_fmap (map_prod id pterm_to_sterm |`| cs))) =\n    cs", "unfolding map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list\n     (map (\\<lambda>(x, y). (x, sterm_to_pterm y))\n       (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))) =\n    cs", "apply (subst ordered_fmap_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n 2. fset_of_list\n     (ordered_fmap\n       ((\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n        (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)) =\n    cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "using Pabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm ?xaa) = ?xaa\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (1 subgoal):\n 1. is_fmap cs", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list\n     (ordered_fmap\n       ((\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n        (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)) =\n    cs", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap\n     ((\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n      (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)\n 2. (\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n    (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs =\n    cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap\n     ((\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n      (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "using Pabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm ?xaa) = ?xaa\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (1 subgoal):\n 1. is_fmap cs", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n    (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs =\n    cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). (a, sterm_to_pterm b)) |`|\n    (\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs =\n    cs", "apply (subst fset.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(a, b). (a, sterm_to_pterm b)) \\<circ>\n     (\\<lambda>(x, y). (x, pterm_to_sterm y))) |`|\n    cs =\n    cs", "apply (subst map_prod_def[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod (\\<lambda>a. a) sterm_to_pterm \\<circ>\n     map_prod (\\<lambda>x. x) pterm_to_sterm) |`|\n    cs =\n    cs", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        map_prod (\\<lambda>a. a) sterm_to_pterm\n         (map_prod (\\<lambda>x. x) pterm_to_sterm x)) |`|\n    cs =\n    cs", "apply (subst prod.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod ((\\<lambda>a. a) \\<circ> (\\<lambda>x. x))\n     (sterm_to_pterm \\<circ> pterm_to_sterm) |`|\n    cs =\n    cs", "apply (subst id_def[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod (id \\<circ> id) (sterm_to_pterm \\<circ> pterm_to_sterm) |`|\n    cs =\n    cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod id (sterm_to_pterm \\<circ> pterm_to_sterm) |`| cs = cs", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (id x, (sterm_to_pterm \\<circ> pterm_to_sterm) y)) |`|\n    cs =\n    cs", "unfolding id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (x, (sterm_to_pterm \\<circ> pterm_to_sterm) y)) |`|\n    cs =\n    cs", "apply (rule fset_map_snd_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y e.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       (sterm_to_pterm \\<circ> pterm_to_sterm) y = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm y) = y", "apply (rule Pabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x, y) \\<in> fset cs \\<Longrightarrow> ?xa2 x y \\<in> fset cs\n 2. \\<And>x y.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       y \\<in> Basic_BNFs.snds (?xa2 x y)\n 3. \\<And>x y.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed y", "using Pabs(2)"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x, y) \\<in> fset cs \\<Longrightarrow> ?xa2 x y \\<in> fset cs\n 2. \\<And>x y.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       y \\<in> Basic_BNFs.snds (?xa2 x y)\n 3. \\<And>x y.\n       (x, y) \\<in> fset cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed y", "by (auto simp: fmember.rep_eq snds.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sterm_to_pterm (pterm_to_sterm (Pabs cs)) = Pabs cs\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       pre_strong_term_class.wellformed (Pconst x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pconst x)) = Pconst x\n 2. \\<And>x.\n       pre_strong_term_class.wellformed (Pvar x) \\<Longrightarrow>\n       sterm_to_pterm (pterm_to_sterm (Pvar x)) = Pvar x\n 3. \\<And>t1 t2.\n       \\<lbrakk>pre_strong_term_class.wellformed t1 \\<Longrightarrow>\n                sterm_to_pterm (pterm_to_sterm t1) = t1;\n        pre_strong_term_class.wellformed t2 \\<Longrightarrow>\n        sterm_to_pterm (pterm_to_sterm t2) = t2;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (pterm_to_sterm (t1 $\\<^sub>p t2)) =\n                         t1 $\\<^sub>p t2", "qed auto"], ["", "corollary pterm_to_sterm_frees: \"wellformed t \\<Longrightarrow> frees (pterm_to_sterm t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t \\<Longrightarrow>\n    frees (pterm_to_sterm t) = frees t", "by (metis pterm_to_sterm_sterm_to_pterm sterm_to_pterm_frees)"], ["", "corollary pterm_to_sterm_closed:\n  \"closed_except t S \\<Longrightarrow> wellformed t \\<Longrightarrow> closed_except (pterm_to_sterm t) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_except t S; pre_strong_term_class.wellformed t\\<rbrakk>\n    \\<Longrightarrow> closed_except (pterm_to_sterm t) S", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>frees t |\\<subseteq>| S;\n     pre_strong_term_class.wellformed t\\<rbrakk>\n    \\<Longrightarrow> frees (pterm_to_sterm t) |\\<subseteq>| S", "by (simp add: pterm_to_sterm_frees)"], ["", "corollary pterm_to_sterm_consts: \"wellformed t \\<Longrightarrow> consts (pterm_to_sterm t) = consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t \\<Longrightarrow>\n    consts (pterm_to_sterm t) = consts t", "by (metis pterm_to_sterm_sterm_to_pterm sterm_to_pterm_consts)"], ["", "corollary (in constants) pterm_to_sterm_shadows:\n  \"wellformed t \\<Longrightarrow> shadows_consts t \\<longleftrightarrow> shadows_consts (pterm_to_sterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t \\<Longrightarrow>\n    shadows_consts t = shadows_consts (pterm_to_sterm t)", "unfolding shadows_consts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t \\<Longrightarrow>\n    (\\<not> fdisjnt all_consts (all_frees t)) =\n    (\\<not> fdisjnt all_consts (all_frees (pterm_to_sterm t)))", "by (metis pterm_to_sterm_sterm_to_pterm sterm_to_pterm_all_frees)"], ["", "definition compile :: \"prule fset \\<Rightarrow> srule list\" where\n\"compile rs = ordered_fmap (map_prod id pterm_to_sterm |`| rs)\""], ["", "subsubsection \\<open>Correctness of translation\\<close>"], ["", "context prules begin"], ["", "lemma compile_heads: \"fst |`| fset_of_list (compile rs) = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| fset_of_list (Rewriting_Sterm.compile rs) = fst |`| rs", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`|\n    fset_of_list (ordered_fmap (map_prod id pterm_to_sterm |`| rs)) =\n    fst |`| rs", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. fst |`| map_prod id pterm_to_sterm |`| rs = fst |`| rs", "apply (subst map_prod_def, subst id_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)\n 2. fst |`| map_prod id pterm_to_sterm |`| rs = fst |`| rs", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap rs\n 2. fst |`| map_prod id pterm_to_sterm |`| rs = fst |`| rs", "apply (rule fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| map_prod id pterm_to_sterm |`| rs = fst |`| rs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compile_rules: \"srules C_info (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srules C_info (Rewriting_Sterm.compile rs)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all srule (Rewriting_Sterm.compile rs)\n 4. distinct (map fst (Rewriting_Sterm.compile rs))\n 5. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 6. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "show \"list_all srule (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all srule (Rewriting_Sterm.compile rs)", "using fmap all_rules"], ["proof (prove)\nusing this:\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. list_all srule (Rewriting_Sterm.compile rs)", "unfolding compile_def list_all_iff"], ["proof (prove)\nusing this:\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. Ball (set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))) srule", "including fset.lifting"], ["proof (prove)\nusing this:\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. Ball (set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))) srule", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (ordered_map\n                                 (map_prod id pterm_to_sterm ` rs)))\n                          srule", "apply (subst ordered_map_set_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> finite (map_prod id pterm_to_sterm ` rs)\n 2. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> is_map (map_prod id pterm_to_sterm ` rs)\n 3. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> Ball (map_prod id pterm_to_sterm ` rs) srule", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule\\<rbrakk>\n    \\<Longrightarrow> finite (map_prod id pterm_to_sterm ` rs_)", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> is_map (map_prod id pterm_to_sterm ` rs)\n 2. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> Ball (map_prod id pterm_to_sterm ` rs) srule", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule\\<rbrakk>\n    \\<Longrightarrow> is_map (map_prod id pterm_to_sterm ` rs_)", "unfolding map_prod_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule\\<rbrakk>\n    \\<Longrightarrow> is_map\n                       ((\\<lambda>(x, y). (x, pterm_to_sterm y)) ` rs_)", "by (erule is_map_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>finite rs; is_map rs; Ball rs prule\\<rbrakk>\n       \\<Longrightarrow> Ball (map_prod id pterm_to_sterm ` rs) srule", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule\\<rbrakk>\n    \\<Longrightarrow> Ball (map_prod id pterm_to_sterm ` rs_) srule", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        x \\<in> map_prod id pterm_to_sterm ` rs_\\<rbrakk>\n       \\<Longrightarrow> srule x", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (pterm_to_sterm y)\n 2. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> closed (pterm_to_sterm y)\n 3. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> is_abs (pterm_to_sterm y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed (pterm_to_sterm y_)", "apply (rule pterm_to_sterm_wellformed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed y_", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> closed (pterm_to_sterm y)\n 2. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> is_abs (pterm_to_sterm y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> closed (pterm_to_sterm y_)", "apply (rule pterm_to_sterm_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> closed y_\n 2. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed y_", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (x_, y_) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed y_", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x y.\n       \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n        (x, y) \\<in> rs_\\<rbrakk>\n       \\<Longrightarrow> is_abs (pterm_to_sterm y)", "subgoal for _ _ a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rs_; is_map rs_; Ball rs_ prule;\n     (a, b) \\<in> rs_\\<rbrakk>\n    \\<Longrightarrow> is_abs (pterm_to_sterm b)", "apply (erule ballE[where x = \"(a, b)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite rs_; is_map rs_; (a, b) \\<in> rs_; prule (a, b)\\<rbrakk>\n    \\<Longrightarrow> is_abs (pterm_to_sterm b)\n 2. \\<lbrakk>finite rs_; is_map rs_; (a, b) \\<in> rs_;\n     (a, b) \\<notin> rs_\\<rbrakk>\n    \\<Longrightarrow> is_abs (pterm_to_sterm b)", "apply (cases b; auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>finite rs_; is_map rs_; (a, Pconst x1) \\<in> rs_;\n        b = Pconst x1; closed (Pconst x1); is_abs (Pconst x1)\\<rbrakk>\n       \\<Longrightarrow> is_abs (Sconst x1)\n 2. \\<And>x2.\n       \\<lbrakk>finite rs_; is_map rs_; (a, Pvar x2) \\<in> rs_; b = Pvar x2;\n        closed (Pvar x2); is_abs (Pvar x2)\\<rbrakk>\n       \\<Longrightarrow> is_abs (Svar x2)\n 3. \\<And>x3 a b.\n       \\<lbrakk>finite rs_; is_map rs_; (a, Pabs x3) \\<in> rs_; b = Pabs x3;\n        fBall x3\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t);\n        is_fmap x3; pattern_compatibles x3; closed (Pabs x3);\n        is_abs (Pabs x3);\n        \\<not> is_abs\n                (Sabs (ordered_fmap (map_prod id pterm_to_sterm |`| x3)));\n        (a, b) |\\<in>| x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x41 x42.\n       \\<lbrakk>finite rs_; is_map rs_; (a, x41 $\\<^sub>p x42) \\<in> rs_;\n        b = x41 $\\<^sub>p x42; pre_strong_term_class.wellformed x41;\n        pre_strong_term_class.wellformed x42; closed (x41 $\\<^sub>p x42);\n        is_abs (x41 $\\<^sub>p x42)\\<rbrakk>\n       \\<Longrightarrow> is_abs\n                          (pterm_to_sterm x41 $\\<^sub>s pterm_to_sterm x42)\n 5. \\<lbrakk>finite rs_; is_map rs_; (a, b) \\<in> rs_;\n     (a, b) \\<notin> rs_\\<rbrakk>\n    \\<Longrightarrow> is_abs (pterm_to_sterm b)", "apply (auto simp: is_abs_def term_cases_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all srule (Rewriting_Sterm.compile rs)\n\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. distinct (map fst (Rewriting_Sterm.compile rs))\n 4. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 5. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. distinct (map fst (Rewriting_Sterm.compile rs))\n 4. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 5. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "show \"distinct (map fst (compile rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (Rewriting_Sterm.compile rs))", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ordered_fmap (map_prod id pterm_to_sterm |`| rs)))", "apply (rule ordered_fmap_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)", "unfolding map_prod_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "apply (rule fmap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst (Rewriting_Sterm.compile rs))\n\ngoal (4 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 4. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 4. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "have \"list_all (\\<lambda>(_, rhs). welldefined rhs) (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n     (Rewriting_Sterm.compile rs)", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n     (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "apply (subst ordered_fmap_list_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. fBall (map_prod id pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (id x, pterm_to_sterm y)) |`| rs)", "apply (subst id_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "by (fact fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (map_prod id pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>x.\n         case map_prod id pterm_to_sterm x of\n         (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts)", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| rs \\<Longrightarrow>\n       case map_prod id pterm_to_sterm x of\n       (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| rs \\<Longrightarrow>\n    case map_prod id pterm_to_sterm x of\n    (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts", "apply (cases x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts (pterm_to_sterm b) |\\<subseteq>| all_consts", "apply (subst pterm_to_sterm_consts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "using all_rules"], ["proof (prove)\nusing this:\n  fBall rs prule\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "using welldefined_rs"], ["proof (prove)\nusing this:\n  fBall rs (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n   (Rewriting_Sterm.compile rs)\n\ngoal (4 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)\n 4. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "thus \"list_all (\\<lambda>(_, rhs). consts rhs |\\<subseteq>| pre_constants.all_consts C_info (fst |`| fset_of_list (compile rs))) (compile rs)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n   (Rewriting_Sterm.compile rs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info\n          (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n     (Rewriting_Sterm.compile rs)", "by (simp add: compile_heads)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(uu_, rhs).\n       consts rhs |\\<subseteq>|\n       pre_constants.all_consts C_info\n        (fst |`| fset_of_list (Rewriting_Sterm.compile rs)))\n   (Rewriting_Sterm.compile rs)\n\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "interpret c: constants _ \"fset_of_list (map fst (compile rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constants C_info (fset_of_list (map fst (Rewriting_Sterm.compile rs)))", "by (simp add: constants_axioms compile_heads)"], ["proof (state)\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "have all_consts: \"c.all_consts = all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.all_consts = all_consts", "by (simp add: compile_heads)"], ["proof (state)\nthis:\n  c.all_consts = all_consts\n\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "have \"list_all (\\<lambda>(_, rhs). \\<not> shadows_consts rhs) (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n     (Rewriting_Sterm.compile rs)", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n     (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "apply (subst list_all_iff_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (fset_of_list (ordered_fmap (map_prod id pterm_to_sterm |`| rs)))\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. fBall (map_prod id pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (id x, pterm_to_sterm y)) |`| rs)\n 2. fBall (map_prod id pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "unfolding id_apply"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)\n 2. fBall (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap rs\n 2. fBall (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "apply (fact fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs)\n     (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>x.\n         case map_prod (\\<lambda>x. x) pterm_to_sterm x of\n         (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs)", "apply (rule fBall_pred_weaken[where P = \"\\<lambda>(_, rhs). \\<not> shadows_consts rhs\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| rs;\n        case x of\n        (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs\\<rbrakk>\n       \\<Longrightarrow> case map_prod (\\<lambda>x. x) pterm_to_sterm x of\n                         (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs\n 2. fBall rs (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| rs;\n     case x of (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs\\<rbrakk>\n    \\<Longrightarrow> case map_prod (\\<lambda>x. x) pterm_to_sterm x of\n                      (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs", "apply (cases x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; \\<not> shadows_consts b;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (pterm_to_sterm b)", "apply (subst (asm) pterm_to_sterm_shadows)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x = (a, b); (a, b) |\\<in>| rs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; \\<not> shadows_consts (pterm_to_sterm b);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (pterm_to_sterm b)", "using all_rules"], ["proof (prove)\nusing this:\n  fBall rs prule\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x = (a, b); (a, b) |\\<in>| rs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; \\<not> shadows_consts (pterm_to_sterm b);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (pterm_to_sterm b)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; \\<not> shadows_consts (pterm_to_sterm b);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (pterm_to_sterm b)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "using not_shadows"], ["proof (prove)\nusing this:\n  fBall rs (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n   (Rewriting_Sterm.compile rs)\n\ngoal (3 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors\n 3. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "thus \"list_all (\\<lambda>(_, rhs). \\<not> pre_constants.shadows_consts C_info (fst |`| fset_of_list (compile rs)) rhs) (compile rs)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n   (Rewriting_Sterm.compile rs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         \\<not> pre_constants.shadows_consts C_info\n                 (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n     (Rewriting_Sterm.compile rs)", "unfolding compile_heads all_consts"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n   (Rewriting_Sterm.compile rs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs)\n     (Rewriting_Sterm.compile rs)", "."], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(uu_, rhs).\n       \\<not> pre_constants.shadows_consts C_info\n               (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) rhs)\n   (Rewriting_Sterm.compile rs)\n\ngoal (2 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n 2. distinct all_constructors", "show \"fdisjnt (fst |`| fset_of_list (compile rs)) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt\n     (fst |`|\n      fset_of_list (ordered_fmap (map_prod id pterm_to_sterm |`| rs)))\n     C", "apply (subst fset_of_list_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt\n     (fset_of_list\n       (map fst (ordered_fmap (map_prod id pterm_to_sterm |`| rs))))\n     C", "apply (subst ordered_fmap_keys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. fdisjnt\n     (fset_of_list\n       (sorted_list_of_fset (fst |`| map_prod id pterm_to_sterm |`| rs)))\n     C", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (id x, pterm_to_sterm y)) |`| rs)\n 2. fdisjnt\n     (fset_of_list\n       (sorted_list_of_fset (fst |`| map_prod id pterm_to_sterm |`| rs)))\n     C", "apply (subst id_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)\n 2. fdisjnt\n     (fset_of_list\n       (sorted_list_of_fset (fst |`| map_prod id pterm_to_sterm |`| rs)))\n     C", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap rs\n 2. fdisjnt\n     (fset_of_list\n       (sorted_list_of_fset (fst |`| map_prod id pterm_to_sterm |`| rs)))\n     C", "using fmap disjnt"], ["proof (prove)\nusing this:\n  is_fmap rs\n  fdisjnt (fst |`| rs) C\n\ngoal (2 subgoals):\n 1. is_fmap rs\n 2. fdisjnt\n     (fset_of_list\n       (sorted_list_of_fset (fst |`| map_prod id pterm_to_sterm |`| rs)))\n     C", "by auto"], ["proof (state)\nthis:\n  fdisjnt (fst |`| fset_of_list (Rewriting_Sterm.compile rs)) C\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale prules_as_srules: srules C_info \"compile rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srules C_info (Rewriting_Sterm.compile rs)", "by (fact compile_rules)"], ["", "end"], ["", "global_interpretation srelated: term_struct_rel_strong \"(\\<lambda>p s. p = sterm_to_pterm s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_struct_rel_strong (\\<lambda>p s. p = sterm_to_pterm s)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>name t.\n       const name = sterm_to_pterm t \\<Longrightarrow> t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n          u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "case (5 name t)"], ["proof (state)\nthis:\n  const name = sterm_to_pterm t\n\ngoal (6 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>name t.\n       const name = sterm_to_pterm t \\<Longrightarrow> t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n          u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  const name = sterm_to_pterm t", "show ?case"], ["proof (prove)\nusing this:\n  const name = sterm_to_pterm t\n\ngoal (1 subgoal):\n 1. t = const name", "by (cases t) (auto simp: const_sterm_def const_pterm_def split: option.splits)"], ["proof (state)\nthis:\n  t = const name\n\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n          u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n          u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "case (6 u\\<^sub>1 u\\<^sub>2 t)"], ["proof (state)\nthis:\n  app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t\n\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n          u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t", "show ?case"], ["proof (prove)\nusing this:\n  app u\\<^sub>1 u\\<^sub>2 = sterm_to_pterm t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<^sub>1 t\\<^sub>2.\n       t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n       u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n       u\\<^sub>2 = sterm_to_pterm t\\<^sub>2", "by (cases t) (auto simp: app_sterm_def app_pterm_def split: option.splits)"], ["proof (state)\nthis:\n  \\<exists>t\\<^sub>1 t\\<^sub>2.\n     t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n     u\\<^sub>1 = sterm_to_pterm t\\<^sub>1 \\<and>\n     u\\<^sub>2 = sterm_to_pterm t\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>t name.\n       t = sterm_to_pterm (const name) \\<Longrightarrow> t = const name\n 2. \\<And>name. const name = sterm_to_pterm (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t = sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = sterm_to_pterm u\\<^sub>1 \\<and>\n          t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = sterm_to_pterm u\\<^sub>1;\n        t\\<^sub>2 = sterm_to_pterm u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         sterm_to_pterm (app u\\<^sub>1 u\\<^sub>2)", "qed (auto simp: const_sterm_def const_pterm_def app_sterm_def app_pterm_def)"], ["", "lemma srelated_subst:\n  assumes \"srelated.P_env penv senv\"\n  shows \"subst (sterm_to_pterm t) penv = sterm_to_pterm (subst t senv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm t) penv = sterm_to_pterm (subst t senv)", "using assms"], ["proof (prove)\nusing this:\n  srelated.P_env penv senv\n\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm t) penv = sterm_to_pterm (subst t senv)", "proof (induction t arbitrary: penv senv)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Svar x)) penv =\n       sterm_to_pterm (subst (Svar x) senv)\n 3. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated.P_env penv senv\\<rbrakk>\n                   \\<Longrightarrow> subst (sterm_to_pterm xaa) penv =\n                                     sterm_to_pterm (subst xaa senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (Sabs x)) penv =\n                         sterm_to_pterm (subst (Sabs x) senv)\n 4. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "case (Svar name)"], ["proof (state)\nthis:\n  srelated.P_env penv senv\n\ngoal (4 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Svar x)) penv =\n       sterm_to_pterm (subst (Svar x) senv)\n 3. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated.P_env penv senv\\<rbrakk>\n                   \\<Longrightarrow> subst (sterm_to_pterm xaa) penv =\n                                     sterm_to_pterm (subst xaa senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (Sabs x)) penv =\n                         sterm_to_pterm (subst (Sabs x) senv)\n 4. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "thus ?case"], ["proof (prove)\nusing this:\n  srelated.P_env penv senv\n\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm (Svar name)) penv =\n    sterm_to_pterm (subst (Svar name) senv)", "by (cases rule: fmrel_cases[where x = name]) auto"], ["proof (state)\nthis:\n  subst (sterm_to_pterm (Svar name)) penv =\n  sterm_to_pterm (subst (Svar name) senv)\n\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated.P_env penv senv\\<rbrakk>\n                   \\<Longrightarrow> subst (sterm_to_pterm xaa) penv =\n                                     sterm_to_pterm (subst xaa senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (Sabs x)) penv =\n                         sterm_to_pterm (subst (Sabs x) senv)\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated.P_env penv senv\\<rbrakk>\n                   \\<Longrightarrow> subst (sterm_to_pterm xaa) penv =\n                                     sterm_to_pterm (subst xaa senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (Sabs x)) penv =\n                         sterm_to_pterm (subst (Sabs x) senv)\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "case (Sabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> set cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   srelated.P_env ?penv ?senv\\<rbrakk>\n  \\<Longrightarrow> subst (sterm_to_pterm ?xaa) ?penv =\n                    sterm_to_pterm (subst ?xaa ?senv)\n  srelated.P_env penv senv\n\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated.P_env penv senv\\<rbrakk>\n                   \\<Longrightarrow> subst (sterm_to_pterm xaa) penv =\n                                     sterm_to_pterm (subst xaa senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (Sabs x)) penv =\n                         sterm_to_pterm (subst (Sabs x) senv)\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm (Sabs cs)) penv =\n    sterm_to_pterm (subst (Sabs cs) senv)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) penv))) \\<circ>\n     map_prod id sterm_to_pterm) |`|\n    fset_of_list cs =\n    (map_prod id sterm_to_pterm \\<circ>\n     (\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) senv)))) |`|\n    fset_of_list cs", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) penv))) \\<circ>\n     map_prod id sterm_to_pterm) |`|\n    fset_of_list cs =\n    (map_prod id sterm_to_pterm \\<circ>\n     (\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) senv)))) |`|\n    fset_of_list cs", "apply (transfer' fixing: cs penv senv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) penv))) \\<circ>\n     map_prod id sterm_to_pterm) `\n    set cs =\n    (map_prod id sterm_to_pterm \\<circ>\n     (\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) senv)))) `\n    set cs", "unfolding set_map image_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) penv))) \\<circ>\n     map_prod id sterm_to_pterm) `\n    set cs =\n    (map_prod id sterm_to_pterm \\<circ>\n     (\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) senv)))) `\n    set cs", "apply (rule image_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       ((\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) penv))) \\<circ>\n        map_prod id sterm_to_pterm)\n        x =\n       (map_prod id sterm_to_pterm \\<circ>\n        (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv))))\n        x", "unfolding comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       (case map_prod id sterm_to_pterm x of\n        (pat, rhs) \\<Rightarrow>\n          (pat, subst rhs (fmdrop_fset (frees pat) penv))) =\n       map_prod id sterm_to_pterm\n        (case x of\n         (pat, rhs) \\<Rightarrow>\n           (pat, subst rhs (fmdrop_fset (frees pat) senv)))", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (case map_prod id sterm_to_pterm x of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs (fmdrop_fset (frees pat) penv))) =\n                         map_prod id sterm_to_pterm\n                          (case x of\n                           (pat, rhs) \\<Rightarrow>\n                             (pat,\n                              subst rhs (fmdrop_fset (frees pat) senv)))", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       (case map_prod id sterm_to_pterm (a, b) of\n        (pat, rhs) \\<Rightarrow>\n          (pat, subst rhs (fmdrop_fset (frees pat) penv))) =\n       map_prod id sterm_to_pterm\n        (case (a, b) of\n         (pat, rhs) \\<Rightarrow>\n           (pat, subst rhs (fmdrop_fset (frees pat) senv)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       subst (sterm_to_pterm b) (fmdrop_fset (frees a) penv) =\n       sterm_to_pterm (subst b (fmdrop_fset (frees a) senv))", "apply (rule Sabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> ?xa223 a b \\<in> set cs\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       b \\<in> Basic_BNFs.snds (?xa223 a b)\n 3. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       srelated.P_env (fmdrop_fset (frees a) penv)\n        (fmdrop_fset (frees a) senv)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow> b \\<in> Basic_BNFs.snds (a, b)\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       srelated.P_env (fmdrop_fset (frees a) penv)\n        (fmdrop_fset (frees a) senv)", "apply (simp add: snds.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       srelated.P_env (fmdrop_fset (frees a) penv)\n        (fmdrop_fset (frees a) senv)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow> srelated.P_env penv senv", "apply (rule Sabs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst (sterm_to_pterm (Sabs cs)) penv =\n  sterm_to_pterm (subst (Sabs cs) senv)\n\ngoal (2 subgoals):\n 1. \\<And>x penv senv.\n       srelated.P_env penv senv \\<Longrightarrow>\n       subst (sterm_to_pterm (Sconst x)) penv =\n       sterm_to_pterm (subst (Sconst x) senv)\n 2. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   srelated.P_env penv senv \\<Longrightarrow>\n                   subst (sterm_to_pterm t1) penv =\n                   sterm_to_pterm (subst t1 senv);\n        \\<And>penv senv.\n           srelated.P_env penv senv \\<Longrightarrow>\n           subst (sterm_to_pterm t2) penv = sterm_to_pterm (subst t2 senv);\n        srelated.P_env penv senv\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t1 $\\<^sub>s t2)) penv =\n                         sterm_to_pterm (subst (t1 $\\<^sub>s t2) senv)", "qed auto"], ["", "context begin"], ["", "private"], ["", "lemma srewrite_step_non_empty: \"srewrite_step rs' name rhs \\<Longrightarrow> rs' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srewrite_step rs' name rhs \\<Longrightarrow> rs' \\<noteq> []", "by (induct rule: srewrite_step.induct) auto"], ["", "private"], ["", "lemma compile_consE:\n  assumes \"(name, rhs') # rest = compile rs\" \"is_fmap rs\"\n  obtains rhs where \"rhs' = pterm_to_sterm rhs\" \"(name, rhs) |\\<in>| rs\" \"rest = compile (rs - {| (name, rhs) |})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (name, rhs') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs", "have \"ordered_fmap (map_prod id pterm_to_sterm |`| rs) = (name, rhs') # rest\""], ["proof (prove)\nusing this:\n  (name, rhs') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. ordered_fmap (map_prod id pterm_to_sterm |`| rs) = (name, rhs') # rest", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (name, rhs') # rest = ordered_fmap (map_prod id pterm_to_sterm |`| rs)\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. ordered_fmap (map_prod id pterm_to_sterm |`| rs) = (name, rhs') # rest", "by simp"], ["proof (state)\nthis:\n  ordered_fmap (map_prod id pterm_to_sterm |`| rs) = (name, rhs') # rest\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"(name, rhs') \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))\""], ["proof (prove)\nusing this:\n  ordered_fmap (map_prod id pterm_to_sterm |`| rs) = (name, rhs') # rest\n\ngoal (1 subgoal):\n 1. (name, rhs')\n    \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "by simp"], ["proof (state)\nthis:\n  (name, rhs') \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(name, rhs') |\\<in>| map_prod id pterm_to_sterm |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs') |\\<in>| map_prod id pterm_to_sterm |`| rs", "apply (rule ordered_fmap_sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. (name, rhs')\n    \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)", "unfolding map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs')\n    \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs')\n    \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "by fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (name, rhs') |\\<in>| map_prod id pterm_to_sterm |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (name, rhs') |\\<in>| map_prod id pterm_to_sterm |`| rs", "obtain rhs where \"rhs' = pterm_to_sterm rhs\" \"(name, rhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (name, rhs') |\\<in>| map_prod id pterm_to_sterm |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rhs' = pterm_to_sterm rhs\n  (name, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"rest = compile (rs - {| (name, rhs) |})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    ordered_fmap (map_prod id pterm_to_sterm |`| (rs |-| {|(name, rhs)|}))", "apply (subst inj_on_fimage_set_diff[where C = rs])"], ["proof (prove)\ngoal (4 subgoals):\n 1. inj_on (map_prod id pterm_to_sterm) (fset rs)\n 2. rs |\\<subseteq>| rs\n 3. {|(name, rhs)|} |\\<subseteq>| rs\n 4. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-|\n      map_prod id pterm_to_sterm |`| {|(name, rhs)|})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map_prod id pterm_to_sterm) (fset rs)", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> fset rs; y \\<in> fset rs;\n        map_prod id pterm_to_sterm x = map_prod id pterm_to_sterm y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> fset rs; (aa, ba) \\<in> fset rs;\n        map_prod id pterm_to_sterm (a, b) =\n        map_prod id pterm_to_sterm (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> fset rs; (aa, ba) \\<in> fset rs;\n        map_prod id pterm_to_sterm (a, b) =\n        map_prod id pterm_to_sterm (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) \\<in> fset rs; (a, ba) \\<in> fset rs;\n        pterm_to_sterm b = pterm_to_sterm ba\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply (subst (asm) fmember.rep_eq[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) |\\<in>| rs; (a, ba) |\\<in>| rs;\n        pterm_to_sterm b = pterm_to_sterm ba\\<rbrakk>\n       \\<Longrightarrow> b = ba", "using \\<open>is_fmap rs\\<close>"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) |\\<in>| rs; (a, ba) |\\<in>| rs;\n        pterm_to_sterm b = pterm_to_sterm ba\\<rbrakk>\n       \\<Longrightarrow> b = ba", "by (blast dest: is_fmapD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs |\\<subseteq>| rs\n 2. {|(name, rhs)|} |\\<subseteq>| rs\n 3. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-|\n      map_prod id pterm_to_sterm |`| {|(name, rhs)|})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs |\\<subseteq>| rs", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. {|(name, rhs)|} |\\<subseteq>| rs\n 2. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-|\n      map_prod id pterm_to_sterm |`| {|(name, rhs)|})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {|(name, rhs)|} |\\<subseteq>| rs", "using \\<open>(name, rhs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. {|(name, rhs)|} |\\<subseteq>| rs", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-|\n      map_prod id pterm_to_sterm |`| {|(name, rhs)|})", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-|\n      map_prod id pterm_to_sterm |`| {|(name, rhs)|})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    ordered_fmap\n     (map_prod id pterm_to_sterm |`| rs |-| {|(name, pterm_to_sterm rhs)|})", "apply (subst ordered_fmap_remove)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. (name, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| rs\n 3. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (id x, pterm_to_sterm y)) |`| rs)\n 2. (name, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| rs\n 3. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "unfolding id_apply"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| rs)\n 2. (name, pterm_to_sterm rhs) |\\<in>|\n    map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs\n 3. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "apply (rule is_fmap_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_fmap rs\n 2. (name, pterm_to_sterm rhs) |\\<in>|\n    map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs\n 3. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (name, pterm_to_sterm rhs) |\\<in>|\n    map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs\n 2. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "using \\<open>(name, rhs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| rs\n\ngoal (2 subgoals):\n 1. (name, pterm_to_sterm rhs) |\\<in>|\n    map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs\n 2. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    remove1 (name, pterm_to_sterm rhs)\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "apply (subst \\<open>rhs' = pterm_to_sterm rhs\\<close>[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest =\n    remove1 (name, rhs')\n     (ordered_fmap (map_prod (\\<lambda>x. x) pterm_to_sterm |`| rs))", "apply (subst \\<open>ordered_fmap _ = _\\<close>[unfolded id_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rest = remove1 (name, rhs') ((name, rhs') # rest)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs;\n         rest = Rewriting_Sterm.compile (rs |-| {|(name, rhs)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule that) fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma compile_correct_step:\n  assumes \"srewrite_step (compile rs) name rhs\" \"is_fmap rs\" \"fBall rs prule\"\n  shows \"(name, sterm_to_pterm rhs) |\\<in>| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>| rs", "using assms"], ["proof (prove)\nusing this:\n  srewrite_step (Rewriting_Sterm.compile rs) name rhs\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>| rs", "proof (induction \"compile rs\" name rhs arbitrary: rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name rhs rest rs.\n       \\<lbrakk>(name, rhs) # rest = Rewriting_Sterm.compile rs; is_fmap rs;\n        fBall rs prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rs\n 2. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "case (cons_match name rhs' rest)"], ["proof (state)\nthis:\n  (name, rhs') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule\n\ngoal (2 subgoals):\n 1. \\<And>name rhs rest rs.\n       \\<lbrakk>(name, rhs) # rest = Rewriting_Sterm.compile rs; is_fmap rs;\n        fBall rs prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rs\n 2. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "then"], ["proof (chain)\npicking this:\n  (name, rhs') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule", "obtain rhs where \"rhs' = pterm_to_sterm rhs\" \"(name, rhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (name, rhs') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' = pterm_to_sterm rhs; (name, rhs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: compile_consE)"], ["proof (state)\nthis:\n  rhs' = pterm_to_sterm rhs\n  (name, rhs) |\\<in>| rs\n\ngoal (2 subgoals):\n 1. \\<And>name rhs rest rs.\n       \\<lbrakk>(name, rhs) # rest = Rewriting_Sterm.compile rs; is_fmap rs;\n        fBall rs prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rs\n 2. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs') |\\<in>| rs", "unfolding \\<open>rhs' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm (pterm_to_sterm rhs)) |\\<in>| rs", "apply (subst pterm_to_sterm_sterm_to_pterm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. (name, rhs) |\\<in>| rs", "using fbspec[OF \\<open>fBall rs prule\\<close> \\<open>(name, rhs) |\\<in>| rs\\<close>]"], ["proof (prove)\nusing this:\n  prule (name, rhs)\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. (name, rhs) |\\<in>| rs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs", "by fact"], ["proof (state)\nthis:\n  (name, sterm_to_pterm rhs') |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "case (cons_nomatch name name\\<^sub>1 rest rhs rhs\\<^sub>1')"], ["proof (state)\nthis:\n  name \\<noteq> name\\<^sub>1\n  srewrite_step rest name rhs\n  \\<lbrakk>rest = Rewriting_Sterm.compile ?rs; is_fmap ?rs;\n   fBall ?rs prule\\<rbrakk>\n  \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| ?rs\n  (name\\<^sub>1, rhs\\<^sub>1') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "then"], ["proof (chain)\npicking this:\n  name \\<noteq> name\\<^sub>1\n  srewrite_step rest name rhs\n  \\<lbrakk>rest = Rewriting_Sterm.compile ?rs; is_fmap ?rs;\n   fBall ?rs prule\\<rbrakk>\n  \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| ?rs\n  (name\\<^sub>1, rhs\\<^sub>1') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule", "obtain rhs\\<^sub>1 where \"rhs\\<^sub>1' = pterm_to_sterm rhs\\<^sub>1\" \"(name\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\" \"rest = compile (rs - {| (name\\<^sub>1, rhs\\<^sub>1) |})\""], ["proof (prove)\nusing this:\n  name \\<noteq> name\\<^sub>1\n  srewrite_step rest name rhs\n  \\<lbrakk>rest = Rewriting_Sterm.compile ?rs; is_fmap ?rs;\n   fBall ?rs prule\\<rbrakk>\n  \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| ?rs\n  (name\\<^sub>1, rhs\\<^sub>1') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1.\n        \\<lbrakk>rhs\\<^sub>1' = pterm_to_sterm rhs\\<^sub>1;\n         (name\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs;\n         rest =\n         Rewriting_Sterm.compile\n          (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: compile_consE)"], ["proof (state)\nthis:\n  rhs\\<^sub>1' = pterm_to_sterm rhs\\<^sub>1\n  (name\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  rest = Rewriting_Sterm.compile (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "let ?rs' = \"rs - {| (name\\<^sub>1, rhs\\<^sub>1) |}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "have \"(name, sterm_to_pterm rhs) |\\<in>| ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>|\n    rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}", "proof (intro cons_nomatch)"], ["proof (state)\ngoal (3 subgoals):\n 1. rest = Rewriting_Sterm.compile (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n 2. is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n 3. fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule", "show \"rest = compile ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rest = Rewriting_Sterm.compile (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})", "by fact"], ["proof (state)\nthis:\n  rest = Rewriting_Sterm.compile (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n\ngoal (2 subgoals):\n 1. is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n 2. fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule", "show \"is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})", "using \\<open>is_fmap rs\\<close>"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})", "by (rule is_fmap_subset) auto"], ["proof (state)\nthis:\n  is_fmap (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|})\n\ngoal (1 subgoal):\n 1. fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule", "show \"fBall ?rs' prule\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule", "using cons_nomatch"], ["proof (prove)\nusing this:\n  name \\<noteq> name\\<^sub>1\n  srewrite_step rest name rhs\n  \\<lbrakk>rest = Rewriting_Sterm.compile ?rs; is_fmap ?rs;\n   fBall ?rs prule\\<rbrakk>\n  \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| ?rs\n  (name\\<^sub>1, rhs\\<^sub>1') # rest = Rewriting_Sterm.compile rs\n  is_fmap rs\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule", "by blast"], ["proof (state)\nthis:\n  fBall (rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}) prule\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (name, sterm_to_pterm rhs) |\\<in>| rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}\n\ngoal (1 subgoal):\n 1. \\<And>name name' rs rhs rhs' rsa.\n       \\<lbrakk>name \\<noteq> name'; srewrite_step rs name rhs;\n        \\<And>rsa.\n           \\<lbrakk>rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n            fBall rsa prule\\<rbrakk>\n           \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa;\n        (name', rhs') # rs = Rewriting_Sterm.compile rsa; is_fmap rsa;\n        fBall rsa prule\\<rbrakk>\n       \\<Longrightarrow> (name, sterm_to_pterm rhs) |\\<in>| rsa", "thus ?case"], ["proof (prove)\nusing this:\n  (name, sterm_to_pterm rhs) |\\<in>| rs |-| {|(name\\<^sub>1, rhs\\<^sub>1)|}\n\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>| rs", "by simp"], ["proof (state)\nthis:\n  (name, sterm_to_pterm rhs) |\\<in>| rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compile_correct0:\n  assumes \"compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u'\" \"prules C rs\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow> sterm_to_pterm u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n    sterm_to_pterm u'", "using assms"], ["proof (prove)\nusing this:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u'\n  prules C rs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n    sterm_to_pterm u'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "case (beta cs t t')"], ["proof (state)\nthis:\n  rewrite_first cs t t'\n  prules C rs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "then"], ["proof (chain)\npicking this:\n  rewrite_first cs t t'\n  prules C rs", "obtain pat rhs env where \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\" \"t' = subst rhs env\""], ["proof (prove)\nusing this:\n  rewrite_first cs t t'\n  prules C rs\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs env.\n        \\<lbrakk>(pat, rhs) \\<in> set cs; match pat t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rewrite_firstE)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat t = Some env\n  t' = subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "then"], ["proof (chain)\npicking this:\n  (pat, rhs) \\<in> set cs\n  match pat t = Some env\n  t' = subst rhs env", "obtain env' where \"match pat (sterm_to_pterm t) = Some env'\" \"srelated.P_env env' env\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  match pat t = Some env\n  t' = subst rhs env\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match pat (sterm_to_pterm t) = Some env';\n         srelated.P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis option.distinct(1) option.inject option.rel_cases srelated.match_rel)"], ["proof (state)\nthis:\n  match pat (sterm_to_pterm t) = Some env'\n  srelated.P_env env' env\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "hence \"subst (sterm_to_pterm rhs) env' = sterm_to_pterm (subst rhs env)\""], ["proof (prove)\nusing this:\n  match pat (sterm_to_pterm t) = Some env'\n  srelated.P_env env' env\n\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm rhs) env' = sterm_to_pterm (subst rhs env)", "by (simp add: srelated_subst)"], ["proof (state)\nthis:\n  subst (sterm_to_pterm rhs) env' = sterm_to_pterm (subst rhs env)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "let ?rhs' = \"sterm_to_pterm rhs\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "have \"(pat, ?rhs') |\\<in>| fset_of_list (map (map_prod id sterm_to_pterm) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, sterm_to_pterm rhs) |\\<in>|\n    fset_of_list (map (map_prod id sterm_to_pterm) cs)", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. (pat, sterm_to_pterm rhs) |\\<in>|\n    fset_of_list (map (map_prod id sterm_to_pterm) cs)", "including fset.lifting"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. (pat, sterm_to_pterm rhs) |\\<in>|\n    fset_of_list (map (map_prod id sterm_to_pterm) cs)", "by transfer' force"], ["proof (state)\nthis:\n  (pat, sterm_to_pterm rhs) |\\<in>|\n  fset_of_list (map (map_prod id sterm_to_pterm) cs)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t'; prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm\n                          (Sabs cs $\\<^sub>s t) \\<longrightarrow>\n                         sterm_to_pterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p\n    sterm_to_pterm (Sabs cs $\\<^sub>s t) \\<longrightarrow> sterm_to_pterm t'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p\n    Pabs (fset_of_list (map (map_prod id sterm_to_pterm) cs)) $\\<^sub>p\n    sterm_to_pterm t \\<longrightarrow>\n    sterm_to_pterm t'", "apply (rule prewrite.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?c |\\<in>| fset_of_list (map (map_prod id sterm_to_pterm) cs)\n 2. ?c \\<turnstile> sterm_to_pterm t \\<rightarrow> sterm_to_pterm t'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, sterm_to_pterm rhs) \\<turnstile> sterm_to_pterm t \\<rightarrow>\n    sterm_to_pterm t'", "unfolding rewrite_step.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (subst (sterm_to_pterm rhs)) (match pat (sterm_to_pterm t)) =\n    Some (sterm_to_pterm t')", "apply (subst map_option_eq_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       match pat (sterm_to_pterm t) = Some z \\<and>\n       subst (sterm_to_pterm rhs) z = sterm_to_pterm t'", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat (sterm_to_pterm t) = Some ?z4\n 2. subst (sterm_to_pterm rhs) ?z4 = sterm_to_pterm t'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm rhs) env' = sterm_to_pterm t'", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm rhs) env' = sterm_to_pterm (subst rhs env)", "by fact"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>p\n  sterm_to_pterm (Sabs cs $\\<^sub>s t) \\<longrightarrow> sterm_to_pterm t'\n\ngoal (3 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "case (step name rhs)"], ["proof (state)\nthis:\n  srewrite_step (Rewriting_Sterm.compile rs) name rhs\n  prules C rs\n\ngoal (3 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "hence \"(name, sterm_to_pterm rhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  srewrite_step (Rewriting_Sterm.compile rs) name rhs\n  prules C rs\n\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>| rs", "unfolding prules_def prules_axioms_def"], ["proof (prove)\nusing this:\n  srewrite_step (Rewriting_Sterm.compile rs) name rhs\n  constants C (fst |`| rs) \\<and>\n  (fBall rs prule \\<and> is_fmap rs) \\<and>\n  fBall rs\n   (\\<lambda>(uu_, rhs).\n       \\<not> pre_constants.shadows_consts C (fst |`| rs) rhs) \\<and>\n  fBall rs\n   (\\<lambda>(uu_, rhs).\n       consts rhs |\\<subseteq>| pre_constants.all_consts C (fst |`| rs))\n\ngoal (1 subgoal):\n 1. (name, sterm_to_pterm rhs) |\\<in>| rs", "by (metis compile_correct_step)"], ["proof (state)\nthis:\n  (name, sterm_to_pterm rhs) |\\<in>| rs\n\ngoal (3 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step (Rewriting_Sterm.compile rs) name rhs;\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (Sconst name) \\<longrightarrow>\n                         sterm_to_pterm rhs\n 2. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "thus ?case"], ["proof (prove)\nusing this:\n  (name, sterm_to_pterm rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm (Sconst name) \\<longrightarrow>\n    sterm_to_pterm rhs", "by (auto intro: prewrite.intros)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>p sterm_to_pterm (Sconst name) \\<longrightarrow>\n  sterm_to_pterm rhs\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                t \\<longrightarrow> t';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm t \\<longrightarrow>\n        sterm_to_pterm t';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t' $\\<^sub>s u)\n 2. \\<And>u u' t.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow> u';\n        prules C rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n        sterm_to_pterm u';\n        prules C rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm (t $\\<^sub>s u) \\<longrightarrow>\n                         sterm_to_pterm (t $\\<^sub>s u')", "qed (auto intro: prewrite.intros)"], ["", "end"], ["", "lemma (in prules) compile_correct:\n  assumes \"compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u'\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow> sterm_to_pterm u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>\n    sterm_to_pterm u'", "by (rule compile_correct0) (fact | standard)+"], ["", "hide_fact compile_correct0"], ["", "subsubsection \\<open>Completeness of translation\\<close>"], ["", "global_interpretation srelated': term_struct_rel_strong \"(\\<lambda>p s. pterm_to_sterm p = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_struct_rel_strong (\\<lambda>p. (=) (pterm_to_sterm p))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t name.\n       pterm_to_sterm t = const name \\<Longrightarrow> t = const name\n 2. \\<And>name. pterm_to_sterm (const name) = const name\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n          pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 5. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "case (1 t name)"], ["proof (state)\nthis:\n  pterm_to_sterm t = const name\n\ngoal (6 subgoals):\n 1. \\<And>t name.\n       pterm_to_sterm t = const name \\<Longrightarrow> t = const name\n 2. \\<And>name. pterm_to_sterm (const name) = const name\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n          pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 5. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  pterm_to_sterm t = const name", "show ?case"], ["proof (prove)\nusing this:\n  pterm_to_sterm t = const name\n\ngoal (1 subgoal):\n 1. t = const name", "by (cases t) (auto simp: const_sterm_def const_pterm_def split: option.splits)"], ["proof (state)\nthis:\n  t = const name\n\ngoal (5 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = const name\n 2. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n          pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 4. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = const name\n 2. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n          pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 4. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "case (3 t u\\<^sub>1 u\\<^sub>2)"], ["proof (state)\nthis:\n  pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = const name\n 2. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n          pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 4. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  pterm_to_sterm t = app u\\<^sub>1 u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<^sub>1 t\\<^sub>2.\n       t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n       pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n       pterm_to_sterm t\\<^sub>2 = u\\<^sub>2", "by (cases t) (auto simp: app_sterm_def app_pterm_def split: option.splits)"], ["proof (state)\nthis:\n  \\<exists>t\\<^sub>1 t\\<^sub>2.\n     t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n     pterm_to_sterm t\\<^sub>1 = u\\<^sub>1 \\<and>\n     pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>name. pterm_to_sterm (const name) = const name\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>pterm_to_sterm t\\<^sub>1 = u\\<^sub>1;\n        pterm_to_sterm t\\<^sub>2 = u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app u\\<^sub>1 u\\<^sub>2\n 3. \\<And>name t.\n       pterm_to_sterm (const name) = t \\<Longrightarrow> t = const name\n 4. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       pterm_to_sterm (app u\\<^sub>1 u\\<^sub>2) = t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          pterm_to_sterm u\\<^sub>1 = t\\<^sub>1 \\<and>\n          pterm_to_sterm u\\<^sub>2 = t\\<^sub>2", "qed (auto simp: const_sterm_def const_pterm_def app_sterm_def app_pterm_def)"], ["", "corollary srelated_env_unique:\n  \"srelated'.P_env penv senv \\<Longrightarrow> srelated'.P_env penv senv' \\<Longrightarrow> senv = senv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>srelated'.P_env penv senv; srelated'.P_env penv senv'\\<rbrakk>\n    \\<Longrightarrow> senv = senv'", "apply (subst (asm) fmrel_iff)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                rel_option (\\<lambda>p. (=) (pterm_to_sterm p))\n                 (fmlookup penv x) (fmlookup senv x);\n     \\<forall>x.\n        rel_option (\\<lambda>p. (=) (pterm_to_sterm p)) (fmlookup penv x)\n         (fmlookup senv' x)\\<rbrakk>\n    \\<Longrightarrow> senv = senv'", "apply (subst (asm) option.rel_sel)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (fmlookup penv x = None) = (fmlookup senv x = None) \\<and>\n                (fmlookup penv x \\<noteq> None \\<longrightarrow>\n                 fmlookup senv x \\<noteq> None \\<longrightarrow>\n                 pterm_to_sterm (the (fmlookup penv x)) =\n                 the (fmlookup senv x));\n     \\<forall>x.\n        (fmlookup penv x = None) = (fmlookup senv' x = None) \\<and>\n        (fmlookup penv x \\<noteq> None \\<longrightarrow>\n         fmlookup senv' x \\<noteq> None \\<longrightarrow>\n         pterm_to_sterm (the (fmlookup penv x)) =\n         the (fmlookup senv' x))\\<rbrakk>\n    \\<Longrightarrow> senv = senv'", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (fmlookup penv x = None) =\n                   (fmlookup senv x = None) \\<and>\n                   (fmlookup penv x \\<noteq> None \\<longrightarrow>\n                    fmlookup senv x \\<noteq> None \\<longrightarrow>\n                    pterm_to_sterm (the (fmlookup penv x)) =\n                    the (fmlookup senv x));\n        \\<forall>x.\n           (fmlookup penv x = None) = (fmlookup senv' x = None) \\<and>\n           (fmlookup penv x \\<noteq> None \\<longrightarrow>\n            fmlookup senv' x \\<noteq> None \\<longrightarrow>\n            pterm_to_sterm (the (fmlookup penv x)) =\n            the (fmlookup senv' x))\\<rbrakk>\n       \\<Longrightarrow> fmlookup senv x = fmlookup senv' x", "by (metis option.exhaust_sel)"], ["", "lemma srelated_subst':\n  assumes \"srelated'.P_env penv senv\" \"wellformed t\"\n  shows \"pterm_to_sterm (subst t penv) = subst (pterm_to_sterm t) senv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (subst t penv) = subst (pterm_to_sterm t) senv", "using assms"], ["proof (prove)\nusing this:\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pterm_to_sterm (subst t penv) = subst (pterm_to_sterm t) senv", "proof (induction t arbitrary: penv senv)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pvar x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pvar x) penv) =\n                         subst (pterm_to_sterm (Pvar x)) senv\n 3. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 4. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "case (Pvar name)"], ["proof (state)\nthis:\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed (Pvar name)\n\ngoal (4 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pvar x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pvar x) penv) =\n                         subst (pterm_to_sterm (Pvar x)) senv\n 3. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 4. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "thus ?case"], ["proof (prove)\nusing this:\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed (Pvar name)\n\ngoal (1 subgoal):\n 1. pterm_to_sterm (subst (Pvar name) penv) =\n    subst (pterm_to_sterm (Pvar name)) senv", "by (cases rule: fmrel_cases[where x = name]) auto"], ["proof (state)\nthis:\n  pterm_to_sterm (subst (Pvar name) penv) =\n  subst (pterm_to_sterm (Pvar name)) senv\n\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "case (Pabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   srelated'.P_env ?penv ?senv;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> pterm_to_sterm (subst ?xaa ?penv) =\n                    subst (pterm_to_sterm ?xaa) ?senv\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "hence \"is_fmap cs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   srelated'.P_env ?penv ?senv;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> pterm_to_sterm (subst ?xaa ?penv) =\n                    subst (pterm_to_sterm ?xaa) ?senv\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (1 subgoal):\n 1. is_fmap cs", "by force"], ["proof (state)\nthis:\n  is_fmap cs\n\ngoal (3 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>x penv senv.\n       \\<lbrakk>\\<And>xa xaa penv senv.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed xaa\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst xaa penv) =\n                                     subst (pterm_to_sterm xaa) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pabs x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pabs x) penv) =\n                         subst (pterm_to_sterm (Pabs x)) senv\n 3. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pterm_to_sterm (subst (Pabs cs) penv) =\n    subst (pterm_to_sterm (Pabs cs)) senv", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap\n     ((map_prod id pterm_to_sterm \\<circ>\n       (\\<lambda>(pat, rhs).\n           (pat, subst rhs (fmdrop_fset (frees pat) penv)))) |`|\n      cs) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (ordered_fmap (map_prod id pterm_to_sterm |`| cs))", "unfolding map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap\n     (((\\<lambda>(x, y). (x, pterm_to_sterm y)) \\<circ>\n       (\\<lambda>(pat, rhs).\n           (pat, subst rhs (fmdrop_fset (frees pat) penv)))) |`|\n      cs) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))", "apply (subst ordered_fmap_image[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap cs\n 2. ordered_fmap\n     (((\\<lambda>(x, y). (x, pterm_to_sterm y)) \\<circ>\n       (\\<lambda>(pat, rhs).\n           (pat, subst rhs (fmdrop_fset (frees pat) penv)))) |`|\n      cs) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap\n     (((\\<lambda>(x, y). (x, pterm_to_sterm y)) \\<circ>\n       (\\<lambda>(pat, rhs).\n           (pat, subst rhs (fmdrop_fset (frees pat) penv)))) |`|\n      cs) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply (subst fset.map_comp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_fmap\n     ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`|\n      (\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) penv))) |`|\n      cs) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply (subst ordered_fmap_image[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) penv))) |`|\n      cs)\n 2. map (\\<lambda>(a, b). (a, pterm_to_sterm b))\n     (ordered_fmap\n       ((\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) penv))) |`|\n        cs)) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) penv))) |`|\n      cs)", "by (rule is_fmap_image) fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, pterm_to_sterm b))\n     (ordered_fmap\n       ((\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) penv))) |`|\n        cs)) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply (subst ordered_fmap_image[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap cs\n 2. map (\\<lambda>(a, b). (a, pterm_to_sterm b))\n     (map (\\<lambda>(a, b). (a, subst b (fmdrop_fset (frees a) penv)))\n       (ordered_fmap cs)) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b). (a, pterm_to_sterm b))\n     (map (\\<lambda>(a, b). (a, subst b (fmdrop_fset (frees a) penv)))\n       (ordered_fmap cs)) =\n    map (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) senv)))\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (ordered_fmap cs) \\<Longrightarrow>\n       pterm_to_sterm (subst b (fmdrop_fset (frees a) penv)) =\n       subst (pterm_to_sterm b) (fmdrop_fset (frees a) senv)", "apply (drule ordered_fmap_sound[OF \\<open>is_fmap cs\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       pterm_to_sterm (subst b (fmdrop_fset (frees a) penv)) =\n       subst (pterm_to_sterm b) (fmdrop_fset (frees a) senv)", "subgoal for pat rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pterm_to_sterm (subst rhs (fmdrop_fset (frees pat) penv)) =\n    subst (pterm_to_sterm rhs) (fmdrop_fset (frees pat) senv)", "apply (rule Pabs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (pat, rhs) |\\<in>| cs \\<Longrightarrow> ?xa \\<in> fset cs\n 2. (pat, rhs) |\\<in>| cs \\<Longrightarrow> rhs \\<in> Basic_BNFs.snds ?xa\n 3. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    srelated'.P_env (fmdrop_fset (frees pat) penv)\n     (fmdrop_fset (frees pat) senv)\n 4. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "apply (subst (asm) fmember.rep_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (pat, rhs) \\<in> fset cs \\<Longrightarrow> ?xa \\<in> fset cs\n 2. (pat, rhs) |\\<in>| cs \\<Longrightarrow> rhs \\<in> Basic_BNFs.snds ?xa\n 3. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    srelated'.P_env (fmdrop_fset (frees pat) penv)\n     (fmdrop_fset (frees pat) senv)\n 4. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    rhs \\<in> Basic_BNFs.snds (pat, rhs)\n 2. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    srelated'.P_env (fmdrop_fset (frees pat) penv)\n     (fmdrop_fset (frees pat) senv)\n 3. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    srelated'.P_env (fmdrop_fset (frees pat) penv)\n     (fmdrop_fset (frees pat) senv)\n 2. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "using Pabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   srelated'.P_env ?penv ?senv;\n   pre_strong_term_class.wellformed ?xaa\\<rbrakk>\n  \\<Longrightarrow> pterm_to_sterm (subst ?xaa ?penv) =\n                    subst (pterm_to_sterm ?xaa) ?senv\n  srelated'.P_env penv senv\n  pre_strong_term_class.wellformed (Pabs cs)\n\ngoal (2 subgoals):\n 1. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    srelated'.P_env (fmdrop_fset (frees pat) penv)\n     (fmdrop_fset (frees pat) senv)\n 2. (pat, rhs) |\\<in>| cs \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "by force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pterm_to_sterm (subst (Pabs cs) penv) =\n  subst (pterm_to_sterm (Pabs cs)) senv\n\ngoal (2 subgoals):\n 1. \\<And>x penv senv.\n       \\<lbrakk>srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (Pconst x)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (Pconst x) penv) =\n                         subst (pterm_to_sterm (Pconst x)) senv\n 2. \\<And>t1 t2 penv senv.\n       \\<lbrakk>\\<And>penv senv.\n                   \\<lbrakk>srelated'.P_env penv senv;\n                    pre_strong_term_class.wellformed t1\\<rbrakk>\n                   \\<Longrightarrow> pterm_to_sterm (subst t1 penv) =\n                                     subst (pterm_to_sterm t1) senv;\n        \\<And>penv senv.\n           \\<lbrakk>srelated'.P_env penv senv;\n            pre_strong_term_class.wellformed t2\\<rbrakk>\n           \\<Longrightarrow> pterm_to_sterm (subst t2 penv) =\n                             subst (pterm_to_sterm t2) senv;\n        srelated'.P_env penv senv;\n        pre_strong_term_class.wellformed (t1 $\\<^sub>p t2)\\<rbrakk>\n       \\<Longrightarrow> pterm_to_sterm (subst (t1 $\\<^sub>p t2) penv) =\n                         subst (pterm_to_sterm (t1 $\\<^sub>p t2)) senv", "qed auto"], ["", "lemma srelated_find_match:\n  assumes \"find_match cs t = Some (penv, pat, rhs)\" \"srelated'.P_env penv senv\"\n  shows \"find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) = Some (senv, pat, pterm_to_sterm rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "let ?cs' = \"map (map_prod id pterm_to_sterm) cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "let ?t' = \"pterm_to_sterm t\""], ["proof (state)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "have *: \"list_all2 (rel_prod (=) (\\<lambda>p s. pterm_to_sterm p = s)) cs ?cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod (=) (\\<lambda>p. (=) (pterm_to_sterm p))) cs\n     (map (map_prod id pterm_to_sterm) cs)", "unfolding list.rel_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x y.\n         rel_prod (=) (\\<lambda>p. (=) (pterm_to_sterm p)) x\n          (map_prod id pterm_to_sterm y))\n     cs cs", "by (auto intro: list.rel_refl)"], ["proof (state)\nthis:\n  list_all2 (rel_prod (=) (\\<lambda>p. (=) (pterm_to_sterm p))) cs\n   (map (map_prod id pterm_to_sterm) cs)\n\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "obtain senv0\n    where \"find_match ?cs' ?t' = Some (senv0, pat, pterm_to_sterm rhs)\" \"srelated'.P_env penv senv0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>senv0.\n        \\<lbrakk>find_match (map (map_prod id pterm_to_sterm) cs)\n                  (pterm_to_sterm t) =\n                 Some (senv0, pat, pterm_to_sterm rhs);\n         srelated'.P_env penv senv0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using srelated'.find_match_rel[OF * refl, where t = t, unfolded assms]"], ["proof (prove)\nusing this:\n  rel_option\n   (rel_prod srelated'.P_env\n     (rel_prod (=) (\\<lambda>p. (=) (pterm_to_sterm p))))\n   (Some (penv, pat, rhs))\n   (find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t))\n\ngoal (1 subgoal):\n 1. (\\<And>senv0.\n        \\<lbrakk>find_match (map (map_prod id pterm_to_sterm) cs)\n                  (pterm_to_sterm t) =\n                 Some (senv0, pat, pterm_to_sterm rhs);\n         srelated'.P_env penv senv0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding option_rel_Some1 rel_prod_conv"], ["proof (prove)\nusing this:\n  \\<exists>y'.\n     find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n     Some y' \\<and>\n     (case (penv, pat, rhs) of\n      (a, b) \\<Rightarrow>\n        \\<lambda>(c, d).\n           srelated'.P_env a c \\<and>\n           (case b of\n            (a, b) \\<Rightarrow>\n              \\<lambda>(c, d). a = c \\<and> pterm_to_sterm b = d)\n            d)\n      y'\n\ngoal (1 subgoal):\n 1. (\\<And>senv0.\n        \\<lbrakk>find_match (map (map_prod id pterm_to_sterm) cs)\n                  (pterm_to_sterm t) =\n                 Some (senv0, pat, pterm_to_sterm rhs);\n         srelated'.P_env penv senv0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n  Some (senv0, pat, pterm_to_sterm rhs)\n  srelated'.P_env penv senv0\n\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "with assms"], ["proof (chain)\npicking this:\n  find_match cs t = Some (penv, pat, rhs)\n  srelated'.P_env penv senv\n  find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n  Some (senv0, pat, pterm_to_sterm rhs)\n  srelated'.P_env penv senv0", "have \"senv = senv0\""], ["proof (prove)\nusing this:\n  find_match cs t = Some (penv, pat, rhs)\n  srelated'.P_env penv senv\n  find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n  Some (senv0, pat, pterm_to_sterm rhs)\n  srelated'.P_env penv senv0\n\ngoal (1 subgoal):\n 1. senv = senv0", "by (metis srelated_env_unique)"], ["proof (state)\nthis:\n  senv = senv0\n\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv, pat, pterm_to_sterm rhs)", "unfolding \\<open>senv = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n    Some (senv0, pat, pterm_to_sterm rhs)", "by fact"], ["proof (state)\nthis:\n  find_match (map (map_prod id pterm_to_sterm) cs) (pterm_to_sterm t) =\n  Some (senv, pat, pterm_to_sterm rhs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in prules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"wellformed t\"\n  shows \"compile rs \\<turnstile>\\<^sub>s pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>(name, rhs) |\\<in>| rs;\n        pre_strong_term_class.wellformed (Pconst name)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (Pconst name) \\<longrightarrow>\n                         pterm_to_sterm rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "case (step name rhs)"], ["proof (state)\nthis:\n  (name, rhs) |\\<in>| rs\n  pre_strong_term_class.wellformed (Pconst name)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>(name, rhs) |\\<in>| rs;\n        pre_strong_term_class.wellformed (Pconst name)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (Pconst name) \\<longrightarrow>\n                         pterm_to_sterm rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "then"], ["proof (chain)\npicking this:\n  (name, rhs) |\\<in>| rs\n  pre_strong_term_class.wellformed (Pconst name)", "show ?case"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| rs\n  pre_strong_term_class.wellformed (Pconst name)\n\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    pterm_to_sterm (Pconst name) \\<longrightarrow> pterm_to_sterm rhs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    Sconst name \\<longrightarrow> pterm_to_sterm rhs", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    srewrite_step (Rewriting_Sterm.compile rs) name (pterm_to_sterm rhs)", "apply (rule prules_as_srules.srewrite_stepI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    (name, pterm_to_sterm rhs) \\<in> set (Rewriting_Sterm.compile rs)", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    (name, pterm_to_sterm rhs)\n    \\<in> set (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "apply (subst fset_of_list_elem[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    (name, pterm_to_sterm rhs) |\\<in>|\n    fset_of_list (ordered_fmap (map_prod id pterm_to_sterm |`| rs))", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. (name, rhs) |\\<in>| rs \\<Longrightarrow>\n    (name, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| rs", "apply (insert fmap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(name, rhs) |\\<in>| rs; is_fmap rs\\<rbrakk>\n    \\<Longrightarrow> is_fmap (map_prod id pterm_to_sterm |`| rs)\n 2. \\<lbrakk>(name, rhs) |\\<in>| rs; is_fmap rs\\<rbrakk>\n    \\<Longrightarrow> (name, pterm_to_sterm rhs) |\\<in>|\n                      map_prod id pterm_to_sterm |`| rs", "apply (rule is_fmapI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(name, rhs) |\\<in>| rs; is_fmap rs;\n        (a, b\\<^sub>1) |\\<in>| map_prod id pterm_to_sterm |`| rs;\n        (a, b\\<^sub>2) |\\<in>| map_prod id pterm_to_sterm |`| rs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2\n 2. \\<lbrakk>(name, rhs) |\\<in>| rs; is_fmap rs\\<rbrakk>\n    \\<Longrightarrow> (name, pterm_to_sterm rhs) |\\<in>|\n                      map_prod id pterm_to_sterm |`| rs", "apply (force dest: is_fmapD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(name, rhs) |\\<in>| rs; is_fmap rs\\<rbrakk>\n    \\<Longrightarrow> (name, pterm_to_sterm rhs) |\\<in>|\n                      map_prod id pterm_to_sterm |`| rs", "by (simp add: rev_fimage_eqI)"], ["proof (state)\nthis:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n  pterm_to_sterm (Pconst name) \\<longrightarrow> pterm_to_sterm rhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "case (beta c cs t t')"], ["proof (state)\nthis:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "from beta"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)", "obtain pat rhs penv where \"c = (pat, rhs)\" \"match pat t = Some penv\" \"subst rhs penv = t'\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs penv.\n        \\<lbrakk>c = (pat, rhs); match pat t = Some penv;\n         subst rhs penv = t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) map_option_eq_Some rewrite_step.simps surj_pair)"], ["proof (state)\nthis:\n  c = (pat, rhs)\n  match pat t = Some penv\n  subst rhs penv = t'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "then"], ["proof (chain)\npicking this:\n  c = (pat, rhs)\n  match pat t = Some penv\n  subst rhs penv = t'", "obtain senv where \"match pat (pterm_to_sterm t) = Some senv\" \"srelated'.P_env penv senv\""], ["proof (prove)\nusing this:\n  c = (pat, rhs)\n  match pat t = Some penv\n  subst rhs penv = t'\n\ngoal (1 subgoal):\n 1. (\\<And>senv.\n        \\<lbrakk>match pat (pterm_to_sterm t) = Some senv;\n         srelated'.P_env penv senv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis option_rel_Some1 srelated'.match_rel)"], ["proof (state)\nthis:\n  match pat (pterm_to_sterm t) = Some senv\n  srelated'.P_env penv senv\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "have \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using beta \\<open>c = _\\<close> prules.all_rules prule.simps"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n  c = (pat, rhs)\n  prules ?C_info ?rs \\<Longrightarrow> fBall ?rs prule\n  prule (?uu, ?rhs) =\n  (pre_strong_term_class.wellformed ?rhs \\<and>\n   closed ?rhs \\<and> is_abs ?rhs)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by force"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "then"], ["proof (chain)\npicking this:\n  pre_strong_term_class.wellformed rhs", "have \"subst (pterm_to_sterm rhs) senv = pterm_to_sterm t'\""], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. subst (pterm_to_sterm rhs) senv = pterm_to_sterm t'", "using srelated_subst' \\<open>_ = t'\\<close> \\<open>srelated'.P_env _ _\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed rhs\n  \\<lbrakk>srelated'.P_env ?penv ?senv;\n   pre_strong_term_class.wellformed ?t\\<rbrakk>\n  \\<Longrightarrow> pterm_to_sterm (subst ?t ?penv) =\n                    subst (pterm_to_sterm ?t) ?senv\n  subst rhs penv = t'\n  srelated'.P_env penv senv\n\ngoal (1 subgoal):\n 1. subst (pterm_to_sterm rhs) senv = pterm_to_sterm t'", "by metis"], ["proof (state)\nthis:\n  subst (pterm_to_sterm rhs) senv = pterm_to_sterm t'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "have \"(pat, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| cs", "using beta \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. (pat, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| cs", "by (metis fimage_eqI id_def map_prod_simp)"], ["proof (state)\nthis:\n  (pat, pterm_to_sterm rhs) |\\<in>| map_prod id pterm_to_sterm |`| cs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "have \"is_fmap cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "using beta"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. is_fmap cs", "by auto"], ["proof (state)\nthis:\n  is_fmap cs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "have \"find_match (ordered_fmap cs) t = Some (penv, pat, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (ordered_fmap cs) t = Some (penv, pat, rhs)", "apply (rule compatible_find_match)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pattern_compatibles (fset_of_list (ordered_fmap cs))\n 2. list_all (linear \\<circ> fst) (ordered_fmap cs)\n 3. is_fmap (fset_of_list (ordered_fmap cs))\n 4. match pat t = Some penv\n 5. (pat, rhs) \\<in> set (ordered_fmap cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern_compatibles (fset_of_list (ordered_fmap cs))", "apply (subst ordered_fmap_set_eq[OF \\<open>is_fmap cs\\<close>])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern_compatibles cs", "using beta"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. pattern_compatibles cs", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_all (linear \\<circ> fst) (ordered_fmap cs)\n 2. is_fmap (fset_of_list (ordered_fmap cs))\n 3. match pat t = Some penv\n 4. (pat, rhs) \\<in> set (ordered_fmap cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (linear \\<circ> fst) (ordered_fmap cs)", "unfolding list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (ordered_fmap cs)) (linear \\<circ> fst)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (ordered_fmap cs) \\<Longrightarrow>\n       (linear \\<circ> fst) x", "apply (rename_tac x, case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x \\<in> set (ordered_fmap cs); x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (linear \\<circ> fst) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>(a, b) \\<in> set (ordered_fmap cs); x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> linear a", "apply (drule ordered_fmap_sound[OF \\<open>is_fmap cs\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x = (a, b); (a, b) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> linear a", "using beta"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>x = (a, b); (a, b) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> linear a", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_fmap (fset_of_list (ordered_fmap cs))\n 2. match pat t = Some penv\n 3. (pat, rhs) \\<in> set (ordered_fmap cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap (fset_of_list (ordered_fmap cs))", "apply (subst ordered_fmap_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat t = Some penv\n 2. (pat, rhs) \\<in> set (ordered_fmap cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. match pat t = Some penv", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set (ordered_fmap cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set (ordered_fmap cs)", "using beta(1) \\<open>c = _\\<close> \\<open>is_fmap cs\\<close>"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c = (pat, rhs)\n  is_fmap cs\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set (ordered_fmap cs)", "using fset_of_list_elem ordered_fmap_set_eq"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c = (pat, rhs)\n  is_fmap cs\n  (?x |\\<in>| fset_of_list ?xs) = (?x \\<in> set ?xs)\n  is_fmap ?S \\<Longrightarrow> fset_of_list (ordered_fmap ?S) = ?S\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set (ordered_fmap cs)", "by fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_match (ordered_fmap cs) t = Some (penv, pat, rhs)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_strong_term_class.wellformed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm\n                          (Pabs cs $\\<^sub>p t) \\<longrightarrow>\n                         pterm_to_sterm t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    pterm_to_sterm (Pabs cs $\\<^sub>p t) \\<longrightarrow> pterm_to_sterm t'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n    Sabs (ordered_fmap (map_prod id pterm_to_sterm |`| cs)) $\\<^sub>s\n    pterm_to_sterm t \\<longrightarrow>\n    pterm_to_sterm t'", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. rewrite_first (ordered_fmap (map_prod id pterm_to_sterm |`| cs))\n     (pterm_to_sterm t) (pterm_to_sterm t')", "apply (subst \\<open>_ = pterm_to_sterm t'\\<close>[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rewrite_first (ordered_fmap (map_prod id pterm_to_sterm |`| cs))\n     (pterm_to_sterm t) (subst (pterm_to_sterm rhs) senv)", "apply (rule find_match_rewrite_first)"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (ordered_fmap (map_prod id pterm_to_sterm |`| cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "unfolding map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match\n     (ordered_fmap ((\\<lambda>(x, y). (x, pterm_to_sterm y)) |`| cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "apply (subst ordered_fmap_image[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_fmap cs\n 2. find_match\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match\n     (map (\\<lambda>(a, b). (a, pterm_to_sterm b)) (ordered_fmap cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "apply (subst map_prod_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match\n     (map (map_prod (\\<lambda>a. a) pterm_to_sterm) (ordered_fmap cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "apply (subst id_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (map (map_prod id pterm_to_sterm) (ordered_fmap cs))\n     (pterm_to_sterm t) =\n    Some (senv, ?pat2, pterm_to_sterm rhs)", "apply (rule srelated_find_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. find_match (ordered_fmap cs) t = Some (?penv8, ?pat2, rhs)\n 2. srelated'.P_env ?penv8 senv", "by fact+"], ["proof (state)\nthis:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n  pterm_to_sterm (Pabs cs $\\<^sub>p t) \\<longrightarrow> pterm_to_sterm t'\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm t \\<longrightarrow> pterm_to_sterm t';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t' $\\<^sub>p u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n        pterm_to_sterm u \\<longrightarrow> pterm_to_sterm u';\n        pre_strong_term_class.wellformed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                         pterm_to_sterm (t $\\<^sub>p u) \\<longrightarrow>\n                         pterm_to_sterm (t $\\<^sub>p u')", "qed (auto intro: srewrite.intros)"], ["", "subsubsection \\<open>Computability\\<close>"], ["", "export_code compile\n  checking Scala"], ["", "end"]]}