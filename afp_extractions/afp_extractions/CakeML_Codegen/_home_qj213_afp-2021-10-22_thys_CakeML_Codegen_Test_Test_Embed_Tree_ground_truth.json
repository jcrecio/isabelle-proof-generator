{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Test/Test_Embed_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma nat_diff_abs_int[simp]: \"nat_diff x y = nat (abs (int x - int y))\"", "lemma [code]:\n  \"wbalanced Leaf = True\"\n  \"wbalanced (Node l x r) = (nat_diff (size l) (size r) \\<le> 1 \\<and> wbalanced l \\<and> wbalanced r)\"", "lemma [code_unfold]: \"(\\<forall>x \\<in> set_tree l. P x) \\<longleftrightarrow> list_all P (inorder l)\"", "lemma [code]:\n  \"heap Leaf = True\"\n  \"heap (Node l m r) = (heap l \\<and> heap r \\<and> (\\<forall>x \\<in> set_tree l. m \\<le> x) \\<and> (\\<forall>x \\<in> set_tree r. m \\<le> x))\""], "translations": [["", "lemma nat_diff_abs_int[simp]: \"nat_diff x y = nat (abs (int x - int y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_diff x y = nat \\<bar>int x - int y\\<bar>", "unfolding nat_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y then y - x else x - y) = nat \\<bar>int x - int y\\<bar>", "by auto"], ["", "lemma [code]:\n  \"wbalanced Leaf = True\"\n  \"wbalanced (Node l x r) = (nat_diff (size l) (size r) \\<le> 1 \\<and> wbalanced l \\<and> wbalanced r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wbalanced \\<langle>\\<rangle> = True &&&\n    wbalanced \\<langle>l, x, r\\<rangle> =\n    (nat_diff (size l) (size r) \\<le> 1 \\<and>\n     wbalanced l \\<and> wbalanced r)", "by auto"], ["", "text \\<open>Sets are also unsupported, so we have to rewrite @{const set_tree} to use @{const inorder}.\\<close>"], ["", "lemma [code_unfold]: \"(\\<forall>x \\<in> set_tree l. P x) \\<longleftrightarrow> list_all P (inorder l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set_tree l. P x) = list_all P (inorder l)", "by (induction l) auto"], ["", "lemma [code]:\n  \"heap Leaf = True\"\n  \"heap (Node l m r) = (heap l \\<and> heap r \\<and> (\\<forall>x \\<in> set_tree l. m \\<le> x) \\<and> (\\<forall>x \\<in> set_tree r. m \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap \\<langle>\\<rangle> = True &&&\n    heap \\<langle>l, m, r\\<rangle> =\n    (heap l \\<and>\n     heap r \\<and>\n     (\\<forall>x\\<in>set_tree l. m \\<le> x) \\<and>\n     (\\<forall>x\\<in>set_tree r. m \\<le> x))", "by auto"], ["", "text \\<open>@{term \"(-)\"} on @{typ nat} is not pattern compatible\\<close>"], ["", "declassify valid: wbalanced ipl preorder inorder postorder bst_wrt heap"], ["", "thm valid"], ["", "experiment begin"], ["", "code_thms Tree_wbalanced"], ["", "(* FIXME bogus error message when using the non-dict-eliminated constant *)"], ["", "embed (eval) test1 is Tree_wbalanced"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "experiment begin"], ["", "code_thms Tree_ipl Tree_preorder Tree_inorder Tree_postorder"], ["", "embed (eval) test2 is Tree_ipl Tree_preorder Tree_inorder Tree_postorder"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "(* FIXME auto-derive these things? *)"], ["", "derive evaluate\n  Orderings_ord__dict\n  Orderings_preorder__dict\n  Orderings_order__dict\n  Orderings_linorder__dict"], ["", "experiment begin"], ["", "code_thms Tree_bst__wrt Tree_linorder__class_heap"], ["", "embed (eval) test3 is Tree_bst__wrt Tree_linorder__class_heap"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"]]}