{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Terms/Value.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemmas vmatch_induct = vmatch.induct[case_names var constr]", "lemma pred_alt_def[simp, code]:\n  \"pred (Vconstr name vs) \\<longleftrightarrow> Q name \\<and> list_all pred vs\"\n  \"pred (Vabs cs \\<Gamma>) \\<longleftrightarrow> fmpred (\\<lambda>_. pred) \\<Gamma> \\<and> P \\<Gamma> cs\"\n  \"pred (Vrecabs css name \\<Gamma>) \\<longleftrightarrow> fmpred (\\<lambda>_. pred) \\<Gamma> \\<and> pred_fmap (P \\<Gamma>) css \\<and> name |\\<in>| fmdom css \\<and> R (fmdom css)\"", "lemma vmatch_env:\n  assumes \"vmatch pat v = Some env\" \"pred v\"\n  shows \"fmpred (\\<lambda>_. pred) env\"", "lemmas vwelldefined_alt_def = vwelldefined.pred_alt_def", "lemmas vconstructor_value_alt_def = vconstructor_value.pred_alt_def", "lemmas not_shadows_vconsts_alt_def = not_shadows_vconsts.pred_alt_def", "lemma (in constructors) term_to_value_to_sterm:\n  assumes \"is_value t\"\n  shows \"value_to_sterm (term_to_value t) = t\"", "lemma vmatch_dom:\n  assumes \"vmatch pat v = Some env\"\n  shows \"fmdom env = patvars pat\"", "lemma vfind_match_elem:\n  assumes \"vfind_match cs t = Some (env, pat, rhs)\"\n  shows \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) t = Some env\"", "lemma veq_structure_simps[code, simp]:\n  \"veq_structure (Vabs cs\\<^sub>1 \\<Gamma>\\<^sub>1) (Vabs cs\\<^sub>2 \\<Gamma>\\<^sub>2)\"\n  \"veq_structure (Vrecabs css\\<^sub>1 name\\<^sub>1 \\<Gamma>\\<^sub>1) (Vrecabs css\\<^sub>2 name\\<^sub>2 \\<Gamma>\\<^sub>2)\"\n  \"veq_structure (Vconstr name\\<^sub>1 ts) (Vconstr name\\<^sub>2 us) \\<longleftrightarrow> name\\<^sub>1 = name\\<^sub>2 \\<and> list_all2 veq_structure ts us\"", "lemma veq_structure_refl[simp]: \"veq_structure t t\"", "lemma veq_structure_eq_left:\n  assumes \"veq_structure t u\" \"vno_abs t\"\n  shows \"t = u\"", "lemma veq_structure_eq_right:\n  assumes \"veq_structure t u\" \"vno_abs u\"\n  shows \"t = u\"", "lemma vmatch_vmatch'_eq: \"vmatch p v = vmatch' p v\"", "lemma eq_left: \"Q t u \\<Longrightarrow> vno_abs t \\<Longrightarrow> t = u\"", "lemma eq_right: \"Q t u \\<Longrightarrow> vno_abs u \\<Longrightarrow> t = u\"", "lemma vmatch'_rel:\n  assumes \"Q t\\<^sub>1 t\\<^sub>2\"\n  shows \"rel_option (fmrel Q) (vmatch' p t\\<^sub>1) (vmatch' p t\\<^sub>2)\"", "lemma vmatch_rel: \"Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow> rel_option (fmrel Q) (vmatch p t\\<^sub>1) (vmatch p t\\<^sub>2)\"", "lemma vfind_match_rel:\n  assumes \"list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\"\n  assumes \"Q t\\<^sub>1 t\\<^sub>2\"\n  shows \"rel_option (rel_prod (fmrel Q) (rel_prod (=) R)) (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\"", "lemmas vfind_match_rel' =\n  vfind_match_rel[\n    where R = \"(=)\" and cs\\<^sub>1 = cs and cs\\<^sub>2 = cs for cs,\n    unfolded prod.rel_eq,\n    OF list.rel_refl, OF refl]", "lemma env_eq_eq:\n  assumes \"env_eq venv senv\"\n  shows \"senv = fmmap value_to_sterm venv\"", "lemma vmatch_eq0: \"rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))\"", "lemma (in constructors) find_match_eq:\n  assumes \"list_all (linear \\<circ> fst) cs\" \"vconstructor_value v\"\n  shows \"rel_option match_related (vfind_match cs v) (find_match cs (value_to_sterm v))\"", "lemma erelated_refl[intro]: \"t \\<approx>\\<^sub>e t\""], "translations": [["", "lemmas vmatch_induct = vmatch.induct[case_names var constr]"], ["", "locale value_pred =\n  fixes P :: \"(name, value) fmap \\<Rightarrow> sclauses \\<Rightarrow> bool\"\n  fixes Q :: \"name \\<Rightarrow> bool\"\n  fixes R :: \"name fset \\<Rightarrow> bool\"\nbegin"], ["", "primrec pred :: \"value \\<Rightarrow> bool\" where\n\"pred (Vconstr name vs) \\<longleftrightarrow> Q name \\<and> list_all id (map pred vs)\" |\n\"pred (Vabs cs \\<Gamma>) \\<longleftrightarrow> pred_fmap id (fmmap pred \\<Gamma>) \\<and> P \\<Gamma> cs\" |\n\"pred (Vrecabs css name \\<Gamma>) \\<longleftrightarrow>\n    pred_fmap id (fmmap pred \\<Gamma>) \\<and>\n    pred_fmap (P \\<Gamma>) css \\<and>\n    name |\\<in>| fmdom css \\<and>\n    R (fmdom css)\""], ["", "declare pred.simps[simp del]"], ["", "lemma pred_alt_def[simp, code]:\n  \"pred (Vconstr name vs) \\<longleftrightarrow> Q name \\<and> list_all pred vs\"\n  \"pred (Vabs cs \\<Gamma>) \\<longleftrightarrow> fmpred (\\<lambda>_. pred) \\<Gamma> \\<and> P \\<Gamma> cs\"\n  \"pred (Vrecabs css name \\<Gamma>) \\<longleftrightarrow> fmpred (\\<lambda>_. pred) \\<Gamma> \\<and> pred_fmap (P \\<Gamma>) css \\<and> name |\\<in>| fmdom css \\<and> R (fmdom css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred (Vconstr name vs) = (Q name \\<and> list_all pred vs) &&&\n    pred (Vabs cs \\<Gamma>) =\n    (fmpred (\\<lambda>_. pred) \\<Gamma> \\<and> P \\<Gamma> cs) &&&\n    pred (Vrecabs css name \\<Gamma>) =\n    (fmpred (\\<lambda>_. pred) \\<Gamma> \\<and>\n     pred_fmap (P \\<Gamma>) css \\<and>\n     name |\\<in>| fmdom css \\<and> R (fmdom css))", "by (auto simp: list_all_iff pred.simps)"], ["", "text \\<open>\n  For technical reasons, we don't introduce an abbreviation for @{prop \\<open>fmpred (\\<lambda>_. pred) env\\<close>}\n  here. This locale is supposed to be interpreted with @{command global_interpretation} (or\n  @{command sublocale} and a @{theory_text \\<open>defines\\<close>} clause. However, this does not affect\n  abbreviations: the abbreviation would still refer to the locale constant, not the constant\n  introduced by the interpretation.\n\\<close>"], ["", "lemma vmatch_env:\n  assumes \"vmatch pat v = Some env\" \"pred v\"\n  shows \"fmpred (\\<lambda>_. pred) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "using assms"], ["proof (prove)\nusing this:\n  vmatch pat v = Some env\n  pred v\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "proof (induction pat v arbitrary: env rule: vmatch_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "case (constr name ps name' vs)"], ["proof (state)\nthis:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env; pred ?y\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n  pred (Vconstr name' vs)\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "hence\n    \"map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch ps vs)) = Some env\"\n    \"name = name'\" \"length ps = length vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env; pred ?y\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n  pred (Vconstr name' vs)\n\ngoal (1 subgoal):\n 1. map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps vs)) =\n    Some env &&&\n    name = name' &&& length ps = length vs", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "then"], ["proof (chain)\npicking this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs", "obtain envs where \"env = foldl (++\\<^sub>f) fmempty envs\" \"map2 vmatch ps vs = map Some envs\""], ["proof (prove)\nusing this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>envs.\n        \\<lbrakk>env = foldl (++\\<^sub>f) fmempty envs;\n         Term_Utils.map2 vmatch ps vs = map Some envs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: those_someD)"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "moreover"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "have \"fmpred (\\<lambda>_. pred) env\" if \"env \\<in> set envs\" for env"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "from that"], ["proof (chain)\npicking this:\n  env \\<in> set envs", "have \"Some env \\<in> set (map2 vmatch ps vs)\""], ["proof (prove)\nusing this:\n  env \\<in> set envs\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "unfolding \\<open>map2 _ _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  env \\<in> set envs\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (map Some envs)", "by simp"], ["proof (state)\nthis:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "then"], ["proof (chain)\npicking this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "obtain p v where \"p \\<in> set ps\" \"v \\<in> set vs\" \"vmatch p v = Some env\""], ["proof (prove)\nusing this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>p \\<in> set ps; v \\<in> set vs;\n         vmatch p v = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule map2_elemE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>p \\<in> set ps; v \\<in> set vs;\n                    vmatch p v = Some env\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        x \\<in> set ps; y \\<in> set vs; Some env = vmatch x y\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "hence \"pred v\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. pred v", "using constr"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env; pred ?y\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some enva__\n  pred (Vconstr name' vs)\n\ngoal (1 subgoal):\n 1. pred v", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  pred v\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "by (rule constr; safe?) fact+"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. pred) env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?env \\<in> set envs \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    pred y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. pred) env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        pred (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "ultimately"], ["proof (chain)\npicking this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  ?env \\<in> set envs \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env", "show ?case"], ["proof (prove)\nusing this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  ?env \\<in> set envs \\<Longrightarrow> fmpred (\\<lambda>_. pred) ?env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pred) env", "by auto"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. pred) env\n\ngoal (3 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; pred v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 2. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        pred (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env\n 3. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        pred (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. pred) env", "qed auto"], ["", "end"], ["", "primrec value_to_sterm :: \"value \\<Rightarrow> sterm\" where\n\"value_to_sterm (Vconstr name vs) = name $$ map value_to_sterm vs\" |\n\"value_to_sterm (Vabs cs \\<Gamma>) = Sabs (map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))) cs)\" |\n\"value_to_sterm (Vrecabs css name \\<Gamma>) =\n  Sabs (map (\\<lambda>(pat, t). (pat, subst t (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))) (the (fmlookup css name)))\""], ["", "text \\<open>\n  This locale establishes a connection between a predicate on @{typ value}s with the corresponding\n  predicate on @{typ sterm}s, by means of @{const value_to_sterm}.\n\\<close>"], ["", "locale pre_value_sterm_pred = value_pred +\n  fixes S\n  assumes value_to_sterm: \"pred v \\<Longrightarrow> S (value_to_sterm v)\"\nbegin"], ["", "corollary value_to_sterm_env:\n  assumes \"fmpred (\\<lambda>_. pred) \\<Gamma>\"\n  shows \"fmpred (\\<lambda>_. S) (fmmap value_to_sterm \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. S) (fmmap value_to_sterm \\<Gamma>)", "unfolding fmpred_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>k v. S (value_to_sterm v)) \\<Gamma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup \\<Gamma> x = Some y \\<Longrightarrow> S (value_to_sterm y)", "fix name v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup \\<Gamma> x = Some y \\<Longrightarrow> S (value_to_sterm y)", "assume \"fmlookup \\<Gamma> name = Some v\""], ["proof (state)\nthis:\n  fmlookup \\<Gamma> name = Some v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup \\<Gamma> x = Some y \\<Longrightarrow> S (value_to_sterm y)", "with assms"], ["proof (chain)\npicking this:\n  fmpred (\\<lambda>_. pred) \\<Gamma>\n  fmlookup \\<Gamma> name = Some v", "have \"pred v\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. pred) \\<Gamma>\n  fmlookup \\<Gamma> name = Some v\n\ngoal (1 subgoal):\n 1. pred v", "by (metis fmpredD)"], ["proof (state)\nthis:\n  pred v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup \\<Gamma> x = Some y \\<Longrightarrow> S (value_to_sterm y)", "thus \"S (value_to_sterm v)\""], ["proof (prove)\nusing this:\n  pred v\n\ngoal (1 subgoal):\n 1. S (value_to_sterm v)", "by (rule value_to_sterm)"], ["proof (state)\nthis:\n  S (value_to_sterm v)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale value_sterm_pred = value_pred + S: simple_syntactic_and S for S +\n  assumes const: \"\\<And>name. Q name \\<Longrightarrow> S (const name)\"\n  assumes abs: \"\\<And>\\<Gamma> cs.\n    (\\<And>n v. fmlookup \\<Gamma> n = Some v \\<Longrightarrow> pred v \\<Longrightarrow> S (value_to_sterm v)) \\<Longrightarrow>\n    fmpred (\\<lambda>_. pred) \\<Gamma> \\<Longrightarrow>\n    P \\<Gamma> cs \\<Longrightarrow>\n    S (Sabs (map (\\<lambda>(pat, t). (pat, subst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))) cs))\"\nbegin"], ["", "sublocale pre_value_sterm_pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_value_sterm_pred P Q R S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. pred v \\<Longrightarrow> S (value_to_sterm v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. pred v \\<Longrightarrow> S (value_to_sterm v)", "assume \"pred v\""], ["proof (state)\nthis:\n  pred v\n\ngoal (1 subgoal):\n 1. \\<And>v. pred v \\<Longrightarrow> S (value_to_sterm v)", "then"], ["proof (chain)\npicking this:\n  pred v", "show \"S (value_to_sterm v)\""], ["proof (prove)\nusing this:\n  pred v\n\ngoal (1 subgoal):\n 1. S (value_to_sterm v)", "proof (induction v)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vconstr x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vconstr x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vabs x1 x2))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "case (Vconstr x1 x2)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set x2; pred ?x2a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x2a)\n  pred (Vconstr x1 x2)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vconstr x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vconstr x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vabs x1 x2))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (value_to_sterm (Vconstr x1 x2))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (x1 $$ map value_to_sterm x2)", "unfolding S.list_comb"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (const x1) \\<and> list_all S (map value_to_sterm x2)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. S (const x1)\n 2. list_all S (map value_to_sterm x2)", "apply (rule const)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q x1\n 2. list_all S (map value_to_sterm x2)", "using Vconstr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set x2; pred ?x2a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x2a)\n  pred (Vconstr x1 x2)\n\ngoal (2 subgoals):\n 1. Q x1\n 2. list_all S (map value_to_sterm x2)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  S (value_to_sterm (Vconstr x1 x2))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vabs x1 x2))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vabs x1 x2))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "case (Vabs x1 x2)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> fmran' x2; pred ?x2a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x2a)\n  pred (Vabs x1 x2)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2; pred x2a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x2a);\n        pred (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vabs x1 x2))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (value_to_sterm (Vabs x1 x2))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (Sabs\n        (map (\\<lambda>(pat, t).\n                 (pat,\n                  subst t\n                   (fmmap value_to_sterm (fmdrop_fset (frees pat) x2))))\n          x1))", "apply (rule abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n v.\n       \\<lbrakk>fmlookup x2 n = Some v; pred v\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm v)\n 2. fmpred (\\<lambda>_. pred) x2\n 3. P x2 x1", "using Vabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> fmran' x2; pred ?x2a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x2a)\n  pred (Vabs x1 x2)\n\ngoal (3 subgoals):\n 1. \\<And>n v.\n       \\<lbrakk>fmlookup x2 n = Some v; pred v\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm v)\n 2. fmpred (\\<lambda>_. pred) x2\n 3. P x2 x1", "by (auto intro: fmran'I)"], ["proof (state)\nthis:\n  S (value_to_sterm (Vabs x1 x2))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "case (Vrecabs x1 x2 x3)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3a \\<in> fmran' x3; pred ?x3a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x3a)\n  pred (Vrecabs x1 x2 x3)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3; pred x3a\\<rbrakk>\n                   \\<Longrightarrow> S (value_to_sterm x3a);\n        pred (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm (Vrecabs x1 x2 x3))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (value_to_sterm (Vrecabs x1 x2 x3))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (Sabs\n        (map (\\<lambda>(pat, t).\n                 (pat,\n                  subst t\n                   (fmmap value_to_sterm (fmdrop_fset (frees pat) x3))))\n          (the (fmlookup x1 x2))))", "apply (rule abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n v.\n       \\<lbrakk>fmlookup x3 n = Some v; pred v\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm v)\n 2. fmpred (\\<lambda>_. pred) x3\n 3. P x3 (the (fmlookup x1 x2))", "using Vrecabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3a \\<in> fmran' x3; pred ?x3a\\<rbrakk>\n  \\<Longrightarrow> S (value_to_sterm ?x3a)\n  pred (Vrecabs x1 x2 x3)\n\ngoal (3 subgoals):\n 1. \\<And>n v.\n       \\<lbrakk>fmlookup x3 n = Some v; pred v\\<rbrakk>\n       \\<Longrightarrow> S (value_to_sterm v)\n 2. fmpred (\\<lambda>_. pred) x3\n 3. P x3 (the (fmlookup x1 x2))", "by (auto simp: fmlookup_dom_iff fmpred_iff intro: fmran'I)"], ["proof (state)\nthis:\n  S (value_to_sterm (Vrecabs x1 x2 x3))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S (value_to_sterm v)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "global_interpretation vwellformed:\n  value_sterm_pred\n    \"\\<lambda>_. wellformed_clauses\"\n    \"\\<lambda>_. True\"\n    \"\\<lambda>_. True\"\n    wellformed\n  defines vwellformed = vwellformed.pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_sterm_pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n     (\\<lambda>_. True) pre_strong_term_class.wellformed", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "case (2 \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "hence \"cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  cs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "moreover"], ["proof (state)\nthis:\n  cs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "have \"wellformed (subst rhs (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))\"\n    if \"(pat, rhs) \\<in> set cs\" for pat rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (subst rhs (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (subst rhs (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (subst rhs (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))", "apply (rule subst_wellformed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_env (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using 2 that"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (force simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_env (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>))", "apply (rule fmpred_drop_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_env (fmmap value_to_sterm \\<Gamma>)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. wellformed_env (fmmap value_to_sterm \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed\n   (subst rhs (fmdrop_fset (frees pat) (fmmap value_to_sterm \\<Gamma>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?pat, ?rhs) \\<in> set cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed\n   (subst ?rhs (fmdrop_fset (frees ?pat) (fmmap value_to_sterm \\<Gamma>)))\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "moreover"], ["proof (state)\nthis:\n  (?pat, ?rhs) \\<in> set cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed\n   (subst ?rhs (fmdrop_fset (frees ?pat) (fmmap value_to_sterm \\<Gamma>)))\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "have \"distinct (map (fst \\<circ> (\\<lambda>(pat, t). (pat, subst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (fst \\<circ>\n           (\\<lambda>(pat, t).\n               (pat,\n                subst t\n                 (fmmap value_to_sterm\n                   (fmdrop_fset (frees pat) \\<Gamma>)))))\n       cs)", "apply (subst map_cong[OF refl, where g = fst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       (fst \\<circ>\n        (\\<lambda>(pat, t).\n            (pat,\n             subst t\n              (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n        x =\n       fst x\n 2. distinct (map fst cs)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       (fst \\<circ>\n        (\\<lambda>(pat, t).\n            (pat,\n             subst t\n              (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n        x =\n       fst x\n 2. distinct (map fst cs)", "by auto"], ["proof (state)\nthis:\n  distinct\n   (map (fst \\<circ>\n         (\\<lambda>(pat, t).\n             (pat,\n              subst t\n               (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n     cs)\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred (\\<lambda>_. wellformed_clauses)\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred (\\<lambda>_. wellformed_clauses)\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "ultimately"], ["proof (chain)\npicking this:\n  cs \\<noteq> []\n  (?pat, ?rhs) \\<in> set cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed\n   (subst ?rhs (fmdrop_fset (frees ?pat) (fmmap value_to_sterm \\<Gamma>)))\n  distinct\n   (map (fst \\<circ>\n         (\\<lambda>(pat, t).\n             (pat,\n              subst t\n               (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n     cs)", "show ?case"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  (?pat, ?rhs) \\<in> set cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed\n   (subst ?rhs (fmdrop_fset (frees ?pat) (fmmap value_to_sterm \\<Gamma>)))\n  distinct\n   (map (fst \\<circ>\n         (\\<lambda>(pat, t).\n             (pat,\n              subst t\n               (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n     cs)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat,\n                 subst t\n                  (fmmap value_to_sterm\n                    (fmdrop_fset (frees pat) \\<Gamma>))))\n         cs))", "using 2"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n  (?pat, ?rhs) \\<in> set cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed\n   (subst ?rhs (fmdrop_fset (frees ?pat) (fmmap value_to_sterm \\<Gamma>)))\n  distinct\n   (map (fst \\<circ>\n         (\\<lambda>(pat, t).\n             (pat,\n              subst t\n               (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))))\n     cs)\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n    (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n        (\\<lambda>_. True))\n   \\<Gamma>\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat,\n                 subst t\n                  (fmmap value_to_sterm\n                    (fmdrop_fset (frees pat) \\<Gamma>))))\n         cs))", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed\n   (Sabs\n     (map (\\<lambda>(pat, t).\n              (pat,\n               subst t\n                (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n       cs))\n\ngoal (1 subgoal):\n 1. \\<And>name.\n       True \\<Longrightarrow> pre_strong_term_class.wellformed (const name)", "qed (auto simp: const_sterm_def)"], ["", "abbreviation \"wellformed_venv \\<equiv> fmpred (\\<lambda>_. vwellformed)\""], ["", "global_interpretation vclosed:\n  value_sterm_pred\n    \"\\<lambda>\\<Gamma> cs. list_all (\\<lambda>(pat, t). closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)) cs\"\n    \"\\<lambda>_. True\"\n    \"\\<lambda>_. True\"\n    closed\n  defines vclosed = vclosed.pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_sterm_pred\n     (\\<lambda>\\<Gamma>.\n         list_all\n          (\\<lambda>(pat, t).\n              closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n     (\\<lambda>_. True) (\\<lambda>_. True) closed", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name. True \\<Longrightarrow> closed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>\\<Gamma>.\n                         list_all\n                          (\\<lambda>(pat, t).\n                              closed_except t\n                               (fmdom \\<Gamma> |\\<union>| frees pat)))\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> closed (value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>\\<Gamma>.\n                  list_all\n                   (\\<lambda>(pat, t).\n                       closed_except t\n                        (fmdom \\<Gamma> |\\<union>| frees pat)))\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        list_all\n         (\\<lambda>(pat, t).\n             closed_except t (fmdom \\<Gamma> |\\<union>| frees pat))\n         cs\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "case (2 \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred\n    (\\<lambda>\\<Gamma>.\n        list_all\n         (\\<lambda>(pat, t).\n             closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> closed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>\\<Gamma>.\n            list_all\n             (\\<lambda>(pat, t).\n                 closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       closed_except t (fmdom \\<Gamma> |\\<union>| frees pat))\n   cs\n\ngoal (2 subgoals):\n 1. \\<And>name. True \\<Longrightarrow> closed (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>\\<Gamma>.\n                         list_all\n                          (\\<lambda>(pat, t).\n                              closed_except t\n                               (fmdom \\<Gamma> |\\<union>| frees pat)))\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> closed (value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>\\<Gamma>.\n                  list_all\n                   (\\<lambda>(pat, t).\n                       closed_except t\n                        (fmdom \\<Gamma> |\\<union>| frees pat)))\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        list_all\n         (\\<lambda>(pat, t).\n             closed_except t (fmdom \\<Gamma> |\\<union>| frees pat))\n         cs\\<rbrakk>\n       \\<Longrightarrow> closed\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat,\n                 subst t\n                  (fmmap value_to_sterm\n                    (fmdrop_fset (frees pat) \\<Gamma>))))\n         cs))", "apply (simp add: list_all_iff case_prod_twice Sterm.closed_except_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs.\n       case x of\n       (pat, t) \\<Rightarrow>\n         closed_except\n          (subst t\n            (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>)))\n          (frees pat)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       closed_except\n        (subst b (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>)))\n        (frees a)", "apply (subst closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       frees\n        (subst b\n          (fmmap value_to_sterm\n            (fmdrop_fset (frees a) \\<Gamma>))) |\\<subseteq>|\n       frees a", "apply (subst subst_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       closed_env (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>))\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       frees b |-|\n       fmdom\n        (fmmap value_to_sterm\n          (fmdrop_fset (frees a) \\<Gamma>)) |\\<subseteq>|\n       frees a", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       fmpred (\\<lambda>k v. closed (value_to_sterm v))\n        (fmdrop_fset (frees a) \\<Gamma>)\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       frees b |-|\n       fmdom\n        (fmmap value_to_sterm\n          (fmdrop_fset (frees a) \\<Gamma>)) |\\<subseteq>|\n       frees a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    fmpred (\\<lambda>k v. closed (value_to_sterm v))\n     (fmdrop_fset (frees a_) \\<Gamma>)", "apply (rule fmpred_drop_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    fmpred (\\<lambda>k v. closed (value_to_sterm v)) \\<Gamma>", "apply (rule fmpredI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(a_, b_) \\<in> set cs; fmlookup \\<Gamma> x = Some y\\<rbrakk>\n       \\<Longrightarrow> closed (value_to_sterm y)", "apply (rule 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(a_, b_) \\<in> set cs; fmlookup \\<Gamma> x = Some y\\<rbrakk>\n       \\<Longrightarrow> fmlookup \\<Gamma> (?n4 x y) = Some y\n 2. \\<And>x y.\n       \\<lbrakk>(a_, b_) \\<in> set cs; fmlookup \\<Gamma> x = Some y\\<rbrakk>\n       \\<Longrightarrow> value_pred.pred\n                          (\\<lambda>\\<Gamma>.\n                              list_all\n                               (\\<lambda>(pat, t).\n                                   closed_except t\n                                    (fmdom \\<Gamma> |\\<union>| frees pat)))\n                          (\\<lambda>_. True) (\\<lambda>_. True) y", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(a_, b_) \\<in> set cs; fmlookup \\<Gamma> x = Some y\\<rbrakk>\n       \\<Longrightarrow> value_pred.pred\n                          (\\<lambda>\\<Gamma>.\n                              list_all\n                               (\\<lambda>(pat, t).\n                                   closed_except t\n                                    (fmdom \\<Gamma> |\\<union>| frees pat)))\n                          (\\<lambda>_. True) (\\<lambda>_. True) y", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred\n    (\\<lambda>\\<Gamma>.\n        list_all\n         (\\<lambda>(pat, t).\n             closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> closed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>\\<Gamma>.\n            list_all\n             (\\<lambda>(pat, t).\n                 closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       closed_except t (fmdom \\<Gamma> |\\<union>| frees pat))\n   cs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(a_, b_) \\<in> set cs; fmlookup \\<Gamma> x = Some y\\<rbrakk>\n       \\<Longrightarrow> value_pred.pred\n                          (\\<lambda>\\<Gamma>.\n                              list_all\n                               (\\<lambda>(pat, t).\n                                   closed_except t\n                                    (fmdom \\<Gamma> |\\<union>| frees pat)))\n                          (\\<lambda>_. True) (\\<lambda>_. True) y", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       frees b |-|\n       fmdom\n        (fmmap value_to_sterm\n          (fmdrop_fset (frees a) \\<Gamma>)) |\\<subseteq>|\n       frees a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    frees b_ |-|\n    fmdom\n     (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)) |\\<subseteq>|\n    frees a_", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n = Some ?v;\n   value_pred.pred\n    (\\<lambda>\\<Gamma>.\n        list_all\n         (\\<lambda>(pat, t).\n             closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v\\<rbrakk>\n  \\<Longrightarrow> closed (value_to_sterm ?v)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>\\<Gamma>.\n            list_all\n             (\\<lambda>(pat, t).\n                 closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       closed_except t (fmdom \\<Gamma> |\\<union>| frees pat))\n   cs\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    frees b_ |-|\n    fmdom\n     (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)) |\\<subseteq>|\n    frees a_", "by (auto simp: list_all_iff closed_except_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed\n   (Sabs\n     (map (\\<lambda>(pat, t).\n              (pat,\n               subst t\n                (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n       cs))\n\ngoal (1 subgoal):\n 1. \\<And>name. True \\<Longrightarrow> closed (const name)", "qed simp"], ["", "abbreviation \"closed_venv \\<equiv> fmpred (\\<lambda>_. vclosed)\""], ["", "context pre_constants begin"], ["", "sublocale vwelldefined:\n  value_sterm_pred\n    \"\\<lambda>_ cs. list_all (\\<lambda>(_, t). welldefined t) cs\"\n    \"\\<lambda>name. name |\\<in>| C\"\n    \"\\<lambda>dom. dom |\\<subseteq>| heads\"\n    welldefined\n  defines vwelldefined = vwelldefined.pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_sterm_pred\n     (\\<lambda>_.\n         list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n     (\\<lambda>name. name |\\<in>| C) (\\<lambda>dom. dom |\\<subseteq>| heads)\n     (\\<lambda>t. consts t |\\<subseteq>| all_consts)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name.\n       name |\\<in>| C \\<Longrightarrow>\n       consts (const name) |\\<subseteq>| all_consts\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>_.\n                         list_all\n                          (\\<lambda>(uu_, t).\n                              consts t |\\<subseteq>| all_consts))\n                     (\\<lambda>name. name |\\<in>| C)\n                     (\\<lambda>dom. dom |\\<subseteq>| heads) v\\<rbrakk>\n                   \\<Longrightarrow> consts (value_to_sterm v) |\\<subseteq>|\n                                     all_consts;\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>_.\n                  list_all\n                   (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n              (\\<lambda>name. name |\\<in>| C)\n              (\\<lambda>dom. dom |\\<subseteq>| heads))\n         \\<Gamma>;\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n         cs\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs)) |\\<subseteq>|\n                         all_consts", "case (2 \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n    (\\<lambda>name. name |\\<in>| C) (\\<lambda>dom. dom |\\<subseteq>| heads)\n    ?v3\\<rbrakk>\n  \\<Longrightarrow> consts (value_to_sterm ?v3) |\\<subseteq>| all_consts\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n        (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>dom. dom |\\<subseteq>| heads))\n   \\<Gamma>\n  list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       name |\\<in>| C \\<Longrightarrow>\n       consts (const name) |\\<subseteq>| all_consts\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>_.\n                         list_all\n                          (\\<lambda>(uu_, t).\n                              consts t |\\<subseteq>| all_consts))\n                     (\\<lambda>name. name |\\<in>| C)\n                     (\\<lambda>dom. dom |\\<subseteq>| heads) v\\<rbrakk>\n                   \\<Longrightarrow> consts (value_to_sterm v) |\\<subseteq>|\n                                     all_consts;\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>_.\n                  list_all\n                   (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n              (\\<lambda>name. name |\\<in>| C)\n              (\\<lambda>dom. dom |\\<subseteq>| heads))\n         \\<Gamma>;\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n         cs\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs)) |\\<subseteq>|\n                         all_consts", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       name |\\<in>| C \\<Longrightarrow>\n       consts (const name) |\\<subseteq>| all_consts\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>_.\n                         list_all\n                          (\\<lambda>(uu_, t).\n                              consts t |\\<subseteq>| all_consts))\n                     (\\<lambda>name. name |\\<in>| C)\n                     (\\<lambda>dom. dom |\\<subseteq>| heads) v\\<rbrakk>\n                   \\<Longrightarrow> consts (value_to_sterm v) |\\<subseteq>|\n                                     all_consts;\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>_.\n                  list_all\n                   (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n              (\\<lambda>name. name |\\<in>| C)\n              (\\<lambda>dom. dom |\\<subseteq>| heads))\n         \\<Gamma>;\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n         cs\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (Sabs\n                            (map (\\<lambda>(pat, t).\n                                     (pat,\nsubst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                              cs)) |\\<subseteq>|\n                         all_consts", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts\n     (Sabs\n       (map (\\<lambda>(pat, t).\n                (pat,\n                 subst t\n                  (fmmap value_to_sterm\n                    (fmdrop_fset (frees pat) \\<Gamma>))))\n         cs)) |\\<subseteq>|\n    all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     (fset_of_list\n       (map ((\\<lambda>(uu_, y). consts y) \\<circ>\n             (\\<lambda>(pat, t).\n                 (pat,\n                  subst t\n                   (fmmap value_to_sterm\n                     (fmdrop_fset (frees pat) \\<Gamma>)))))\n         cs)) |\\<subseteq>|\n    all_consts", "apply (rule ffUnion_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall\n     (fset_of_list\n       (map ((\\<lambda>(uu_, y). consts y) \\<circ>\n             (\\<lambda>(pat, t).\n                 (pat,\n                  subst t\n                   (fmmap value_to_sterm\n                     (fmdrop_fset (frees pat) \\<Gamma>)))))\n         cs))\n     (\\<lambda>X. X |\\<subseteq>| all_consts)", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>|\n       fset_of_list\n        (map ((\\<lambda>(uu_, y). consts y) \\<circ>\n              (\\<lambda>(pat, t).\n                  (pat,\n                   subst t\n                    (fmmap value_to_sterm\n                      (fmdrop_fset (frees pat) \\<Gamma>)))))\n          cs) \\<Longrightarrow>\n       x |\\<subseteq>| all_consts", "apply (subst (asm) fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map ((\\<lambda>(uu_, y). consts y) \\<circ>\n                         (\\<lambda>(pat, t).\n                             (pat,\n                              subst t\n                               (fmmap value_to_sterm\n                                 (fmdrop_fset (frees pat) \\<Gamma>)))))\n                     cs) \\<Longrightarrow>\n       x |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   case case x of\n                        (pat, t) \\<Rightarrow>\n                          (pat,\n                           subst t\n                            (fmmap value_to_sterm\n                              (fmdrop_fset (frees pat) \\<Gamma>))) of\n                   (uu_, x) \\<Rightarrow> consts x) `\n               set cs \\<Longrightarrow>\n       x |\\<subseteq>| all_consts", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x =\n                (case case xa of\n                      (pat, t) \\<Rightarrow>\n                        (pat,\n                         subst t\n                          (fmmap value_to_sterm\n                            (fmdrop_fset (frees pat) \\<Gamma>))) of\n                 (uu_, x) \\<Rightarrow> consts x);\n        xa \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> x |\\<subseteq>| all_consts", "apply (simp add: case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x =\n                (case xa of\n                 (pat, t) \\<Rightarrow>\n                   consts\n                    (subst t\n                      (fmmap value_to_sterm\n                        (fmdrop_fset (frees pat) \\<Gamma>))));\n        xa \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (pat, t) \\<Rightarrow>\n                            consts\n                             (subst t\n                               (fmmap value_to_sterm\n                                 (fmdrop_fset (frees pat)\n                                   \\<Gamma>)))) |\\<subseteq>|\n                         all_consts", "subgoal for _ x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             (case x of\n              (pat, t) \\<Rightarrow>\n                consts\n                 (subst t\n                   (fmmap value_to_sterm\n                     (fmdrop_fset (frees pat) \\<Gamma>))));\n     x \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> (case x of\n                       (pat, t) \\<Rightarrow>\n                         consts\n                          (subst t\n                            (fmmap value_to_sterm\n                              (fmdrop_fset (frees pat)\n                                \\<Gamma>)))) |\\<subseteq>|\n                      all_consts", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x_ =\n                (case x of\n                 (pat, t) \\<Rightarrow>\n                   consts\n                    (subst t\n                      (fmmap value_to_sterm\n                        (fmdrop_fset (frees pat) \\<Gamma>))));\n        x \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (pat, t) \\<Rightarrow>\n                            consts\n                             (subst t\n                               (fmmap value_to_sterm\n                                 (fmdrop_fset (frees pat)\n                                   \\<Gamma>)))) |\\<subseteq>|\n                         all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b\n                   (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>)));\n        (a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (subst b\n                            (fmmap value_to_sterm\n                              (fmdrop_fset (frees a)\n                                \\<Gamma>))) |\\<subseteq>|\n                         all_consts", "apply (rule subst_consts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b\n                   (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>)));\n        (a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts\n 2. \\<And>a b.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b\n                   (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>)));\n        (a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>_ u. consts u |\\<subseteq>| all_consts)\n                          (fmmap value_to_sterm\n                            (fmdrop_fset (frees a) \\<Gamma>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> consts b_ |\\<subseteq>| all_consts", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n    (\\<lambda>name. name |\\<in>| C) (\\<lambda>dom. dom |\\<subseteq>| heads)\n    ?v3\\<rbrakk>\n  \\<Longrightarrow> consts (value_to_sterm ?v3) |\\<subseteq>| all_consts\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n        (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>dom. dom |\\<subseteq>| heads))\n   \\<Gamma>\n  list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> consts b_ |\\<subseteq>| all_consts", "by (fastforce simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b\n                   (fmmap value_to_sterm (fmdrop_fset (frees a) \\<Gamma>)));\n        (a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>_ u. consts u |\\<subseteq>| all_consts)\n                          (fmmap value_to_sterm\n                            (fmdrop_fset (frees a) \\<Gamma>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fmpred\n                       (\\<lambda>_ u. consts u |\\<subseteq>| all_consts)\n                       (fmmap value_to_sterm\n                         (fmdrop_fset (frees a_) \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fmpred\n                       (\\<lambda>k v.\n                           consts (value_to_sterm v) |\\<subseteq>|\n                           all_consts)\n                       (fmdrop_fset (frees a_) \\<Gamma>)", "apply (rule fmpred_drop_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fmpred\n                       (\\<lambda>k v.\n                           consts (value_to_sterm v) |\\<subseteq>|\n                           all_consts)\n                       \\<Gamma>", "unfolding fmpred_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ =\n             consts\n              (subst b_\n                (fmmap value_to_sterm (fmdrop_fset (frees a_) \\<Gamma>)));\n     (a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fmpred\n                       (\\<lambda>k v.\n                           consts (value_to_sterm v) |\\<subseteq>|\n                           all_consts)\n                       \\<Gamma>", "apply (rule fmpredI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb y.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b_\n                   (fmmap value_to_sterm\n                     (fmdrop_fset (frees a_) \\<Gamma>)));\n        (a_, b_) \\<in> set cs; x = (a_, b_);\n        fmlookup \\<Gamma> xb = Some y\\<rbrakk>\n       \\<Longrightarrow> consts (value_to_sterm y) |\\<subseteq>| all_consts", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n    (\\<lambda>name. name |\\<in>| C) (\\<lambda>dom. dom |\\<subseteq>| heads)\n    ?v3\\<rbrakk>\n  \\<Longrightarrow> consts (value_to_sterm ?v3) |\\<subseteq>| all_consts\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n        (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>dom. dom |\\<subseteq>| heads))\n   \\<Gamma>\n  list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs\n\ngoal (1 subgoal):\n 1. \\<And>xb y.\n       \\<lbrakk>x_ =\n                consts\n                 (subst b_\n                   (fmmap value_to_sterm\n                     (fmdrop_fset (frees a_) \\<Gamma>)));\n        (a_, b_) \\<in> set cs; x = (a_, b_);\n        fmlookup \\<Gamma> xb = Some y\\<rbrakk>\n       \\<Longrightarrow> consts (value_to_sterm y) |\\<subseteq>| all_consts", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts\n   (Sabs\n     (map (\\<lambda>(pat, t).\n              (pat,\n               subst t\n                (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n       cs)) |\\<subseteq>|\n  all_consts\n\ngoal (1 subgoal):\n 1. \\<And>name.\n       name |\\<in>| C \\<Longrightarrow>\n       consts (const name) |\\<subseteq>| all_consts", "qed (simp add: all_consts_def)"], ["", "lemmas vwelldefined_alt_def = vwelldefined.pred_alt_def"], ["", "end"], ["", "declare pre_constants.vwelldefined_alt_def[code]"], ["", "context constructors begin"], ["", "sublocale vconstructor_value:\n  pre_value_sterm_pred\n    \"\\<lambda>_ _. True\"\n    \"\\<lambda>name. name |\\<in>| C\"\n    \"\\<lambda>_. True\"\n    is_value\n  defines vconstructor_value = vconstructor_value.pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_value_sterm_pred (\\<lambda>_ _. True)\n     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True) is_value", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>_. True) v \\<Longrightarrow>\n       is_value (value_to_sterm v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>_. True) v \\<Longrightarrow>\n       is_value (value_to_sterm v)", "assume \"value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True) v\""], ["proof (state)\nthis:\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n        (\\<lambda>_. True) v \\<Longrightarrow>\n       is_value (value_to_sterm v)", "then"], ["proof (chain)\npicking this:\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) v", "show \"is_value (value_to_sterm v)\""], ["proof (prove)\nusing this:\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) v\n\ngoal (1 subgoal):\n 1. is_value (value_to_sterm v)", "proof (induction v)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vconstr x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vconstr x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vabs x1 x2))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x3a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x3a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vrecabs x1 x2 x3))", "case (Vconstr name vs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set vs;\n   value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n    (\\<lambda>_. True) ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_value (value_to_sterm ?x2a)\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) (Vconstr name vs)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vconstr x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vconstr x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vabs x1 x2))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x3a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x3a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vrecabs x1 x2 x3))", "hence \"list_all is_value (map value_to_sterm vs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set vs;\n   value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n    (\\<lambda>_. True) ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_value (value_to_sterm ?x2a)\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) (Vconstr name vs)\n\ngoal (1 subgoal):\n 1. list_all is_value (map value_to_sterm vs)", "by (fastforce simp: list_all_iff value_pred.pred_alt_def)"], ["proof (state)\nthis:\n  list_all is_value (map value_to_sterm vs)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vconstr x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vconstr x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vabs x1 x2))\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x3a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x3a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vrecabs x1 x2 x3))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_value (value_to_sterm (Vconstr name vs))", "unfolding value_to_sterm.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_value (name $$ map value_to_sterm vs)", "apply (rule is_value.constr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all is_value (map value_to_sterm vs)\n 2. name |\\<in>| C", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| C", "using Vconstr"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set vs;\n   value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n    (\\<lambda>_. True) ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_value (value_to_sterm ?x2a)\n  value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n   (\\<lambda>_. True) (Vconstr name vs)\n\ngoal (1 subgoal):\n 1. name |\\<in>| C", "by (simp add: value_pred.pred_alt_def)"], ["proof (state)\nthis:\n  is_value (value_to_sterm (Vconstr name vs))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x2a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x2a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vabs x1 x2)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vabs x1 x2))\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<And>x3a.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    value_pred.pred (\\<lambda>_ _. True)\n                     (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True)\n                     x3a\\<rbrakk>\n                   \\<Longrightarrow> is_value (value_to_sterm x3a);\n        value_pred.pred (\\<lambda>_ _. True) (\\<lambda>name. name |\\<in>| C)\n         (\\<lambda>_. True) (Vrecabs x1 x2 x3)\\<rbrakk>\n       \\<Longrightarrow> is_value (value_to_sterm (Vrecabs x1 x2 x3))", "qed (auto simp: disjnt_def intro: is_value.intros)"], ["proof (state)\nthis:\n  is_value (value_to_sterm v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas vconstructor_value_alt_def = vconstructor_value.pred_alt_def"], ["", "abbreviation \"vconstructor_value_env \\<equiv> fmpred (\\<lambda>_. vconstructor_value)\""], ["", "definition vconstructor_value_rs :: \"vrule list \\<Rightarrow> bool\" where\n\"vconstructor_value_rs rs \\<longleftrightarrow>\n  list_all (\\<lambda>(_, rhs). vconstructor_value rhs) rs \\<and>\n  fdisjnt (fset_of_list (map fst rs)) C\""], ["", "end"], ["", "declare constructors.vconstructor_value_alt_def[code]"], ["", "declare constructors.vconstructor_value_rs_def[code]"], ["", "context pre_constants begin"], ["", "sublocale not_shadows_vconsts:\n  value_sterm_pred\n    \"\\<lambda>_ cs. list_all (\\<lambda>(pat, t). fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t) cs\"\n    \"\\<lambda>_. True\"\n    \"\\<lambda>_. True\"\n    \"\\<lambda>t. \\<not> shadows_consts t\"\n  defines not_shadows_vconsts = not_shadows_vconsts.pred"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_sterm_pred\n     (\\<lambda>_.\n         list_all\n          (\\<lambda>(pat, t).\n              fdisjnt all_consts (frees pat) \\<and>\n              \\<not> shadows_consts t))\n     (\\<lambda>_. True) (\\<lambda>_. True)\n     (\\<lambda>t. \\<not> shadows_consts t)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name. True \\<Longrightarrow> \\<not> shadows_consts (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>_.\n                         list_all\n                          (\\<lambda>(pat, t).\n                              fdisjnt all_consts (frees pat) \\<and>\n                              \\<not> shadows_consts t))\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>_.\n                  list_all\n                   (\\<lambda>(pat, t).\n                       fdisjnt all_consts (frees pat) \\<and>\n                       \\<not> shadows_consts t))\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n         cs\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat,\n       subst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                                     cs))", "case (2 \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm ?v3)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all\n             (\\<lambda>(pat, t).\n                 fdisjnt all_consts (frees pat) \\<and>\n                 \\<not> shadows_consts t))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n   cs\n\ngoal (2 subgoals):\n 1. \\<And>name. True \\<Longrightarrow> \\<not> shadows_consts (const name)\n 2. \\<And>\\<Gamma> cs.\n       \\<lbrakk>\\<And>n v.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some v;\n                    value_pred.pred\n                     (\\<lambda>_.\n                         list_all\n                          (\\<lambda>(pat, t).\n                              fdisjnt all_consts (frees pat) \\<and>\n                              \\<not> shadows_consts t))\n                     (\\<lambda>_. True) (\\<lambda>_. True) v\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (value_to_sterm v);\n        fmpred\n         (\\<lambda>_.\n             value_pred.pred\n              (\\<lambda>_.\n                  list_all\n                   (\\<lambda>(pat, t).\n                       fdisjnt all_consts (frees pat) \\<and>\n                       \\<not> shadows_consts t))\n              (\\<lambda>_. True) (\\<lambda>_. True))\n         \\<Gamma>;\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n         cs\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (Sabs\n                                   (map (\\<lambda>(pat, t).\n      (pat,\n       subst t (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))\n                                     cs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts\n            (Sabs\n              (map (\\<lambda>(pat, t).\n                       (pat,\n                        subst t\n                         (fmmap value_to_sterm\n                           (fmdrop_fset (frees pat) \\<Gamma>))))\n                cs))", "apply (simp add: list_all_iff list_ex_iff case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs.\n       \\<not> (case x of\n               (pat, t) \\<Rightarrow>\n                 fdisjnt all_consts (frees pat) \\<longrightarrow>\n                 shadows_consts\n                  (subst t\n                    (fmmap value_to_sterm\n                      (fmdrop_fset (frees pat) \\<Gamma>))))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       \\<not> (case x of\n               (pat, t) \\<Rightarrow>\n                 fdisjnt all_consts (frees pat) \\<longrightarrow>\n                 shadows_consts\n                  (subst t\n                    (fmmap value_to_sterm\n                      (fmdrop_fset (frees pat) \\<Gamma>))))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set cs \\<Longrightarrow>\n    \\<not> (case x of\n            (pat, t) \\<Rightarrow>\n              fdisjnt all_consts (frees pat) \\<longrightarrow>\n              shadows_consts\n               (subst t\n                 (fmmap value_to_sterm (fmdrop_fset (frees pat) \\<Gamma>))))", "apply (cases x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt all_consts (frees a) \\<and>\n                         \\<not> shadows_consts\n                                 (subst b\n                                   (fmmap value_to_sterm\n                                     (fmdrop_fset (frees a) \\<Gamma>)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt all_consts (frees a)\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (subst b\n                                   (fmmap value_to_sterm\n                                     (fmdrop_fset (frees a) \\<Gamma>)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fdisjnt all_consts (frees a_)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm ?v3)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all\n             (\\<lambda>(pat, t).\n                 fdisjnt all_consts (frees pat) \\<and>\n                 \\<not> shadows_consts t))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n   cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> fdisjnt all_consts (frees a_)", "by (force simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (subst b\n                                   (fmmap value_to_sterm\n                                     (fmdrop_fset (frees a) \\<Gamma>)))", "apply (rule subst_shadows)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts b\n 2. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_consts_env\n                          (fmmap value_to_sterm\n                            (fmdrop_fset (frees a) \\<Gamma>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> \\<not> shadows_consts b_", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm ?v3)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all\n             (\\<lambda>(pat, t).\n                 fdisjnt all_consts (frees pat) \\<and>\n                 \\<not> shadows_consts t))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n   cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a_, b_) \\<in> set cs; x = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> \\<not> shadows_consts b_", "by (force simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_consts_env\n                          (fmmap value_to_sterm\n                            (fmdrop_fset (frees a) \\<Gamma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>k v.\n                              \\<not> shadows_consts (value_to_sterm v))\n                          (fmdrop_fset (frees a) \\<Gamma>)", "apply (rule fmpred_drop_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>k v.\n                              \\<not> shadows_consts (value_to_sterm v))\n                          \\<Gamma>", "apply (rule fmpredI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa y.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b);\n        fmlookup \\<Gamma> xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm y)", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmlookup \\<Gamma> ?n3 = Some ?v3;\n   value_pred.pred\n    (\\<lambda>_.\n        list_all\n         (\\<lambda>(pat, t).\n             fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t))\n    (\\<lambda>_. True) (\\<lambda>_. True) ?v3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm ?v3)\n  fmpred\n   (\\<lambda>_.\n       value_pred.pred\n        (\\<lambda>_.\n            list_all\n             (\\<lambda>(pat, t).\n                 fdisjnt all_consts (frees pat) \\<and>\n                 \\<not> shadows_consts t))\n        (\\<lambda>_. True) (\\<lambda>_. True))\n   \\<Gamma>\n  list_all\n   (\\<lambda>(pat, t).\n       fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n   cs\n\ngoal (1 subgoal):\n 1. \\<And>a b xa y.\n       \\<lbrakk>(a, b) \\<in> set cs; x = (a, b);\n        fmlookup \\<Gamma> xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (value_to_sterm y)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> shadows_consts\n          (Sabs\n            (map (\\<lambda>(pat, t).\n                     (pat,\n                      subst t\n                       (fmmap value_to_sterm\n                         (fmdrop_fset (frees pat) \\<Gamma>))))\n              cs))\n\ngoal (1 subgoal):\n 1. \\<And>name. True \\<Longrightarrow> \\<not> shadows_consts (const name)", "qed (auto simp: const_sterm_def app_sterm_def)"], ["", "lemmas not_shadows_vconsts_alt_def = not_shadows_vconsts.pred_alt_def"], ["", "abbreviation \"not_shadows_vconsts_env \\<equiv> fmpred (\\<lambda>_ s. not_shadows_vconsts s)\""], ["", "end"], ["", "declare pre_constants.not_shadows_vconsts_alt_def[code]"], ["", "fun term_to_value :: \"sterm \\<Rightarrow> value\" where\n\"term_to_value t =\n  (case strip_comb t of\n    (Sconst name, args) \\<Rightarrow> Vconstr name (map term_to_value args)\n  | (Sabs cs, []) \\<Rightarrow> Vabs cs fmempty)\""], ["", "lemma (in constructors) term_to_value_to_sterm:\n  assumes \"is_value t\"\n  shows \"value_to_sterm (term_to_value t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_to_sterm (term_to_value t) = t", "using assms"], ["proof (prove)\nusing this:\n  is_value t\n\ngoal (1 subgoal):\n 1. value_to_sterm (term_to_value t) = t", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs. value_to_sterm (term_to_value (Sabs cs)) = Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and> value_to_sterm (term_to_value x) = x)\n                 vs;\n        name |\\<in>| C\\<rbrakk>\n       \\<Longrightarrow> value_to_sterm (term_to_value (name $$ vs)) =\n                         name $$ vs", "case (constr vs name)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>x. is_value x \\<and> value_to_sterm (term_to_value x) = x) vs\n  name |\\<in>| C\n\ngoal (2 subgoals):\n 1. \\<And>cs. value_to_sterm (term_to_value (Sabs cs)) = Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and> value_to_sterm (term_to_value x) = x)\n                 vs;\n        name |\\<in>| C\\<rbrakk>\n       \\<Longrightarrow> value_to_sterm (term_to_value (name $$ vs)) =\n                         name $$ vs", "have \"map (value_to_sterm \\<circ> term_to_value) vs = map id vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (value_to_sterm \\<circ> term_to_value) vs = map id vs", "proof (rule list.map_cong0, unfold comp_apply id_apply)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow> value_to_sterm (term_to_value z) = z", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow> value_to_sterm (term_to_value z) = z", "assume \"v \\<in> set vs\""], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set vs \\<Longrightarrow> value_to_sterm (term_to_value z) = z", "with constr"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>x. is_value x \\<and> value_to_sterm (term_to_value x) = x) vs\n  name |\\<in>| C\n  v \\<in> set vs", "show \"value_to_sterm (term_to_value v) = v\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>x. is_value x \\<and> value_to_sterm (term_to_value x) = x) vs\n  name |\\<in>| C\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. value_to_sterm (term_to_value v) = v", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  value_to_sterm (term_to_value v) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (value_to_sterm \\<circ> term_to_value) vs = map id vs\n\ngoal (2 subgoals):\n 1. \\<And>cs. value_to_sterm (term_to_value (Sabs cs)) = Sabs cs\n 2. \\<And>vs name.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     is_value x \\<and> value_to_sterm (term_to_value x) = x)\n                 vs;\n        name |\\<in>| C\\<rbrakk>\n       \\<Longrightarrow> value_to_sterm (term_to_value (name $$ vs)) =\n                         name $$ vs", "thus ?case"], ["proof (prove)\nusing this:\n  map (value_to_sterm \\<circ> term_to_value) vs = map id vs\n\ngoal (1 subgoal):\n 1. value_to_sterm (term_to_value (name $$ vs)) = name $$ vs", "apply (simp add: strip_list_comb_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (value_to_sterm \\<circ> term_to_value) vs = vs \\<Longrightarrow>\n    value_to_sterm\n     (case const name of\n      Sconst name \\<Rightarrow> Vconstr name (map term_to_value vs)\n      | Sabs cs \\<Rightarrow> case vs of [] \\<Rightarrow> Vabs cs fmempty) =\n    name $$ vs", "apply (subst const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (value_to_sterm \\<circ> term_to_value) vs = vs \\<Longrightarrow>\n    value_to_sterm\n     (case Sconst name of\n      Sconst name \\<Rightarrow> Vconstr name (map term_to_value vs)\n      | Sabs cs \\<Rightarrow> case vs of [] \\<Rightarrow> Vabs cs fmempty) =\n    name $$ vs", "by simp"], ["proof (state)\nthis:\n  value_to_sterm (term_to_value (name $$ vs)) = name $$ vs\n\ngoal (1 subgoal):\n 1. \\<And>cs. value_to_sterm (term_to_value (Sabs cs)) = Sabs cs", "qed simp"], ["", "lemma vmatch_dom:\n  assumes \"vmatch pat v = Some env\"\n  shows \"fmdom env = patvars pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = patvars pat", "using assms"], ["proof (prove)\nusing this:\n  vmatch pat v = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = patvars pat", "proof (induction pat v arbitrary: env rule: vmatch_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "case (constr name ps name' vs)"], ["proof (state)\nthis:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env\\<rbrakk>\n  \\<Longrightarrow> fmdom ?env = patvars ?x\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "hence\n    \"map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch ps vs)) = Some env\"\n    \"name = name'\" \"length ps = length vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env\\<rbrakk>\n  \\<Longrightarrow> fmdom ?env = patvars ?x\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n\ngoal (1 subgoal):\n 1. map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps vs)) =\n    Some env &&&\n    name = name' &&& length ps = length vs", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "then"], ["proof (chain)\npicking this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs", "obtain envs where \"env = foldl (++\\<^sub>f) fmempty envs\" \"map2 vmatch ps vs = map Some envs\""], ["proof (prove)\nusing this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>envs.\n        \\<lbrakk>env = foldl (++\\<^sub>f) fmempty envs;\n         Term_Utils.map2 vmatch ps vs = map Some envs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: those_someD)"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "moreover"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "have \"fset_of_list (map fmdom envs) = fset_of_list (map patvars ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list (map fmdom envs) = fset_of_list (map patvars ps)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "fix names"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "assume \"names |\\<in>| fset_of_list (map fmdom envs)\""], ["proof (state)\nthis:\n  names |\\<in>| fset_of_list (map fmdom envs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "hence \"names \\<in> set (map fmdom envs)\""], ["proof (prove)\nusing this:\n  names |\\<in>| fset_of_list (map fmdom envs)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map fmdom envs)", "unfolding fset_of_list_elem"], ["proof (prove)\nusing this:\n  names \\<in> set (map fmdom envs)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map fmdom envs)", "."], ["proof (state)\nthis:\n  names \\<in> set (map fmdom envs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "then"], ["proof (chain)\npicking this:\n  names \\<in> set (map fmdom envs)", "obtain env where \"env \\<in> set envs\" \"names = fmdom env\""], ["proof (prove)\nusing this:\n  names \\<in> set (map fmdom envs)\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>env \\<in> set envs; names = fmdom env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  env \\<in> set envs\n  names = fmdom env\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "hence \"Some env \\<in> set (map2 vmatch ps vs)\""], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  names = fmdom env\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "unfolding \\<open>map2 _ _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  names = fmdom env\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (map Some envs)", "by simp"], ["proof (state)\nthis:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "then"], ["proof (chain)\npicking this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "obtain p v where \"p \\<in> set ps\" \"v \\<in> set vs\" \"vmatch p v = Some env\""], ["proof (prove)\nusing this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>p \\<in> set ps; v \\<in> set vs;\n         vmatch p v = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: map2_elemE)"], ["proof (state)\nthis:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "moreover"], ["proof (state)\nthis:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "hence \"fmdom env = patvars p\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = patvars p", "using constr"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env\\<rbrakk>\n  \\<Longrightarrow> fmdom ?env = patvars ?x\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some enva__\n\ngoal (1 subgoal):\n 1. fmdom env = patvars p", "by fastforce"], ["proof (state)\nthis:\n  fmdom env = patvars p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  fmdom env = patvars p", "have \"names \\<in> set (map patvars ps)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  fmdom env = patvars p\n\ngoal (1 subgoal):\n 1. names \\<in> set (map patvars ps)", "unfolding \\<open>names = _\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  fmdom env = patvars p\n\ngoal (1 subgoal):\n 1. fmdom env \\<in> set (map patvars ps)", "by simp"], ["proof (state)\nthis:\n  names \\<in> set (map patvars ps)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map fmdom envs) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map patvars ps)\n 2. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "thus \"names |\\<in>| fset_of_list (map patvars ps)\""], ["proof (prove)\nusing this:\n  names \\<in> set (map patvars ps)\n\ngoal (1 subgoal):\n 1. names |\\<in>| fset_of_list (map patvars ps)", "unfolding fset_of_list_elem"], ["proof (prove)\nusing this:\n  names \\<in> set (map patvars ps)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map patvars ps)", "."], ["proof (state)\nthis:\n  names |\\<in>| fset_of_list (map patvars ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "fix names"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "assume \"names |\\<in>| fset_of_list (map patvars ps)\""], ["proof (state)\nthis:\n  names |\\<in>| fset_of_list (map patvars ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "hence \"names \\<in> set (map patvars ps)\""], ["proof (prove)\nusing this:\n  names |\\<in>| fset_of_list (map patvars ps)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map patvars ps)", "unfolding fset_of_list_elem"], ["proof (prove)\nusing this:\n  names \\<in> set (map patvars ps)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map patvars ps)", "."], ["proof (state)\nthis:\n  names \\<in> set (map patvars ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "then"], ["proof (chain)\npicking this:\n  names \\<in> set (map patvars ps)", "obtain p where \"p \\<in> set ps\" \"names = patvars p\""], ["proof (prove)\nusing this:\n  names \\<in> set (map patvars ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> set ps; names = patvars p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> set ps\n  names = patvars p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps\n  names = patvars p", "obtain v where \"v \\<in> set vs\" \"vmatch p v \\<in> set (map2 vmatch ps vs)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  names = patvars p\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set vs;\n         vmatch p v \\<in> set (Term_Utils.map2 vmatch ps vs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>length ps = length vs\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  names = patvars p\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set vs;\n         vmatch p v \\<in> set (Term_Utils.map2 vmatch ps vs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: map2_elemE1)"], ["proof (state)\nthis:\n  v \\<in> set vs\n  vmatch p v \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "then"], ["proof (chain)\npicking this:\n  v \\<in> set vs\n  vmatch p v \\<in> set (Term_Utils.map2 vmatch ps vs)", "obtain env where \"env \\<in> set envs\" \"vmatch p v = Some env\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  vmatch p v \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>env \\<in> set envs; vmatch p v = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>map2 vmatch ps vs = _\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n  vmatch p v \\<in> set (map Some envs)\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>env \\<in> set envs; vmatch p v = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  env \\<in> set envs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "moreover"], ["proof (state)\nthis:\n  env \\<in> set envs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "hence \"fmdom env = patvars p\""], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = patvars p", "using constr \\<open>name = name'\\<close> \\<open>length ps = length vs\\<close> \\<open>p \\<in> set ps\\<close> \\<open>v \\<in> set vs\\<close>"], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  vmatch p v = Some env\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs; vmatch ?x ?y = Some ?env\\<rbrakk>\n  \\<Longrightarrow> fmdom ?env = patvars ?x\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some enva__\n  name = name'\n  length ps = length vs\n  p \\<in> set ps\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. fmdom env = patvars p", "by fastforce"], ["proof (state)\nthis:\n  fmdom env = patvars p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "ultimately"], ["proof (chain)\npicking this:\n  env \\<in> set envs\n  vmatch p v = Some env\n  fmdom env = patvars p", "have \"names \\<in> set (map fmdom envs)\""], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  vmatch p v = Some env\n  fmdom env = patvars p\n\ngoal (1 subgoal):\n 1. names \\<in> set (map fmdom envs)", "unfolding \\<open>names = _\\<close>"], ["proof (prove)\nusing this:\n  env \\<in> set envs\n  vmatch p v = Some env\n  fmdom env = patvars p\n\ngoal (1 subgoal):\n 1. patvars p \\<in> set (map fmdom envs)", "by auto"], ["proof (state)\nthis:\n  names \\<in> set (map fmdom envs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list (map patvars ps) \\<Longrightarrow>\n       x |\\<in>| fset_of_list (map fmdom envs)", "thus \"names |\\<in>| fset_of_list (map fmdom envs)\""], ["proof (prove)\nusing this:\n  names \\<in> set (map fmdom envs)\n\ngoal (1 subgoal):\n 1. names |\\<in>| fset_of_list (map fmdom envs)", "unfolding fset_of_list_elem"], ["proof (prove)\nusing this:\n  names \\<in> set (map fmdom envs)\n\ngoal (1 subgoal):\n 1. names \\<in> set (map fmdom envs)", "."], ["proof (state)\nthis:\n  names |\\<in>| fset_of_list (map fmdom envs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fset_of_list (map fmdom envs) = fset_of_list (map patvars ps)\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs;\n                    vmatch x y = Some env\\<rbrakk>\n                   \\<Longrightarrow> fmdom env = patvars x;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\\<rbrakk>\n       \\<Longrightarrow> fmdom env = patvars (Patconstr name ps)\n 3. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 4. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "ultimately"], ["proof (chain)\npicking this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  fset_of_list (map fmdom envs) = fset_of_list (map patvars ps)", "show ?case"], ["proof (prove)\nusing this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  fset_of_list (map fmdom envs) = fset_of_list (map patvars ps)\n\ngoal (1 subgoal):\n 1. fmdom env = patvars (Patconstr name ps)", "by (auto simp: fmdom_foldl_add)"], ["proof (state)\nthis:\n  fmdom env = patvars (Patconstr name ps)\n\ngoal (3 subgoals):\n 1. \\<And>name v env.\n       vmatch (Patvar name) v = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patvar name)\n 2. \\<And>v va vb vc env.\n       vmatch (Patconstr v va) (Vabs vb vc) = Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)\n 3. \\<And>v va vb vc vd env.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       Some env \\<Longrightarrow>\n       fmdom env = patvars (Patconstr v va)", "qed auto"], ["", "fun vfind_match :: \"sclauses \\<Rightarrow> value \\<Rightarrow> ((name, value) fmap \\<times> term \\<times> sterm) option\" where\n\"vfind_match [] _ = None\" |\n\"vfind_match ((pat, rhs) # cs) t =\n  (case vmatch (mk_pat pat) t of\n    Some env \\<Rightarrow> Some (env, pat, rhs)\n  | None \\<Rightarrow> vfind_match cs t)\""], ["", "lemma vfind_match_elem:\n  assumes \"vfind_match cs t = Some (env, pat, rhs)\"\n  shows \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) t = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) t = Some env", "using assms"], ["proof (prove)\nusing this:\n  vfind_match cs t = Some (env, pat, rhs)\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) t = Some env", "by (induct cs) (auto split: option.splits)"], ["", "inductive veq_structure :: \"value \\<Rightarrow> value \\<Rightarrow> bool\" where\nabs_abs: \"veq_structure (Vabs _ _) (Vabs _ _)\" |\nrecabs_recabs: \"veq_structure (Vrecabs _ _ _) (Vrecabs _ _ _)\" |\nconstr_constr: \"list_all2 veq_structure ts us \\<Longrightarrow> veq_structure (Vconstr name ts) (Vconstr name us)\""], ["", "lemma veq_structure_simps[code, simp]:\n  \"veq_structure (Vabs cs\\<^sub>1 \\<Gamma>\\<^sub>1) (Vabs cs\\<^sub>2 \\<Gamma>\\<^sub>2)\"\n  \"veq_structure (Vrecabs css\\<^sub>1 name\\<^sub>1 \\<Gamma>\\<^sub>1) (Vrecabs css\\<^sub>2 name\\<^sub>2 \\<Gamma>\\<^sub>2)\"\n  \"veq_structure (Vconstr name\\<^sub>1 ts) (Vconstr name\\<^sub>2 us) \\<longleftrightarrow> name\\<^sub>1 = name\\<^sub>2 \\<and> list_all2 veq_structure ts us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. veq_structure (Vabs cs\\<^sub>1 \\<Gamma>\\<^sub>1)\n     (Vabs cs\\<^sub>2 \\<Gamma>\\<^sub>2) &&&\n    veq_structure (Vrecabs css\\<^sub>1 name\\<^sub>1 \\<Gamma>\\<^sub>1)\n     (Vrecabs css\\<^sub>2 name\\<^sub>2 \\<Gamma>\\<^sub>2) &&&\n    veq_structure (Vconstr name\\<^sub>1 ts) (Vconstr name\\<^sub>2 us) =\n    (name\\<^sub>1 = name\\<^sub>2 \\<and> list_all2 veq_structure ts us)", "by (auto intro: veq_structure.intros elim: veq_structure.cases)"], ["", "lemma veq_structure_refl[simp]: \"veq_structure t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. veq_structure t t", "by (induction t) (auto simp: list.rel_refl_strong)"], ["", "global_interpretation vno_abs: value_pred \"\\<lambda>_ _. False\" \"\\<lambda>_. True\" \"\\<lambda>_. False\"\n  defines vno_abs = vno_abs.pred"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma veq_structure_eq_left:\n  assumes \"veq_structure t u\" \"vno_abs t\"\n  shows \"t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = u", "using assms"], ["proof (prove)\nusing this:\n  veq_structure t u\n  vno_abs t\n\ngoal (1 subgoal):\n 1. t = u", "proof (induction rule: veq_structure.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uu_ uv_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs uy_ uz_ va_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x1 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name ts)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "case (constr_constr ts us name)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x1 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name ts)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uu_ uv_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs uy_ uz_ va_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x1 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name ts)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "have \"ts = us\" if \"list_all vno_abs ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts = us", "using constr_constr.IH that"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x1 \\<longrightarrow> x1 = x2))\n   ts us\n  list_all vno_abs ts\n\ngoal (1 subgoal):\n 1. ts = us", "by induction auto"], ["proof (state)\nthis:\n  list_all vno_abs ts \\<Longrightarrow> ts = us\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uu_ uv_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs uy_ uz_ va_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x1 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name ts)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "with constr_constr"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x1 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name ts)\n  list_all vno_abs ts \\<Longrightarrow> ts = us", "show ?case"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x1 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name ts)\n  list_all vno_abs ts \\<Longrightarrow> ts = us\n\ngoal (1 subgoal):\n 1. Vconstr name ts = Vconstr name us", "by auto"], ["proof (state)\nthis:\n  Vconstr name ts = Vconstr name us\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uu_ uv_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs uy_ uz_ va_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_", "qed auto"], ["", "lemma veq_structure_eq_right:\n  assumes \"veq_structure t u\" \"vno_abs u\"\n  shows \"t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = u", "using assms"], ["proof (prove)\nusing this:\n  veq_structure t u\n  vno_abs u\n\ngoal (1 subgoal):\n 1. t = u", "proof (induction rule: veq_structure.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uw_ ux_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs vb_ vc_ vd_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x2 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name us)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "case (constr_constr ts us name)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x2 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name us)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uw_ ux_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs vb_ vc_ vd_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x2 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name us)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "have \"ts = us\" if \"list_all vno_abs us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts = us", "using constr_constr.IH that"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x2 \\<longrightarrow> x1 = x2))\n   ts us\n  list_all vno_abs us\n\ngoal (1 subgoal):\n 1. ts = us", "by induction auto"], ["proof (state)\nthis:\n  list_all vno_abs us \\<Longrightarrow> ts = us\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uw_ ux_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs vb_ vc_ vd_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_\n 3. \\<And>ts us name.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     veq_structure x1 x2 \\<and>\n                     (vno_abs x2 \\<longrightarrow> x1 = x2))\n                 ts us;\n        vno_abs (Vconstr name us)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name ts = Vconstr name us", "with constr_constr"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x2 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name us)\n  list_all vno_abs us \\<Longrightarrow> ts = us", "show ?case"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       veq_structure x1 x2 \\<and> (vno_abs x2 \\<longrightarrow> x1 = x2))\n   ts us\n  vno_abs (Vconstr name us)\n  list_all vno_abs us \\<Longrightarrow> ts = us\n\ngoal (1 subgoal):\n 1. Vconstr name ts = Vconstr name us", "by auto"], ["proof (state)\nthis:\n  Vconstr name ts = Vconstr name us\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       vno_abs (Vabs uw_ ux_) \\<Longrightarrow> Vabs uu_ uv_ = Vabs uw_ ux_\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       vno_abs (Vrecabs vb_ vc_ vd_) \\<Longrightarrow>\n       Vrecabs uy_ uz_ va_ = Vrecabs vb_ vc_ vd_", "qed auto"], ["", "fun vmatch' :: \"pat \\<Rightarrow> value \\<Rightarrow> (name, value) fmap option\" where\n\"vmatch' (Patvar name) v = Some (fmap_of_list [(name, v)])\" |\n\"vmatch' (Patconstr name ps) v =\n  (case v of\n    Vconstr name' vs \\<Rightarrow>\n      (if name = name' \\<and> length ps = length vs then\n        map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch' ps vs))\n      else\n        None)\n  | _ \\<Rightarrow> None)\""], ["", "lemma vmatch_vmatch'_eq: \"vmatch p v = vmatch' p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vmatch p v = vmatch' p v", "proof (induction rule: vmatch.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name v. vmatch (Patvar name) v = vmatch' (Patvar name) v\n 2. \\<And>name ps name' vs.\n       (\\<And>x y.\n           \\<lbrakk>name = name' \\<and> length ps = length vs;\n            x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n           \\<Longrightarrow> vmatch x y = vmatch' x y) \\<Longrightarrow>\n       vmatch (Patconstr name ps) (Vconstr name' vs) =\n       vmatch' (Patconstr name ps) (Vconstr name' vs)\n 3. \\<And>v va vb vc.\n       vmatch (Patconstr v va) (Vabs vb vc) =\n       vmatch' (Patconstr v va) (Vabs vb vc)\n 4. \\<And>v va vb vc vd.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       vmatch' (Patconstr v va) (Vrecabs vb vc vd)", "case (2 name ps name' vs)"], ["proof (state)\nthis:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> vmatch ?x ?y = vmatch' ?x ?y\n\ngoal (4 subgoals):\n 1. \\<And>name v. vmatch (Patvar name) v = vmatch' (Patvar name) v\n 2. \\<And>name ps name' vs.\n       (\\<And>x y.\n           \\<lbrakk>name = name' \\<and> length ps = length vs;\n            x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n           \\<Longrightarrow> vmatch x y = vmatch' x y) \\<Longrightarrow>\n       vmatch (Patconstr name ps) (Vconstr name' vs) =\n       vmatch' (Patconstr name ps) (Vconstr name' vs)\n 3. \\<And>v va vb vc.\n       vmatch (Patconstr v va) (Vabs vb vc) =\n       vmatch' (Patconstr v va) (Vabs vb vc)\n 4. \\<And>v va vb vc vd.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       vmatch' (Patconstr v va) (Vrecabs vb vc vd)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> vmatch ?x ?y = vmatch' ?x ?y", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x \\<in> set ps;\n   ?y \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> vmatch ?x ?y = vmatch' ?x ?y\n\ngoal (1 subgoal):\n 1. vmatch (Patconstr name ps) (Vconstr name' vs) =\n    vmatch' (Patconstr name ps) (Vconstr name' vs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n                \\<Longrightarrow> vmatch x y = vmatch' x y;\n     length ps = length vs; name = name'\\<rbrakk>\n    \\<Longrightarrow> map_option (foldl (++\\<^sub>f) fmempty)\n                       (those (Term_Utils.map2 vmatch ps vs)) =\n                      map_option (foldl (++\\<^sub>f) fmempty)\n                       (those (Term_Utils.map2 vmatch' ps vs))", "apply (rule map_option_cong[OF _ refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n                \\<Longrightarrow> vmatch x y = vmatch' x y;\n     length ps = length vs; name = name'\\<rbrakk>\n    \\<Longrightarrow> those (Term_Utils.map2 vmatch ps vs) =\n                      those (Term_Utils.map2 vmatch' ps vs)", "apply (rule arg_cong[where f = those])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n                \\<Longrightarrow> vmatch x y = vmatch' x y;\n     length ps = length vs; name = name'\\<rbrakk>\n    \\<Longrightarrow> Term_Utils.map2 vmatch ps vs =\n                      Term_Utils.map2 vmatch' ps vs", "apply (rule map2_cong[OF refl refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n                   \\<Longrightarrow> vmatch x y = vmatch' x y;\n        length ps = length vs; name = name'; x \\<in> set ps;\n        y \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> vmatch x y = vmatch' x y", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vmatch (Patconstr name ps) (Vconstr name' vs) =\n  vmatch' (Patconstr name ps) (Vconstr name' vs)\n\ngoal (3 subgoals):\n 1. \\<And>name v. vmatch (Patvar name) v = vmatch' (Patvar name) v\n 2. \\<And>v va vb vc.\n       vmatch (Patconstr v va) (Vabs vb vc) =\n       vmatch' (Patconstr v va) (Vabs vb vc)\n 3. \\<And>v va vb vc vd.\n       vmatch (Patconstr v va) (Vrecabs vb vc vd) =\n       vmatch' (Patconstr v va) (Vrecabs vb vc vd)", "qed auto"], ["", "locale value_struct_rel =\n  fixes Q :: \"value \\<Rightarrow> value \\<Rightarrow> bool\"\n  assumes Q_impl_struct: \"Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow> veq_structure t\\<^sub>1 t\\<^sub>2\"\n  assumes Q_def[simp]: \"Q (Vconstr name ts) (Vconstr name' us) \\<longleftrightarrow> name = name' \\<and> list_all2 Q ts us\"\nbegin"], ["", "lemma eq_left: \"Q t u \\<Longrightarrow> vno_abs t \\<Longrightarrow> t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q t u; vno_abs t\\<rbrakk> \\<Longrightarrow> t = u", "using Q_impl_struct"], ["proof (prove)\nusing this:\n  Q ?t\\<^sub>1 ?t\\<^sub>2 \\<Longrightarrow>\n  veq_structure ?t\\<^sub>1 ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q t u; vno_abs t\\<rbrakk> \\<Longrightarrow> t = u", "by (metis veq_structure_eq_left)"], ["", "lemma eq_right: \"Q t u \\<Longrightarrow> vno_abs u \\<Longrightarrow> t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q t u; vno_abs u\\<rbrakk> \\<Longrightarrow> t = u", "using Q_impl_struct"], ["proof (prove)\nusing this:\n  Q ?t\\<^sub>1 ?t\\<^sub>2 \\<Longrightarrow>\n  veq_structure ?t\\<^sub>1 ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q t u; vno_abs u\\<rbrakk> \\<Longrightarrow> t = u", "by (metis veq_structure_eq_right)"], ["", "context begin"], ["", "private"], ["", "lemma vmatch'_rel:\n  assumes \"Q t\\<^sub>1 t\\<^sub>2\"\n  shows \"rel_option (fmrel Q) (vmatch' p t\\<^sub>1) (vmatch' p t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' p t\\<^sub>1) (vmatch' p t\\<^sub>2)", "using assms(1)"], ["proof (prove)\nusing this:\n  Q t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' p t\\<^sub>1) (vmatch' p t\\<^sub>2)", "proof (induction p arbitrary: t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t\\<^sub>1 t\\<^sub>2.\n       Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n       rel_option (fmrel Q) (vmatch' (Patvar x) t\\<^sub>1)\n        (vmatch' (Patvar x) t\\<^sub>2)\n 2. \\<And>x1a x2 t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set x2; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>1)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>2)", "case (Patconstr name ps)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set ps; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q t\\<^sub>1 t\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x t\\<^sub>1 t\\<^sub>2.\n       Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n       rel_option (fmrel Q) (vmatch' (Patvar x) t\\<^sub>1)\n        (vmatch' (Patvar x) t\\<^sub>2)\n 2. \\<And>x1a x2 t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set x2; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>1)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>2)", "with Q_impl_struct"], ["proof (chain)\npicking this:\n  Q ?t\\<^sub>1 ?t\\<^sub>2 \\<Longrightarrow>\n  veq_structure ?t\\<^sub>1 ?t\\<^sub>2\n  \\<lbrakk>?x2a \\<in> set ps; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q t\\<^sub>1 t\\<^sub>2", "have \"veq_structure t\\<^sub>1 t\\<^sub>2\""], ["proof (prove)\nusing this:\n  Q ?t\\<^sub>1 ?t\\<^sub>2 \\<Longrightarrow>\n  veq_structure ?t\\<^sub>1 ?t\\<^sub>2\n  \\<lbrakk>?x2a \\<in> set ps; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. veq_structure t\\<^sub>1 t\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  veq_structure t\\<^sub>1 t\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x t\\<^sub>1 t\\<^sub>2.\n       Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n       rel_option (fmrel Q) (vmatch' (Patvar x) t\\<^sub>1)\n        (vmatch' (Patvar x) t\\<^sub>2)\n 2. \\<And>x1a x2 t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set x2; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>1)\n                          (vmatch' (Patconstr x1a x2) t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  veq_structure t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' (Patconstr name ps) t\\<^sub>1)\n     (vmatch' (Patconstr name ps) t\\<^sub>2)", "proof (cases rule: veq_structure.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "case (constr_constr ts us name')"], ["proof (state)\nthis:\n  t\\<^sub>1 = Vconstr name' ts\n  t\\<^sub>2 = Vconstr name' us\n  list_all2 veq_structure ts us\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "{"], ["proof (state)\nthis:\n  t\\<^sub>1 = Vconstr name' ts\n  t\\<^sub>2 = Vconstr name' us\n  list_all2 veq_structure ts us\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "assume \"length ps = length ts\""], ["proof (state)\nthis:\n  length ps = length ts\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "have \"list_all2 (rel_option (fmrel Q)) (map2 vmatch' ps ts) (map2 vmatch' ps us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n     (Term_Utils.map2 vmatch' ps us)", "using \\<open>list_all2 veq_structure ts us\\<close> Patconstr \\<open>length ps = length ts\\<close>"], ["proof (prove)\nusing this:\n  list_all2 veq_structure ts us\n  \\<lbrakk>?x2a \\<in> set ps; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q t\\<^sub>1 t\\<^sub>2\n  length ps = length ts\n\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n     (Term_Utils.map2 vmatch' ps us)", "unfolding \\<open>t\\<^sub>1 = _\\<close> \\<open>t\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2 veq_structure ts us\n  \\<lbrakk>?x2a \\<in> set ps; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' ts) (Vconstr name' us)\n  length ps = length ts\n\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n     (Term_Utils.map2 vmatch' ps us)", "proof (induction arbitrary: ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "case (Cons t ts u us ps0)"], ["proof (state)\nthis:\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set ps0; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ps0 = length (t # ts)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "then"], ["proof (chain)\npicking this:\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set ps0; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ps0 = length (t # ts)", "obtain p ps where \"ps0 = p # ps\""], ["proof (prove)\nusing this:\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set ps0; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ps0 = length (t # ts)\n\ngoal (1 subgoal):\n 1. (\\<And>p ps. ps0 = p # ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ps0) auto"], ["proof (state)\nthis:\n  ps0 = p # ps\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "have \"length ts = length us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts = length us", "using Cons"], ["proof (prove)\nusing this:\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set ps0; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ps0 = length (t # ts)\n\ngoal (1 subgoal):\n 1. length ts = length us", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length ts = length us\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "hence \"Q t u\""], ["proof (prove)\nusing this:\n  length ts = length us\n\ngoal (1 subgoal):\n 1. Q t u", "using \\<open>Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\\<close>"], ["proof (prove)\nusing this:\n  length ts = length us\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n\ngoal (1 subgoal):\n 1. Q t u", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  Q t u\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "hence \"rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\""], ["proof (prove)\nusing this:\n  Q t u\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)", "using Cons"], ["proof (prove)\nusing this:\n  Q t u\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set ps0; Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ps0 = length (t # ts)\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)", "unfolding \\<open>ps0 = _\\<close>"], ["proof (prove)\nusing this:\n  Q t u\n  veq_structure t u\n  list_all2 veq_structure ts us\n  \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n              \\<lbrakk>x2a \\<in> set ?ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                                 (vmatch' x2a t\\<^sub>2);\n   Q (Vconstr name' ts) (Vconstr name' us); length ?ps = length ts\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                     (Term_Utils.map2 vmatch' ?ps ts)\n                     (Term_Utils.map2 vmatch' ?ps us)\n  \\<lbrakk>?x2a \\<in> set (p # ps); Q ?t\\<^sub>1 ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> rel_option (fmrel Q) (vmatch' ?x2a ?t\\<^sub>1)\n                     (vmatch' ?x2a ?t\\<^sub>2)\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length (p # ps) = length (t # ts)\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)", "by simp"], ["proof (state)\nthis:\n  rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "moreover"], ["proof (state)\nthis:\n  rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "have \"list_all2 (rel_option (fmrel Q)) (map2 vmatch' ps ts) (map2 vmatch' ps us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n     (Term_Utils.map2 vmatch' ps us)", "apply (rule Cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                          (vmatch' x2a t\\<^sub>2)\n 2. Q (Vconstr name' ts) (Vconstr name' us)\n 3. length ps = length ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a_ t\\<^sub>1_)\n                       (vmatch' x2a_ t\\<^sub>2_)", "apply (rule Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> x2a_ \\<in> set ps0\n 2. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> Q t\\<^sub>1_ t\\<^sub>2_", "unfolding \\<open>ps0 = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> x2a_ \\<in> set (p # ps)\n 2. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> Q t\\<^sub>1_ t\\<^sub>2_", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2a_ \\<in> set ps; Q t\\<^sub>1_ t\\<^sub>2_\\<rbrakk>\n    \\<Longrightarrow> Q t\\<^sub>1_ t\\<^sub>2_", "by assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q (Vconstr name' ts) (Vconstr name' us)\n 2. length ps = length ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (Vconstr name' ts) (Vconstr name' us)", "using \\<open>Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\\<close> \\<open>length ts = length us\\<close>"], ["proof (prove)\nusing this:\n  Q (Vconstr name' (t # ts)) (Vconstr name' (u # us))\n  length ts = length us\n\ngoal (1 subgoal):\n 1. Q (Vconstr name' ts) (Vconstr name' us)", "by (simp add: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps = length ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps = length ts", "using \\<open>length ps0 = length (t # ts)\\<close>"], ["proof (prove)\nusing this:\n  length ps0 = length (t # ts)\n\ngoal (1 subgoal):\n 1. length ps = length ts", "unfolding \\<open>ps0 = _\\<close>"], ["proof (prove)\nusing this:\n  length (p # ps) = length (t # ts)\n\ngoal (1 subgoal):\n 1. length ps = length ts", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])\n 2. \\<And>x xs y ys ps.\n       \\<lbrakk>veq_structure x y; list_all2 veq_structure xs ys;\n        \\<And>ps.\n           \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                       \\<lbrakk>x2a \\<in> set ps;\n                        Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> rel_option (fmrel Q)\n    (vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n            Q (Vconstr name' xs) (Vconstr name' ys);\n            length ps = length xs\\<rbrakk>\n           \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                              (Term_Utils.map2 vmatch' ps xs)\n                              (Term_Utils.map2 vmatch' ps ys);\n        \\<And>x2a t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> rel_option (fmrel Q) (vmatch' x2a t\\<^sub>1)\n                              (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' (x # xs)) (Vconstr name' (y # ys));\n        length ps = length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps (x # xs))\n                          (Term_Utils.map2 vmatch' ps (y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)", "show ?case"], ["proof (prove)\nusing this:\n  rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)\n\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps0 (t # ts))\n     (Term_Utils.map2 vmatch' ps0 (u # us))", "unfolding \\<open>ps0 = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option (fmrel Q) (vmatch' p t) (vmatch' p u)\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)\n\ngoal (1 subgoal):\n 1. list_all2 (rel_option (fmrel Q))\n     (Term_Utils.map2 vmatch' (p # ps) (t # ts))\n     (Term_Utils.map2 vmatch' (p # ps) (u # us))", "by auto"], ["proof (state)\nthis:\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps0 (t # ts))\n   (Term_Utils.map2 vmatch' ps0 (u # us))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>\\<And>x2a t\\<^sub>1 t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ps; Q t\\<^sub>1 t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (fmrel Q)\n(vmatch' x2a t\\<^sub>1) (vmatch' x2a t\\<^sub>2);\n        Q (Vconstr name' []) (Vconstr name' []);\n        length ps = length []\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_option (fmrel Q))\n                          (Term_Utils.map2 vmatch' ps [])\n                          (Term_Utils.map2 vmatch' ps [])", "qed auto"], ["proof (state)\nthis:\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "hence \"rel_option (list_all2 (fmrel Q)) (those (map2 vmatch' ps ts)) (those (map2 vmatch' ps us))\""], ["proof (prove)\nusing this:\n  list_all2 (rel_option (fmrel Q)) (Term_Utils.map2 vmatch' ps ts)\n   (Term_Utils.map2 vmatch' ps us)\n\ngoal (1 subgoal):\n 1. rel_option (list_all2 (fmrel Q)) (those (Term_Utils.map2 vmatch' ps ts))\n     (those (Term_Utils.map2 vmatch' ps us))", "by (rule rel_funD[OF those_transfer])"], ["proof (state)\nthis:\n  rel_option (list_all2 (fmrel Q)) (those (Term_Utils.map2 vmatch' ps ts))\n   (those (Term_Utils.map2 vmatch' ps us))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "have\n          \"rel_option (fmrel Q)\n            (map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch' ps ts)))\n            (map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch' ps us)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (fmrel Q)\n     (map_option (foldl (++\\<^sub>f) fmempty)\n       (those (Term_Utils.map2 vmatch' ps ts)))\n     (map_option (foldl (++\\<^sub>f) fmempty)\n       (those (Term_Utils.map2 vmatch' ps us)))", "apply (rule rel_funD[OF rel_funD[OF option.map_transfer]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_fun ?Rb2 (fmrel Q) (foldl (++\\<^sub>f) fmempty)\n     (foldl (++\\<^sub>f) fmempty)\n 2. rel_option ?Rb2 (those (Term_Utils.map2 vmatch' ps ts))\n     (those (Term_Utils.map2 vmatch' ps us))", "apply transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (list_all2 (fmrel Q)) (those (Term_Utils.map2 vmatch' ps ts))\n     (those (Term_Utils.map2 vmatch' ps us))", "by fact"], ["proof (state)\nthis:\n  rel_option (fmrel Q)\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps ts)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "}"], ["proof (state)\nthis:\n  length ps = length ts \\<Longrightarrow>\n  rel_option (fmrel Q)\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps ts)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "note * = this"], ["proof (state)\nthis:\n  length ps = length ts \\<Longrightarrow>\n  rel_option (fmrel Q)\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps ts)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch' ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "have \"length ts = length us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts = length us", "using constr_constr"], ["proof (prove)\nusing this:\n  t\\<^sub>1 = Vconstr name' ts\n  t\\<^sub>2 = Vconstr name' us\n  list_all2 veq_structure ts us\n\ngoal (1 subgoal):\n 1. length ts = length us", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length ts = length us\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 3. \\<And>ts us namea.\n       \\<lbrakk>t\\<^sub>1 = Vconstr namea ts; t\\<^sub>2 = Vconstr namea us;\n        list_all2 veq_structure ts us\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length ts = length us\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' (Patconstr name ps) t\\<^sub>1)\n     (vmatch' (Patconstr name ps) t\\<^sub>2)", "unfolding \\<open>t\\<^sub>1 = _\\<close> \\<open>t\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  length ts = length us\n\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch' (Patconstr name ps) (Vconstr name' ts))\n     (vmatch' (Patconstr name ps) (Vconstr name' us))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ts = length us; name = name';\n     length ps = length us\\<rbrakk>\n    \\<Longrightarrow> rel_option (fmrel Q)\n                       (map_option (foldl (++\\<^sub>f) fmempty)\n                         (those (Term_Utils.map2 vmatch' ps ts)))\n                       (map_option (foldl (++\\<^sub>f) fmempty)\n                         (those (Term_Utils.map2 vmatch' ps us)))", "apply (rule *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ts = length us; name = name';\n     length ps = length us\\<rbrakk>\n    \\<Longrightarrow> length ps = length ts", "by simp"], ["proof (state)\nthis:\n  rel_option (fmrel Q) (vmatch' (Patconstr name ps) t\\<^sub>1)\n   (vmatch' (Patconstr name ps) t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ uw_ ux_.\n       \\<lbrakk>t\\<^sub>1 = Vabs uu_ uv_; t\\<^sub>2 = Vabs uw_ ux_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)\n 2. \\<And>uy_ uz_ va_ vb_ vc_ vd_.\n       \\<lbrakk>t\\<^sub>1 = Vrecabs uy_ uz_ va_;\n        t\\<^sub>2 = Vrecabs vb_ vc_ vd_\\<rbrakk>\n       \\<Longrightarrow> rel_option (fmrel Q)\n                          (vmatch' (Patconstr name ps) t\\<^sub>1)\n                          (vmatch' (Patconstr name ps) t\\<^sub>2)", "qed auto"], ["proof (state)\nthis:\n  rel_option (fmrel Q) (vmatch' (Patconstr name ps) t\\<^sub>1)\n   (vmatch' (Patconstr name ps) t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x t\\<^sub>1 t\\<^sub>2.\n       Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n       rel_option (fmrel Q) (vmatch' (Patvar x) t\\<^sub>1)\n        (vmatch' (Patvar x) t\\<^sub>2)", "qed auto"], ["", "lemma vmatch_rel: \"Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow> rel_option (fmrel Q) (vmatch p t\\<^sub>1) (vmatch p t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n    rel_option (fmrel Q) (vmatch p t\\<^sub>1) (vmatch p t\\<^sub>2)", "unfolding vmatch_vmatch'_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q t\\<^sub>1 t\\<^sub>2 \\<Longrightarrow>\n    rel_option (fmrel Q) (vmatch' p t\\<^sub>1) (vmatch' p t\\<^sub>2)", "by (rule vmatch'_rel)"], ["", "lemma vfind_match_rel:\n  assumes \"list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\"\n  assumes \"Q t\\<^sub>1 t\\<^sub>2\"\n  shows \"rel_option (rel_prod (fmrel Q) (rel_prod (=) R)) (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)", "using assms(1)"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "case (Cons c\\<^sub>1 cs\\<^sub>1 c\\<^sub>2 cs\\<^sub>2)"], ["proof (state)\nthis:\n  rel_prod (=) R c\\<^sub>1 c\\<^sub>2\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  rel_prod (=) R c\\<^sub>1 c\\<^sub>2\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "obtain pat\\<^sub>1 rhs\\<^sub>1 where \"c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat\\<^sub>1 rhs\\<^sub>1.\n        c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "obtain pat\\<^sub>2 rhs\\<^sub>2 where \"c\\<^sub>2 = (pat\\<^sub>2, rhs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat\\<^sub>2 rhs\\<^sub>2.\n        c\\<^sub>2 = (pat\\<^sub>2, rhs\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c\\<^sub>2 = (pat\\<^sub>2, rhs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  rel_prod (=) R c\\<^sub>1 c\\<^sub>2\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\n  c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1)\n  c\\<^sub>2 = (pat\\<^sub>2, rhs\\<^sub>2)", "have \"pat\\<^sub>1 = pat\\<^sub>2\" \"R rhs\\<^sub>1 rhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  rel_prod (=) R c\\<^sub>1 c\\<^sub>2\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\n  c\\<^sub>1 = (pat\\<^sub>1, rhs\\<^sub>1)\n  c\\<^sub>2 = (pat\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pat\\<^sub>1 = pat\\<^sub>2 &&& R rhs\\<^sub>1 rhs\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  pat\\<^sub>1 = pat\\<^sub>2\n  R rhs\\<^sub>1 rhs\\<^sub>2\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "have \"rel_option (fmrel Q) (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1) (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (fmrel Q) (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1)\n     (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2)", "by (rule vmatch_rel) fact"], ["proof (state)\nthis:\n  rel_option (fmrel Q) (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1)\n   (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) R x y; list_all2 (rel_prod (=) R) xs ys;\n        rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n         (vfind_match xs t\\<^sub>1) (vfind_match ys t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (x # xs) t\\<^sub>1)\n                          (vfind_match (y # ys) t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  rel_option (fmrel Q) (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1)\n   (vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = None;\n     vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = None\\<rbrakk>\n    \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                       (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                       (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)\n 2. \\<And>x y.\n       \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some x;\n        vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some y; fmrel Q x y\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                          (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "case None"], ["proof (state)\nthis:\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = None\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = None;\n     vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = None\\<rbrakk>\n    \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                       (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                       (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)\n 2. \\<And>x y.\n       \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some x;\n        vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some y; fmrel Q x y\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                          (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = None\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = None\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "unfolding \\<open>c\\<^sub>1 = _\\<close> \\<open>c\\<^sub>2 = _\\<close> \\<open>pat\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>1 = None\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>2 = None\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>1) # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>2) # cs\\<^sub>2) t\\<^sub>2)", "using Cons"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>1 = None\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>2 = None\n  rel_prod (=) R c\\<^sub>1 c\\<^sub>2\n  list_all2 (rel_prod (=) R) cs\\<^sub>1 cs\\<^sub>2\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match cs\\<^sub>1 t\\<^sub>1) (vfind_match cs\\<^sub>2 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>1) # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>2) # cs\\<^sub>2) t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n   (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some x;\n        vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some y; fmrel Q x y\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                          (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some x;\n        vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some y; fmrel Q x y\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                          (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "case (Some \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2)"], ["proof (state)\nthis:\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some \\<Gamma>\\<^sub>1\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some \\<Gamma>\\<^sub>2\n  fmrel Q \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some x;\n        vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some y; fmrel Q x y\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n                          (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n                          (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>1 = Some \\<Gamma>\\<^sub>1\n  vmatch (mk_pat pat\\<^sub>1) t\\<^sub>2 = Some \\<Gamma>\\<^sub>2\n  fmrel Q \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)", "unfolding \\<open>c\\<^sub>1 = _\\<close> \\<open>c\\<^sub>2 = _\\<close> \\<open>pat\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>1 = Some \\<Gamma>\\<^sub>1\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>2 = Some \\<Gamma>\\<^sub>2\n  fmrel Q \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>1) # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>2) # cs\\<^sub>2) t\\<^sub>2)", "using \\<open>R rhs\\<^sub>1 rhs\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>1 = Some \\<Gamma>\\<^sub>1\n  vmatch (mk_pat pat\\<^sub>2) t\\<^sub>2 = Some \\<Gamma>\\<^sub>2\n  fmrel Q \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n  R rhs\\<^sub>1 rhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>1) # cs\\<^sub>1) t\\<^sub>1)\n     (vfind_match ((pat\\<^sub>2, rhs\\<^sub>2) # cs\\<^sub>2) t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n   (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n   (vfind_match (c\\<^sub>1 # cs\\<^sub>1) t\\<^sub>1)\n   (vfind_match (c\\<^sub>2 # cs\\<^sub>2) t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel Q) (rel_prod (=) R))\n     (vfind_match [] t\\<^sub>1) (vfind_match [] t\\<^sub>2)", "qed simp"], ["", "lemmas vfind_match_rel' =\n  vfind_match_rel[\n    where R = \"(=)\" and cs\\<^sub>1 = cs and cs\\<^sub>2 = cs for cs,\n    unfolded prod.rel_eq,\n    OF list.rel_refl, OF refl]"], ["", "end"], ["", "end"], ["", "hide_fact vmatch_vmatch'_eq"], ["", "hide_const vmatch'"], ["", "global_interpretation veq_structure: value_struct_rel veq_structure"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_struct_rel veq_structure", "by standard auto"], ["", "abbreviation env_eq where\n\"env_eq \\<equiv> fmrel (\\<lambda>v t. t = value_to_sterm v)\""], ["", "lemma env_eq_eq:\n  assumes \"env_eq venv senv\"\n  shows \"senv = fmmap value_to_sterm venv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. senv = fmmap value_to_sterm venv", "proof (rule fmap_ext, unfold fmlookup_map)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fmlookup senv x = map_option value_to_sterm (fmlookup venv x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fmlookup senv x = map_option value_to_sterm (fmlookup venv x)", "from assms"], ["proof (chain)\npicking this:\n  env_eq venv senv", "have \"rel_option (\\<lambda>v t. t = value_to_sterm v) (fmlookup venv name) (fmlookup senv name)\""], ["proof (prove)\nusing this:\n  env_eq venv senv\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>v t. t = value_to_sterm v) (fmlookup venv name)\n     (fmlookup senv name)", "by auto"], ["proof (state)\nthis:\n  rel_option (\\<lambda>v t. t = value_to_sterm v) (fmlookup venv name)\n   (fmlookup senv name)\n\ngoal (1 subgoal):\n 1. \\<And>x. fmlookup senv x = map_option value_to_sterm (fmlookup venv x)", "thus \"fmlookup senv name = map_option value_to_sterm (fmlookup venv name)\""], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>v t. t = value_to_sterm v) (fmlookup venv name)\n   (fmlookup senv name)\n\ngoal (1 subgoal):\n 1. fmlookup senv name = map_option value_to_sterm (fmlookup venv name)", "by cases auto"], ["proof (state)\nthis:\n  fmlookup senv name = map_option value_to_sterm (fmlookup venv name)\n\ngoal:\nNo subgoals!", "qed"], ["", "context constructors begin"], ["", "context begin"], ["", "private"], ["", "lemma vmatch_eq0: \"rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))", "proof (induction p v rule: vmatch_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name v.\n       rel_option env_eq (vmatch (Patvar name) v)\n        (smatch' (Patvar name) (value_to_sterm v))\n 2. \\<And>name ps name' vs.\n       (\\<And>x y.\n           \\<lbrakk>name = name' \\<and> length ps = length vs;\n            x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x\n                                (value_to_sterm y))) \\<Longrightarrow>\n       rel_option env_eq (vmatch (Patconstr name ps) (Vconstr name' vs))\n        (smatch' (Patconstr name ps) (value_to_sterm (Vconstr name' vs)))\n 3. \\<And>v va vb vc.\n       rel_option env_eq (vmatch (Patconstr v va) (Vabs vb vc))\n        (smatch' (Patconstr v va) (value_to_sterm (Vabs vb vc)))\n 4. \\<And>v va vb vc vd.\n       rel_option env_eq (vmatch (Patconstr v va) (Vrecabs vb vc vd))\n        (smatch' (Patconstr v va) (value_to_sterm (Vrecabs vb vc vd)))", "case (constr name ps name' vs)"], ["proof (state)\nthis:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x1 \\<in> set ps;\n   ?y1 \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq (vmatch ?x1 ?y1)\n                     (smatch' ?x1 (value_to_sterm ?y1))\n\ngoal (4 subgoals):\n 1. \\<And>name v.\n       rel_option env_eq (vmatch (Patvar name) v)\n        (smatch' (Patvar name) (value_to_sterm v))\n 2. \\<And>name ps name' vs.\n       (\\<And>x y.\n           \\<lbrakk>name = name' \\<and> length ps = length vs;\n            x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x\n                                (value_to_sterm y))) \\<Longrightarrow>\n       rel_option env_eq (vmatch (Patconstr name ps) (Vconstr name' vs))\n        (smatch' (Patconstr name ps) (value_to_sterm (Vconstr name' vs)))\n 3. \\<And>v va vb vc.\n       rel_option env_eq (vmatch (Patconstr v va) (Vabs vb vc))\n        (smatch' (Patconstr v va) (value_to_sterm (Vabs vb vc)))\n 4. \\<And>v va vb vc vd.\n       rel_option env_eq (vmatch (Patconstr v va) (Vrecabs vb vc vd))\n        (smatch' (Patconstr v va) (value_to_sterm (Vrecabs vb vc vd)))", "have\n    \"rel_option env_eq\n      (map_option (foldl (++\\<^sub>f) \\<Gamma>) (those (map2 vmatch ps vs)))\n      (map_option (foldl (++\\<^sub>f) \\<Gamma>') (those (map2 smatch' ps (map value_to_sterm vs))))\"\n    if \"length ps = length vs\" and \"name = name'\" and \"env_eq \\<Gamma> \\<Gamma>'\" for \\<Gamma> \\<Gamma>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option env_eq\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch ps vs)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n       (those (Term_Utils.map2 smatch' ps (map value_to_sterm vs))))", "using that constr"], ["proof (prove)\nusing this:\n  length ps = length vs\n  name = name'\n  env_eq \\<Gamma> \\<Gamma>'\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x1 \\<in> set ps;\n   ?y1 \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq (vmatch ?x1 ?y1)\n                     (smatch' ?x1 (value_to_sterm ?y1))\n\ngoal (1 subgoal):\n 1. rel_option env_eq\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch ps vs)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n       (those (Term_Utils.map2 smatch' ps (map value_to_sterm vs))))", "proof (induction arbitrary: \\<Gamma> \\<Gamma>' rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>'.\n       \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>x y.\n           \\<lbrakk>name = name' \\<and> length [] = length [];\n            x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x (value_to_sterm y))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' []\n                                (map value_to_sterm []))))\n 2. \\<And>x xs y ys \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n            \\<And>x y.\n               \\<lbrakk>name = name' \\<and> length xs = length ys;\n                x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n               \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                                  (smatch' x (value_to_sterm y))\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch xs ys)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                                (those\n                                  (Term_Utils.map2 smatch' xs\n                                    (map value_to_sterm ys))));\n        name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>xa ya.\n           \\<lbrakk>name = name' \\<and> length (x # xs) = length (y # ys);\n            xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch xa ya)\n                              (smatch' xa (value_to_sterm ya))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (x # xs) (y # ys))))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' (x # xs)\n                                (map value_to_sterm (y # ys)))))", "case (Cons p ps v vs)"], ["proof (state)\nthis:\n  length ps = length vs\n  \\<lbrakk>name = name'; env_eq ?\\<Gamma>1 ?\\<Gamma>'1;\n   \\<And>x y.\n      \\<lbrakk>name = name' \\<and> length ps = length vs; x \\<in> set ps;\n       y \\<in> set vs\\<rbrakk>\n      \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                         (smatch' x (value_to_sterm y))\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>1)\n                       (those (Term_Utils.map2 vmatch ps vs)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>'1)\n                       (those\n                         (Term_Utils.map2 smatch' ps\n                           (map value_to_sterm vs))))\n  name = name'\n  env_eq \\<Gamma> \\<Gamma>'\n  \\<lbrakk>name = name' \\<and> length (p # ps) = length (v # vs);\n   ?x1 \\<in> set (p # ps); ?y1 \\<in> set (v # vs)\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq (vmatch ?x1 ?y1)\n                     (smatch' ?x1 (value_to_sterm ?y1))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>'.\n       \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>x y.\n           \\<lbrakk>name = name' \\<and> length [] = length [];\n            x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x (value_to_sterm y))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' []\n                                (map value_to_sterm []))))\n 2. \\<And>x xs y ys \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n            \\<And>x y.\n               \\<lbrakk>name = name' \\<and> length xs = length ys;\n                x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n               \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                                  (smatch' x (value_to_sterm y))\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch xs ys)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                                (those\n                                  (Term_Utils.map2 smatch' xs\n                                    (map value_to_sterm ys))));\n        name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>xa ya.\n           \\<lbrakk>name = name' \\<and> length (x # xs) = length (y # ys);\n            xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch xa ya)\n                              (smatch' xa (value_to_sterm ya))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (x # xs) (y # ys))))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' (x # xs)\n                                (map value_to_sterm (y # ys)))))", "hence \"rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))\""], ["proof (prove)\nusing this:\n  length ps = length vs\n  \\<lbrakk>name = name'; env_eq ?\\<Gamma>1 ?\\<Gamma>'1;\n   \\<And>x y.\n      \\<lbrakk>name = name' \\<and> length ps = length vs; x \\<in> set ps;\n       y \\<in> set vs\\<rbrakk>\n      \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                         (smatch' x (value_to_sterm y))\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>1)\n                       (those (Term_Utils.map2 vmatch ps vs)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>'1)\n                       (those\n                         (Term_Utils.map2 smatch' ps\n                           (map value_to_sterm vs))))\n  name = name'\n  env_eq \\<Gamma> \\<Gamma>'\n  \\<lbrakk>name = name' \\<and> length (p # ps) = length (v # vs);\n   ?x1 \\<in> set (p # ps); ?y1 \\<in> set (v # vs)\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq (vmatch ?x1 ?y1)\n                     (smatch' ?x1 (value_to_sterm ?y1))\n\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))", "by auto"], ["proof (state)\nthis:\n  rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Gamma>'.\n       \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>x y.\n           \\<lbrakk>name = name' \\<and> length [] = length [];\n            x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x (value_to_sterm y))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' []\n                                (map value_to_sterm []))))\n 2. \\<And>x xs y ys \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>length xs = length ys;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n            \\<And>x y.\n               \\<lbrakk>name = name' \\<and> length xs = length ys;\n                x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n               \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                                  (smatch' x (value_to_sterm y))\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch xs ys)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                                (those\n                                  (Term_Utils.map2 smatch' xs\n                                    (map value_to_sterm ys))));\n        name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>xa ya.\n           \\<lbrakk>name = name' \\<and> length (x # xs) = length (y # ys);\n            xa \\<in> set (x # xs); ya \\<in> set (y # ys)\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch xa ya)\n                              (smatch' xa (value_to_sterm ya))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (x # xs) (y # ys))))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' (x # xs)\n                                (map value_to_sterm (y # ys)))))", "thus ?case"], ["proof (prove)\nusing this:\n  rel_option env_eq (vmatch p v) (smatch' p (value_to_sterm v))\n\ngoal (1 subgoal):\n 1. rel_option env_eq\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n       (those\n         (Term_Utils.map2 smatch' (p # ps) (map value_to_sterm (v # vs)))))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vmatch p v = None; smatch' p (value_to_sterm v) = None\\<rbrakk>\n    \\<Longrightarrow> rel_option env_eq\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                         (those\n                           (Term_Utils.map2 smatch' (p # ps)\n                             (map value_to_sterm (v # vs)))))\n 2. \\<And>x y.\n       \\<lbrakk>vmatch p v = Some x; smatch' p (value_to_sterm v) = Some y;\n        env_eq x y\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' (p # ps)\n                                (map value_to_sterm (v # vs)))))", "case (Some \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2)"], ["proof (state)\nthis:\n  vmatch p v = Some \\<Gamma>\\<^sub>1\n  smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2\n  env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vmatch p v = None; smatch' p (value_to_sterm v) = None\\<rbrakk>\n    \\<Longrightarrow> rel_option env_eq\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                         (those\n                           (Term_Utils.map2 smatch' (p # ps)\n                             (map value_to_sterm (v # vs)))))\n 2. \\<And>x y.\n       \\<lbrakk>vmatch p v = Some x; smatch' p (value_to_sterm v) = Some y;\n        env_eq x y\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' (p # ps)\n                                (map value_to_sterm (v # vs)))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vmatch p v = Some \\<Gamma>\\<^sub>1\n  smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2\n  env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option env_eq\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n       (those\n         (Term_Utils.map2 smatch' (p # ps) (map value_to_sterm (v # vs)))))", "apply (simp add: option.map_comp comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n     smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n     env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> rel_option env_eq\n                       (map_option\n                         (foldl (++\\<^sub>f)\n                           (\\<Gamma> ++\\<^sub>f \\<Gamma>\\<^sub>1))\n                         (those (Term_Utils.map2 vmatch ps vs)))\n                       (map_option\n                         (foldl (++\\<^sub>f)\n                           (\\<Gamma>' ++\\<^sub>f \\<Gamma>\\<^sub>2))\n                         (those\n                           (Term_Utils.map2 smatch' ps\n                             (map value_to_sterm vs))))", "apply (rule Cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n     smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n     env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> name = name'\n 2. \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n     smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n     env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env_eq (\\<Gamma> ++\\<^sub>f \\<Gamma>\\<^sub>1)\n                       (\\<Gamma>' ++\\<^sub>f \\<Gamma>\\<^sub>2)\n 3. \\<And>x y.\n       \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n        smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n        env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2;\n        name = name' \\<and> length ps = length vs; x \\<in> set ps;\n        y \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                          (smatch' x (value_to_sterm y))", "using Cons"], ["proof (prove)\nusing this:\n  length ps = length vs\n  \\<lbrakk>name = name'; env_eq ?\\<Gamma>1 ?\\<Gamma>'1;\n   \\<And>x y.\n      \\<lbrakk>name = name' \\<and> length ps = length vs; x \\<in> set ps;\n       y \\<in> set vs\\<rbrakk>\n      \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                         (smatch' x (value_to_sterm y))\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>1)\n                       (those (Term_Utils.map2 vmatch ps vs)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>'1)\n                       (those\n                         (Term_Utils.map2 smatch' ps\n                           (map value_to_sterm vs))))\n  name = name'\n  env_eq \\<Gamma> \\<Gamma>'\n  \\<lbrakk>name = name' \\<and> length (p # ps) = length (v # vs);\n   ?x1 \\<in> set (p # ps); ?y1 \\<in> set (v # vs)\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq (vmatch ?x1 ?y1)\n                     (smatch' ?x1 (value_to_sterm ?y1))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n     smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n     env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> name = name'\n 2. \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n     smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n     env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env_eq (\\<Gamma> ++\\<^sub>f \\<Gamma>\\<^sub>1)\n                       (\\<Gamma>' ++\\<^sub>f \\<Gamma>\\<^sub>2)\n 3. \\<And>x y.\n       \\<lbrakk>vmatch p v = Some \\<Gamma>\\<^sub>1;\n        smatch' p (value_to_sterm v) = Some \\<Gamma>\\<^sub>2;\n        env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2;\n        name = name' \\<and> length ps = length vs; x \\<in> set ps;\n        y \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                          (smatch' x (value_to_sterm y))", "by auto"], ["proof (state)\nthis:\n  rel_option env_eq\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n     (those\n       (Term_Utils.map2 smatch' (p # ps) (map value_to_sterm (v # vs)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vmatch p v = None; smatch' p (value_to_sterm v) = None\\<rbrakk>\n    \\<Longrightarrow> rel_option env_eq\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                         (those\n                           (Term_Utils.map2 smatch' (p # ps)\n                             (map value_to_sterm (v # vs)))))", "qed simp"], ["proof (state)\nthis:\n  rel_option env_eq\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (v # vs))))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n     (those\n       (Term_Utils.map2 smatch' (p # ps) (map value_to_sterm (v # vs)))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> \\<Gamma>'.\n       \\<lbrakk>name = name'; env_eq \\<Gamma> \\<Gamma>';\n        \\<And>x y.\n           \\<lbrakk>name = name' \\<and> length [] = length [];\n            x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x (value_to_sterm y))\\<rbrakk>\n       \\<Longrightarrow> rel_option env_eq\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                            (those\n                              (Term_Utils.map2 smatch' []\n                                (map value_to_sterm []))))", "qed fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>length ps = length vs; name = name';\n   env_eq ?\\<Gamma>1 ?\\<Gamma>'1\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>1)\n                       (those (Term_Utils.map2 vmatch ps vs)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>'1)\n                       (those\n                         (Term_Utils.map2 smatch' ps\n                           (map value_to_sterm vs))))\n\ngoal (4 subgoals):\n 1. \\<And>name v.\n       rel_option env_eq (vmatch (Patvar name) v)\n        (smatch' (Patvar name) (value_to_sterm v))\n 2. \\<And>name ps name' vs.\n       (\\<And>x y.\n           \\<lbrakk>name = name' \\<and> length ps = length vs;\n            x \\<in> set ps; y \\<in> set vs\\<rbrakk>\n           \\<Longrightarrow> rel_option env_eq (vmatch x y)\n                              (smatch' x\n                                (value_to_sterm y))) \\<Longrightarrow>\n       rel_option env_eq (vmatch (Patconstr name ps) (Vconstr name' vs))\n        (smatch' (Patconstr name ps) (value_to_sterm (Vconstr name' vs)))\n 3. \\<And>v va vb vc.\n       rel_option env_eq (vmatch (Patconstr v va) (Vabs vb vc))\n        (smatch' (Patconstr v va) (value_to_sterm (Vabs vb vc)))\n 4. \\<And>v va vb vc vd.\n       rel_option env_eq (vmatch (Patconstr v va) (Vrecabs vb vc vd))\n        (smatch' (Patconstr v va) (value_to_sterm (Vrecabs vb vc vd)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ps = length vs; name = name';\n   env_eq ?\\<Gamma>1 ?\\<Gamma>'1\\<rbrakk>\n  \\<Longrightarrow> rel_option env_eq\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>1)\n                       (those (Term_Utils.map2 vmatch ps vs)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>'1)\n                       (those\n                         (Term_Utils.map2 smatch' ps\n                           (map value_to_sterm vs))))\n\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch (Patconstr name ps) (Vconstr name' vs))\n     (smatch' (Patconstr name ps) (value_to_sterm (Vconstr name' vs)))", "apply (auto simp: strip_list_comb_const)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                env_eq \\<Gamma> \\<Gamma>' \\<Longrightarrow>\n                rel_option env_eq\n                 (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                   (those (Term_Utils.map2 vmatch ps vs)))\n                 (map_option (foldl (++\\<^sub>f) \\<Gamma>')\n                   (those\n                     (Term_Utils.map2 smatch' ps (map value_to_sterm vs))));\n     length ps = length vs; name = name'\\<rbrakk>\n    \\<Longrightarrow> rel_option env_eq\n                       (map_option (foldl (++\\<^sub>f) fmempty)\n                         (those (Term_Utils.map2 vmatch ps vs)))\n                       (case const name' of\n                        Sconst name'a \\<Rightarrow>\n                          if name' = name'a \\<and>\n                             length ps = length (map value_to_sterm vs)\n                          then map_option (foldl (++\\<^sub>f) fmempty)\n                                (those\n                                  (Term_Utils.map2 smatch' ps\n                                    (map value_to_sterm vs)))\n                          else None\n                        | Svar x \\<Rightarrow> Map.empty x\n                        | Sabs x \\<Rightarrow> Map.empty x\n                        | sterm1 $\\<^sub>s x \\<Rightarrow> Map.empty x)\n 2. name \\<noteq> name' \\<Longrightarrow>\n    (case const name' of\n     Sconst name' \\<Rightarrow>\n       if name = name' \\<and> length ps = length (map value_to_sterm vs)\n       then map_option (foldl (++\\<^sub>f) fmempty)\n             (those (Term_Utils.map2 smatch' ps (map value_to_sterm vs)))\n       else None\n     | Svar x \\<Rightarrow> Map.empty x | Sabs x \\<Rightarrow> Map.empty x\n     | sterm1 $\\<^sub>s x \\<Rightarrow> Map.empty x) =\n    None\n 3. length ps \\<noteq> length vs \\<Longrightarrow>\n    (case const name' of\n     Sconst name' \\<Rightarrow>\n       if name = name' \\<and> length ps = length (map value_to_sterm vs)\n       then map_option (foldl (++\\<^sub>f) fmempty)\n             (those (Term_Utils.map2 smatch' ps (map value_to_sterm vs)))\n       else None\n     | Svar x \\<Rightarrow> Map.empty x | Sabs x \\<Rightarrow> Map.empty x\n     | sterm1 $\\<^sub>s x \\<Rightarrow> Map.empty x) =\n    None", "apply (subst const_sterm_def, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option env_eq (vmatch (Patconstr name ps) (Vconstr name' vs))\n   (smatch' (Patconstr name ps) (value_to_sterm (Vconstr name' vs)))\n\ngoal (3 subgoals):\n 1. \\<And>name v.\n       rel_option env_eq (vmatch (Patvar name) v)\n        (smatch' (Patvar name) (value_to_sterm v))\n 2. \\<And>v va vb vc.\n       rel_option env_eq (vmatch (Patconstr v va) (Vabs vb vc))\n        (smatch' (Patconstr v va) (value_to_sterm (Vabs vb vc)))\n 3. \\<And>v va vb vc vd.\n       rel_option env_eq (vmatch (Patconstr v va) (Vrecabs vb vc vd))\n        (smatch' (Patconstr v va) (value_to_sterm (Vrecabs vb vc vd)))", "qed auto"], ["", "corollary vmatch_eq:\n  assumes \"linear p\" \"vconstructor_value v\"\n  shows \"rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))", "using assms"], ["proof (prove)\nusing this:\n  linear p\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))", "by (metis smatch_smatch'_eq vmatch_eq0 vconstructor_value.value_to_sterm)"], ["", "end"], ["", "end"], ["", "abbreviation match_related where\n\"match_related \\<equiv> (\\<lambda>(\\<Gamma>\\<^sub>1, pat\\<^sub>1, rhs\\<^sub>1) (\\<Gamma>\\<^sub>2, pat\\<^sub>2, rhs\\<^sub>2). rhs\\<^sub>1 = rhs\\<^sub>2 \\<and> pat\\<^sub>1 = pat\\<^sub>2 \\<and> env_eq \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2)\""], ["", "lemma (in constructors) find_match_eq:\n  assumes \"list_all (linear \\<circ> fst) cs\" \"vconstructor_value v\"\n  shows \"rel_option match_related (vfind_match cs v) (find_match cs (value_to_sterm v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option match_related (vfind_match cs v)\n     (find_match cs (value_to_sterm v))", "using assms"], ["proof (prove)\nusing this:\n  list_all (linear \\<circ> fst) cs\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. rel_option match_related (vfind_match cs v)\n     (find_match cs (value_to_sterm v))", "proof (induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (linear \\<circ> fst) []; vconstructor_value v\\<rbrakk>\n    \\<Longrightarrow> rel_option match_related (vfind_match [] v)\n                       (find_match [] (value_to_sterm v))\n 2. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>list_all (linear \\<circ> fst) cs;\n                 vconstructor_value v\\<rbrakk>\n                \\<Longrightarrow> rel_option match_related\n                                   (vfind_match cs v)\n                                   (find_match cs (value_to_sterm v));\n        list_all (linear \\<circ> fst) (a # cs);\n        vconstructor_value v\\<rbrakk>\n       \\<Longrightarrow> rel_option match_related (vfind_match (a # cs) v)\n                          (find_match (a # cs) (value_to_sterm v))", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) (c # cs)\n  vconstructor_value v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (linear \\<circ> fst) []; vconstructor_value v\\<rbrakk>\n    \\<Longrightarrow> rel_option match_related (vfind_match [] v)\n                       (find_match [] (value_to_sterm v))\n 2. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>list_all (linear \\<circ> fst) cs;\n                 vconstructor_value v\\<rbrakk>\n                \\<Longrightarrow> rel_option match_related\n                                   (vfind_match cs v)\n                                   (find_match cs (value_to_sterm v));\n        list_all (linear \\<circ> fst) (a # cs);\n        vconstructor_value v\\<rbrakk>\n       \\<Longrightarrow> rel_option match_related (vfind_match (a # cs) v)\n                          (find_match (a # cs) (value_to_sterm v))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) (c # cs)\n  vconstructor_value v", "obtain p t where \"c = (p, t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) (c # cs)\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. (\\<And>p t. c = (p, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c = (p, t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (linear \\<circ> fst) []; vconstructor_value v\\<rbrakk>\n    \\<Longrightarrow> rel_option match_related (vfind_match [] v)\n                       (find_match [] (value_to_sterm v))\n 2. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>list_all (linear \\<circ> fst) cs;\n                 vconstructor_value v\\<rbrakk>\n                \\<Longrightarrow> rel_option match_related\n                                   (vfind_match cs v)\n                                   (find_match cs (value_to_sterm v));\n        list_all (linear \\<circ> fst) (a # cs);\n        vconstructor_value v\\<rbrakk>\n       \\<Longrightarrow> rel_option match_related (vfind_match (a # cs) v)\n                          (find_match (a # cs) (value_to_sterm v))", "hence \"rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\""], ["proof (prove)\nusing this:\n  c = (p, t)\n\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))", "using Cons"], ["proof (prove)\nusing this:\n  c = (p, t)\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) (c # cs)\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))", "by (fastforce intro: vmatch_eq)"], ["proof (state)\nthis:\n  rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (linear \\<circ> fst) []; vconstructor_value v\\<rbrakk>\n    \\<Longrightarrow> rel_option match_related (vfind_match [] v)\n                       (find_match [] (value_to_sterm v))\n 2. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>list_all (linear \\<circ> fst) cs;\n                 vconstructor_value v\\<rbrakk>\n                \\<Longrightarrow> rel_option match_related\n                                   (vfind_match cs v)\n                                   (find_match cs (value_to_sterm v));\n        list_all (linear \\<circ> fst) (a # cs);\n        vconstructor_value v\\<rbrakk>\n       \\<Longrightarrow> rel_option match_related (vfind_match (a # cs) v)\n                          (find_match (a # cs) (value_to_sterm v))", "thus ?case"], ["proof (prove)\nusing this:\n  rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\n\ngoal (1 subgoal):\n 1. rel_option match_related (vfind_match (c # cs) v)\n     (find_match (c # cs) (value_to_sterm v))", "using Cons"], ["proof (prove)\nusing this:\n  rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) (c # cs)\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. rel_option match_related (vfind_match (c # cs) v)\n     (find_match (c # cs) (value_to_sterm v))", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option env_eq (vmatch (mk_pat p) v) (match p (value_to_sterm v))\n  \\<lbrakk>list_all (linear \\<circ> fst) cs; vconstructor_value v\\<rbrakk>\n  \\<Longrightarrow> rel_option match_related (vfind_match cs v)\n                     (find_match cs (value_to_sterm v))\n  list_all (linear \\<circ> fst) ((p, t) # cs)\n  vconstructor_value v\n\ngoal (1 subgoal):\n 1. rel_option match_related (vfind_match ((p, t) # cs) v)\n     (find_match ((p, t) # cs) (value_to_sterm v))", "by cases auto"], ["proof (state)\nthis:\n  rel_option match_related (vfind_match (c # cs) v)\n   (find_match (c # cs) (value_to_sterm v))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (linear \\<circ> fst) []; vconstructor_value v\\<rbrakk>\n    \\<Longrightarrow> rel_option match_related (vfind_match [] v)\n                       (find_match [] (value_to_sterm v))", "qed auto"], ["", "inductive erelated :: \"value \\<Rightarrow> value \\<Rightarrow> bool\" (\"_ \\<approx>\\<^sub>e _\") where\nconstr: \"list_all2 erelated ts us \\<Longrightarrow> Vconstr name ts \\<approx>\\<^sub>e Vconstr name us\" |\nabs: \"fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<Longrightarrow> Vabs cs \\<Gamma>\\<^sub>1 \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>2\" |\nrec_abs:\n  \"pred_fmap (\\<lambda>cs. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2) css \\<Longrightarrow>\n     Vrecabs css name \\<Gamma>\\<^sub>1 \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>2\""], ["", "code_pred erelated"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "global_interpretation erelated: value_struct_rel erelated"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_struct_rel erelated", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       t\\<^sub>1 \\<approx>\\<^sub>e t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "fix v\\<^sub>1 v\\<^sub>2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       t\\<^sub>1 \\<approx>\\<^sub>e t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "assume \"v\\<^sub>1 \\<approx>\\<^sub>e v\\<^sub>2\""], ["proof (state)\nthis:\n  v\\<^sub>1 \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       t\\<^sub>1 \\<approx>\\<^sub>e t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "thus \"veq_structure v\\<^sub>1 v\\<^sub>2\""], ["proof (prove)\nusing this:\n  v\\<^sub>1 \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (1 subgoal):\n 1. veq_structure v\\<^sub>1 v\\<^sub>2", "by induction (auto intro: list.rel_mono_strong)"], ["proof (state)\nthis:\n  veq_structure v\\<^sub>1 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "fix name name' and ts us :: \"value list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n       (name = name' \\<and> list_all2 erelated ts us)", "show \"Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us \\<longleftrightarrow> (name = name' \\<and> list_all2 erelated ts us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n    (name = name' \\<and> list_all2 erelated ts us)", "by (auto intro: erelated.intros elim: erelated.cases)"], ["proof (state)\nthis:\n  Vconstr name ts \\<approx>\\<^sub>e Vconstr name' us =\n  (name = name' \\<and> list_all2 erelated ts us)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erelated_refl[intro]: \"t \\<approx>\\<^sub>e t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>e t", "proof (induction t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vconstr x1 x2 \\<approx>\\<^sub>e Vconstr x1 x2\n 2. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> fmran' x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vabs x1 x2 \\<approx>\\<^sub>e Vabs x1 x2\n 3. \\<And>x1 x2 x3.\n       (\\<And>x3a.\n           x3a \\<in> fmran' x3 \\<Longrightarrow>\n           x3a \\<approx>\\<^sub>e x3a) \\<Longrightarrow>\n       Vrecabs x1 x2 x3 \\<approx>\\<^sub>e Vrecabs x1 x2 x3", "case Vrecabs"], ["proof (state)\nthis:\n  ?x3a \\<in> fmran' x3_ \\<Longrightarrow> ?x3a \\<approx>\\<^sub>e ?x3a\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vconstr x1 x2 \\<approx>\\<^sub>e Vconstr x1 x2\n 2. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> fmran' x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vabs x1 x2 \\<approx>\\<^sub>e Vabs x1 x2\n 3. \\<And>x1 x2 x3.\n       (\\<And>x3a.\n           x3a \\<in> fmran' x3 \\<Longrightarrow>\n           x3a \\<approx>\\<^sub>e x3a) \\<Longrightarrow>\n       Vrecabs x1 x2 x3 \\<approx>\\<^sub>e Vrecabs x1 x2 x3", "thus ?case"], ["proof (prove)\nusing this:\n  ?x3a \\<in> fmran' x3_ \\<Longrightarrow> ?x3a \\<approx>\\<^sub>e ?x3a\n\ngoal (1 subgoal):\n 1. Vrecabs x1_ x2_ x3_ \\<approx>\\<^sub>e Vrecabs x1_ x2_ x3_", "apply (auto intro!: erelated.intros fmpredI fmrel_on_fset_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>\\<And>x3a.\n                   x3a \\<in> fmran' x3_ \\<Longrightarrow>\n                   x3a \\<approx>\\<^sub>e x3a;\n        fmlookup x1_ x = Some y; xa |\\<in>| ids (Sabs y);\n        fmlookup x3_ xa = Some ya\\<rbrakk>\n       \\<Longrightarrow> ya \\<approx>\\<^sub>e ya", "apply (auto intro: fmran'I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Vrecabs x1_ x2_ x3_ \\<approx>\\<^sub>e Vrecabs x1_ x2_ x3_\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vconstr x1 x2 \\<approx>\\<^sub>e Vconstr x1 x2\n 2. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> fmran' x2 \\<Longrightarrow>\n           x2a \\<approx>\\<^sub>e x2a) \\<Longrightarrow>\n       Vabs x1 x2 \\<approx>\\<^sub>e Vabs x1 x2", "qed (auto intro!: erelated.intros list.rel_refl_strong fmrel_on_fset_refl_strong fmran'I)"], ["", "export_code\n  value_to_sterm vmatch vwellformed vclosed erelated_i_i pre_constants.vwelldefined\n  constructors.vconstructor_value_rs pre_constants.not_shadows_vconsts term_to_value\n  vfind_match veq_structure vno_abs\n  checking Scala"], ["", "end"]]}