{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Rewriting_Nterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma (in nrules) nrewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"closed t\"\n  shows \"closed t'\"", "lemma term_to_nterm_all_vars0:\n  assumes \"wellformed' (length \\<Gamma>) t\"\n  shows \"\\<exists>T. all_frees (fst (run_state (term_to_nterm \\<Gamma> t) x)) |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| T \\<and> fBall T (\\<lambda>y. y > x)\"", "lemma term_to_nterm_all_vars:\n  assumes \"wellformed t\" \"fdisjnt (frees t) S\"\n  shows \"fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S\"", "lemma translate_rule_alt_def:\n  \"translate_rule S = (\\<lambda>(lhs, rhs). (lhs, fresh_frun (term_to_nterm [] rhs) (frees lhs |\\<union>| S)))\"", "lemma compile'_compile_eq[simp]: \"compile' C_info rs = compile\"", "lemma compile_heads: \"heads_of compile = heads_of rs\"", "lemma compile_rules: \"nrules C_info compile\"", "theorem (in rules) compile_correct:\n  assumes \"compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\" \"closed u\"\n  shows \"rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'\"", "lemma compile_complete0:\n  assumes \"rs \\<turnstile> t \\<longrightarrow> t'\" \"closed t\" \"wellformed t\"\n  obtains u' where \"compile \\<turnstile>\\<^sub>n fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\" \"u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\"", "lemma compile_complete:\n  assumes \"rs \\<turnstile> t \\<longrightarrow> t'\" \"closed t\" \"wellformed t\"\n  obtains u' where \"compile \\<turnstile>\\<^sub>n term_to_nterm' t \\<longrightarrow> u'\" \"u' \\<approx>\\<^sub>\\<alpha> term_to_nterm' t'\"", "lemma arity_compatible_length:\n  assumes \"arity_compatibles rs\" \"(pats, rhs) |\\<in>| rs\"\n  shows \"length pats = arity rs\"", "lemma (in pre_crules) crulesI:\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> arity_compatibles crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> is_fmap crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> patterns_compatibles crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> crs \\<noteq> {||}\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> linears pats\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> pats \\<noteq> []\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> fdisjnt (freess pats) all_consts\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> \\<not> shadows_consts rhs\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> welldefined rhs\"\n  assumes \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  shows \"crules C_info rs\"", "lemmas crulesI[intro!] = pre_crules.crulesI[unfolded pre_crules_def]", "lemma consts_of_heads: \"fst |`| consts_of rs = heads_of rs\"", "lemma (in nrules) consts_rules: \"crules C_info (consts_of rs)\""], "translations": [["", "lemma (in nrules) nrewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"closed t\"\n  shows \"closed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. closed t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "case (step r t u)"], ["proof (state)\nthis:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> u\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "obtain lhs rhs where \"r = (lhs, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lhs rhs.\n        r = (lhs, rhs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r = (lhs, rhs)\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "with step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> u\n  closed t\n  r = (lhs, rhs)", "have \"nrule (lhs, rhs)\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> u\n  closed t\n  r = (lhs, rhs)\n\ngoal (1 subgoal):\n 1. nrule (lhs, rhs)", "using all_rules"], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> u\n  closed t\n  r = (lhs, rhs)\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. nrule (lhs, rhs)", "by blast"], ["proof (state)\nthis:\n  nrule (lhs, rhs)\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "hence \"frees rhs |\\<subseteq>| frees lhs\""], ["proof (prove)\nusing this:\n  nrule (lhs, rhs)\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "by simp"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "have \"(lhs, rhs) \\<turnstile> t \\<rightarrow> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lhs, rhs) \\<turnstile> t \\<rightarrow> u", "using step"], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> u\n  closed t\n\ngoal (1 subgoal):\n 1. (lhs, rhs) \\<turnstile> t \\<rightarrow> u", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| rs\n  (lhs, rhs) \\<turnstile> t \\<rightarrow> u\n  closed t\n\ngoal (1 subgoal):\n 1. (lhs, rhs) \\<turnstile> t \\<rightarrow> u", "by simp"], ["proof (state)\nthis:\n  (lhs, rhs) \\<turnstile> t \\<rightarrow> u\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "apply (rule rewrite_step_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. frees ?t\\<^sub>2 |\\<subseteq>| frees ?t\\<^sub>1\n 2. (?t\\<^sub>1, ?t\\<^sub>2) \\<turnstile> ?u \\<rightarrow> u\n 3. closed ?u", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed u\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "case beta"], ["proof (state)\nthis:\n  closed ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_)\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       closed (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst t_ (fmap_of_list [(x_, t'_)]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst t_ (fmupd x_ t'_ fmempty))", "apply (subst closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst t_ (fmupd x_ t'_ fmempty)) |\\<subseteq>| {||}", "apply (subst subst_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env (fmupd x_ t'_ fmempty)\n 2. frees t_ |-| fmdom (fmupd x_ t'_ fmempty) |\\<subseteq>| {||}", "using beta"], ["proof (prove)\nusing this:\n  closed ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_)\n\ngoal (2 subgoals):\n 1. closed_env (fmupd x_ t'_ fmempty)\n 2. frees t_ |-| fmdom (fmupd x_ t'_ fmempty) |\\<subseteq>| {||}", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_) |\\<subseteq>| {||}\n\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_ t. frees t |\\<subseteq>| {||}) (fmupd x_ t'_ fmempty)\n 2. frees t_ |-| fmdom (fmupd x_ t'_ fmempty) |\\<subseteq>| {||}", "by auto"], ["proof (state)\nthis:\n  closed (subst t_ (fmap_of_list [(x_, t'_)]))\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>n u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>n u')", "qed (auto simp: closed_except_def)"], ["", "corollary (in nrules) nrewrite_rt_closed:\n  assumes \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\" \"closed t\"\n  shows \"closed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\n  closed t\n\ngoal (1 subgoal):\n 1. closed t'", "by induction (auto intro: nrewrite_closed)"], ["", "subsection \\<open>Translation from @{typ term} to @{typ nterm}\\<close>"], ["", "context begin"], ["", "private"], ["", "lemma term_to_nterm_all_vars0:\n  assumes \"wellformed' (length \\<Gamma>) t\"\n  shows \"\\<exists>T. all_frees (fst (run_state (term_to_nterm \\<Gamma> t) x)) |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| T \\<and> fBall T (\\<lambda>y. y > x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> t) x)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| T \\<and>\n       fBall T ((<) x)", "using assms"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) t\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> t) x)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| T \\<and>\n       fBall T ((<) x)", "proof (induction \\<Gamma> t arbitrary: x rule: term_to_nterm_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> n x.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                  x)) |\\<subseteq>|\n          fset_of_list \\<Gamma> |\\<union>| frees (Bound n) |\\<union>|\n          T \\<and>\n          fBall T ((<) x)\n 4. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "case (bound \\<Gamma> i)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>) (Bound i)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> n x.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                  x)) |\\<subseteq>|\n          fset_of_list \\<Gamma> |\\<union>| frees (Bound n) |\\<union>|\n          T \\<and>\n          fBall T ((<) x)\n 4. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "hence \"\\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Bound i)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>", "by (simp add: fset_of_list_elem)"], ["proof (state)\nthis:\n  \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> n x.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                  x)) |\\<subseteq>|\n          fset_of_list \\<Gamma> |\\<union>| frees (Bound n) |\\<union>|\n          T \\<and>\n          fBall T ((<) x)\n 4. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "with bound"], ["proof (chain)\npicking this:\n  wellformed' (length \\<Gamma>) (Bound i)\n  \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>", "show ?case"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Bound i)\n  \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) x)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees (Bound i) |\\<union>| T \\<and>\n       fBall T ((<) x)", "by (auto simp: State_Monad.return_def)"], ["proof (state)\nthis:\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) x)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees (Bound i) |\\<union>| T \\<and>\n     fBall T ((<) x)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "case (abs \\<Gamma> t)"], ["proof (state)\nthis:\n  wellformed' (length (?x # \\<Gamma>)) t \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?xa)) |\\<subseteq>|\n     fset_of_list (?x # \\<Gamma>) |\\<union>| frees t |\\<union>| T \\<and>\n     fBall T ((<) ?xa)\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "obtain T\n    where \"all_frees (fst (run_state (term_to_nterm (next x # \\<Gamma>) t) (next x))) |\\<subseteq>| fset_of_list (next x # \\<Gamma>) |\\<union>| frees t |\\<union>| T\"\n      and \"fBall T ((<) (next x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>all_frees\n                  (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n                         (next x))) |\\<subseteq>|\n                 fset_of_list (next x # \\<Gamma>) |\\<union>|\n                 frees t |\\<union>|\n                 T;\n         fBall T ((<) (next x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n               (next x))) |\\<subseteq>|\n       fset_of_list (next x # \\<Gamma>) |\\<union>| frees t |\\<union>|\n       T \\<and>\n       fBall T ((<) (next x))", "apply (rule abs(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length (next x # \\<Gamma>)) t", "using abs"], ["proof (prove)\nusing this:\n  wellformed' (length (?x # \\<Gamma>)) t \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?xa)) |\\<subseteq>|\n     fset_of_list (?x # \\<Gamma>) |\\<union>| frees t |\\<union>| T \\<and>\n     fBall T ((<) ?xa)\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n\ngoal (1 subgoal):\n 1. wellformed' (length (next x # \\<Gamma>)) t", "by auto"], ["proof (state)\nthis:\n  all_frees\n   (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n          (next x))) |\\<subseteq>|\n  fset_of_list (next x # \\<Gamma>) |\\<union>| frees t |\\<union>| T\n  fBall T ((<) (next x))\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t x.\n       \\<lbrakk>\\<And>x xa.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                              xa)) |\\<subseteq>|\n                      fset_of_list (x # \\<Gamma>) |\\<union>|\n                      frees t |\\<union>|\n                      T \\<and>\n                      fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (\\<Lambda> t) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t))\n               x)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees (\\<Lambda> t) |\\<union>|\n       T \\<and>\n       fBall T ((<) x)", "apply (simp add: split_beta create_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       (next x |\\<in>| fset_of_list \\<Gamma> \\<or>\n        next x |\\<in>| frees t \\<or> next x |\\<in>| T) \\<and>\n       all_frees\n        (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n               (next x))) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| T \\<and>\n       fBall T ((<) x)", "apply (rule exI[where x = \"finsert (next x) T\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (next x |\\<in>| fset_of_list \\<Gamma> \\<or>\n     next x |\\<in>| frees t \\<or> next x |\\<in>| finsert (next x) T) \\<and>\n    all_frees\n     (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n            (next x))) |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>|\n    finsert (next x) T \\<and>\n    fBall (finsert (next x) T) ((<) x)", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. next x |\\<in>| fset_of_list \\<Gamma> \\<or>\n    next x |\\<in>| frees t \\<or> next x |\\<in>| finsert (next x) T\n 2. all_frees\n     (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n            (next x))) |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| finsert (next x) T\n 3. fBall (finsert (next x) T) ((<) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. next x |\\<in>| fset_of_list \\<Gamma> \\<or>\n    next x |\\<in>| frees t \\<or> next x |\\<in>| finsert (next x) T", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_frees\n     (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n            (next x))) |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| finsert (next x) T\n 2. fBall (finsert (next x) T) ((<) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees\n     (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n            (next x))) |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| finsert (next x) T", "using \\<open>all_frees (fst (run_state _ (next x))) |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  all_frees\n   (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n          (next x))) |\\<subseteq>|\n  fset_of_list (next x # \\<Gamma>) |\\<union>| frees t |\\<union>| T\n\ngoal (1 subgoal):\n 1. all_frees\n     (fst (run_state (term_to_nterm (next x # \\<Gamma>) t)\n            (next x))) |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t |\\<union>| finsert (next x) T", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (finsert (next x) T) ((<) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (finsert (next x) T) ((<) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < next x \\<and> fBall T ((<) x)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < next x\n 2. fBall T ((<) x)", "apply (rule next_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall T ((<) x)", "using \\<open>fBall T ((<) (next x))\\<close>"], ["proof (prove)\nusing this:\n  fBall T ((<) (next x))\n\ngoal (1 subgoal):\n 1. fBall T ((<) x)", "by (metis fBallE fBallI fresh_class.next_ge order.strict_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t))\n             x)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees (\\<Lambda> t) |\\<union>|\n     T \\<and>\n     fBall T ((<) x)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "case (app \\<Gamma> t\\<^sub>1 t\\<^sub>2 x\\<^sub>1)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) ?x)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T \\<and>\n     fBall T ((<) ?x)\n  wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) ?xa)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T \\<and>\n     fBall T ((<) ?xa)\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "obtain t\\<^sub>1' x\\<^sub>2 where \"run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 = (t\\<^sub>1', x\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>1' x\\<^sub>2.\n        run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 =\n        (t\\<^sub>1', x\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 =\n  (t\\<^sub>1', x\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "moreover"], ["proof (state)\nthis:\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 =\n  (t\\<^sub>1', x\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "obtain T\\<^sub>1\n    where \"all_frees (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1)) |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\"\n      and \"fBall T\\<^sub>1 ((<) x\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T\\<^sub>1.\n        \\<lbrakk>all_frees\n                  (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                         x\\<^sub>1)) |\\<subseteq>|\n                 fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>|\n                 T\\<^sub>1;\n         fBall T\\<^sub>1 ((<) x\\<^sub>1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T\\<^sub>1.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n               x\\<^sub>1)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>|\n       T\\<^sub>1 \\<and>\n       fBall T\\<^sub>1 ((<) x\\<^sub>1)", "apply (rule app(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>1", "using app"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) ?x)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T \\<and>\n     fBall T ((<) ?x)\n  wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) ?xa)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T \\<and>\n     fBall T ((<) ?xa)\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n          x\\<^sub>1)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\n  fBall T\\<^sub>1 ((<) x\\<^sub>1)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "ultimately"], ["proof (chain)\npicking this:\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 =\n  (t\\<^sub>1', x\\<^sub>2)\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n          x\\<^sub>1)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\n  fBall T\\<^sub>1 ((<) x\\<^sub>1)", "have \"all_frees t\\<^sub>1' |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\""], ["proof (prove)\nusing this:\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 =\n  (t\\<^sub>1', x\\<^sub>2)\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n          x\\<^sub>1)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\n  fBall T\\<^sub>1 ((<) x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>1' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  all_frees t\\<^sub>1' |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "obtain T\\<^sub>2\n    where \"all_frees (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2)) |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\"\n      and \"fBall T\\<^sub>2 ((<) x\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T\\<^sub>2.\n        \\<lbrakk>all_frees\n                  (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                         x\\<^sub>2)) |\\<subseteq>|\n                 fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n                 T\\<^sub>2;\n         fBall T\\<^sub>2 ((<) x\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T\\<^sub>2.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n               x\\<^sub>2)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n       T\\<^sub>2 \\<and>\n       fBall T\\<^sub>2 ((<) x\\<^sub>2)", "apply (rule app(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>2", "using app"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) ?x)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T \\<and>\n     fBall T ((<) ?x)\n  wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) ?xa)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T \\<and>\n     fBall T ((<) ?xa)\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n          x\\<^sub>2)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n  fBall T\\<^sub>2 ((<) x\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "moreover"], ["proof (state)\nthis:\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n          x\\<^sub>2)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n  fBall T\\<^sub>2 ((<) x\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "obtain t\\<^sub>2' x' where \"run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 = (t\\<^sub>2', x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>2' x'.\n        run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 =\n        (t\\<^sub>2', x') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 = (t\\<^sub>2', x')\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "ultimately"], ["proof (chain)\npicking this:\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n          x\\<^sub>2)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n  fBall T\\<^sub>2 ((<) x\\<^sub>2)\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 = (t\\<^sub>2', x')", "have \"all_frees t\\<^sub>2' |\\<subseteq>| fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\""], ["proof (prove)\nusing this:\n  all_frees\n   (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n          x\\<^sub>2)) |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n  fBall T\\<^sub>2 ((<) x\\<^sub>2)\n  run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 = (t\\<^sub>2', x')\n\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  all_frees t\\<^sub>2' |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "have \"x\\<^sub>1 \\<le> x\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>1 \\<le> x\\<^sub>2", "apply (rule state_io_relD[OF term_to_nterm_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (term_to_nterm ?\\<Gamma>1 ?x1) x\\<^sub>1 = (?a, x\\<^sub>2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x\\<^sub>1 \\<le> x\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   \\<exists>T.\n                      all_frees\n                       (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                              x)) |\\<subseteq>|\n                      fset_of_list \\<Gamma> |\\<union>|\n                      frees t\\<^sub>1 |\\<union>|\n                      T \\<and>\n                      fBall T ((<) x);\n        \\<And>x xa.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           \\<exists>T.\n              all_frees\n               (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                      xa)) |\\<subseteq>|\n              fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>|\n              T \\<and>\n              fBall T ((<) xa);\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            all_frees\n                             (fst (run_state\n                                    (term_to_nterm \\<Gamma>\n(t\\<^sub>1 $ t\\<^sub>2))\n                                    x)) |\\<subseteq>|\n                            fset_of_list \\<Gamma> |\\<union>|\n                            frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                            T \\<and>\n                            fBall T ((<) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (run_state (term_to_nterm \\<Gamma> (t\\<^sub>1 $ t\\<^sub>2))\n               x\\<^sub>1)) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (case run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 of\n              (a, s') \\<Rightarrow>\n                case run_state (term_to_nterm \\<Gamma> t\\<^sub>2) s' of\n                (aa, s') \\<Rightarrow> (a $\\<^sub>n aa, s'))) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "unfolding \\<open>run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x\\<^sub>1 = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (case (t\\<^sub>1', x\\<^sub>2) of\n              (a, s') \\<Rightarrow>\n                case run_state (term_to_nterm \\<Gamma> t\\<^sub>2) s' of\n                (aa, s') \\<Rightarrow> (a $\\<^sub>n aa, s'))) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (case run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 of\n              (a, x) \\<Rightarrow>\n                (t\\<^sub>1' $\\<^sub>n a, x))) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "unfolding \\<open>run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x\\<^sub>2 = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees\n        (fst (case (t\\<^sub>2', x') of\n              (a, x) \\<Rightarrow>\n                (t\\<^sub>1' $\\<^sub>n a, x))) |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       all_frees t\\<^sub>1' |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       all_frees t\\<^sub>2' |\\<subseteq>|\n       fset_of_list \\<Gamma> |\\<union>|\n       (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n       T \\<and>\n       fBall T ((<) x\\<^sub>1)", "apply (rule exI[where x = \"T\\<^sub>1 |\\<union>| T\\<^sub>2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>1' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2) \\<and>\n    all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2) \\<and>\n    fBall (T\\<^sub>1 |\\<union>| T\\<^sub>2) ((<) x\\<^sub>1)", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. all_frees t\\<^sub>1' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)\n 2. all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)\n 3. fBall (T\\<^sub>1 |\\<union>| T\\<^sub>2) ((<) x\\<^sub>1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>1' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)", "using \\<open>all_frees t\\<^sub>1' |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  all_frees t\\<^sub>1' |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>1 |\\<union>| T\\<^sub>1\n\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>1' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)\n 2. fBall (T\\<^sub>1 |\\<union>| T\\<^sub>2) ((<) x\\<^sub>1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)", "using \\<open>all_frees t\\<^sub>2' |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  all_frees t\\<^sub>2' |\\<subseteq>|\n  fset_of_list \\<Gamma> |\\<union>| frees t\\<^sub>2 |\\<union>| T\\<^sub>2\n\ngoal (1 subgoal):\n 1. all_frees t\\<^sub>2' |\\<subseteq>|\n    fset_of_list \\<Gamma> |\\<union>|\n    (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2) |\\<union>|\n    (T\\<^sub>1 |\\<union>| T\\<^sub>2)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (T\\<^sub>1 |\\<union>| T\\<^sub>2) ((<) x\\<^sub>1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (T\\<^sub>1 |\\<union>| T\\<^sub>2) ((<) x\\<^sub>1)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x |\\<in>| T\\<^sub>1 \\<Longrightarrow> x\\<^sub>1 < x\n 2. \\<And>x. x |\\<in>| T\\<^sub>2 \\<Longrightarrow> x\\<^sub>1 < x", "using \\<open>fBall T\\<^sub>1 ((<) x\\<^sub>1)\\<close>"], ["proof (prove)\nusing this:\n  fBall T\\<^sub>1 ((<) x\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>x. x |\\<in>| T\\<^sub>1 \\<Longrightarrow> x\\<^sub>1 < x\n 2. \\<And>x. x |\\<in>| T\\<^sub>2 \\<Longrightarrow> x\\<^sub>1 < x", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x |\\<in>| T\\<^sub>2 \\<Longrightarrow> x\\<^sub>1 < x", "using \\<open>fBall T\\<^sub>2 ((<) x\\<^sub>2)\\<close> \\<open>x\\<^sub>1 \\<le> x\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  fBall T\\<^sub>2 ((<) x\\<^sub>2)\n  x\\<^sub>1 \\<le> x\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x. x |\\<in>| T\\<^sub>2 \\<Longrightarrow> x\\<^sub>1 < x", "by (meson fBallE less_le_not_le order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>T.\n     all_frees\n      (fst (run_state (term_to_nterm \\<Gamma> (t\\<^sub>1 $ t\\<^sub>2))\n             x\\<^sub>1)) |\\<subseteq>|\n     fset_of_list \\<Gamma> |\\<union>|\n     frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n     T \\<and>\n     fBall T ((<) x\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name x.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uu_ (Const name))\n                  x)) |\\<subseteq>|\n          fset_of_list uu_ |\\<union>| frees (Const name) |\\<union>| T \\<and>\n          fBall T ((<) x)\n 2. \\<And>uv_ name x.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       \\<exists>T.\n          all_frees\n           (fst (run_state (term_to_nterm uv_ (Free name)) x)) |\\<subseteq>|\n          fset_of_list uv_ |\\<union>| frees (Free name) |\\<union>| T \\<and>\n          fBall T ((<) x)", "qed auto"], ["", "lemma term_to_nterm_all_vars:\n  assumes \"wellformed t\" \"fdisjnt (frees t) S\"\n  shows \"fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "let ?\\<Gamma> = \"[]\""], ["proof (state)\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "let ?x = \"fresh_fNext (T |\\<union>| S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "from assms"], ["proof (chain)\npicking this:\n  pre_strong_term_class.wellformed t\n  fdisjnt (frees t) S", "have \"wellformed' (length ?\\<Gamma>) t\""], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n  fdisjnt (frees t) S\n\ngoal (1 subgoal):\n 1. wellformed' (length []) t", "by simp"], ["proof (state)\nthis:\n  wellformed' (length []) t\n\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "then"], ["proof (chain)\npicking this:\n  wellformed' (length []) t", "obtain F\n    where \"all_frees (fst (run_state (term_to_nterm ?\\<Gamma> t) ?x)) |\\<subseteq>| fset_of_list ?\\<Gamma> |\\<union>| frees t |\\<union>| F\"\n      and \"fBall F (\\<lambda>y. y > ?x)\""], ["proof (prove)\nusing this:\n  wellformed' (length []) t\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<lbrakk>all_frees\n                  (fst (run_state (term_to_nterm [] t)\n                         (fresh_fNext (T |\\<union>| S)))) |\\<subseteq>|\n                 fset_of_list [] |\\<union>| frees t |\\<union>| F;\n         fBall F ((<) (fresh_fNext (T |\\<union>| S)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis term_to_nterm_all_vars0)"], ["proof (state)\nthis:\n  all_frees\n   (fst (run_state (term_to_nterm [] t)\n          (fresh_fNext (T |\\<union>| S)))) |\\<subseteq>|\n  fset_of_list [] |\\<union>| frees t |\\<union>| F\n  fBall F ((<) (fresh_fNext (T |\\<union>| S)))\n\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "have \"fdisjnt F (T |\\<union>| S)\" if \"S \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt F (T |\\<union>| S)", "apply (rule fdisjnt_ge_max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall F ((<) (fMax (T |\\<union>| S)))", "apply (rule fBall_pred_weaken[OF _ \\<open>fBall F (\\<lambda>y. y > ?x)\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> fMax (T |\\<union>| S) < x", "apply (rule less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> fMax (T |\\<union>| S) < ?y5 x\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> ?y5 x < x", "apply (rule fNext_ge_max)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> T |\\<union>| S \\<noteq> {||}\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> fresh_fNext (T |\\<union>| S) < x", "using that"], ["proof (prove)\nusing this:\n  S \\<noteq> {||}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> T |\\<union>| S \\<noteq> {||}\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| F; fresh_fNext (T |\\<union>| S) < x\\<rbrakk>\n       \\<Longrightarrow> fresh_fNext (T |\\<union>| S) < x", "by auto"], ["proof (state)\nthis:\n  S \\<noteq> {||} \\<Longrightarrow> fdisjnt F (T |\\<union>| S)\n\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S", "apply (rule fdisjnt_subset_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_frees\n     (fresh_frun (term_to_nterm [] t) (T |\\<union>| S)) |\\<subseteq>|\n    ?N\n 2. fdisjnt ?N S", "apply (subst fresh_frun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_frees\n     (frun_fresh (term_to_nterm [] t) (T |\\<union>| S)) |\\<subseteq>|\n    ?N\n 2. fdisjnt ?N S", "apply (subst fresh_fNext_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_frees\n     (fst (run_state (term_to_nterm [] t)\n            (fresh_fNext (T |\\<union>| S)))) |\\<subseteq>|\n    ?N\n 2. fdisjnt ?N S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list [] |\\<union>| frees t |\\<union>| F) S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees t |\\<union>| F) S", "apply (rule fdisjnt_union_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fdisjnt (frees t) S\n 2. fdisjnt F S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt F S", "using \\<open>_ \\<Longrightarrow> fdisjnt F (T |\\<union>| S)\\<close>"], ["proof (prove)\nusing this:\n  S \\<noteq> {||} \\<Longrightarrow> fdisjnt F (T |\\<union>| S)\n\ngoal (1 subgoal):\n 1. fdisjnt F S", "by (auto simp: fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt (all_frees (fresh_frun (term_to_nterm [] t) (T |\\<union>| S))) S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun translate_rule :: \"name fset \\<Rightarrow> rule \\<Rightarrow> nrule\" where\n\"translate_rule S (lhs, rhs) = (lhs, fresh_frun (term_to_nterm [] rhs) (frees lhs |\\<union>| S))\""], ["", "lemma translate_rule_alt_def:\n  \"translate_rule S = (\\<lambda>(lhs, rhs). (lhs, fresh_frun (term_to_nterm [] rhs) (frees lhs |\\<union>| S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. translate_rule S =\n    (\\<lambda>(lhs, rhs).\n        (lhs, fresh_frun (term_to_nterm [] rhs) (frees lhs |\\<union>| S)))", "by auto"], ["", "definition compile' where\n\"compile' C_info rs = translate_rule (pre_constants.all_consts C_info (heads_of rs)) |`| rs\""], ["", "context rules begin"], ["", "definition compile :: \"nrule fset\" where\n\"compile = translate_rule all_consts |`| rs\""], ["", "lemma compile'_compile_eq[simp]: \"compile' C_info rs = compile\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile' C_info rs = compile", "unfolding compile'_def compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. translate_rule all_consts |`| rs = translate_rule all_consts |`| rs", ".."], ["", "lemma compile_heads: \"heads_of compile = heads_of rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heads_of compile = heads_of rs", "unfolding compile_def translate_rule_alt_def head_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. const_name (fst (strip_comb t))) \\<circ> fst) |`|\n    (\\<lambda>(lhs, rhs).\n        (lhs,\n         fresh_frun (term_to_nterm [] rhs)\n          (frees lhs |\\<union>|\n           pre_constants.all_consts C_info\n            (((\\<lambda>t. const_name (fst (strip_comb t))) \\<circ> fst) |`|\n             rs)))) |`|\n    rs =\n    ((\\<lambda>t. const_name (fst (strip_comb t))) \\<circ> fst) |`| rs", "by force"], ["", "lemma compile_rules: \"nrules C_info compile\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrules C_info compile", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. fBall compile nrule\n 4. arity_compatibles compile\n 5. is_fmap compile\n 6. pattern_compatibles compile\n 7. compile \\<noteq> {||}\n 8. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 9. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "have \"fBall compile (\\<lambda>(lhs, rhs). nrule (lhs, rhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall compile (\\<lambda>(lhs, rhs). nrule (lhs, rhs))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> nrule (a, b)", "fix lhs rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> nrule (a, b)", "assume \"(lhs, rhs) |\\<in>| compile\""], ["proof (state)\nthis:\n  (lhs, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> nrule (a, b)", "then"], ["proof (chain)\npicking this:\n  (lhs, rhs) |\\<in>| compile", "obtain rhs'\n        where \"(lhs, rhs') |\\<in>| rs\"\n          and rhs: \"rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\""], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>(lhs, rhs') |\\<in>| rs;\n         rhs =\n         fresh_frun (term_to_nterm [] rhs')\n          (frees lhs |\\<union>| all_consts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| translate_rule all_consts |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>(lhs, rhs') |\\<in>| rs;\n         rhs =\n         fresh_frun (term_to_nterm [] rhs')\n          (frees lhs |\\<union>| all_consts)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (lhs, rhs') |\\<in>| rs\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> nrule (a, b)", "then"], ["proof (chain)\npicking this:\n  (lhs, rhs') |\\<in>| rs\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)", "have rule: \"rule (lhs, rhs')\""], ["proof (prove)\nusing this:\n  (lhs, rhs') |\\<in>| rs\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n\ngoal (1 subgoal):\n 1. rule (lhs, rhs')", "using all_rules"], ["proof (prove)\nusing this:\n  (lhs, rhs') |\\<in>| rs\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n  fBall rs rule\n\ngoal (1 subgoal):\n 1. rule (lhs, rhs')", "by blast"], ["proof (state)\nthis:\n  rule (lhs, rhs')\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> nrule (a, b)", "show \"nrule (lhs, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrule (lhs, rhs)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. linear lhs\n 2. is_const (fst (strip_comb lhs))\n 3. \\<not> is_const lhs\n 4. frees rhs |\\<subseteq>| frees lhs", "from rule"], ["proof (chain)\npicking this:\n  rule (lhs, rhs')", "show \"linear lhs\" \"is_const (fst (strip_comb lhs))\" \"\\<not> is_const lhs\""], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n\ngoal (1 subgoal):\n 1. linear lhs &&& is_const (fst (strip_comb lhs)) &&& \\<not> is_const lhs", "by auto"], ["proof (state)\nthis:\n  linear lhs\n  is_const (fst (strip_comb lhs))\n  \\<not> is_const lhs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "have \"frees rhs |\\<subseteq>| frees rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees rhs'", "unfolding rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees\n     (fresh_frun (term_to_nterm [] rhs')\n       (frees lhs |\\<union>| all_consts)) |\\<subseteq>|\n    frees rhs'", "using rule"], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n\ngoal (1 subgoal):\n 1. frees\n     (fresh_frun (term_to_nterm [] rhs')\n       (frees lhs |\\<union>| all_consts)) |\\<subseteq>|\n    frees rhs'", "by (metis rule.simps term_to_nterm_vars)"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees rhs'\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "also"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees rhs'\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "have \"frees rhs' |\\<subseteq>| frees lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs' |\\<subseteq>| frees lhs", "using rule"], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n\ngoal (1 subgoal):\n 1. frees rhs' |\\<subseteq>| frees lhs", "by auto"], ["proof (state)\nthis:\n  frees rhs' |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "finally"], ["proof (chain)\npicking this:\n  frees rhs |\\<subseteq>| frees lhs", "show \"frees rhs |\\<subseteq>| frees lhs\""], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees lhs", "."], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nrule (lhs, rhs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fBall compile (\\<lambda>(lhs, rhs). nrule (lhs, rhs))\n\ngoal (9 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. fBall compile nrule\n 4. arity_compatibles compile\n 5. is_fmap compile\n 6. pattern_compatibles compile\n 7. compile \\<noteq> {||}\n 8. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 9. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "thus \"fBall compile nrule\""], ["proof (prove)\nusing this:\n  fBall compile (\\<lambda>(lhs, rhs). nrule (lhs, rhs))\n\ngoal (1 subgoal):\n 1. fBall compile nrule", "by fast"], ["proof (state)\nthis:\n  fBall compile nrule\n\ngoal (8 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. arity_compatibles compile\n 4. is_fmap compile\n 5. pattern_compatibles compile\n 6. compile \\<noteq> {||}\n 7. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 8. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. arity_compatibles compile\n 4. is_fmap compile\n 5. pattern_compatibles compile\n 6. compile \\<noteq> {||}\n 7. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 8. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "show \"arity_compatibles compile\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_compatibles compile", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| compile; (aa, ba) |\\<in>| compile\\<rbrakk>\n       \\<Longrightarrow> arity_compatible a aa", "fix lhs\\<^sub>1 rhs\\<^sub>1 lhs\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| compile; (aa, ba) |\\<in>| compile\\<rbrakk>\n       \\<Longrightarrow> arity_compatible a aa", "assume \"(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| compile\" \"(lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| compile\""], ["proof (state)\nthis:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| compile\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| compile; (aa, ba) |\\<in>| compile\\<rbrakk>\n       \\<Longrightarrow> arity_compatible a aa", "then"], ["proof (chain)\npicking this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| compile\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| compile", "obtain rhs\\<^sub>1' rhs\\<^sub>2' where \"(lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs\" \"(lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| compile\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1' rhs\\<^sub>2'.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| translate_rule all_consts |`| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| translate_rule all_consts |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1' rhs\\<^sub>2'.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| compile; (aa, ba) |\\<in>| compile\\<rbrakk>\n       \\<Longrightarrow> arity_compatible a aa", "thus \"arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\n\ngoal (1 subgoal):\n 1. arity_compatible lhs\\<^sub>1 lhs\\<^sub>2", "using arity"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1') |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2') |\\<in>| rs\n  arity_compatibles rs\n\ngoal (1 subgoal):\n 1. arity_compatible lhs\\<^sub>1 lhs\\<^sub>2", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arity_compatibles compile\n\ngoal (7 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. is_fmap compile\n 4. pattern_compatibles compile\n 5. compile \\<noteq> {||}\n 6. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 7. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. is_fmap compile\n 4. pattern_compatibles compile\n 5. compile \\<noteq> {||}\n 6. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 7. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "have \"is_fmap rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "using fmap"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap rs", "by simp"], ["proof (state)\nthis:\n  is_fmap rs\n\ngoal (7 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. is_fmap compile\n 4. pattern_compatibles compile\n 5. compile \\<noteq> {||}\n 6. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 7. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "thus \"is_fmap compile\""], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap compile", "unfolding compile_def translate_rule_alt_def"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap\n     ((\\<lambda>(lhs, rhs).\n          (lhs,\n           fresh_frun (term_to_nterm [] rhs)\n            (frees lhs |\\<union>| all_consts))) |`|\n      rs)", "by (rule is_fmap_image)"], ["proof (state)\nthis:\n  is_fmap compile\n\ngoal (6 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. pattern_compatibles compile\n 4. compile \\<noteq> {||}\n 5. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 6. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. pattern_compatibles compile\n 4. compile \\<noteq> {||}\n 5. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 6. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "have \"pattern_compatibles rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern_compatibles rs", "using patterns"], ["proof (prove)\nusing this:\n  pattern_compatibles rs\n\ngoal (1 subgoal):\n 1. pattern_compatibles rs", "by simp"], ["proof (state)\nthis:\n  pattern_compatibles rs\n\ngoal (6 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. pattern_compatibles compile\n 4. compile \\<noteq> {||}\n 5. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 6. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "thus \"pattern_compatibles compile\""], ["proof (prove)\nusing this:\n  pattern_compatibles rs\n\ngoal (1 subgoal):\n 1. pattern_compatibles compile", "unfolding compile_def translate_rule_alt_def"], ["proof (prove)\nusing this:\n  pattern_compatibles rs\n\ngoal (1 subgoal):\n 1. pattern_compatibles\n     ((\\<lambda>(lhs, rhs).\n          (lhs,\n           fresh_frun (term_to_nterm [] rhs)\n            (frees lhs |\\<union>| all_consts))) |`|\n      rs)", "by (auto dest: fpairwiseD)"], ["proof (state)\nthis:\n  pattern_compatibles compile\n\ngoal (5 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. compile \\<noteq> {||}\n 4. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 5. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt (heads_of compile) C\n 2. distinct all_constructors\n 3. compile \\<noteq> {||}\n 4. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 5. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "show \"fdisjnt (heads_of compile) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (heads_of compile) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (heads_of rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (heads_of compile) C", "by (simp add: compile_heads)"], ["proof (state)\nthis:\n  fdisjnt (heads_of compile) C\n\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}\n 3. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 4. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}\n 3. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 4. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "have \"fBall compile not_shadowing\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall compile not_shadowing", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "fix lhs rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "assume \"(lhs, rhs) |\\<in>| compile\""], ["proof (state)\nthis:\n  (lhs, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "then"], ["proof (chain)\npicking this:\n  (lhs, rhs) |\\<in>| compile", "obtain rhs'\n        where \"rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\"\n          and \"(lhs, rhs') |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>rhs =\n                 fresh_frun (term_to_nterm [] rhs')\n                  (frees lhs |\\<union>| all_consts);\n         (lhs, rhs') |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def translate_rule_alt_def"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>|\n  (\\<lambda>(lhs, rhs).\n      (lhs,\n       fresh_frun (term_to_nterm [] rhs)\n        (frees lhs |\\<union>| all_consts))) |`|\n  rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>rhs =\n                 fresh_frun (term_to_nterm [] rhs')\n                  (frees lhs |\\<union>| all_consts);\n         (lhs, rhs') |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n  (lhs, rhs') |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "hence \"rule (lhs, rhs')\" \"\\<not> shadows_consts lhs\""], ["proof (prove)\nusing this:\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n  (lhs, rhs') |\\<in>| rs\n\ngoal (1 subgoal):\n 1. rule (lhs, rhs') &&& \\<not> shadows_consts lhs", "using all_rules not_shadows"], ["proof (prove)\nusing this:\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees lhs |\\<union>| all_consts)\n  (lhs, rhs') |\\<in>| rs\n  fBall rs rule\n  fBall rs (\\<lambda>(lhs, uu_). \\<not> shadows_consts lhs)\n\ngoal (1 subgoal):\n 1. rule (lhs, rhs') &&& \\<not> shadows_consts lhs", "by blast+"], ["proof (state)\nthis:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "moreover"], ["proof (state)\nthis:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "hence \"wellformed rhs'\" \"frees rhs' |\\<subseteq>| frees lhs\" \"fdisjnt all_consts (frees lhs)\""], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs' &&&\n    frees rhs' |\\<subseteq>| frees lhs &&& fdisjnt all_consts (frees lhs)", "unfolding shadows_consts_def"], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n  \\<not> \\<not> fdisjnt all_consts (all_frees lhs)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs' &&&\n    frees rhs' |\\<subseteq>| frees lhs &&& fdisjnt all_consts (frees lhs)", "by simp+"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs'\n  frees rhs' |\\<subseteq>| frees lhs\n  fdisjnt all_consts (frees lhs)\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "moreover"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs'\n  frees rhs' |\\<subseteq>| frees lhs\n  fdisjnt all_consts (frees lhs)\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "apply (subst shadows_consts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> fdisjnt all_consts (all_frees rhs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts (all_frees rhs)", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts\n     (all_frees\n       (fresh_frun (term_to_nterm [] rhs')\n         (frees lhs |\\<union>| all_consts)))", "apply (rule fdisjnt_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt\n     (all_frees\n       (fresh_frun (term_to_nterm [] rhs')\n         (frees lhs |\\<union>| all_consts)))\n     all_consts", "apply (rule term_to_nterm_all_vars)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs'\n 2. fdisjnt (frees rhs') all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees rhs') all_consts", "apply (rule fdisjnt_subset_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees rhs' |\\<subseteq>| ?N6\n 2. fdisjnt ?N6 all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees lhs) all_consts", "apply (rule fdisjnt_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees lhs)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) |\\<in>| compile \\<Longrightarrow> not_shadowing (a, b)", "ultimately"], ["proof (chain)\npicking this:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n  pre_strong_term_class.wellformed rhs'\n  frees rhs' |\\<subseteq>| frees lhs\n  fdisjnt all_consts (frees lhs)\n  \\<not> shadows_consts rhs", "show \"not_shadowing (lhs, rhs)\""], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n  pre_strong_term_class.wellformed rhs'\n  frees rhs' |\\<subseteq>| frees lhs\n  fdisjnt all_consts (frees lhs)\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. not_shadowing (lhs, rhs)", "unfolding compile_heads"], ["proof (prove)\nusing this:\n  rule (lhs, rhs')\n  \\<not> shadows_consts lhs\n  pre_strong_term_class.wellformed rhs'\n  frees rhs' |\\<subseteq>| frees lhs\n  fdisjnt all_consts (frees lhs)\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. not_shadowing (lhs, rhs)", "by simp"], ["proof (state)\nthis:\n  not_shadowing (lhs, rhs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fBall compile not_shadowing\n\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}\n 3. fBall compile (constants.not_shadowing C_info (heads_of compile))\n 4. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "thus \"fBall compile (constants.not_shadowing C_info (heads_of compile))\""], ["proof (prove)\nusing this:\n  fBall compile not_shadowing\n\ngoal (1 subgoal):\n 1. fBall compile (constants.not_shadowing C_info (heads_of compile))", "unfolding compile_heads"], ["proof (prove)\nusing this:\n  fBall compile not_shadowing\n\ngoal (1 subgoal):\n 1. fBall compile not_shadowing", "."], ["proof (state)\nthis:\n  fBall compile (constants.not_shadowing C_info (heads_of compile))\n\ngoal (3 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}\n 3. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "have \"fBall compile (\\<lambda>(_, rhs). welldefined rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "unfolding compile_heads"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "unfolding compile_def ball_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>x.\n         case translate_rule all_consts x of\n         (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts)", "apply (rule fBall_pred_weaken[OF _ welldefined_rs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| rs;\n        case x of\n        (uu_, rhs) \\<Rightarrow>\n          consts rhs |\\<subseteq>| all_consts\\<rbrakk>\n       \\<Longrightarrow> case translate_rule all_consts x of\n                         (uu_, rhs) \\<Rightarrow>\n                           consts rhs |\\<subseteq>| all_consts", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<in>| rs;\n     case x of\n     (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts\\<rbrakk>\n    \\<Longrightarrow> case translate_rule all_consts x of\n                      (uu_, rhs) \\<Rightarrow>\n                        consts rhs |\\<subseteq>| all_consts", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x |\\<in>| rs;\n        case x of\n        (uu_, rhs) \\<Rightarrow> consts rhs |\\<subseteq>| all_consts;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> case translate_rule all_consts x of\n                         (uu_, rhs) \\<Rightarrow>\n                           consts rhs |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; consts b |\\<subseteq>| all_consts;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (fresh_frun (term_to_nterm [] b)\n                            (frees a |\\<union>| all_consts)) |\\<subseteq>|\n                         all_consts", "apply (subst fresh_frun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; consts b |\\<subseteq>| all_consts;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts\n                          (frun_fresh (term_to_nterm [] b)\n                            (frees a |\\<union>| all_consts)) |\\<subseteq>|\n                         all_consts", "apply (subst term_to_nterm_consts[THEN pred_state_run_state])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) |\\<in>| rs; consts b |\\<subseteq>| all_consts;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (3 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}\n 3. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "thus \"fBall compile (\\<lambda>(_, rhs). consts rhs |\\<subseteq>| pre_constants.all_consts C_info (heads_of compile))\""], ["proof (prove)\nusing this:\n  fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. fBall compile\n     (\\<lambda>(uu_, rhs).\n         consts rhs |\\<subseteq>|\n         pre_constants.all_consts C_info (heads_of compile))", "unfolding compile_heads"], ["proof (prove)\nusing this:\n  fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. fBall compile (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)", "."], ["proof (state)\nthis:\n  fBall compile\n   (\\<lambda>(uu_, rhs).\n       consts rhs |\\<subseteq>|\n       pre_constants.all_consts C_info (heads_of compile))\n\ngoal (2 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct all_constructors\n 2. compile \\<noteq> {||}", "show \"compile \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<noteq> {||}", "using nonempty"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. compile \\<noteq> {||}", "unfolding compile_def"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. translate_rule all_consts |`| rs \\<noteq> {||}", "by auto"], ["proof (state)\nthis:\n  compile \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale rules_as_nrules: nrules C_info compile"], ["proof (prove)\ngoal (1 subgoal):\n 1. nrules C_info compile", "by (fact compile_rules)"], ["", "end"], ["", "subsection \\<open>Correctness of translation\\<close>"], ["", "theorem (in rules) compile_correct:\n  assumes \"compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\" \"closed u\"\n  shows \"rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'", "using assms"], ["proof (prove)\nusing this:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'", "proof (induction u u')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "case (step r u u')"], ["proof (state)\nthis:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "moreover"], ["proof (state)\nthis:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "obtain pat rhs' where \"r = (pat, rhs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs'.\n        r = (pat, rhs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r = (pat, rhs')\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "ultimately"], ["proof (chain)\npicking this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n  r = (pat, rhs')", "obtain nenv where \"match pat u = Some nenv\" \"u' = subst rhs' nenv\""], ["proof (prove)\nusing this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n  r = (pat, rhs')\n\ngoal (1 subgoal):\n 1. (\\<And>nenv.\n        \\<lbrakk>match pat u = Some nenv; u' = subst rhs' nenv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match pat u = Some nenv\n  u' = subst rhs' nenv\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  match pat u = Some nenv\n  u' = subst rhs' nenv", "obtain env where \"nrelated.P_env [] env nenv\" \"match pat (nterm_to_term [] u) = Some env\""], ["proof (prove)\nusing this:\n  match pat u = Some nenv\n  u' = subst rhs' nenv\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>nrelated.P_env [] env nenv;\n         match pat (nterm_to_term' u) = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis nrelated.match_rel option.exhaust option.rel_distinct(1) option.rel_inject(2))"], ["proof (state)\nthis:\n  nrelated.P_env [] env nenv\n  match pat (nterm_to_term' u) = Some env\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "have \"closed_env nenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env nenv", "using step \\<open>match pat u = Some nenv\\<close>"], ["proof (prove)\nusing this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n  match pat u = Some nenv\n\ngoal (1 subgoal):\n 1. closed_env nenv", "by (intro closed.match)"], ["proof (state)\nthis:\n  closed_env nenv\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "from step"], ["proof (chain)\npicking this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u", "obtain rhs\n    where \"rhs' = fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts)\" \"(pat, rhs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' =\n                 fresh_frun (term_to_nterm [] rhs)\n                  (frees pat |\\<union>| all_consts);\n         (pat, rhs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>r = _\\<close> compile_def"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| translate_rule all_consts |`| rs\n  (pat, rhs') \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs' =\n                 fresh_frun (term_to_nterm [] rhs)\n                  (frees pat |\\<union>| all_consts);\n         (pat, rhs) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rhs' = fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| rs\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "with assms"], ["proof (chain)\npicking this:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u\n  rhs' = fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| rs", "have \"rule (pat, rhs)\""], ["proof (prove)\nusing this:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u\n  rhs' = fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. rule (pat, rhs)", "using all_rules"], ["proof (prove)\nusing this:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u\n  rhs' = fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| rs\n  fBall rs rule\n\ngoal (1 subgoal):\n 1. rule (pat, rhs)", "by blast"], ["proof (state)\nthis:\n  rule (pat, rhs)\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "hence \"rhs = nterm_to_term [] rhs'\""], ["proof (prove)\nusing this:\n  rule (pat, rhs)\n\ngoal (1 subgoal):\n 1. rhs = nterm_to_term' rhs'", "unfolding \\<open>rhs' = _\\<close>"], ["proof (prove)\nusing this:\n  rule (pat, rhs)\n\ngoal (1 subgoal):\n 1. rhs =\n    nterm_to_term'\n     (fresh_frun (term_to_nterm [] rhs) (frees pat |\\<union>| all_consts))", "by (simp add: term_to_nterm_nterm_to_term fresh_frun_def)"], ["proof (state)\nthis:\n  rhs = nterm_to_term' rhs'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "have \"compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'", "using step"], ["proof (prove)\nusing this:\n  r |\\<in>| compile\n  r \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'", "by (auto intro: nrewrite.step)"], ["proof (state)\nthis:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "hence \"closed u'\""], ["proof (prove)\nusing this:\n  compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n\ngoal (1 subgoal):\n 1. closed u'", "by (rule rules_as_nrules.nrewrite_closed) fact"], ["proof (state)\nthis:\n  closed u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| compile; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n                         nterm_to_term' u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'", "proof (rule rewrite.step)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?r |\\<in>| rs\n 2. ?r \\<turnstile> nterm_to_term' u \\<rightarrow> nterm_to_term' u'", "show \"(pat, rhs) \\<turnstile> nterm_to_term [] u \\<rightarrow> nterm_to_term [] u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<turnstile> nterm_to_term' u \\<rightarrow> nterm_to_term' u'", "apply (subst nterm_to_term_eq_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed u\n 2. (pat, rhs) \\<turnstile> nterm_to_term ?\\<Gamma>' u \\<rightarrow>\n    nterm_to_term' u'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<turnstile> nterm_to_term ?\\<Gamma>' u \\<rightarrow>\n    nterm_to_term' u'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       match pat (nterm_to_term ?\\<Gamma>' u) = Some z \\<and>\n       subst rhs z = nterm_to_term' u'", "apply (rule exI[where x = env])"], ["proof (prove)\ngoal (1 subgoal):\n 1. match pat (nterm_to_term ?\\<Gamma>' u) = Some env \\<and>\n    subst rhs env = nterm_to_term' u'", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat (nterm_to_term ?\\<Gamma>' u) = Some env\n 2. subst rhs env = nterm_to_term' u'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env = nterm_to_term' u'", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term' rhs') env = nterm_to_term' u'", "apply (subst nrelated_subst)"], ["proof (prove)\ngoal (4 subgoals):\n 1. nrelated.P_env [] env ?nenv8\n 2. closed_env ?nenv8\n 3. fdisjnt (fset_of_list []) (fmdom ?nenv8)\n 4. nterm_to_term' (subst rhs' ?nenv8) = nterm_to_term' u'", "apply fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. closed_env nenv\n 2. fdisjnt (fset_of_list []) (fmdom nenv)\n 3. nterm_to_term' (subst rhs' nenv) = nterm_to_term' u'", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. fdisjnt (fset_of_list []) (fmdom nenv)\n 2. nterm_to_term' (subst rhs' nenv) = nterm_to_term' u'", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. fset_of_list [] |\\<inter>| fmdom nenv = {||}\n 2. nterm_to_term' (subst rhs' nenv) = nterm_to_term' u'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term' (subst rhs' nenv) = nterm_to_term' u'", "unfolding \\<open>u' = subst rhs' nenv\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term' (subst rhs' nenv) = nterm_to_term' (subst rhs' nenv)", "by simp"], ["proof (state)\nthis:\n  (pat, rhs) \\<turnstile> nterm_to_term' u \\<rightarrow> nterm_to_term' u'\n\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| rs", "qed fact"], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow> nterm_to_term' u'\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "case beta"], ["proof (state)\nthis:\n  closed ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_)\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       rs \\<turnstile>\n       nterm_to_term'\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_term' (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    nterm_to_term'\n     ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_) \\<longrightarrow>\n    nterm_to_term' (subst t_ (fmap_of_list [(x_, t'_)]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term' (subst t_ (fmupd x_ t'_ fmempty))", "apply (subst subst_single_eq[symmetric, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term' (subst_single t_ x_ t'_)", "apply (subst nterm_to_term_subst_replace_bound[where n = 0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. closed t'_\n 2. 0 \\<le> length []\n 3. x_ \\<notin> set (take 0 [])\n 4. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term (insert_nth 0 x_ []) t_ [nterm_to_term' t'_]\\<^sub>\\<beta>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'_", "using beta"], ["proof (prove)\nusing this:\n  closed ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_)\n\ngoal (1 subgoal):\n 1. closed t'_", "by (simp add: closed_except_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> length []\n 2. x_ \\<notin> set (take 0 [])\n 3. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term (insert_nth 0 x_ []) t_ [nterm_to_term' t'_]\\<^sub>\\<beta>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> length []", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x_ \\<notin> set (take 0 [])\n 2. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term (insert_nth 0 x_ []) t_ [nterm_to_term' t'_]\\<^sub>\\<beta>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<notin> set (take 0 [])", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term (insert_nth 0 x_ []) t_ [nterm_to_term' t'_]\\<^sub>\\<beta>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    \\<Lambda> nterm_to_term [x_] t_ $ nterm_to_term' t'_ \\<longrightarrow>\n    nterm_to_term (insert_nth 0 x_ []) t_ [nterm_to_term' t'_]\\<^sub>\\<beta>", "by simp (rule rewrite.beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\n  nterm_to_term'\n   ((\\<Lambda>\\<^sub>n x_. t_) $\\<^sub>n t'_) \\<longrightarrow>\n  nterm_to_term' (subst t_ (fmap_of_list [(x_, t'_)]))\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' t \\<longrightarrow>\n        nterm_to_term' t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t' $\\<^sub>n u)\n 2. \\<And>u u' t.\n       \\<lbrakk>compile \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>\n        nterm_to_term' u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\n                         nterm_to_term' (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_term' (t $\\<^sub>n u')", "qed (auto intro: rewrite.intros simp: closed_except_def)"], ["", "subsection \\<open>Completeness of translation\\<close>"], ["", "context rules begin"], ["", "context\n  notes [simp] = closed_except_def fdisjnt_alt_def\nbegin"], ["", "private"], ["", "lemma compile_complete0:\n  assumes \"rs \\<turnstile> t \\<longrightarrow> t'\" \"closed t\" \"wellformed t\"\n  obtains u' where \"compile \\<turnstile>\\<^sub>n fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\" \"u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 fst (run_state (term_to_nterm [] t) s) \\<longrightarrow>\n                 u';\n         u' \\<approx>\\<^sub>\\<alpha>\n         fst (run_state (term_to_nterm [] t') s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u' \\<and>\n       u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u' \\<and>\n       u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "proof (induction t t' arbitrary: s s')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "case (step r t t')"], ["proof (state)\nthis:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "let ?t\\<^sub>n = \"fst (run_state (term_to_nterm [] t) s)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "let ?t\\<^sub>n' = \"fst (run_state (term_to_nterm [] t') s')\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t", "have \"closed t\" \"closed ?t\\<^sub>n\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. closed t &&& closed (fst (run_state (term_to_nterm [] t) s))", "using term_to_nterm_vars0[where \\<Gamma> = \"[]\"]"], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  wellformed' (length []) ?t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm [] ?t) ?s)) |\\<subseteq>|\n  frees ?t |\\<union>| fset_of_list []\n\ngoal (1 subgoal):\n 1. closed t &&& closed (fst (run_state (term_to_nterm [] t) s))", "by force+"], ["proof (state)\nthis:\n  closed t\n  closed (fst (run_state (term_to_nterm [] t) s))\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t", "have \"nterm_to_term' ?t\\<^sub>n = t\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. nterm_to_term' (fst (run_state (term_to_nterm [] t) s)) = t", "by (auto intro!: term_to_nterm_nterm_to_term0)"], ["proof (state)\nthis:\n  nterm_to_term' (fst (run_state (term_to_nterm [] t) s)) = t\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "obtain pat rhs' where \"r = (pat, rhs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs'.\n        r = (pat, rhs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  r = (pat, rhs')\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  r = (pat, rhs')", "obtain env' where \"match pat t = Some env'\" \"t' = subst rhs' env'\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  r = (pat, rhs')\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match pat t = Some env'; t' = subst rhs' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  match pat t = Some env'\n  t' = subst rhs' env'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with \\<open>_ = t\\<close>"], ["proof (chain)\npicking this:\n  nterm_to_term' (fst (run_state (term_to_nterm [] t) s)) = t\n  match pat t = Some env'\n  t' = subst rhs' env'", "have \"rel_option (nrelated.P_env []) (match pat t) (match pat (?t\\<^sub>n))\""], ["proof (prove)\nusing this:\n  nterm_to_term' (fst (run_state (term_to_nterm [] t) s)) = t\n  match pat t = Some env'\n  t' = subst rhs' env'\n\ngoal (1 subgoal):\n 1. rel_option (nrelated.P_env []) (match pat t)\n     (match pat (fst (run_state (term_to_nterm [] t) s)))", "by (metis nrelated.match_rel)"], ["proof (state)\nthis:\n  rel_option (nrelated.P_env []) (match pat t)\n   (match pat (fst (run_state (term_to_nterm [] t) s)))\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with step \\<open>_ = Some env'\\<close>"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  match pat t = Some env'\n  rel_option (nrelated.P_env []) (match pat t)\n   (match pat (fst (run_state (term_to_nterm [] t) s)))", "obtain env where \"nrelated.P_env [] env' env\" \"match pat ?t\\<^sub>n = Some env\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  match pat t = Some env'\n  rel_option (nrelated.P_env []) (match pat t)\n   (match pat (fst (run_state (term_to_nterm [] t) s)))\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>nrelated.P_env [] env' env;\n         match pat (fst (run_state (term_to_nterm [] t) s)) =\n         Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) option_rel_Some1)"], ["proof (state)\nthis:\n  nrelated.P_env [] env' env\n  match pat (fst (run_state (term_to_nterm [] t) s)) = Some env\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with \\<open>closed ?t\\<^sub>n\\<close>"], ["proof (chain)\npicking this:\n  closed (fst (run_state (term_to_nterm [] t) s))\n  nrelated.P_env [] env' env\n  match pat (fst (run_state (term_to_nterm [] t) s)) = Some env", "have \"closed_env env\""], ["proof (prove)\nusing this:\n  closed (fst (run_state (term_to_nterm [] t) s))\n  nrelated.P_env [] env' env\n  match pat (fst (run_state (term_to_nterm [] t) s)) = Some env\n\ngoal (1 subgoal):\n 1. closed_env env", "by (blast intro: closed.match)"], ["proof (state)\nthis:\n  closed_env env\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t", "obtain rhs\n    where \"rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\" \"(pat, rhs) |\\<in>| compile\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs =\n                 fresh_frun (term_to_nterm [] rhs')\n                  (frees pat |\\<union>| all_consts);\n         (pat, rhs) |\\<in>| compile\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>r = _\\<close> compile_def"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs =\n                 fresh_frun (term_to_nterm [] rhs')\n                  (frees pat |\\<union>| all_consts);\n         (pat, rhs) |\\<in>| translate_rule all_consts |`| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| compile\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| compile", "have \"rule (pat, rhs')\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. rule (pat, rhs')", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| compile\n\ngoal (1 subgoal):\n 1. rule (pat, rhs')", "using all_rules"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n  rhs = fresh_frun (term_to_nterm [] rhs') (frees pat |\\<union>| all_consts)\n  (pat, rhs) |\\<in>| compile\n  fBall rs rule\n\ngoal (1 subgoal):\n 1. rule (pat, rhs')", "by fast"], ["proof (state)\nthis:\n  rule (pat, rhs')\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "hence \"nterm_to_term' rhs = rhs'\""], ["proof (prove)\nusing this:\n  rule (pat, rhs')\n\ngoal (1 subgoal):\n 1. nterm_to_term' rhs = rhs'", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\nusing this:\n  rule (pat, rhs')\n\ngoal (1 subgoal):\n 1. nterm_to_term'\n     (fresh_frun (term_to_nterm [] rhs')\n       (frees pat |\\<union>| all_consts)) =\n    rhs'", "by (simp add: fresh_frun_def term_to_nterm_nterm_to_term)"], ["proof (state)\nthis:\n  nterm_to_term' rhs = rhs'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "obtain u' where \"subst rhs env = u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        subst rhs env = u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  subst rhs env = u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "have \"t' = nterm_to_term' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = nterm_to_term' u'", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs' env' = nterm_to_term' u'", "unfolding \\<open>_ = rhs'\\<close>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term' rhs) env' = nterm_to_term' u'", "apply (subst nrelated_subst)"], ["proof (prove)\ngoal (4 subgoals):\n 1. nrelated.P_env [] env' ?nenv\n 2. closed_env ?nenv\n 3. fdisjnt (fset_of_list []) (fmdom ?nenv)\n 4. nterm_to_term' (subst rhs ?nenv) = nterm_to_term' u'", "apply fact+"], ["proof (prove)\ngoal (2 subgoals):\n 1. fdisjnt (fset_of_list []) (fmdom env)\n 2. nterm_to_term' (subst rhs env) = nterm_to_term' u'", "using \\<open>_ = u'\\<close>"], ["proof (prove)\nusing this:\n  subst rhs env = u'\n\ngoal (2 subgoals):\n 1. fdisjnt (fset_of_list []) (fmdom env)\n 2. nterm_to_term' (subst rhs env) = nterm_to_term' u'", "by simp+"], ["proof (state)\nthis:\n  t' = nterm_to_term' u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "have \"compile \\<turnstile>\\<^sub>n ?t\\<^sub>n \\<longrightarrow> u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'", "apply (rule nrewrite.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?r |\\<in>| compile\n 2. ?r \\<turnstile> fst (run_state (term_to_nterm [] t) s) \\<rightarrow> u'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<turnstile>\n    fst (run_state (term_to_nterm [] t) s) \\<rightarrow> u'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       match pat (fst (run_state (term_to_nterm [] t) s)) = Some z \\<and>\n       subst rhs z = u'", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat (fst (run_state (term_to_nterm [] t) s)) = Some ?z4\n 2. subst rhs ?z4 = u'", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compile \\<turnstile>\\<^sub>n\n  fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with \\<open>closed ?t\\<^sub>n\\<close>"], ["proof (chain)\npicking this:\n  closed (fst (run_state (term_to_nterm [] t) s))\n  compile \\<turnstile>\\<^sub>n\n  fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'", "have \"closed u'\""], ["proof (prove)\nusing this:\n  closed (fst (run_state (term_to_nterm [] t) s))\n  compile \\<turnstile>\\<^sub>n\n  fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\n\ngoal (1 subgoal):\n 1. closed u'", "by (blast intro:rules_as_nrules.nrewrite_closed)"], ["proof (state)\nthis:\n  closed u'\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "with \\<open>t' = nterm_to_term' _\\<close>"], ["proof (chain)\npicking this:\n  t' = nterm_to_term' u'\n  closed u'", "have \"u' \\<approx>\\<^sub>\\<alpha> ?t\\<^sub>n'\""], ["proof (prove)\nusing this:\n  t' = nterm_to_term' u'\n  closed u'\n\ngoal (1 subgoal):\n 1. u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "by (force intro: nterm_to_term_term_to_nterm[where \\<Gamma> = \"[]\" and \\<Gamma>' = \"[]\",simplified])"], ["proof (state)\nthis:\n  u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\n\ngoal (4 subgoals):\n 1. \\<And>r t u s s'.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u; closed t;\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] t)\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] u) s')\n 2. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 3. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 4. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u' \\<and>\n       u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply (rule nrewrite.step)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?r2 |\\<in>| compile\n 2. ?r2 \\<turnstile> fst (run_state (term_to_nterm [] t) s) \\<rightarrow>\n    ?u'\n 3. ?u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (pat, rhs) \\<turnstile>\n    fst (run_state (term_to_nterm [] t) s) \\<rightarrow> ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>z.\n       match pat (fst (run_state (term_to_nterm [] t) s)) = Some z \\<and>\n       subst rhs z = ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply (intro conjI exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. match pat (fst (run_state (term_to_nterm [] t) s)) = Some ?z6\n 2. subst rhs ?z6 = ?u'\n 3. ?u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>u'.\n     compile \\<turnstile>\\<^sub>n\n     fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u' \\<and>\n     u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "case (beta t t')"], ["proof (state)\nthis:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "let ?name = \"next s\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "let ?t\\<^sub>n = \"fst (run_state (term_to_nterm [?name] t) (?name))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "let ?t\\<^sub>n' = \"fst (run_state (term_to_nterm [] t') (snd (run_state (term_to_nterm [?name] t) (?name))))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from beta"], ["proof (chain)\npicking this:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')", "have \"closed t\" \"closed (t [t']\\<^sub>\\<beta>)\"  \"closed (\\<Lambda> t $ t')\" \"closed  t'\""], ["proof (prove)\nusing this:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')\n\ngoal (1 subgoal):\n 1. (closed t &&& closed t [t']\\<^sub>\\<beta>) &&&\n    closed (\\<Lambda> t $ t') &&& closed t'", "using replace_bound_frees"], ["proof (prove)\nusing this:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')\n  frees (replace_bound ?n ?t ?t') |\\<subseteq>|\n  frees ?t |\\<union>| frees ?t'\n\ngoal (1 subgoal):\n 1. (closed t &&& closed t [t']\\<^sub>\\<beta>) &&&\n    closed (\\<Lambda> t $ t') &&& closed t'", "by fastforce+"], ["proof (state)\nthis:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "moreover"], ["proof (state)\nthis:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from beta"], ["proof (chain)\npicking this:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')", "have \"wellformed' (Suc 0) t\" \"wellformed t'\""], ["proof (prove)\nusing this:\n  closed (\\<Lambda> t $ t')\n  pre_strong_term_class.wellformed (\\<Lambda> t $ t')\n\ngoal (1 subgoal):\n 1. wellformed' (Suc 0) t &&& pre_strong_term_class.wellformed t'", "by simp+"], ["proof (state)\nthis:\n  wellformed' (Suc 0) t\n  pre_strong_term_class.wellformed t'\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "ultimately"], ["proof (chain)\npicking this:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n  wellformed' (Suc 0) t\n  pre_strong_term_class.wellformed t'", "have \"t = nterm_to_term [?name] ?t\\<^sub>n\"\n             and \"t' = nterm_to_term' ?t\\<^sub>n'\"\n             and *:\"frees ?t\\<^sub>n = {|?name|} \\<or> frees ?t\\<^sub>n = fempty\"\n             and \"closed ?t\\<^sub>n'\""], ["proof (prove)\nusing this:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n  wellformed' (Suc 0) t\n  pre_strong_term_class.wellformed t'\n\ngoal (1 subgoal):\n 1. (t =\n     nterm_to_term [next s]\n      (fst (run_state (term_to_nterm [next s] t) (next s))) &&&\n     t' =\n     nterm_to_term'\n      (fst (run_state (term_to_nterm [] t')\n             (snd (run_state (term_to_nterm [next s] t) (next s)))))) &&&\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n    {|next s|} \\<or>\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||} &&&\n    closed\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t) (next s)))))", "using term_to_nterm_vars0[where \\<Gamma> = \"[?name]\"]"], ["proof (prove)\nusing this:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n  wellformed' (Suc 0) t\n  pre_strong_term_class.wellformed t'\n  wellformed' (length [next s]) ?t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm [next s] ?t) ?s)) |\\<subseteq>|\n  frees ?t |\\<union>| fset_of_list [next s]\n\ngoal (1 subgoal):\n 1. (t =\n     nterm_to_term [next s]\n      (fst (run_state (term_to_nterm [next s] t) (next s))) &&&\n     t' =\n     nterm_to_term'\n      (fst (run_state (term_to_nterm [] t')\n             (snd (run_state (term_to_nterm [next s] t) (next s)))))) &&&\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n    {|next s|} \\<or>\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||} &&&\n    closed\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t) (next s)))))", "using term_to_nterm_vars0[where \\<Gamma> = \"[]\"]"], ["proof (prove)\nusing this:\n  closed t\n  closed t [t']\\<^sub>\\<beta>\n  closed (\\<Lambda> t $ t')\n  closed t'\n  wellformed' (Suc 0) t\n  pre_strong_term_class.wellformed t'\n  wellformed' (length [next s]) ?t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm [next s] ?t) ?s)) |\\<subseteq>|\n  frees ?t |\\<union>| fset_of_list [next s]\n  wellformed' (length []) ?t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm [] ?t) ?s)) |\\<subseteq>|\n  frees ?t |\\<union>| fset_of_list []\n\ngoal (1 subgoal):\n 1. (t =\n     nterm_to_term [next s]\n      (fst (run_state (term_to_nterm [next s] t) (next s))) &&&\n     t' =\n     nterm_to_term'\n      (fst (run_state (term_to_nterm [] t')\n             (snd (run_state (term_to_nterm [next s] t) (next s)))))) &&&\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n    {|next s|} \\<or>\n    frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||} &&&\n    closed\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t) (next s)))))", "by (force simp: term_to_nterm_nterm_to_term0)+"], ["proof (state)\nthis:\n  t =\n  nterm_to_term [next s]\n   (fst (run_state (term_to_nterm [next s] t) (next s)))\n  t' =\n  nterm_to_term'\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n  {|next s|} \\<or>\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||}\n  closed\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "hence **:\"t [t']\\<^sub>\\<beta> = nterm_to_term' (subst_single ?t\\<^sub>n ?name ?t\\<^sub>n')\""], ["proof (prove)\nusing this:\n  t =\n  nterm_to_term [next s]\n   (fst (run_state (term_to_nterm [next s] t) (next s)))\n  t' =\n  nterm_to_term'\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n  {|next s|} \\<or>\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||}\n  closed\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))\n\ngoal (1 subgoal):\n 1. t [t']\\<^sub>\\<beta> =\n    nterm_to_term'\n     (subst_single (fst (run_state (term_to_nterm [next s] t) (next s)))\n       (next s)\n       (fst (run_state (term_to_nterm [] t')\n              (snd (run_state (term_to_nterm [next s] t) (next s))))))", "by (auto simp: nterm_to_term_subst_replace_bound[where n = 0])"], ["proof (state)\nthis:\n  t [t']\\<^sub>\\<beta> =\n  nterm_to_term'\n   (subst_single (fst (run_state (term_to_nterm [next s] t) (next s)))\n     (next s)\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t) (next s))))))\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from \\<open>closed ?t\\<^sub>n'\\<close>"], ["proof (chain)\npicking this:\n  closed\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))", "have \"closed_env (fmap_of_list [(?name, ?t\\<^sub>n')])\""], ["proof (prove)\nusing this:\n  closed\n   (fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t) (next s)))))\n\ngoal (1 subgoal):\n 1. closed_env\n     (fmap_of_list\n       [(next s,\n         fst (run_state (term_to_nterm [] t')\n               (snd (run_state (term_to_nterm [next s] t) (next s)))))])", "by auto"], ["proof (state)\nthis:\n  closed_env\n   (fmap_of_list\n     [(next s,\n       fst (run_state (term_to_nterm [] t')\n             (snd (run_state (term_to_nterm [next s] t) (next s)))))])\n\ngoal (3 subgoals):\n 1. \\<And>t t' s s'.\n       \\<lbrakk>closed (\\<Lambda> t $ t');\n        pre_strong_term_class.wellformed (\\<Lambda> t $ t')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state\n                                  (term_to_nterm [] (\\<Lambda> t $ t'))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state\n                                  (term_to_nterm [] t [t']\\<^sub>\\<beta>)\n                                  s')\n 2. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 3. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] (\\<Lambda> t $ t'))\n             s) \\<longrightarrow>\n       u' \\<and>\n       u' \\<approx>\\<^sub>\\<alpha>\n       fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] (\\<Lambda> t $ t'))\n          s) \\<longrightarrow>\n    ?u' \\<and>\n    ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')", "apply (auto simp: split_beta create_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    (\\<Lambda>\\<^sub>n next\n                        s. fst (run_state (term_to_nterm [next s] t)\n                                 (next s))) $\\<^sub>n\n    fst (run_state (term_to_nterm [] t')\n          (snd (run_state (term_to_nterm [next s] t)\n                 (next s)))) \\<longrightarrow>\n    ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')", "apply (rule nrewrite.beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (fst (run_state (term_to_nterm [next s] t) (next s)))\n     (fmap_of_list\n       [(next s,\n         fst (run_state (term_to_nterm [] t')\n               (snd (run_state (term_to_nterm [next s] t)\n                      (next s)))))]) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')", "apply (subst subst_single_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_single (fst (run_state (term_to_nterm [next s] t) (next s)))\n     (next s)\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t)\n                   (next s))))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')", "apply (subst **)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_single (fst (run_state (term_to_nterm [next s] t) (next s)))\n     (next s)\n     (fst (run_state (term_to_nterm [] t')\n            (snd (run_state (term_to_nterm [next s] t)\n                   (next s))))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state\n          (term_to_nterm []\n            (nterm_to_term'\n              (subst_single\n                (fst (run_state (term_to_nterm [next s] t) (next s)))\n                (next s)\n                (fst (run_state (term_to_nterm [] t')\n                       (snd (run_state (term_to_nterm [next s] t)\n                              (next s))))))))\n          s')", "apply (rule nterm_to_term_term_to_nterm[where \\<Gamma> = \"[]\" and \\<Gamma>' = \"[]\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees\n     (subst_single (fst (run_state (term_to_nterm [next s] t) (next s)))\n       (next s)\n       (fst (run_state (term_to_nterm [] t')\n              (snd (run_state (term_to_nterm [next s] t) (next s)))))) =\n    {||}", "apply (subst subst_single_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees\n     (subst (fst (run_state (term_to_nterm [next s] t) (next s)))\n       (fmap_of_list\n         [(next s,\n           fst (run_state (term_to_nterm [] t')\n                 (snd (run_state (term_to_nterm [next s] t)\n                        (next s)))))])) =\n    {||}", "apply (subst subst_frees[OF \\<open>closed_env _\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (fst (run_state (term_to_nterm [next s] t) (next s))) |-|\n    fmdom\n     (fmap_of_list\n       [(next s,\n         fst (run_state (term_to_nterm [] t')\n               (snd (run_state (term_to_nterm [next s] t) (next s)))))]) =\n    {||}", "using *"], ["proof (prove)\nusing this:\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) =\n  {|next s|} \\<or>\n  frees (fst (run_state (term_to_nterm [next s] t) (next s))) = {||}\n\ngoal (1 subgoal):\n 1. frees (fst (run_state (term_to_nterm [next s] t) (next s))) |-|\n    fmdom\n     (fmap_of_list\n       [(next s,\n         fst (run_state (term_to_nterm [] t')\n               (snd (run_state (term_to_nterm [next s] t) (next s)))))]) =\n    {||}", "by force"], ["proof (state)\nthis:\n  \\<exists>u'.\n     compile \\<turnstile>\\<^sub>n\n     fst (run_state (term_to_nterm [] (\\<Lambda> t $ t'))\n           s) \\<longrightarrow>\n     u' \\<and>\n     u' \\<approx>\\<^sub>\\<alpha>\n     fst (run_state (term_to_nterm [] t [t']\\<^sub>\\<beta>) s')\n\ngoal (2 subgoals):\n 1. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 2. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 2. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "case (\"fun\" t t' u)"], ["proof (state)\nthis:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] t)\n                             ?s3) \\<longrightarrow>\n                       u' \\<and>\n                       u' \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] t') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (2 subgoals):\n 1. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 2. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "hence \"closed  t\" \"closed u\" \"closed (t $ u)\"\n       and wellform:\"wellformed t\" \"wellformed u\""], ["proof (prove)\nusing this:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] t)\n                             ?s3) \\<longrightarrow>\n                       u' \\<and>\n                       u' \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] t') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (1 subgoal):\n 1. (closed t &&& closed u &&& closed (t $ u)) &&&\n    pre_strong_term_class.wellformed t &&&\n    pre_strong_term_class.wellformed u", "by fastforce+"], ["proof (state)\nthis:\n  closed t\n  closed u\n  closed (t $ u)\n  pre_strong_term_class.wellformed t\n  pre_strong_term_class.wellformed u\n\ngoal (2 subgoals):\n 1. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 2. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from \"fun\""], ["proof (chain)\npicking this:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] t)\n                             ?s3) \\<longrightarrow>\n                       u' \\<and>\n                       u' \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] t') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)", "obtain u'\n    where \"compile \\<turnstile>\\<^sub>n fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\"\n          \"u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\""], ["proof (prove)\nusing this:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] t)\n                             ?s3) \\<longrightarrow>\n                       u' \\<and>\n                       u' \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] t') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 fst (run_state (term_to_nterm [] t) s) \\<longrightarrow>\n                 u';\n         u' \\<approx>\\<^sub>\\<alpha>\n         fst (run_state (term_to_nterm [] t') s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  compile \\<turnstile>\\<^sub>n\n  fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> u'\n  u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\n\ngoal (2 subgoals):\n 1. \\<And>t t' u s s'.\n       \\<lbrakk>rs \\<turnstile> t \\<longrightarrow> t';\n        \\<And>s s'.\n           \\<lbrakk>closed t; pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] t)\ns) \\<longrightarrow>\n                                u' \\<and>\n                                u' \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] t') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u' \\<and>\n                            u' \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t' $ u)) s')\n 2. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n       u' \\<and>\n       u' \\<approx>\\<^sub>\\<alpha>\n       fst (run_state (term_to_nterm [] (t' $ u)) s')", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n    ?u' \\<and>\n    ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] (t' $ u)) s')", "apply (auto simp: split_beta create_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] t) s) $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<longrightarrow>\n    ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t') s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t') s')))", "apply (rule nrewrite.fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] t) s) \\<longrightarrow> ?t'3\n 2. ?t'3 $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t') s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t') s')))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. u' $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t') s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t') s')))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. u' \\<approx>\\<^sub>\\<alpha> fst (run_state (term_to_nterm [] t') s')\n 2. fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t') s')))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t') s')))", "apply (subst term_to_nterm_alpha_equiv[of \"[]\" \"[]\", simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. frees u = {||}\n 2. Term.wellformed u\n 3. True", "using \\<open>closed u\\<close> \\<open>wellformed u\\<close>"], ["proof (prove)\nusing this:\n  closed u\n  pre_strong_term_class.wellformed u\n\ngoal (3 subgoals):\n 1. frees u = {||}\n 2. Term.wellformed u\n 3. True", "by auto"], ["proof (state)\nthis:\n  \\<exists>u'.\n     compile \\<turnstile>\\<^sub>n\n     fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n     u' \\<and>\n     u' \\<approx>\\<^sub>\\<alpha>\n     fst (run_state (term_to_nterm [] (t' $ u)) s')\n\ngoal (1 subgoal):\n 1. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "case (arg u u' t)"], ["proof (state)\nthis:\n  rs \\<turnstile> u \\<longrightarrow> u'\n  \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'a.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] u)\n                             ?s3) \\<longrightarrow>\n                       u'a \\<and>\n                       u'a \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] u') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (1 subgoal):\n 1. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "hence \"closed  t\" \"closed u\" \"closed (t $ u)\"\n       and wellform:\"wellformed t\" \"wellformed u\""], ["proof (prove)\nusing this:\n  rs \\<turnstile> u \\<longrightarrow> u'\n  \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'a.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] u)\n                             ?s3) \\<longrightarrow>\n                       u'a \\<and>\n                       u'a \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] u') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (1 subgoal):\n 1. (closed t &&& closed u &&& closed (t $ u)) &&&\n    pre_strong_term_class.wellformed t &&&\n    pre_strong_term_class.wellformed u", "by fastforce+"], ["proof (state)\nthis:\n  closed t\n  closed u\n  closed (t $ u)\n  pre_strong_term_class.wellformed t\n  pre_strong_term_class.wellformed u\n\ngoal (1 subgoal):\n 1. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "from arg"], ["proof (chain)\npicking this:\n  rs \\<turnstile> u \\<longrightarrow> u'\n  \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'a.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] u)\n                             ?s3) \\<longrightarrow>\n                       u'a \\<and>\n                       u'a \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] u') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)", "obtain t'\n    where \"compile \\<turnstile>\\<^sub>n fst (run_state (term_to_nterm [] u) (snd (run_state (term_to_nterm [] t) s))) \\<longrightarrow> t'\"\n          \"t' \\<approx>\\<^sub>\\<alpha>  fst (run_state (term_to_nterm [] u') (snd (run_state (term_to_nterm [] t) s')))\""], ["proof (prove)\nusing this:\n  rs \\<turnstile> u \\<longrightarrow> u'\n  \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u'a.\n                       compile \\<turnstile>\\<^sub>n\n                       fst (run_state (term_to_nterm [] u)\n                             ?s3) \\<longrightarrow>\n                       u'a \\<and>\n                       u'a \\<approx>\\<^sub>\\<alpha>\n                       fst (run_state (term_to_nterm [] u') ?s'3)\n  closed (t $ u)\n  pre_strong_term_class.wellformed (t $ u)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 fst (run_state (term_to_nterm [] u)\n                       (snd (run_state (term_to_nterm [] t)\n                              s))) \\<longrightarrow>\n                 t';\n         t' \\<approx>\\<^sub>\\<alpha>\n         fst (run_state (term_to_nterm [] u')\n               (snd (run_state (term_to_nterm [] t) s')))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  compile \\<turnstile>\\<^sub>n\n  fst (run_state (term_to_nterm [] u)\n        (snd (run_state (term_to_nterm [] t) s))) \\<longrightarrow>\n  t'\n  t' \\<approx>\\<^sub>\\<alpha>\n  fst (run_state (term_to_nterm [] u')\n        (snd (run_state (term_to_nterm [] t) s')))\n\ngoal (1 subgoal):\n 1. \\<And>u u' t s s'.\n       \\<lbrakk>rs \\<turnstile> u \\<longrightarrow> u';\n        \\<And>s s'.\n           \\<lbrakk>closed u; pre_strong_term_class.wellformed u\\<rbrakk>\n           \\<Longrightarrow> \\<exists>u'a.\n                                compile \\<turnstile>\\<^sub>n\n                                fst (run_state (term_to_nterm [] u)\ns) \\<longrightarrow>\n                                u'a \\<and>\n                                u'a \\<approx>\\<^sub>\\<alpha>\n                                fst (run_state (term_to_nterm [] u') s');\n        closed (t $ u); pre_strong_term_class.wellformed (t $ u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'a.\n                            compile \\<turnstile>\\<^sub>n\n                            fst (run_state (term_to_nterm [] (t $ u))\n                                  s) \\<longrightarrow>\n                            u'a \\<and>\n                            u'a \\<approx>\\<^sub>\\<alpha>\n                            fst (run_state (term_to_nterm [] (t $ u')) s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'a.\n       compile \\<turnstile>\\<^sub>n\n       fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n       u'a \\<and>\n       u'a \\<approx>\\<^sub>\\<alpha>\n       fst (run_state (term_to_nterm [] (t $ u')) s')", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n    ?u' \\<and>\n    ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] (t $ u')) s')", "apply (auto simp: split_beta create_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] t) s) $\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<longrightarrow>\n    ?u'\n 2. ?u' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t) s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. compile \\<turnstile>\\<^sub>n\n    fst (run_state (term_to_nterm [] u)\n          (snd (run_state (term_to_nterm [] t) s))) \\<longrightarrow>\n    ?u'3\n 2. fst (run_state (term_to_nterm [] t) s) $\\<^sub>n\n    ?u'3 \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t) s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (term_to_nterm [] t) s) $\\<^sub>n\n    t' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t) s') $\\<^sub>n\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst (run_state (term_to_nterm [] t) s) \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] t) s')\n 2. t' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "apply (subst term_to_nterm_alpha_equiv[of \"[]\" \"[]\", simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. frees t = {||}\n 2. Term.wellformed t\n 3. True\n 4. t' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "using \\<open>closed t\\<close> \\<open>wellformed t\\<close>"], ["proof (prove)\nusing this:\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (4 subgoals):\n 1. frees t = {||}\n 2. Term.wellformed t\n 3. True\n 4. t' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>\\<alpha>\n    fst (run_state (term_to_nterm [] u')\n          (snd (run_state (term_to_nterm [] t) s')))", "by fact"], ["proof (state)\nthis:\n  \\<exists>u'a.\n     compile \\<turnstile>\\<^sub>n\n     fst (run_state (term_to_nterm [] (t $ u)) s) \\<longrightarrow>\n     u'a \\<and>\n     u'a \\<approx>\\<^sub>\\<alpha>\n     fst (run_state (term_to_nterm [] (t $ u')) s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compile_complete:\n  assumes \"rs \\<turnstile> t \\<longrightarrow> t'\" \"closed t\" \"wellformed t\"\n  obtains u' where \"compile \\<turnstile>\\<^sub>n term_to_nterm' t \\<longrightarrow> u'\" \"u' \\<approx>\\<^sub>\\<alpha> term_to_nterm' t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 term_to_nterm' t \\<longrightarrow> u';\n         u' \\<approx>\\<^sub>\\<alpha> term_to_nterm' t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding term_to_nterm'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 frun_fresh (term_to_nterm [] t) (frees t) \\<longrightarrow>\n                 u';\n         u' \\<approx>\\<^sub>\\<alpha>\n         frun_fresh (term_to_nterm [] t') (frees t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile> t \\<longrightarrow> t'\n  closed t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>compile \\<turnstile>\\<^sub>n\n                 frun_fresh (term_to_nterm [] t) (frees t) \\<longrightarrow>\n                 u';\n         u' \\<approx>\\<^sub>\\<alpha>\n         frun_fresh (term_to_nterm [] t') (frees t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis compile_complete0)"], ["", "end"], ["", "end"], ["", "subsection \\<open>Splitting into constants\\<close>"], ["", "type_synonym crules = \"(term list \\<times> nterm) fset\""], ["", "type_synonym crule_set = \"(name \\<times> crules) fset\""], ["", "abbreviation arity_compatibles :: \"(term list \\<times> 'a) fset \\<Rightarrow> bool\" where\n\"arity_compatibles \\<equiv> fpairwise (\\<lambda>(pats\\<^sub>1, _) (pats\\<^sub>2, _). length pats\\<^sub>1 = length pats\\<^sub>2)\""], ["", "lemma arity_compatible_length:\n  assumes \"arity_compatibles rs\" \"(pats, rhs) |\\<in>| rs\"\n  shows \"length pats = arity rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length pats = arity rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length pats = arity rs", "have \"fBall rs (\\<lambda>(pats\\<^sub>1, _). fBall rs (\\<lambda>(pats\\<^sub>2, _). length pats\\<^sub>1 = length pats\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>(pats\\<^sub>1, uu_).\n         fBall rs\n          (\\<lambda>(pats\\<^sub>2, uu_).\n              length pats\\<^sub>1 = length pats\\<^sub>2))", "using assms"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles rs\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>(pats\\<^sub>1, uu_).\n         fBall rs\n          (\\<lambda>(pats\\<^sub>2, uu_).\n              length pats\\<^sub>1 = length pats\\<^sub>2))", "unfolding fpairwise_alt_def"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>m.\n       fBall rs\n        (case m of\n         (pats\\<^sub>1, uu_) \\<Rightarrow>\n           \\<lambda>(pats\\<^sub>2, uu_).\n              length pats\\<^sub>1 = length pats\\<^sub>2))\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>(pats\\<^sub>1, uu_).\n         fBall rs\n          (\\<lambda>(pats\\<^sub>2, uu_).\n              length pats\\<^sub>1 = length pats\\<^sub>2))", "by blast"], ["proof (state)\nthis:\n  fBall rs\n   (\\<lambda>(pats\\<^sub>1, uu_).\n       fBall rs\n        (\\<lambda>(pats\\<^sub>2, uu_).\n            length pats\\<^sub>1 = length pats\\<^sub>2))\n\ngoal (1 subgoal):\n 1. length pats = arity rs", "hence \"fBall rs (\\<lambda>x. fBall rs (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))\""], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>(pats\\<^sub>1, uu_).\n       fBall rs\n        (\\<lambda>(pats\\<^sub>2, uu_).\n            length pats\\<^sub>1 = length pats\\<^sub>2))\n\ngoal (1 subgoal):\n 1. fBall rs\n     (\\<lambda>x.\n         fBall rs\n          (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))", "by force"], ["proof (state)\nthis:\n  fBall rs\n   (\\<lambda>x.\n       fBall rs\n        (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))\n\ngoal (1 subgoal):\n 1. length pats = arity rs", "hence \"(length \\<circ> fst) (pats, rhs) = arity rs\""], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>x.\n       fBall rs\n        (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))\n\ngoal (1 subgoal):\n 1. (length \\<circ> fst) (pats, rhs) = arity rs", "using assms(2)"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>x.\n       fBall rs\n        (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (length \\<circ> fst) (pats, rhs) = arity rs", "unfolding arity_def fthe_elem'_eq"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>x.\n       fBall rs\n        (\\<lambda>y. (length \\<circ> fst) x = (length \\<circ> fst) y))\n  (pats, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. (length \\<circ> fst) (pats, rhs) =\n    fthe_elem ((length \\<circ> fst) |`| rs)", "by (rule singleton_fset_holds)"], ["proof (state)\nthis:\n  (length \\<circ> fst) (pats, rhs) = arity rs\n\ngoal (1 subgoal):\n 1. length pats = arity rs", "thus ?thesis"], ["proof (prove)\nusing this:\n  (length \\<circ> fst) (pats, rhs) = arity rs\n\ngoal (1 subgoal):\n 1. length pats = arity rs", "by simp"], ["proof (state)\nthis:\n  length pats = arity rs\n\ngoal:\nNo subgoals!", "qed"], ["", "locale pre_crules = constants C_info \"fst |`| rs\" for C_info and rs :: \"crule_set\""], ["", "locale crules = pre_crules +\n  assumes fmap: \"is_fmap rs\"\n  assumes nonempty: \"rs \\<noteq> {||}\"\n  assumes inner:\n    \"fBall rs (\\<lambda>(_, crs).\n      arity_compatibles crs \\<and>\n      is_fmap crs \\<and>\n      patterns_compatibles crs \\<and>\n      crs \\<noteq> {||} \\<and>\n      fBall crs (\\<lambda>(pats, rhs).\n        linears pats \\<and>\n        pats \\<noteq> [] \\<and>\n        fdisjnt (freess pats) all_consts \\<and>\n        \\<not> shadows_consts rhs \\<and>\n        frees rhs |\\<subseteq>| freess pats \\<and>\n        welldefined rhs))\""], ["", "lemma (in pre_crules) crulesI:\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> arity_compatibles crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> is_fmap crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> patterns_compatibles crs\"\n  assumes \"\\<And>name crs. (name, crs) |\\<in>| rs \\<Longrightarrow> crs \\<noteq> {||}\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> linears pats\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> pats \\<noteq> []\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> fdisjnt (freess pats) all_consts\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> \\<not> shadows_consts rhs\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\"\n  assumes \"\\<And>name crs pats rhs. (name, crs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| crs \\<Longrightarrow> welldefined rhs\"\n  assumes \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  shows \"crules C_info rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crules C_info rs", "using assms"], ["proof (prove)\nusing this:\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow>\n  Rewriting_Nterm.arity_compatibles ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> is_fmap ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> patterns_compatibles ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> ?crs3 \\<noteq> {||}\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> linears ?pats3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> ?pats3 \\<noteq> []\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> fdisjnt (freess ?pats3) all_consts\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts ?rhs3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> frees ?rhs3 |\\<subseteq>| freess ?pats3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> consts ?rhs3 |\\<subseteq>| all_consts\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. crules C_info rs", "unfolding crules_axioms_def crules_def"], ["proof (prove)\nusing this:\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow>\n  Rewriting_Nterm.arity_compatibles ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> is_fmap ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> patterns_compatibles ?crs3\n  (?name3, ?crs3) |\\<in>| rs \\<Longrightarrow> ?crs3 \\<noteq> {||}\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> linears ?pats3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> ?pats3 \\<noteq> []\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> fdisjnt (freess ?pats3) all_consts\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts ?rhs3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> frees ?rhs3 |\\<subseteq>| freess ?pats3\n  \\<lbrakk>(?name3, ?crs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?crs3\\<rbrakk>\n  \\<Longrightarrow> consts ?rhs3 |\\<subseteq>| all_consts\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. pre_crules C_info rs \\<and>\n    is_fmap rs \\<and>\n    rs \\<noteq> {||} \\<and>\n    fBall rs\n     (\\<lambda>(uu_, crs).\n         Rewriting_Nterm.arity_compatibles crs \\<and>\n         is_fmap crs \\<and>\n         patterns_compatibles crs \\<and>\n         crs \\<noteq> {||} \\<and>\n         fBall crs\n          (\\<lambda>(pats, rhs).\n              linears pats \\<and>\n              pats \\<noteq> [] \\<and>\n              fdisjnt (freess pats) all_consts \\<and>\n              \\<not> shadows_consts rhs \\<and>\n              frees rhs |\\<subseteq>| freess pats \\<and>\n              consts rhs |\\<subseteq>| all_consts))", "by (auto simp: prod_fBallI intro: pre_crules_axioms)"], ["", "lemmas crulesI[intro!] = pre_crules.crulesI[unfolded pre_crules_def]"], ["", "definition \"consts_of\" :: \"nrule fset \\<Rightarrow> crule_set\" where\n\"consts_of = fgroup_by split_rule\""], ["", "lemma consts_of_heads: \"fst |`| consts_of rs = heads_of rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| consts_of rs = heads_of rs", "unfolding consts_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| fgroup_by split_rule rs = heads_of rs", "by (simp add: split_rule_fst comp_def)"], ["", "lemma (in nrules) consts_rules: \"crules C_info (consts_of rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crules C_info (consts_of rs)", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. constants C_info (fst |`| consts_of rs)\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 5. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\nA total of 13 subgoals...", "have \"is_fmap rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "using fmap"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap rs", "by simp"], ["proof (state)\nthis:\n  is_fmap rs\n\ngoal (13 subgoals):\n 1. constants C_info (fst |`| consts_of rs)\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 5. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\nA total of 13 subgoals...", "thus \"is_fmap (consts_of rs)\""], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (consts_of rs)", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (fgroup_by split_rule rs)", "by auto"], ["proof (state)\nthis:\n  is_fmap (consts_of rs)\n\ngoal (12 subgoals):\n 1. constants C_info (fst |`| consts_of rs)\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 5. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\nA total of 12 subgoals...", "show \"consts_of rs \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts_of rs \\<noteq> {||}", "using nonempty"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. consts_of rs \\<noteq> {||}", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. fgroup_by split_rule rs \\<noteq> {||}", "by (meson fgroup_by_nonempty)"], ["proof (state)\nthis:\n  consts_of rs \\<noteq> {||}\n\ngoal (11 subgoals):\n 1. constants C_info (fst |`| consts_of rs)\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 5. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\nA total of 11 subgoals...", "show \"constants C_info (fst |`| consts_of rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constants C_info (fst |`| consts_of rs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (fst |`| consts_of rs) C\n 2. distinct all_constructors", "show \"fdisjnt (fst |`| consts_of rs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| consts_of rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (heads_of rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| consts_of rs) C", "by (auto simp: consts_of_heads)"], ["proof (state)\nthis:\n  fdisjnt (fst |`| consts_of rs) C\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  constants C_info (fst |`| consts_of rs)\n\ngoal (10 subgoals):\n 1. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| consts_of rs)", "fix name crs"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| consts_of rs)", "assume crs: \"(name, crs) |\\<in>| consts_of rs\""], ["proof (state)\nthis:\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (10 subgoals):\n 1. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 4. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> crs \\<noteq> {||}\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 10. \\<And>name crs pats rhs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs) |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| consts_of rs)", "thus \"crs \\<noteq> {||}\""], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (1 subgoal):\n 1. crs \\<noteq> {||}", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| fgroup_by split_rule rs\n\ngoal (1 subgoal):\n 1. crs \\<noteq> {||}", "by (meson femptyE fgroup_by_nonempty_inner)"], ["proof (state)\nthis:\n  crs \\<noteq> {||}\n\ngoal (9 subgoals):\n 1. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles crs\n 2. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 3. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow>\n       patterns_compatibles crs\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 8. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 9. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "show \"arity_compatibles crs\" \"patterns_compatibles crs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles crs &&& patterns_compatibles crs", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "fix pats\\<^sub>1 rhs\\<^sub>1 pats\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "assume \"(pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| crs\" \"(pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| crs\""], ["proof (state)\nthis:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| crs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "with crs"], ["proof (chain)\npicking this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| crs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| crs", "obtain lhs\\<^sub>1 lhs\\<^sub>2\n        where rs: \"(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\" \"(lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\" and\n              split: \"split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, (pats\\<^sub>1, rhs\\<^sub>1))\"\n                     \"split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, (pats\\<^sub>2, rhs\\<^sub>2))\""], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| crs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs\\<^sub>1 lhs\\<^sub>2.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs;\n         split_rule (lhs\\<^sub>1, rhs\\<^sub>1) =\n         (name, pats\\<^sub>1, rhs\\<^sub>1);\n         split_rule (lhs\\<^sub>2, rhs\\<^sub>2) =\n         (name, pats\\<^sub>2, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| fgroup_by split_rule rs\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| crs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs\\<^sub>1 lhs\\<^sub>2.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs;\n         split_rule (lhs\\<^sub>1, rhs\\<^sub>1) =\n         (name, pats\\<^sub>1, rhs\\<^sub>1);\n         split_rule (lhs\\<^sub>2, rhs\\<^sub>2) =\n         (name, pats\\<^sub>2, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: split_beta)"], ["proof (state)\nthis:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "hence arity: \"arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. arity_compatible lhs\\<^sub>1 lhs\\<^sub>2", "using arity"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n  term_class.arity_compatibles rs\n\ngoal (1 subgoal):\n 1. arity_compatible lhs\\<^sub>1 lhs\\<^sub>2", "by (force dest: fpairwiseD)"], ["proof (state)\nthis:\n  arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "from rs"], ["proof (chain)\npicking this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs", "have const: \"is_const (fst (strip_comb lhs\\<^sub>1))\" \"is_const (fst (strip_comb lhs\\<^sub>2))\""], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb lhs\\<^sub>1)) &&&\n    is_const (fst (strip_comb lhs\\<^sub>2))", "using all_rules"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb lhs\\<^sub>1)) &&&\n    is_const (fst (strip_comb lhs\\<^sub>2))", "by force+"], ["proof (state)\nthis:\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "have \"name = const_name (fst (strip_comb lhs\\<^sub>1))\" \"name = const_name (fst (strip_comb lhs\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name = const_name (fst (strip_comb lhs\\<^sub>1)) &&&\n    name = const_name (fst (strip_comb lhs\\<^sub>2))", "using split"], ["proof (prove)\nusing this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. name = const_name (fst (strip_comb lhs\\<^sub>1)) &&&\n    name = const_name (fst (strip_comb lhs\\<^sub>2))", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  name = const_name (fst (strip_comb lhs\\<^sub>1))\n  name = const_name (fst (strip_comb lhs\\<^sub>2))\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "with const"], ["proof (chain)\npicking this:\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n  name = const_name (fst (strip_comb lhs\\<^sub>1))\n  name = const_name (fst (strip_comb lhs\\<^sub>2))", "have \"fst (strip_comb lhs\\<^sub>1) = Const name\" \"fst (strip_comb lhs\\<^sub>2) = Const name\""], ["proof (prove)\nusing this:\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n  name = const_name (fst (strip_comb lhs\\<^sub>1))\n  name = const_name (fst (strip_comb lhs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. fst (strip_comb lhs\\<^sub>1) = Const name &&&\n    fst (strip_comb lhs\\<^sub>2) = Const name", "apply (fold const_term_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_const (fst (strip_comb lhs\\<^sub>1));\n     is_const (fst (strip_comb lhs\\<^sub>2));\n     name = const_name (fst (strip_comb lhs\\<^sub>1));\n     name = const_name (fst (strip_comb lhs\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> fst (strip_comb lhs\\<^sub>1) = const name\n 2. \\<lbrakk>is_const (fst (strip_comb lhs\\<^sub>1));\n     is_const (fst (strip_comb lhs\\<^sub>2));\n     name = const_name (fst (strip_comb lhs\\<^sub>1));\n     name = const_name (fst (strip_comb lhs\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> fst (strip_comb lhs\\<^sub>2) = const name", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_const (fst (strip_comb lhs\\<^sub>1));\n     is_const (fst (strip_comb lhs\\<^sub>2));\n     name = const_name (fst (strip_comb lhs\\<^sub>1));\n     name = const_name (fst (strip_comb lhs\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> fst (strip_comb lhs\\<^sub>1) = const name", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_const (fst (strip_comb lhs\\<^sub>1));\n     is_const (fst (strip_comb lhs\\<^sub>2));\n     name = const_name (fst (strip_comb lhs\\<^sub>1));\n     name = const_name (fst (strip_comb lhs\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> fst (strip_comb lhs\\<^sub>2) = const name", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_const (fst (strip_comb lhs\\<^sub>1));\n     is_const (fst (strip_comb lhs\\<^sub>2));\n     name = const_name (fst (strip_comb lhs\\<^sub>1));\n     name = const_name (fst (strip_comb lhs\\<^sub>2))\\<rbrakk>\n    \\<Longrightarrow> fst (strip_comb lhs\\<^sub>2) = const name", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fst (strip_comb lhs\\<^sub>1) = Const name\n  fst (strip_comb lhs\\<^sub>2) = Const name\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "hence fst: \"fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)\""], ["proof (prove)\nusing this:\n  fst (strip_comb lhs\\<^sub>1) = Const name\n  fst (strip_comb lhs\\<^sub>2) = Const name\n\ngoal (1 subgoal):\n 1. fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "with arity"], ["proof (chain)\npicking this:\n  arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\n  fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)", "have \"length (snd (strip_comb lhs\\<^sub>1)) = length (snd (strip_comb lhs\\<^sub>2))\""], ["proof (prove)\nusing this:\n  arity_compatible lhs\\<^sub>1 lhs\\<^sub>2\n  fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. length (snd (strip_comb lhs\\<^sub>1)) =\n    length (snd (strip_comb lhs\\<^sub>2))", "unfolding arity_compatible_def"], ["proof (prove)\nusing this:\n  let (head\\<^sub>1, pats\\<^sub>1) = strip_comb lhs\\<^sub>1;\n      (head\\<^sub>2, pats\\<^sub>2) = strip_comb lhs\\<^sub>2\n  in head\\<^sub>1 = head\\<^sub>2 \\<longrightarrow>\n     length pats\\<^sub>1 = length pats\\<^sub>2\n  fst (strip_comb lhs\\<^sub>1) = fst (strip_comb lhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. length (snd (strip_comb lhs\\<^sub>1)) =\n    length (snd (strip_comb lhs\\<^sub>2))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  length (snd (strip_comb lhs\\<^sub>1)) =\n  length (snd (strip_comb lhs\\<^sub>2))\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "with split"], ["proof (chain)\npicking this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n  length (snd (strip_comb lhs\\<^sub>1)) =\n  length (snd (strip_comb lhs\\<^sub>2))", "show \"length pats\\<^sub>1 = length pats\\<^sub>2\""], ["proof (prove)\nusing this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n  length (snd (strip_comb lhs\\<^sub>1)) =\n  length (snd (strip_comb lhs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. length pats\\<^sub>1 = length pats\\<^sub>2", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  length pats\\<^sub>1 = length pats\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "have \"pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2", "using rs patterns"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  pattern_compatibles rs\n\ngoal (1 subgoal):\n 1. pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2", "by (auto dest: fpairwiseD)"], ["proof (state)\nthis:\n  pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "moreover"], ["proof (state)\nthis:\n  pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "have \"lhs\\<^sub>1 = name $$ pats\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 = name $$ pats\\<^sub>1", "using split(1) const(1)"], ["proof (prove)\nusing this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats\\<^sub>1, rhs\\<^sub>1)\n  is_const (fst (strip_comb lhs\\<^sub>1))\n\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 = name $$ pats\\<^sub>1", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  lhs\\<^sub>1 = name $$ pats\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "moreover"], ["proof (state)\nthis:\n  lhs\\<^sub>1 = name $$ pats\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "have \"lhs\\<^sub>2 = name $$ pats\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs\\<^sub>2 = name $$ pats\\<^sub>2", "using split(2) const(2)"], ["proof (prove)\nusing this:\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats\\<^sub>2, rhs\\<^sub>2)\n  is_const (fst (strip_comb lhs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. lhs\\<^sub>2 = name $$ pats\\<^sub>2", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  lhs\\<^sub>2 = name $$ pats\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "ultimately"], ["proof (chain)\npicking this:\n  pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2\n  lhs\\<^sub>1 = name $$ pats\\<^sub>1\n  lhs\\<^sub>2 = name $$ pats\\<^sub>2", "have \"pattern_compatible (name $$ pats\\<^sub>1) (name $$ pats\\<^sub>2)\""], ["proof (prove)\nusing this:\n  pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2\n  lhs\\<^sub>1 = name $$ pats\\<^sub>1\n  lhs\\<^sub>2 = name $$ pats\\<^sub>2\n\ngoal (1 subgoal):\n 1. pattern_compatible (name $$ pats\\<^sub>1) (name $$ pats\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  pattern_compatible (name $$ pats\\<^sub>1) (name $$ pats\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| crs; (aa, ba) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "thus \"patterns_compatible pats\\<^sub>1 pats\\<^sub>2\""], ["proof (prove)\nusing this:\n  pattern_compatible (name $$ pats\\<^sub>1) (name $$ pats\\<^sub>2)\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1 pats\\<^sub>2", "using \\<open>length pats\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  pattern_compatible (name $$ pats\\<^sub>1) (name $$ pats\\<^sub>2)\n  length pats\\<^sub>1 = length pats\\<^sub>2\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1 pats\\<^sub>2", "by (auto dest: pattern_compatible_combD)"], ["proof (state)\nthis:\n  patterns_compatible pats\\<^sub>1 pats\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles crs\n  patterns_compatibles crs\n\ngoal (7 subgoals):\n 1. \\<And>name crs.\n       (name, crs) |\\<in>| consts_of rs \\<Longrightarrow> is_fmap crs\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 7. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "show \"is_fmap crs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap crs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| crs;\n        (a, b\\<^sub>2) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "fix pats rhs\\<^sub>1 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| crs;\n        (a, b\\<^sub>2) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "assume \"(pats, rhs\\<^sub>1) |\\<in>| crs\" \"(pats, rhs\\<^sub>2) |\\<in>| crs\""], ["proof (state)\nthis:\n  (pats, rhs\\<^sub>1) |\\<in>| crs\n  (pats, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| crs;\n        (a, b\\<^sub>2) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "with crs"], ["proof (chain)\npicking this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats, rhs\\<^sub>1) |\\<in>| crs\n  (pats, rhs\\<^sub>2) |\\<in>| crs", "obtain lhs\\<^sub>1 lhs\\<^sub>2\n        where rs: \"(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\" \"(lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\" and\n              split: \"split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, (pats, rhs\\<^sub>1))\"\n                     \"split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, (pats, rhs\\<^sub>2))\""], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats, rhs\\<^sub>1) |\\<in>| crs\n  (pats, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs\\<^sub>1 lhs\\<^sub>2.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs;\n         split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1);\n         split_rule (lhs\\<^sub>2, rhs\\<^sub>2) =\n         (name, pats, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| fgroup_by split_rule rs\n  (pats, rhs\\<^sub>1) |\\<in>| crs\n  (pats, rhs\\<^sub>2) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs\\<^sub>1 lhs\\<^sub>2.\n        \\<lbrakk>(lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs;\n         (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs;\n         split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1);\n         split_rule (lhs\\<^sub>2, rhs\\<^sub>2) =\n         (name, pats, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: split_beta)"], ["proof (state)\nthis:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| crs;\n        (a, b\\<^sub>2) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "have \"lhs\\<^sub>1 = lhs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 = lhs\\<^sub>2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2 \\<Longrightarrow> False", "assume \"lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2\""], ["proof (state)\nthis:\n  lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2", "consider (fst) \"fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\"\n                      | (snd) \"snd (strip_comb lhs\\<^sub>1) \\<noteq> snd (strip_comb lhs\\<^sub>2)\""], ["proof (prove)\nusing this:\n  lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (strip_comb lhs\\<^sub>1) \\<noteq>\n             fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n             thesis;\n     snd (strip_comb lhs\\<^sub>1) \\<noteq>\n     snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis list_strip_comb)"], ["proof (state)\nthis:\n  \\<lbrakk>fst (strip_comb lhs\\<^sub>1) \\<noteq>\n           fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n           ?thesis3;\n   snd (strip_comb lhs\\<^sub>1) \\<noteq>\n   snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n   ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (1 subgoal):\n 1. lhs\\<^sub>1 \\<noteq> lhs\\<^sub>2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst (strip_comb lhs\\<^sub>1) \\<noteq>\n           fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n           ?thesis3;\n   snd (strip_comb lhs\\<^sub>1) \\<noteq>\n   snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n   ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (strip_comb lhs\\<^sub>1) \\<noteq>\n    fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False\n 2. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "case fst"], ["proof (state)\nthis:\n  fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. fst (strip_comb lhs\\<^sub>1) \\<noteq>\n    fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False\n 2. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\n\ngoal (2 subgoals):\n 1. fst (strip_comb lhs\\<^sub>1) \\<noteq>\n    fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False\n 2. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "have \"is_const (fst (strip_comb lhs\\<^sub>1))\" \"is_const (fst (strip_comb lhs\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb lhs\\<^sub>1)) &&&\n    is_const (fst (strip_comb lhs\\<^sub>2))", "using rs all_rules"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb lhs\\<^sub>1)) &&&\n    is_const (fst (strip_comb lhs\\<^sub>2))", "by force+"], ["proof (state)\nthis:\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n\ngoal (2 subgoals):\n 1. fst (strip_comb lhs\\<^sub>1) \\<noteq>\n    fst (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False\n 2. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n\ngoal (1 subgoal):\n 1. False", "using split const_name_simps"], ["proof (prove)\nusing this:\n  fst (strip_comb lhs\\<^sub>1) \\<noteq> fst (strip_comb lhs\\<^sub>2)\n  is_const (fst (strip_comb lhs\\<^sub>1))\n  is_const (fst (strip_comb lhs\\<^sub>2))\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats, rhs\\<^sub>2)\n  const_name (const ?name) = ?name\n  is_const ?t \\<Longrightarrow> const (const_name ?t) = ?t\n\ngoal (1 subgoal):\n 1. False", "by (fastforce simp: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "case snd"], ["proof (state)\nthis:\n  snd (strip_comb lhs\\<^sub>1) \\<noteq> snd (strip_comb lhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. snd (strip_comb lhs\\<^sub>1) \\<noteq>\n    snd (strip_comb lhs\\<^sub>2) \\<Longrightarrow>\n    False", "with split"], ["proof (chain)\npicking this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats, rhs\\<^sub>2)\n  snd (strip_comb lhs\\<^sub>1) \\<noteq> snd (strip_comb lhs\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  split_rule (lhs\\<^sub>1, rhs\\<^sub>1) = (name, pats, rhs\\<^sub>1)\n  split_rule (lhs\\<^sub>2, rhs\\<^sub>2) = (name, pats, rhs\\<^sub>2)\n  snd (strip_comb lhs\\<^sub>1) \\<noteq> snd (strip_comb lhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lhs\\<^sub>1 = lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| crs;\n        (a, b\\<^sub>2) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "with rs"], ["proof (chain)\npicking this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  lhs\\<^sub>1 = lhs\\<^sub>2", "show \"rhs\\<^sub>1 = rhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  lhs\\<^sub>1 = lhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. rhs\\<^sub>1 = rhs\\<^sub>2", "using \\<open>is_fmap rs\\<close>"], ["proof (prove)\nusing this:\n  (lhs\\<^sub>1, rhs\\<^sub>1) |\\<in>| rs\n  (lhs\\<^sub>2, rhs\\<^sub>2) |\\<in>| rs\n  lhs\\<^sub>1 = lhs\\<^sub>2\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. rhs\\<^sub>1 = rhs\\<^sub>2", "by (auto dest: is_fmapD)"], ["proof (state)\nthis:\n  rhs\\<^sub>1 = rhs\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_fmap crs\n\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "fix pats rhs"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "assume \"(pats, rhs) |\\<in>| crs\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| crs\n\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "then"], ["proof (chain)\npicking this:\n  (pats, rhs) |\\<in>| crs", "obtain lhs where \"(lhs, rhs) |\\<in>| rs\" \"pats = snd (strip_comb lhs)\""], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs.\n        \\<lbrakk>(lhs, rhs) |\\<in>| rs; pats = snd (strip_comb lhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using crs"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs.\n        \\<lbrakk>(lhs, rhs) |\\<in>| rs; pats = snd (strip_comb lhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| crs\n  (name, crs) |\\<in>| fgroup_by split_rule rs\n\ngoal (1 subgoal):\n 1. (\\<And>lhs.\n        \\<lbrakk>(lhs, rhs) |\\<in>| rs; pats = snd (strip_comb lhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: split_beta)"], ["proof (state)\nthis:\n  (lhs, rhs) |\\<in>| rs\n  pats = snd (strip_comb lhs)\n\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "hence \"nrule (lhs, rhs)\""], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| rs\n  pats = snd (strip_comb lhs)\n\ngoal (1 subgoal):\n 1. nrule (lhs, rhs)", "using all_rules"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| rs\n  pats = snd (strip_comb lhs)\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. nrule (lhs, rhs)", "by blast"], ["proof (state)\nthis:\n  nrule (lhs, rhs)\n\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "hence \"linear lhs\" \"frees rhs |\\<subseteq>| frees lhs\""], ["proof (prove)\nusing this:\n  nrule (lhs, rhs)\n\ngoal (1 subgoal):\n 1. linear lhs &&& frees rhs |\\<subseteq>| frees lhs", "by auto"], ["proof (state)\nthis:\n  linear lhs\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (6 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 6. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "thus \"linears pats\""], ["proof (prove)\nusing this:\n  linear lhs\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. linears pats", "unfolding \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  linear lhs\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. linears (snd (strip_comb lhs))", "by (intro linears_strip_comb)"], ["proof (state)\nthis:\n  linears pats\n\ngoal (5 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "have \"\\<not> is_const lhs\" \"is_const (fst (strip_comb lhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_const lhs &&& is_const (fst (strip_comb lhs))", "using \\<open>nrule _\\<close>"], ["proof (prove)\nusing this:\n  nrule (lhs, rhs)\n\ngoal (1 subgoal):\n 1. \\<not> is_const lhs &&& is_const (fst (strip_comb lhs))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_const lhs\n  is_const (fst (strip_comb lhs))\n\ngoal (5 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> pats \\<noteq> []\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 5. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "thus \"pats \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> is_const lhs\n  is_const (fst (strip_comb lhs))\n\ngoal (1 subgoal):\n 1. pats \\<noteq> []", "unfolding \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  \\<not> is_const lhs\n  is_const (fst (strip_comb lhs))\n\ngoal (1 subgoal):\n 1. snd (strip_comb lhs) \\<noteq> []", "using \\<open>linear lhs\\<close>"], ["proof (prove)\nusing this:\n  \\<not> is_const lhs\n  is_const (fst (strip_comb lhs))\n  linear lhs\n\ngoal (1 subgoal):\n 1. snd (strip_comb lhs) \\<noteq> []", "apply (cases lhs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Const x1\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 2. \\<And>x2.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Free x2\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 3. \\<And>x3.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 4. \\<And>x4.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Bound x4\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []", "apply (fold app_term_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Const x1\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 2. \\<And>x2.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Free x2\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 3. \\<And>x3.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 4. \\<And>x4.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = Bound x4\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<not> is_const lhs; is_const (fst (strip_comb lhs));\n        linear lhs; lhs = app x51 x52\\<rbrakk>\n       \\<Longrightarrow> snd (strip_comb lhs) \\<noteq> []", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  pats \\<noteq> []\n\ngoal (4 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "from \\<open>nrule (lhs, rhs)\\<close>"], ["proof (chain)\npicking this:\n  nrule (lhs, rhs)", "have \"frees (fst (strip_comb lhs)) = {||}\""], ["proof (prove)\nusing this:\n  nrule (lhs, rhs)\n\ngoal (1 subgoal):\n 1. frees (fst (strip_comb lhs)) = {||}", "by (cases \"fst (strip_comb lhs)\") (auto simp: is_const_def)"], ["proof (state)\nthis:\n  frees (fst (strip_comb lhs)) = {||}\n\ngoal (4 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "hence \"frees lhs = freess (snd (strip_comb lhs))\""], ["proof (prove)\nusing this:\n  frees (fst (strip_comb lhs)) = {||}\n\ngoal (1 subgoal):\n 1. frees lhs = freess (snd (strip_comb lhs))", "by (subst frees_strip_comb) auto"], ["proof (state)\nthis:\n  frees lhs = freess (snd (strip_comb lhs))\n\ngoal (4 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> frees rhs |\\<subseteq>| freess pats\n 4. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "thus \"frees rhs |\\<subseteq>| freess pats\""], ["proof (prove)\nusing this:\n  frees lhs = freess (snd (strip_comb lhs))\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| freess pats", "unfolding \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  frees lhs = freess (snd (strip_comb lhs))\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| freess (snd (strip_comb lhs))", "using \\<open>frees rhs |\\<subseteq>| frees lhs\\<close>"], ["proof (prove)\nusing this:\n  frees lhs = freess (snd (strip_comb lhs))\n  frees rhs |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| freess (snd (strip_comb lhs))", "by simp"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| freess pats\n\ngoal (3 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(lhs, rhs) |\\<in>| rs\\<close> not_shadows"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| rs\n  fBall rs not_shadowing\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by force"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| consts_of rs) rhs\n 3. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "thus \"\\<not> pre_constants.shadows_consts C_info (fst |`| consts_of rs) rhs\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<not> pre_constants.shadows_consts C_info (fst |`| consts_of rs) rhs", "by (simp add: consts_of_heads)"], ["proof (state)\nthis:\n  \\<not> pre_constants.shadows_consts C_info (fst |`| consts_of rs) rhs\n\ngoal (2 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "have \"fdisjnt all_consts (frees lhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees lhs)", "using \\<open>(lhs, rhs) |\\<in>| rs\\<close> not_shadows"], ["proof (prove)\nusing this:\n  (lhs, rhs) |\\<in>| rs\n  fBall rs not_shadowing\n\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees lhs)", "by (force simp: shadows_consts_def)"], ["proof (state)\nthis:\n  fdisjnt all_consts (frees lhs)\n\ngoal (2 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "moreover"], ["proof (state)\nthis:\n  fdisjnt all_consts (frees lhs)\n\ngoal (2 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "have \"freess pats |\\<subseteq>| frees lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess pats |\\<subseteq>| frees lhs", "unfolding \\<open>pats = _\\<close> \\<open>frees lhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. freess (snd (strip_comb lhs)) |\\<subseteq>|\n    freess (snd (strip_comb lhs))", "by simp"], ["proof (state)\nthis:\n  freess pats |\\<subseteq>| frees lhs\n\ngoal (2 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt all_consts (frees lhs)\n  freess pats |\\<subseteq>| frees lhs", "have \"fdisjnt (freess pats) all_consts\""], ["proof (prove)\nusing this:\n  fdisjnt all_consts (frees lhs)\n  freess pats |\\<subseteq>| frees lhs\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "by (metis fdisjnt_subset_right fdisjnt_swap)"], ["proof (state)\nthis:\n  fdisjnt (freess pats) all_consts\n\ngoal (2 subgoals):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| consts_of rs))\n 2. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "thus \"fdisjnt (freess pats) (pre_constants.all_consts C_info (fst |`| consts_of rs))\""], ["proof (prove)\nusing this:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats)\n     (pre_constants.all_consts C_info (fst |`| consts_of rs))", "by (simp add: consts_of_heads)"], ["proof (state)\nthis:\n  fdisjnt (freess pats)\n   (pre_constants.all_consts C_info (fst |`| consts_of rs))\n\ngoal (1 subgoal):\n 1. \\<And>name crs pats rhs.\n       \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n        (pats, rhs) |\\<in>| crs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| consts_of rs)", "show \"pre_constants.welldefined C_info (fst |`| consts_of rs) rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    pre_constants.all_consts C_info (fst |`| consts_of rs)", "using welldefined_rs \\<open>(lhs, rhs) |\\<in>| rs\\<close>"], ["proof (prove)\nusing this:\n  fBall rs (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts)\n  (lhs, rhs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    pre_constants.all_consts C_info (fst |`| consts_of rs)", "by (force simp: consts_of_heads)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  pre_constants.all_consts C_info (fst |`| consts_of rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale nrules \\<subseteq> nrules_as_crules?: crules C_info \"consts_of rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crules C_info (consts_of rs)", "by (fact consts_rules)"], ["", "subsection \\<open>Computability\\<close>"], ["", "export_code\n  translate_rule consts_of arity nterm_to_term\n  checking Scala"], ["", "end"]]}