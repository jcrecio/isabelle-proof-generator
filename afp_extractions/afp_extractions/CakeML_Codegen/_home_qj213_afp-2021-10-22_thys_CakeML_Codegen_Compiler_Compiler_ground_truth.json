{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Compiler/Compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma (in rules) \"Compiler.term_to_exp C_info rs = term_to_cake\"", "lemma compress_pterm_eq[simp]: \"compress_pterm t = t\"", "lemma compress_crule_set_eq[simp]: \"compress_crule_set rs = rs\"", "lemma compress_irule_set_eq[simp]: \"compress_irule_set rs = rs\"", "lemma compress_prule_set[simp]: \"compress_prule_set rs = rs\"", "lemma (in rules) \"Compiler.compile_to_env C_info rs = rules.cake_sem_env C_info rs\""], "translations": [["", "lemma (in rules) \"Compiler.term_to_exp C_info rs = term_to_cake\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_to_exp C_info rs = term_to_cake", "unfolding term_to_exp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_con\n         (heads_of rs |\\<union>| C)\n         (pterm_to_sterm\n           (nterm_to_pterm\n             (fresh_frun (Term_to_Nterm.term_to_nterm [] t)\n               (heads_of rs |\\<union>| C))))) =\n    term_to_cake", "by (simp add: all_consts_def)"], ["", "primrec compress_pterm :: \"pterm \\<Rightarrow> pterm\" where\n\"compress_pterm (Pabs cs) = Pabs (fcompress (map_prod id compress_pterm |`| cs))\" |\n\"compress_pterm (Pconst name) = Pconst name\" |\n\"compress_pterm (Pvar name) = Pvar name\" |\n\"compress_pterm (t $\\<^sub>p u) = compress_pterm t $\\<^sub>p compress_pterm u\""], ["", "lemma compress_pterm_eq[simp]: \"compress_pterm t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_pterm t = t", "by (induction t) (auto simp: subst_pabs_id fset_map_snd_id map_prod_def fmember.rep_eq)"], ["", "definition compress_crule_set :: \"crule_set \\<Rightarrow> crule_set\" where\n\"compress_crule_set = fcompress \\<circ> fimage (map_prod id fcompress)\""], ["", "definition compress_irule_set :: \"irule_set \\<Rightarrow> irule_set\" where\n\"compress_irule_set = fcompress \\<circ> fimage (map_prod id (fcompress \\<circ> fimage (map_prod id compress_pterm)))\""], ["", "definition compress_prule_set :: \"prule fset \\<Rightarrow> prule fset\" where\n\"compress_prule_set = fcompress \\<circ> fimage (map_prod id compress_pterm)\""], ["", "lemma compress_crule_set_eq[simp]: \"compress_crule_set rs = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_crule_set rs = rs", "unfolding compress_crule_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fcompress \\<circ> (|`|) (map_prod id fcompress)) rs = rs", "by force"], ["", "lemma compress_irule_set_eq[simp]: \"compress_irule_set rs = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_irule_set rs = rs", "unfolding compress_irule_set_def map_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fcompress \\<circ>\n     (|`|)\n      (\\<lambda>(x, y).\n          (id x,\n           (fcompress \\<circ>\n            (|`|) (\\<lambda>(x, y). (id x, compress_pterm y)))\n            y)))\n     rs =\n    rs", "by simp"], ["", "lemma compress_prule_set[simp]: \"compress_prule_set rs = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compress_prule_set rs = rs", "unfolding compress_prule_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fcompress \\<circ> (|`|) (map_prod id compress_pterm)) rs = rs", "by force"], ["", "definition transform_irule_set_iter :: \"irule_set \\<Rightarrow> irule_set\" where\n\"transform_irule_set_iter rs = ((transform_irule_set \\<circ> compress_irule_set) ^^ max_arity rs) rs\""], ["", "definition as_sem_env :: \"C_info \\<Rightarrow> srule list \\<Rightarrow> v sem_env \\<Rightarrow> v sem_env\" where\n\"as_sem_env C_info rs env =\n  \\<lparr> sem_env.v =\n      build_rec_env (cakeml.mk_letrec_body C_info (fset_of_list (map fst rs) |\\<union>| constructors.C C_info) rs) env nsEmpty,\n    sem_env.c =\n      nsEmpty \\<rparr>\""], ["", "definition empty_sem_env :: \"C_info \\<Rightarrow> v sem_env\" where\n\"empty_sem_env C_info = \\<lparr> sem_env.v = nsEmpty, sem_env.c = constructors.as_static_cenv C_info \\<rparr>\""], ["", "definition sem_env :: \"C_info \\<Rightarrow> srule list \\<Rightarrow> v sem_env\" where\n\"sem_env C_info rs = extend_dec_env (as_sem_env C_info rs (empty_sem_env C_info)) (empty_sem_env C_info)\""], ["", "definition compile :: \"C_info \\<Rightarrow> rule fset \\<Rightarrow> Ast.prog\" where\n\"compile C_info =\n  CakeML_Backend.compile' C_info \\<circ>\n  Rewriting_Sterm.compile \\<circ>\n  compress_prule_set \\<circ>\n  Rewriting_Pterm.compile \\<circ>\n  transform_irule_set_iter \\<circ>\n  compress_irule_set \\<circ>\n  Rewriting_Pterm_Elim.compile \\<circ>\n  compress_crule_set \\<circ>\n  Rewriting_Nterm.consts_of \\<circ>\n  fcompress \\<circ>\n  Rewriting_Nterm.compile' C_info \\<circ>\n  fcompress\""], ["", "definition compile_to_env :: \"C_info \\<Rightarrow> rule fset \\<Rightarrow> v sem_env\" where\n\"compile_to_env C_info =\n  sem_env C_info \\<circ>\n  Rewriting_Sterm.compile \\<circ>\n  compress_prule_set \\<circ>\n  Rewriting_Pterm.compile \\<circ>\n  transform_irule_set_iter \\<circ>\n  compress_irule_set \\<circ>\n  Rewriting_Pterm_Elim.compile \\<circ>\n  compress_crule_set \\<circ>\n  Rewriting_Nterm.consts_of \\<circ>\n  fcompress \\<circ>\n  Rewriting_Nterm.compile' C_info \\<circ>\n  fcompress\""], ["", "lemma (in rules) \"Compiler.compile_to_env C_info rs = rules.cake_sem_env C_info rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile_to_env C_info rs = cake_sem_env", "unfolding Compiler.compile_to_env_def Compiler.sem_env_def Compiler.as_sem_env_def Compiler.empty_sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>rs.\n         extend_dec_env\n          (make_sem_env\n            (build_rec_env\n              (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n                (fset_of_list (map fst rs) |\\<union>| C) rs)\n              (make_sem_env nsEmpty as_static_cenv) nsEmpty)\n            nsEmpty)\n          (make_sem_env nsEmpty as_static_cenv)) \\<circ>\n     Rewriting_Sterm.compile \\<circ>\n     compress_prule_set \\<circ>\n     Rewriting_Pterm.compile \\<circ>\n     Compiler.transform_irule_set_iter \\<circ>\n     compress_irule_set \\<circ>\n     Rewriting_Pterm_Elim.compile \\<circ>\n     compress_crule_set \\<circ>\n     consts_of \\<circ>\n     fcompress \\<circ>\n     Rewriting_Nterm.compile' C_info \\<circ>\n     fcompress)\n     rs =\n    cake_sem_env", "unfolding rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>rs.\n         extend_dec_env\n          (make_sem_env\n            (build_rec_env\n              (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n                (fset_of_list (map fst rs) |\\<union>| C) rs)\n              (make_sem_env nsEmpty as_static_cenv) nsEmpty)\n            nsEmpty)\n          (make_sem_env nsEmpty as_static_cenv)) \\<circ>\n     Rewriting_Sterm.compile \\<circ>\n     compress_prule_set \\<circ>\n     Rewriting_Pterm.compile \\<circ>\n     Compiler.transform_irule_set_iter \\<circ>\n     compress_irule_set \\<circ>\n     Rewriting_Pterm_Elim.compile \\<circ>\n     compress_crule_set \\<circ>\n     consts_of \\<circ>\n     fcompress \\<circ>\n     Rewriting_Nterm.compile' C_info \\<circ>\n     fcompress)\n     rs =\n    extend_dec_env\n     (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_sem_env\n       cake_static_env.empty_sem_env)\n     cake_static_env.empty_sem_env", "unfolding rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>rs.\n         extend_dec_env\n          (make_sem_env\n            (build_rec_env\n              (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n                (fset_of_list (map fst rs) |\\<union>| C) rs)\n              (make_sem_env nsEmpty as_static_cenv) nsEmpty)\n            nsEmpty)\n          (make_sem_env nsEmpty as_static_cenv)) \\<circ>\n     Rewriting_Sterm.compile \\<circ>\n     compress_prule_set \\<circ>\n     Rewriting_Pterm.compile \\<circ>\n     Compiler.transform_irule_set_iter \\<circ>\n     compress_irule_set \\<circ>\n     Rewriting_Pterm_Elim.compile \\<circ>\n     compress_crule_set \\<circ>\n     consts_of \\<circ>\n     fcompress \\<circ>\n     Rewriting_Nterm.compile' C_info \\<circ>\n     fcompress)\n     rs =\n    extend_dec_env\n     (make_sem_env\n       (build_rec_env\n         (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n           rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n           (Rewriting_Sterm.compile\n             (Rewriting_Pterm.compile\n               (Composition.transform_irule_set_iter\n                 (Rewriting_Pterm_Elim.compile\n                   (consts_of local.compile))))))\n         cake_static_env.empty_sem_env nsEmpty)\n       nsEmpty)\n     cake_static_env.empty_sem_env", "unfolding empty_sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>rs.\n         extend_dec_env\n          (make_sem_env\n            (build_rec_env\n              (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n                (fset_of_list (map fst rs) |\\<union>| C) rs)\n              (make_sem_env nsEmpty as_static_cenv) nsEmpty)\n            nsEmpty)\n          (make_sem_env nsEmpty as_static_cenv)) \\<circ>\n     Rewriting_Sterm.compile \\<circ>\n     compress_prule_set \\<circ>\n     Rewriting_Pterm.compile \\<circ>\n     Compiler.transform_irule_set_iter \\<circ>\n     compress_irule_set \\<circ>\n     Rewriting_Pterm_Elim.compile \\<circ>\n     compress_crule_set \\<circ>\n     consts_of \\<circ>\n     fcompress \\<circ>\n     Rewriting_Nterm.compile' C_info \\<circ>\n     fcompress)\n     rs =\n    extend_dec_env\n     (make_sem_env\n       (build_rec_env\n         (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_letrec_body\n           rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n           (Rewriting_Sterm.compile\n             (Rewriting_Pterm.compile\n               (Composition.transform_irule_set_iter\n                 (Rewriting_Pterm_Elim.compile\n                   (consts_of local.compile))))))\n         (make_sem_env nsEmpty as_static_cenv) nsEmpty)\n       nsEmpty)\n     (make_sem_env nsEmpty as_static_cenv)", "by (auto simp:\n        Compiler.compress_irule_set_eq[abs_def]\n        Composition.transform_irule_set_iter_def[abs_def]\n        Compiler.transform_irule_set_iter_def[abs_def] comp_def pre_constants.all_consts_def)"], ["", "export_code\n  term_to_exp compile compile_to_env\n  checking Scala"], ["", "end"]]}