{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Terms/Strong_Term.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma frees_all_frees: \"frees t |\\<subseteq>| all_frees t\"", "lemma subst_wellformed: \"wellformed t \\<Longrightarrow> wellformed_env env \\<Longrightarrow> wellformed (subst t env)\"", "lemma frees_all_frees_term[simp]: \"all_frees t = frees (t::term)\"", "lemma (in pre_constants) shadows_consts_frees:\n  fixes t :: \"'a::strong_term\"\n  shows \"\\<not> shadows_consts t \\<Longrightarrow> fdisjnt all_consts (frees t)\""], "translations": [["", "lemma frees_all_frees: \"frees t |\\<subseteq>| all_frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| all_frees t", "proof (induction t rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name. frees (const name) |\\<subseteq>| all_frees (const name)\n 2. \\<And>name. frees (free name) |\\<subseteq>| all_frees (free name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>frees t\\<^sub>1 |\\<subseteq>| all_frees t\\<^sub>1;\n        frees t\\<^sub>2 |\\<subseteq>| all_frees t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (app t\\<^sub>1 t\\<^sub>2) |\\<subseteq>|\n                         all_frees (app t\\<^sub>1 t\\<^sub>2)\n 4. \\<And>t. abs_pred (\\<lambda>a. frees a |\\<subseteq>| all_frees a) t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name. frees (const name) |\\<subseteq>| all_frees (const name)\n 2. \\<And>name. frees (free name) |\\<subseteq>| all_frees (free name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>frees t\\<^sub>1 |\\<subseteq>| all_frees t\\<^sub>1;\n        frees t\\<^sub>2 |\\<subseteq>| all_frees t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (app t\\<^sub>1 t\\<^sub>2) |\\<subseteq>|\n                         all_frees (app t\\<^sub>1 t\\<^sub>2)\n 4. \\<And>t. abs_pred (\\<lambda>a. frees a |\\<subseteq>| all_frees a) t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred (\\<lambda>a. frees a |\\<subseteq>| all_frees a) t", "by (rule raw_frees_all_frees)"], ["proof (state)\nthis:\n  abs_pred (\\<lambda>a. frees a |\\<subseteq>| all_frees a) t\n\ngoal (3 subgoals):\n 1. \\<And>name. frees (const name) |\\<subseteq>| all_frees (const name)\n 2. \\<And>name. frees (free name) |\\<subseteq>| all_frees (free name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>frees t\\<^sub>1 |\\<subseteq>| all_frees t\\<^sub>1;\n        frees t\\<^sub>2 |\\<subseteq>| all_frees t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (app t\\<^sub>1 t\\<^sub>2) |\\<subseteq>|\n                         all_frees (app t\\<^sub>1 t\\<^sub>2)", "qed auto"], ["", "lemma subst_wellformed: \"wellformed t \\<Longrightarrow> wellformed_env env \\<Longrightarrow> wellformed (subst t env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_strong_term_class.wellformed t; wellformed_env env\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed (subst t env)", "proof (induction t arbitrary: env rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (const name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (const name) env)\n 2. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (free name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (free name) env)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1;\n                    wellformed_env env\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(subst t\\<^sub>1 env);\n        \\<And>env.\n           \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>2;\n            wellformed_env env\\<rbrakk>\n           \\<Longrightarrow> pre_strong_term_class.wellformed\n                              (subst t\\<^sub>2 env);\n        pre_strong_term_class.wellformed (app t\\<^sub>1 t\\<^sub>2);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (app t\\<^sub>1 t\\<^sub>2) env)\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            pre_strong_term_class.wellformed a \\<longrightarrow>\n            (\\<forall>x.\n                wellformed_env x \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst a x)))\n        t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (const name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (const name) env)\n 2. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (free name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (free name) env)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1;\n                    wellformed_env env\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(subst t\\<^sub>1 env);\n        \\<And>env.\n           \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>2;\n            wellformed_env env\\<rbrakk>\n           \\<Longrightarrow> pre_strong_term_class.wellformed\n                              (subst t\\<^sub>2 env);\n        pre_strong_term_class.wellformed (app t\\<^sub>1 t\\<^sub>2);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (app t\\<^sub>1 t\\<^sub>2) env)\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            pre_strong_term_class.wellformed a \\<longrightarrow>\n            (\\<forall>x.\n                wellformed_env x \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst a x)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         pre_strong_term_class.wellformed a \\<longrightarrow>\n         (\\<forall>x.\n             wellformed_env x \\<longrightarrow>\n             pre_strong_term_class.wellformed (subst a x)))\n     t", "by (rule raw_subst_wellformed)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       pre_strong_term_class.wellformed a \\<longrightarrow>\n       (\\<forall>x.\n           wellformed_env x \\<longrightarrow>\n           pre_strong_term_class.wellformed (subst a x)))\n   t\n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (const name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (const name) env)\n 2. \\<And>name env.\n       \\<lbrakk>pre_strong_term_class.wellformed (free name);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (free name) env)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1;\n                    wellformed_env env\\<rbrakk>\n                   \\<Longrightarrow> pre_strong_term_class.wellformed\n(subst t\\<^sub>1 env);\n        \\<And>env.\n           \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>2;\n            wellformed_env env\\<rbrakk>\n           \\<Longrightarrow> pre_strong_term_class.wellformed\n                              (subst t\\<^sub>2 env);\n        pre_strong_term_class.wellformed (app t\\<^sub>1 t\\<^sub>2);\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (app t\\<^sub>1 t\\<^sub>2) env)", "qed (auto split: option.splits)"], ["", "end"], ["", "global_interpretation wellformed: subst_syntactic_and \"wellformed :: 'a::strong_term \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_syntactic_and pre_strong_term_class.wellformed", "by standard (auto simp: subst_wellformed)"], ["", "instantiation \"term\" :: strong_term begin"], ["", "fun all_frees_term :: \"term \\<Rightarrow> name fset\" where\n\"all_frees_term (Free x) = {| x |}\" |\n\"all_frees_term (t\\<^sub>1 $ t\\<^sub>2) = all_frees_term t\\<^sub>1 |\\<union>| all_frees_term t\\<^sub>2\" |\n\"all_frees_term (\\<Lambda> t) = all_frees_term t\" |\n\"all_frees_term _ = {||}\""], ["", "lemma frees_all_frees_term[simp]: \"all_frees t = frees (t::term)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees t = frees t", "by (induction t) auto"], ["", "definition wellformed_term :: \"term \\<Rightarrow> bool\" where\n[simp]: \"wellformed_term t \\<longleftrightarrow> Term.wellformed t\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Term_Class.term, strong_term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case 8"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "(* FIXME move upstream *)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "have *: \"abs_pred P t\" if \"P t\" for P and t :: \"term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred P t", "unfolding abs_pred_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. t = Bound x \\<longrightarrow> P t) \\<and>\n    (\\<forall>t'.\n        t = \\<Lambda> t' \\<longrightarrow> P t' \\<longrightarrow> P t)", "using that"], ["proof (prove)\nusing this:\n  P t\n\ngoal (1 subgoal):\n 1. (\\<forall>x. t = Bound x \\<longrightarrow> P t) \\<and>\n    (\\<forall>t'.\n        t = \\<Lambda> t' \\<longrightarrow> P t' \\<longrightarrow> P t)", "by auto"], ["proof (state)\nthis:\n  ?P ?t \\<Longrightarrow> abs_pred ?P ?t\n\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         pre_strong_term_class.wellformed t \\<longrightarrow>\n         (\\<forall>env.\n             fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n              env \\<longrightarrow>\n             pre_strong_term_class.wellformed (subst t env)))\n     t_", "apply (rule *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t_ \\<longrightarrow>\n    (\\<forall>env.\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n         env \\<longrightarrow>\n        pre_strong_term_class.wellformed (subst t_ env))", "unfolding wellformed_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Term.wellformed t_ \\<longrightarrow>\n    (\\<forall>env.\n        fmpred (\\<lambda>_. Term.wellformed) env \\<longrightarrow>\n        Term.wellformed (subst t_ env))", "by (auto simp: Term.subst_wellformed)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       pre_strong_term_class.wellformed t \\<longrightarrow>\n       (\\<forall>env.\n           fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n            env \\<longrightarrow>\n           pre_strong_term_class.wellformed (subst t env)))\n   t_\n\ngoal (7 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t", "qed (auto simp: const_term_def free_term_def app_term_def abs_pred_term_def)"], ["", "end"], ["", "instantiation nterm :: strong_term begin"], ["", "definition wellformed_nterm :: \"nterm \\<Rightarrow> bool\" where\n[simp]: \"wellformed_nterm t \\<longleftrightarrow> True\""], ["", "fun all_frees_nterm :: \"nterm \\<Rightarrow> name fset\" where\n\"all_frees_nterm (Nvar x) = {| x |}\" |\n\"all_frees_nterm (t\\<^sub>1 $\\<^sub>n t\\<^sub>2) = all_frees_nterm t\\<^sub>1 |\\<union>| all_frees_nterm t\\<^sub>2\" |\n\"all_frees_nterm (\\<Lambda>\\<^sub>n x. t) = finsert x (all_frees_nterm t)\" |\n\"all_frees_nterm (Nconst _) = {||}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nterm, strong_term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case (7 t)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t", "unfolding abs_pred_nterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t' x.\n       t = (\\<Lambda>\\<^sub>n x. t') \\<longrightarrow>\n       frees t' |\\<subseteq>| all_frees t' \\<longrightarrow>\n       frees t |\\<subseteq>| all_frees t", "by auto"], ["proof (state)\nthis:\n  abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n\ngoal (7 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "qed (auto simp: const_nterm_def free_nterm_def app_nterm_def abs_pred_nterm_def)"], ["", "end"], ["", "lemma (in pre_constants) shadows_consts_frees:\n  fixes t :: \"'a::strong_term\"\n  shows \"\\<not> shadows_consts t \\<Longrightarrow> fdisjnt all_consts (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t \\<Longrightarrow> fdisjnt all_consts (frees t)", "unfolding fdisjnt_alt_def shadows_consts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> all_consts |\\<inter>| all_frees t \\<noteq> {||} \\<Longrightarrow>\n    all_consts |\\<inter>| frees t = {||}", "using frees_all_frees"], ["proof (prove)\nusing this:\n  frees ?t |\\<subseteq>| all_frees ?t\n\ngoal (1 subgoal):\n 1. \\<not> all_consts |\\<inter>| all_frees t \\<noteq> {||} \\<Longrightarrow>\n    all_consts |\\<inter>| frees t = {||}", "by auto"], ["", "abbreviation wellformed_clauses :: \"_ \\<Rightarrow> bool\" where\n\"wellformed_clauses cs \\<equiv> list_all (\\<lambda>(pat, t). linear pat \\<and> wellformed t) cs \\<and> distinct (map fst cs) \\<and> cs \\<noteq> []\""], ["", "end"]]}