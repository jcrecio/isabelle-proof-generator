{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Backend/CakeML_Backend.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma mk_pat_cupcake[intro]: \"is_cupcake_pat (mk_ml_pat pat)\"", "lemma frees'_eq[simp]: \"fset_of_list (frees' t) = frees t\"", "lemma frees'_list_comb: \"frees' (list_comb f xs) = concat (rev (map frees' xs)) @ frees' f\"", "lemma frees'_distinct: \"linear pat \\<Longrightarrow> distinct (frees' pat)\"", "lemma pat_bindings'_eq:\n  \"map Name (pats_bindings ps xs) = concat (rev (map pat_bindings' ps)) @ map Name xs\"\n  \"map Name (pat_bindings p xs) = pat_bindings' p @ map Name xs\"", "lemma pat_bindings'_empty_eq: \"map Name (pat_bindings p []) = pat_bindings' p\"", "lemma pat_bindings'_eq_frees: \"linear p \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat p)) = frees' p\"", "lemma mk_pat_distinct: \"linear pat \\<Longrightarrow> distinct (pat_bindings (mk_ml_pat (mk_pat pat)) [])\"", "lemma mk_exp_cupcake0:\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\"\n  \"wellformed_clauses cs \\<Longrightarrow> cupcake_clauses (mk_clauses S cs) \\<and> cake_linear_clauses (mk_clauses S cs)\"\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_con S t)\"", "lemma mk_exp_cupcake:\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\"\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_con S t)\"", "lemma mk_letrec_cupcake:\n  \"list_all (\\<lambda>(_, _, exp). is_cupcake_exp exp) (mk_letrec_body S rs)\"", "lemma (in srules) compile'_compile_eq: \"compile' C_info rs = compile rs\"", "lemma related_exp_is_cupcake:\n  assumes \"related_exp t e\" \"wellformed t\"\n  shows \"is_cupcake_exp e\"", "lemma related_fun_alt_def:\n  \"related_fun cs n (Ast.Mat (Ast.Var (Short (as_string n))) ml_cs) \\<longleftrightarrow>\n    list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\"", "lemma related_funE:\n  assumes \"related_fun cs n e\"\n  obtains ml_cs\n    where \"e = Ast.Mat (Ast.Var (Short (as_string n))) ml_cs\" \"n |\\<notin>| ids (Sabs cs)\" \"n |\\<notin>| all_consts\"\n      and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\"", "lemma related_exp_fun:\n  \"related_fun cs n e \\<longleftrightarrow> related_exp (Sabs cs) (Ast.Fun (as_string n) e) \\<and> n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma related_v_ext:\n  assumes \"related_v v ml_v\"\n  assumes \"v' \\<approx>\\<^sub>e v\"\n  shows \"related_v v' ml_v\"", "lemma cupcake_pmatch_related:\n  assumes \"related_v v ml_v\"\n  shows \"match_result_related eenv (cupcake_pmatch as_static_cenv (mk_ml_pat pat) ml_v eenv) (vmatch pat v)\"", "lemma match_all_related:\n  assumes \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\"\n  assumes \"list_all (\\<lambda>(pat, _). linear pat) cs\"\n  assumes \"related_v v ml_v\"\n  assumes \"cupcake_match_result as_static_cenv ml_v ml_cs Bindv = Rval (ml_rhs, ml_pat, eenv)\"\n  obtains rhs pat \\<Gamma> where\n    \"ml_pat = mk_ml_pat (mk_pat pat)\"\n    \"related_exp rhs ml_rhs\"\n    \"vfind_match cs v = Some (\\<Gamma>, pat, rhs)\"\n    \"var_env \\<Gamma> eenv\""], "translations": [["", "lemma mk_pat_cupcake[intro]: \"is_cupcake_pat (mk_ml_pat pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_pat (mk_ml_pat pat)", "by (induct pat) (auto simp: list_all_iff)"], ["", "context begin"], ["", "private"], ["", "fun frees' :: \"term \\<Rightarrow> name list\" where\n\"frees' (Free x) = [x]\" |\n\"frees' (t\\<^sub>1 $ t\\<^sub>2) = frees' t\\<^sub>2 @ frees' t\\<^sub>1 \" |\n\"frees' (\\<Lambda> t) = frees' t\" |\n\"frees' _ = []\""], ["", "private"], ["", "lemma frees'_eq[simp]: \"fset_of_list (frees' t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list (frees' t) = frees t", "by (induction t) auto"], ["", "private"], ["", "lemma frees'_list_comb: \"frees' (list_comb f xs) = concat (rev (map frees' xs)) @ frees' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees' (list_comb f xs) = concat (rev (map frees' xs)) @ frees' f", "by (induction xs arbitrary: f) (auto simp: app_term_def)"], ["", "private"], ["", "lemma frees'_distinct: \"linear pat \\<Longrightarrow> distinct (frees' pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pats.linear pat \\<Longrightarrow> distinct (frees' pat)", "proof (induction pat)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       Pats.linear (Const x) \\<Longrightarrow> distinct (frees' (Const x))\n 2. \\<And>x.\n       Pats.linear (Free x) \\<Longrightarrow> distinct (frees' (Free x))\n 3. \\<And>pat.\n       \\<lbrakk>Pats.linear pat \\<Longrightarrow> distinct (frees' pat);\n        Pats.linear (\\<Lambda> pat)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (\\<Lambda> pat))\n 4. \\<And>x.\n       Pats.linear (Bound x) \\<Longrightarrow> distinct (frees' (Bound x))\n 5. \\<And>pat1 pat2.\n       \\<lbrakk>Pats.linear pat1 \\<Longrightarrow> distinct (frees' pat1);\n        Pats.linear pat2 \\<Longrightarrow> distinct (frees' pat2);\n        Pats.linear (pat1 $ pat2)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (pat1 $ pat2))", "case (App t u)"], ["proof (state)\nthis:\n  Pats.linear t \\<Longrightarrow> distinct (frees' t)\n  Pats.linear u \\<Longrightarrow> distinct (frees' u)\n  Pats.linear (t $ u)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       Pats.linear (Const x) \\<Longrightarrow> distinct (frees' (Const x))\n 2. \\<And>x.\n       Pats.linear (Free x) \\<Longrightarrow> distinct (frees' (Free x))\n 3. \\<And>pat.\n       \\<lbrakk>Pats.linear pat \\<Longrightarrow> distinct (frees' pat);\n        Pats.linear (\\<Lambda> pat)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (\\<Lambda> pat))\n 4. \\<And>x.\n       Pats.linear (Bound x) \\<Longrightarrow> distinct (frees' (Bound x))\n 5. \\<And>pat1 pat2.\n       \\<lbrakk>Pats.linear pat1 \\<Longrightarrow> distinct (frees' pat1);\n        Pats.linear pat2 \\<Longrightarrow> distinct (frees' pat2);\n        Pats.linear (pat1 $ pat2)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (pat1 $ pat2))", "hence \"distinct (frees' u @ frees' t)\""], ["proof (prove)\nusing this:\n  Pats.linear t \\<Longrightarrow> distinct (frees' t)\n  Pats.linear u \\<Longrightarrow> distinct (frees' u)\n  Pats.linear (t $ u)\n\ngoal (1 subgoal):\n 1. distinct (frees' u @ frees' t)", "by (fastforce intro: distinct_append_fset fdisjnt_swap)"], ["proof (state)\nthis:\n  distinct (frees' u @ frees' t)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       Pats.linear (Const x) \\<Longrightarrow> distinct (frees' (Const x))\n 2. \\<And>x.\n       Pats.linear (Free x) \\<Longrightarrow> distinct (frees' (Free x))\n 3. \\<And>pat.\n       \\<lbrakk>Pats.linear pat \\<Longrightarrow> distinct (frees' pat);\n        Pats.linear (\\<Lambda> pat)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (\\<Lambda> pat))\n 4. \\<And>x.\n       Pats.linear (Bound x) \\<Longrightarrow> distinct (frees' (Bound x))\n 5. \\<And>pat1 pat2.\n       \\<lbrakk>Pats.linear pat1 \\<Longrightarrow> distinct (frees' pat1);\n        Pats.linear pat2 \\<Longrightarrow> distinct (frees' pat2);\n        Pats.linear (pat1 $ pat2)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (pat1 $ pat2))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (frees' u @ frees' t)\n\ngoal (1 subgoal):\n 1. distinct (frees' (t $ u))", "by simp"], ["proof (state)\nthis:\n  distinct (frees' (t $ u))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       Pats.linear (Const x) \\<Longrightarrow> distinct (frees' (Const x))\n 2. \\<And>x.\n       Pats.linear (Free x) \\<Longrightarrow> distinct (frees' (Free x))\n 3. \\<And>pat.\n       \\<lbrakk>Pats.linear pat \\<Longrightarrow> distinct (frees' pat);\n        Pats.linear (\\<Lambda> pat)\\<rbrakk>\n       \\<Longrightarrow> distinct (frees' (\\<Lambda> pat))\n 4. \\<And>x.\n       Pats.linear (Bound x) \\<Longrightarrow> distinct (frees' (Bound x))", "qed auto"], ["", "private"], ["", "fun pat_bindings' :: \"Ast.pat \\<Rightarrow> name list\" where\n\"pat_bindings' (Ast.Pvar n) = [Name n]\" |\n\"pat_bindings' (Ast.Pcon _ ps) = concat (rev (map pat_bindings' ps))\" |\n\"pat_bindings' (Ast.Pref p) = pat_bindings' p\" |\n\"pat_bindings' (Ast.Ptannot p _) = pat_bindings' p\" |\n\"pat_bindings' _ = []\""], ["", "private"], ["", "lemma pat_bindings'_eq:\n  \"map Name (pats_bindings ps xs) = concat (rev (map pat_bindings' ps)) @ map Name xs\"\n  \"map Name (pat_bindings p xs) = pat_bindings' p @ map Name xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Name (pats_bindings ps xs) =\n    concat (rev (map pat_bindings' ps)) @ map Name xs &&&\n    map Name (pat_bindings p xs) = pat_bindings' p @ map Name xs", "by (induction ps xs and p xs rule: pats_bindings_pat_bindings.induct) (auto simp: ac_simps)"], ["", "private"], ["", "lemma pat_bindings'_empty_eq: \"map Name (pat_bindings p []) = pat_bindings' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map Name (pat_bindings p []) = pat_bindings' p", "by (simp add: pat_bindings'_eq)"], ["", "private"], ["", "lemma pat_bindings'_eq_frees: \"linear p \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat p)) = frees' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pats.linear p \\<Longrightarrow>\n    pat_bindings' (mk_ml_pat (mk_pat p)) = frees' p", "proof (induction rule: mk_pat.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pat.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb pat; x = Const x1;\n                    xa \\<in> set y; Pats.linear xa\\<rbrakk>\n                   \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat xa)) =\n                                     frees' xa;\n        Pats.linear pat\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat pat)) = frees' pat", "case (1 t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) = strip_comb t; ?x = Const ?x1.0; ?xa \\<in> set ?y;\n   Pats.linear ?xa\\<rbrakk>\n  \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat ?xa)) = frees' ?xa\n  Pats.linear t\n\ngoal (1 subgoal):\n 1. \\<And>pat.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb pat; x = Const x1;\n                    xa \\<in> set y; Pats.linear xa\\<rbrakk>\n                   \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat xa)) =\n                                     frees' xa;\n        Pats.linear pat\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat pat)) = frees' pat", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "using \\<open>linear t\\<close>"], ["proof (prove)\nusing this:\n  Pats.linear t\n\ngoal (1 subgoal):\n 1. pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "proof (cases rule: linear_strip_comb_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "case (comb s args)"], ["proof (state)\nthis:\n  strip_comb t = (Const s, args)\n  t = s $$ args\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "have \"map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args = map frees' args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args =\n    map frees' args", "proof (rule list.map_cong0, unfold comp_apply)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow>\n       pat_bindings' (mk_ml_pat (mk_pat z)) = frees' z", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow>\n       pat_bindings' (mk_ml_pat (mk_pat z)) = frees' z", "assume \"x \\<in> set args\""], ["proof (state)\nthis:\n  x \\<in> set args\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow>\n       pat_bindings' (mk_ml_pat (mk_pat z)) = frees' z", "moreover"], ["proof (state)\nthis:\n  x \\<in> set args\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow>\n       pat_bindings' (mk_ml_pat (mk_pat z)) = frees' z", "hence \"linear x\""], ["proof (prove)\nusing this:\n  x \\<in> set args\n\ngoal (1 subgoal):\n 1. Pats.linear x", "using 1 comb"], ["proof (prove)\nusing this:\n  x \\<in> set args\n  \\<lbrakk>(?x, ?y) = strip_comb t; ?x = Const ?x1.0; ?xa \\<in> set ?y;\n   Pats.linear ?xa\\<rbrakk>\n  \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat ?xa)) = frees' ?xa\n  Pats.linear t\n  strip_comb t = (Const s, args)\n  t = s $$ args\n\ngoal (1 subgoal):\n 1. Pats.linear x", "by (metis linears_linear linears_strip_comb snd_conv)"], ["proof (state)\nthis:\n  Pats.linear x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow>\n       pat_bindings' (mk_ml_pat (mk_pat z)) = frees' z", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set args\n  Pats.linear x", "show \"pat_bindings' (mk_ml_pat (mk_pat x)) = frees' x\""], ["proof (prove)\nusing this:\n  x \\<in> set args\n  Pats.linear x\n\ngoal (1 subgoal):\n 1. pat_bindings' (mk_ml_pat (mk_pat x)) = frees' x", "using 1 comb"], ["proof (prove)\nusing this:\n  x \\<in> set args\n  Pats.linear x\n  \\<lbrakk>(?x, ?y) = strip_comb t; ?x = Const ?x1.0; ?xa \\<in> set ?y;\n   Pats.linear ?xa\\<rbrakk>\n  \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat ?xa)) = frees' ?xa\n  Pats.linear t\n  strip_comb t = (Const s, args)\n  t = s $$ args\n\ngoal (1 subgoal):\n 1. pat_bindings' (mk_ml_pat (mk_pat x)) = frees' x", "by auto"], ["proof (state)\nthis:\n  pat_bindings' (mk_ml_pat (mk_pat x)) = frees' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args =\n  map frees' args\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "hence \"concat (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) = concat (rev (map frees' args))\""], ["proof (prove)\nusing this:\n  map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args =\n  map frees' args\n\ngoal (1 subgoal):\n 1. concat\n     (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) =\n    concat (rev (map frees' args))", "by metis"], ["proof (state)\nthis:\n  concat (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) =\n  concat (rev (map frees' args))\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "with comb"], ["proof (chain)\npicking this:\n  strip_comb t = (Const s, args)\n  t = s $$ args\n  concat (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) =\n  concat (rev (map frees' args))", "show ?thesis"], ["proof (prove)\nusing this:\n  strip_comb t = (Const s, args)\n  t = s $$ args\n  concat (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) =\n  concat (rev (map frees' args))\n\ngoal (1 subgoal):\n 1. pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "apply (fold const_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strip_comb t = (const s, args); t = s $$ args;\n     concat\n      (rev (map (pat_bindings' \\<circ> mk_ml_pat \\<circ> mk_pat) args)) =\n     concat (rev (map frees' args))\\<rbrakk>\n    \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "apply (auto simp: strip_list_comb_const frees'_list_comb comp_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = s $$ args;\n     concat\n      (rev (map (pat_bindings' \\<circ> (mk_ml_pat \\<circ> mk_pat)) args)) =\n     concat (rev (map frees' args))\\<rbrakk>\n    \\<Longrightarrow> frees' (const s) = []", "apply (unfold const_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = list_comb (Const s) args;\n     concat\n      (rev (map (pat_bindings' \\<circ> (mk_ml_pat \\<circ> mk_pat)) args)) =\n     concat (rev (map frees' args))\\<rbrakk>\n    \\<Longrightarrow> frees' (Const s) = []", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t", "qed auto"], ["proof (state)\nthis:\n  pat_bindings' (mk_ml_pat (mk_pat t)) = frees' t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_pat_distinct: \"linear pat \\<Longrightarrow> distinct (pat_bindings (mk_ml_pat (mk_pat pat)) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pats.linear pat \\<Longrightarrow>\n    distinct (pat_bindings (mk_ml_pat (mk_pat pat)) [])", "by (metis pat_bindings'_eq_frees pat_bindings'_empty_eq frees'_distinct distinct_map)"], ["", "end"], ["", "locale cakeml = pre_constants\nbegin"], ["", "fun\n  mk_exp :: \"name fset \\<Rightarrow> sterm \\<Rightarrow> exp\" and\n  mk_clauses :: \"name fset \\<Rightarrow> (term \\<times> sterm) list \\<Rightarrow> (Ast.pat \\<times> exp) list\" and\n  mk_con :: \"name fset \\<Rightarrow> sterm \\<Rightarrow> exp\" where\n\"mk_exp _ (Svar s) = Ast.Var (Short (as_string s))\" |\n\"mk_exp _ (Sconst s) = (if s |\\<in>| C then Ast.Con (Some (Short (as_string s))) [] else Ast.Var (Short (as_string s)))\" |\n\"mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) = Ast.App Ast.Opapp [mk_con S t\\<^sub>1, mk_con S t\\<^sub>2]\" |\n\"mk_exp S (Sabs cs) = (\n  let n = fresh_fNext S in\n  Ast.Fun (as_string n) (Ast.Mat (Ast.Var (Short (as_string n))) (mk_clauses S cs)))\" |\n\"mk_con S t =\n  (case strip_comb t of\n    (Sconst c, args) \\<Rightarrow>\n      if c |\\<in>| C then Ast.Con (Some (Short (as_string c))) (map (mk_con S) args) else mk_exp S t\n   | _ \\<Rightarrow> mk_exp S t)\" |\n\"mk_clauses S cs = map (\\<lambda>(pat, t). (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t)) cs\""], ["", "context begin"], ["", "private"], ["", "lemma mk_exp_cupcake0:\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\"\n  \"wellformed_clauses cs \\<Longrightarrow> cupcake_clauses (mk_clauses S cs) \\<and> cake_linear_clauses (mk_clauses S cs)\"\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_con S t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t \\<Longrightarrow>\n     is_cupcake_exp (mk_exp S t)) &&&\n    (wellformed_clauses cs \\<Longrightarrow>\n     cupcake_clauses (mk_clauses S cs) \\<and>\n     cake_linear_clauses (mk_clauses S cs)) &&&\n    (pre_strong_term_class.wellformed t \\<Longrightarrow>\n     is_cupcake_exp (mk_con S t))", "proof (induction rule: mk_exp_mk_clauses_mk_con.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>uu_ s.\n       pre_strong_term_class.wellformed (Svar s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uu_ (Svar s))\n 2. \\<And>uv_ s.\n       pre_strong_term_class.wellformed (Sconst s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uv_ (Sconst s))\n 3. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n                is_cupcake_exp (mk_con S t\\<^sub>1);\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp (mk_con S t\\<^sub>2);\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    wellformed_clauses cs\\<rbrakk>\n                   \\<Longrightarrow> cupcake_clauses\n(mk_clauses S cs) \\<and>\n                                     cake_linear_clauses (mk_clauses S cs);\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S (Sabs cs))\n 5. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y;\n                    pre_strong_term_class.wellformed xa\\<rbrakk>\n                   \\<Longrightarrow> is_cupcake_exp (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_con S t)\n 6. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    pre_strong_term_class.wellformed y\\<rbrakk>\n                   \\<Longrightarrow> is_cupcake_exp\n(mk_con (frees xa |\\<union>| S) y);\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (mk_clauses S cs) \\<and>\n                         cake_linear_clauses (mk_clauses S cs)", "case (5 S t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4; ?x1.4 |\\<in>| C;\n   ?xa4 \\<in> set ?y4; pre_strong_term_class.wellformed ?xa4\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_con S ?xa4)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4;\n   ?x1.4 |\\<notin>| C; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Svar ?x2.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sabs ?x3.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = ?x41.4 $\\<^sub>s ?x42.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  pre_strong_term_class.wellformed t\n\ngoal (6 subgoals):\n 1. \\<And>uu_ s.\n       pre_strong_term_class.wellformed (Svar s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uu_ (Svar s))\n 2. \\<And>uv_ s.\n       pre_strong_term_class.wellformed (Sconst s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uv_ (Sconst s))\n 3. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n                is_cupcake_exp (mk_con S t\\<^sub>1);\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp (mk_con S t\\<^sub>2);\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    wellformed_clauses cs\\<rbrakk>\n                   \\<Longrightarrow> cupcake_clauses\n(mk_clauses S cs) \\<and>\n                                     cake_linear_clauses (mk_clauses S cs);\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S (Sabs cs))\n 5. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y;\n                    pre_strong_term_class.wellformed xa\\<rbrakk>\n                   \\<Longrightarrow> is_cupcake_exp (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            pre_strong_term_class.wellformed t\\<rbrakk>\n           \\<Longrightarrow> is_cupcake_exp (mk_exp S t);\n        pre_strong_term_class.wellformed t\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_con S t)\n 6. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    pre_strong_term_class.wellformed y\\<rbrakk>\n                   \\<Longrightarrow> is_cupcake_exp\n(mk_con (frees xa |\\<union>| S) y);\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (mk_clauses S cs) \\<and>\n                         cake_linear_clauses (mk_clauses S cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp (mk_con S t)", "apply (simp split!: prod.splits sterm.splits if_splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<in>| C\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_exp (map (mk_con S) x2)\n 2. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n 3. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 4. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 5. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)", "subgoal premises prems for args c"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (map (mk_con S) args)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (map (mk_con S) args)", "from prems"], ["proof (chain)\npicking this:\n  strip_comb t = (Sconst c, args)\n  c |\\<in>| C", "have \"t = c $$ args\""], ["proof (prove)\nusing this:\n  strip_comb t = (Sconst c, args)\n  c |\\<in>| C\n\ngoal (1 subgoal):\n 1. t = c $$ args", "apply (fold const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strip_comb t = (const c, args); c |\\<in>| C\\<rbrakk>\n    \\<Longrightarrow> t = c $$ args", "by (metis fst_conv list_strip_comb snd_conv)"], ["proof (state)\nthis:\n  t = c $$ args\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (map (mk_con S) args)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (map (mk_con S) args)", "apply (auto simp: list_all_iff simp del: mk_con.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> is_cupcake_exp (mk_con S x)", "apply (rule 5(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> (?x13 x, ?y13 x) = strip_comb t\n 2. \\<And>x. x \\<in> set args \\<Longrightarrow> ?x13 x = Sconst (?x1.13 x)\n 3. \\<And>x. x \\<in> set args \\<Longrightarrow> ?x1.13 x |\\<in>| C\n 4. \\<And>x. x \\<in> set args \\<Longrightarrow> x \\<in> set (?y13 x)\n 5. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "apply (rule prems(1)[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> Sconst c = Sconst (?x1.13 x)\n 2. \\<And>x. x \\<in> set args \\<Longrightarrow> ?x1.13 x |\\<in>| C\n 3. \\<And>x. x \\<in> set args \\<Longrightarrow> x \\<in> set args\n 4. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "apply (rule refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> c |\\<in>| C\n 2. \\<And>x. x \\<in> set args \\<Longrightarrow> x \\<in> set args\n 3. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "apply (rule prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> x \\<in> set args\n 2. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "using \\<open>wellformed t\\<close> \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n  t = c $$ args\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set args \\<Longrightarrow> pre_strong_term_class.wellformed x", "apply (auto simp: wellformed.list_comb list_all_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (map (mk_con S) args)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n 2. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 3. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 4. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)", "using 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4; ?x1.4 |\\<in>| C;\n   ?xa4 \\<in> set ?y4; pre_strong_term_class.wellformed ?xa4\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_con S ?xa4)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4;\n   ?x1.4 |\\<notin>| C; pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Svar ?x2.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sabs ?x3.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = ?x41.4 $\\<^sub>s ?x42.4;\n   pre_strong_term_class.wellformed t\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n  pre_strong_term_class.wellformed t\n\ngoal (4 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\n 2. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 3. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)\n 4. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp S t)", "by (auto split: prod.splits sterm.splits)"], ["proof (state)\nthis:\n  is_cupcake_exp (mk_con S t)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       pre_strong_term_class.wellformed (Svar s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uu_ (Svar s))\n 2. \\<And>uv_ s.\n       pre_strong_term_class.wellformed (Sconst s) \\<Longrightarrow>\n       is_cupcake_exp (mk_exp uv_ (Sconst s))\n 3. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n                is_cupcake_exp (mk_con S t\\<^sub>1);\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp (mk_con S t\\<^sub>2);\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    wellformed_clauses cs\\<rbrakk>\n                   \\<Longrightarrow> cupcake_clauses\n(mk_clauses S cs) \\<and>\n                                     cake_linear_clauses (mk_clauses S cs);\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (mk_exp S (Sabs cs))\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    pre_strong_term_class.wellformed y\\<rbrakk>\n                   \\<Longrightarrow> is_cupcake_exp\n(mk_con (frees xa |\\<union>| S) y);\n        wellformed_clauses cs\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (mk_clauses S cs) \\<and>\n                         cake_linear_clauses (mk_clauses S cs)", "qed (auto simp: Let_def list_all_iff intro: mk_pat_distinct)"], ["", "declare mk_con.simps[simp del]"], ["", "lemma mk_exp_cupcake:\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_exp S t)\"\n  \"wellformed t \\<Longrightarrow> is_cupcake_exp (mk_con S t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t \\<Longrightarrow>\n     is_cupcake_exp (mk_exp S t)) &&&\n    (pre_strong_term_class.wellformed t \\<Longrightarrow>\n     is_cupcake_exp (mk_con S t))", "by (metis mk_exp_cupcake0)+"], ["", "end"], ["", "definition mk_letrec_body where\n\"mk_letrec_body S rs = (\n  map (\\<lambda>(name, rhs).\n    (as_string name, (\n      let n = fresh_fNext S in\n        (as_string n, Ast.Mat (Ast.Var (Short (as_string n))) (mk_clauses S (sterm.clauses rhs)))))) rs\n)\""], ["", "definition compile_group :: \"name fset \\<Rightarrow> srule list \\<Rightarrow> Ast.dec\" where\n\"compile_group S rs = Ast.Dletrec empty_locs (mk_letrec_body S rs)\""], ["", "definition compile :: \"srule list \\<Rightarrow> Ast.prog\" where\n\"compile rs = [Ast.Tdec (compile_group all_consts rs)]\""], ["", "end"], ["", "declare cakeml.mk_con.simps[code]"], ["", "declare cakeml.mk_exp.simps[code]"], ["", "declare cakeml.mk_clauses.simps[code]"], ["", "declare cakeml.mk_letrec_body_def[code]"], ["", "declare cakeml.compile_group_def[code]"], ["", "declare cakeml.compile_def[code]"], ["", "locale cakeml' = cakeml + constants"], ["", "context srules begin"], ["", "sublocale srules_as_cake?: cakeml' C_info \"fst |`| fset_of_list rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cakeml' C_info (fst |`| fset_of_list rs)", "by standard"], ["", "lemma mk_letrec_cupcake:\n  \"list_all (\\<lambda>(_, _, exp). is_cupcake_exp exp) (mk_letrec_body S rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, uu_, exp). is_cupcake_exp exp)\n     (mk_letrec_body S rs)", "unfolding mk_letrec_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, uu_, exp). is_cupcake_exp exp)\n     (map (\\<lambda>(name, rhs).\n              (as_string name,\n               let n = fresh_fNext S\n               in (as_string n,\n                   Mat (Var (Short (as_string n)))\n                    (mk_clauses S (clauses rhs)))))\n       rs)", "using all_rules"], ["proof (prove)\nusing this:\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, uu_, exp). is_cupcake_exp exp)\n     (map (\\<lambda>(name, rhs).\n              (as_string name,\n               let n = fresh_fNext S\n               in (as_string n,\n                   Mat (Var (Short (as_string n)))\n                    (mk_clauses S (clauses rhs)))))\n       rs)", "apply (auto simp: Let_def list_all_iff intro!: mk_pat_cupcake mk_exp_cupcake mk_pat_distinct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>x\\<in>set rs. srule x; (a, b) \\<in> set rs;\n        (aa, ba) \\<in> set (clauses b)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>x\\<in>set rs. srule x; (a, b) \\<in> set rs;\n        (aa, ba) \\<in> set (clauses b)\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set rs. srule x; (a, b) \\<in> set rs;\n     (aa_, ba_) \\<in> set (clauses b)\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed ba_", "apply (erule ballE[where x = \"(a, b)\"]; cases b)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Sconst x1\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 2. \\<And>x2.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Svar x2\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 3. \\<And>x3.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Sabs x3\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 4. \\<And>x41 x42.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = x41 $\\<^sub>s x42\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 5. \\<And>x1.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Sconst x1\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 6. \\<And>x2.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Svar x2\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 7. \\<And>x3.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Sabs x3\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_\n 8. \\<And>x41 x42.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = x41 $\\<^sub>s x42\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed ba_", "apply (auto simp: list_all_iff is_abs_def term_cases_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>x\\<in>set rs. srule x; (a, b) \\<in> set rs;\n        (aa, ba) \\<in> set (clauses b)\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set rs. srule x; (a, b) \\<in> set rs;\n     (aa_, ba_) \\<in> set (clauses b)\\<rbrakk>\n    \\<Longrightarrow> Pats.linear aa_", "apply (erule ballE[where x = \"(a, b)\"]; cases b)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Sconst x1\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 2. \\<And>x2.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Svar x2\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 3. \\<And>x3.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = Sabs x3\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 4. \\<And>x41 x42.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        srule (a, b); b = x41 $\\<^sub>s x42\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 5. \\<And>x1.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Sconst x1\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 6. \\<And>x2.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Svar x2\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 7. \\<And>x3.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = Sabs x3\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_\n 8. \\<And>x41 x42.\n       \\<lbrakk>(a, b) \\<in> set rs; (aa_, ba_) \\<in> set (clauses b);\n        (a, b) \\<notin> set rs; b = x41 $\\<^sub>s x42\\<rbrakk>\n       \\<Longrightarrow> Pats.linear aa_", "apply (auto simp: list_all_iff is_abs_def term_cases_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition compile' where\n\"compile' C_info rs = cakeml.compile C_info (fst |`| fset_of_list rs) rs\""], ["", "lemma (in srules) compile'_compile_eq: \"compile' C_info rs = compile rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CakeML_Backend.compile' C_info rs = srules_as_cake.compile rs", "unfolding compile'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. srules_as_cake.compile rs = srules_as_cake.compile rs", ".."], ["", "subsection \\<open>Computability\\<close>"], ["", "export_code cakeml.compile\n  checking Scala"], ["", "subsection \\<open>Correctness of semantic functions\\<close>"], ["", "abbreviation related_pat :: \"term \\<Rightarrow> Ast.pat \\<Rightarrow> bool\" where\n\"related_pat t p \\<equiv> (p = mk_ml_pat (mk_pat t))\""], ["", "context cakeml' begin"], ["", "inductive related_exp :: \"sterm \\<Rightarrow> exp \\<Rightarrow> bool\" where\nvar: \"related_exp (Svar name) (Ast.Var (Short (as_string name)))\" |\nconst: \"name |\\<notin>| C \\<Longrightarrow> related_exp (Sconst name) (Ast.Var (Short (as_string name)))\" |\nconstr: \"name |\\<in>| C \\<Longrightarrow> list_all2 related_exp ts es \\<Longrightarrow>\n          related_exp (name $$ ts) (Ast.Con (Some (Short (as_string name))) es)\" |\napp: \"related_exp t\\<^sub>1 u\\<^sub>1 \\<Longrightarrow> related_exp t\\<^sub>2 u\\<^sub>2 \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (Ast.App Ast.Opapp [u\\<^sub>1, u\\<^sub>2])\" |\n\"fun\": \"list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<Longrightarrow>\n        n |\\<notin>| ids (Sabs cs) \\<Longrightarrow> n |\\<notin>| all_consts \\<Longrightarrow>\n          related_exp (Sabs cs) (Ast.Fun (as_string n) (Ast.Mat (Ast.Var (Short (as_string n))) ml_cs))\" |\nmat: \"list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<Longrightarrow>\n      related_exp scr ml_scr \\<Longrightarrow>\n          related_exp (Sabs cs $\\<^sub>s scr) (Ast.Mat ml_scr ml_cs)\""], ["", "lemma related_exp_is_cupcake:\n  assumes \"related_exp t e\" \"wellformed t\"\n  shows \"is_cupcake_exp e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp e", "using assms"], ["proof (prove)\nusing this:\n  related_exp t e\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e", "proof induction"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs n.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Fun (as_string n)\n                            (Mat (Var (Short (as_string n))) ml_cs))\n 6. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "case (\"fun\" cs ml_cs n)"], ["proof (state)\nthis:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  n |\\<notin>| ids (Sabs cs)\n  n |\\<notin>| all_consts\n  pre_strong_term_class.wellformed (Sabs cs)\n\ngoal (6 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs n.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Fun (as_string n)\n                            (Mat (Var (Short (as_string n))) ml_cs))\n 6. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "hence \"list_all (\\<lambda>(pat, t). linear pat \\<and> wellformed t) cs\""], ["proof (prove)\nusing this:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  n |\\<notin>| ids (Sabs cs)\n  n |\\<notin>| all_consts\n  pre_strong_term_class.wellformed (Sabs cs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     cs", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (6 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs n.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Fun (as_string n)\n                            (Mat (Var (Short (as_string n))) ml_cs))\n 6. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "moreover"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (6 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs n.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Fun (as_string n)\n                            (Mat (Var (Short (as_string n))) ml_cs))\n 6. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "have \"cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "using \\<open>list_all2 _ cs ml_cs\\<close> \\<open>list_all _ cs\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (1 subgoal):\n 1. cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "case (Cons c cs ml_c ml_cs)"], ["proof (state)\nthis:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "obtain ml_p ml_e where \"ml_c = (ml_p, ml_e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ml_p ml_e.\n        ml_c = (ml_p, ml_e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ml_c = (ml_p, ml_e)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "obtain p t where \"c = (p, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p t. c = (p, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c = (p, t)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "have \"ml_p = mk_ml_pat (mk_pat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_pat p ml_p", "using Cons"], ["proof (prove)\nusing this:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. related_pat p ml_p", "unfolding \\<open>ml_c = _\\<close> \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   (p, t) (ml_p, ml_e)\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   ((p, t) # cs)\n\ngoal (1 subgoal):\n 1. related_pat p ml_p", "by simp"], ["proof (state)\nthis:\n  related_pat p ml_p\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n\ngoal (1 subgoal):\n 1. cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)", "using Cons"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)", "unfolding \\<open>ml_c = _\\<close> \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   (p, t) (ml_p, ml_e)\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   ((p, t) # cs)\n\ngoal (1 subgoal):\n 1. cupcake_clauses ((ml_p, ml_e) # ml_cs) \\<and>\n    cake_linear_clauses ((ml_p, ml_e) # ml_cs)", "by (auto intro: mk_pat_distinct)"], ["proof (state)\nthis:\n  cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []", "qed simp"], ["proof (state)\nthis:\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n\ngoal (6 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs n.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n        pre_strong_term_class.wellformed (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Fun (as_string n)\n                            (Mat (Var (Short (as_string n))) ml_cs))\n 6. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "ultimately"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "show ?case"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n\ngoal (1 subgoal):\n 1. is_cupcake_exp\n     (Fun (as_string n) (Mat (Var (Short (as_string n))) ml_cs))", "by auto"], ["proof (state)\nthis:\n  is_cupcake_exp (Fun (as_string n) (Mat (Var (Short (as_string n))) ml_cs))\n\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "case (mat cs ml_cs scr ml_scr)"], ["proof (state)\nthis:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  pre_strong_term_class.wellformed scr \\<Longrightarrow>\n  is_cupcake_exp ml_scr\n  related_exp scr ml_scr\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "hence \"list_all (\\<lambda>(pat, t). linear pat \\<and> wellformed t) cs\""], ["proof (prove)\nusing this:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  pre_strong_term_class.wellformed scr \\<Longrightarrow>\n  is_cupcake_exp ml_scr\n  related_exp scr ml_scr\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     cs", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "moreover"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "have \"cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "using \\<open>list_all2 _ cs ml_cs\\<close> \\<open>list_all _ cs\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n\ngoal (1 subgoal):\n 1. cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "case (Cons c cs ml_c ml_cs)"], ["proof (state)\nthis:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "obtain ml_p ml_e where \"ml_c = (ml_p, ml_e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ml_p ml_e.\n        ml_c = (ml_p, ml_e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ml_c = (ml_p, ml_e)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "obtain p t where \"c = (p, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p t. c = (p, t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c = (p, t)\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "have \"ml_p = mk_ml_pat (mk_pat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_pat p ml_p", "using Cons"], ["proof (prove)\nusing this:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. related_pat p ml_p", "unfolding \\<open>ml_c = _\\<close> \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   (p, t) (ml_p, ml_e)\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   ((p, t) # cs)\n\ngoal (1 subgoal):\n 1. related_pat p ml_p", "by simp"], ["proof (state)\nthis:\n  related_pat p ml_p\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod related_pat\n                 (\\<lambda>x1 x2.\n                     related_exp x1 x2 \\<and>\n                     (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                      is_cupcake_exp x2))\n                 x y;\n        list_all2\n         (rel_prod related_pat\n           (\\<lambda>x1 x2.\n               related_exp x1 x2 \\<and>\n               (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                is_cupcake_exp x2)))\n         xs ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         xs \\<Longrightarrow>\n        cupcake_clauses ys \\<and> cake_linear_clauses ys;\n        list_all\n         (\\<lambda>(pat, t).\n             Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n         (x # xs)\\<rbrakk>\n       \\<Longrightarrow> cupcake_clauses (y # ys) \\<and>\n                         cake_linear_clauses (y # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n\ngoal (1 subgoal):\n 1. cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)", "using Cons"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   c ml_c\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)", "unfolding \\<open>ml_c = _\\<close> \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  related_pat p ml_p\n  rel_prod related_pat\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   (p, t) (ml_p, ml_e)\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs \\<Longrightarrow>\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all\n   (\\<lambda>a.\n       case a of\n       (pat, t) \\<Rightarrow>\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   ((p, t) # cs)\n\ngoal (1 subgoal):\n 1. cupcake_clauses ((ml_p, ml_e) # ml_cs) \\<and>\n    cake_linear_clauses ((ml_p, ml_e) # ml_cs)", "by (auto intro: mk_pat_distinct)"], ["proof (state)\nthis:\n  cupcake_clauses (ml_c # ml_cs) \\<and> cake_linear_clauses (ml_c # ml_cs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n     [] \\<Longrightarrow>\n    cupcake_clauses [] \\<and> cake_linear_clauses []", "qed simp"], ["proof (state)\nthis:\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n\ngoal (5 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])\n 5. \\<And>cs ml_cs scr ml_scr.\n       \\<lbrakk>list_all2\n                 (rel_prod related_pat\n                   (\\<lambda>x1 x2.\n                       related_exp x1 x2 \\<and>\n                       (pre_strong_term_class.wellformed\n                         x1 \\<longrightarrow>\n                        is_cupcake_exp x2)))\n                 cs ml_cs;\n        related_exp scr ml_scr;\n        pre_strong_term_class.wellformed scr \\<Longrightarrow>\n        is_cupcake_exp ml_scr;\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Mat ml_scr ml_cs)", "ultimately"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs", "show ?case"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n\ngoal (1 subgoal):\n 1. is_cupcake_exp (Mat ml_scr ml_cs)", "using mat"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(pat, t).\n       Pats.linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs\n  cupcake_clauses ml_cs \\<and> cake_linear_clauses ml_cs\n  list_all2\n   (rel_prod related_pat\n     (\\<lambda>x1 x2.\n         related_exp x1 x2 \\<and>\n         (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n          is_cupcake_exp x2)))\n   cs ml_cs\n  pre_strong_term_class.wellformed scr \\<Longrightarrow>\n  is_cupcake_exp ml_scr\n  related_exp scr ml_scr\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp (Mat ml_scr ml_cs)", "by auto"], ["proof (state)\nthis:\n  is_cupcake_exp (Mat ml_scr ml_cs)\n\ngoal (4 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "case (constr name ts es)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   ts es\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (4 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "hence \"list_all wellformed ts\""], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   ts es\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed ts", "by (simp add: wellformed.list_comb)"], ["proof (state)\nthis:\n  list_all pre_strong_term_class.wellformed ts\n\ngoal (4 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "with \\<open>list_all2 _ ts es\\<close>"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   ts es\n  list_all pre_strong_term_class.wellformed ts", "have \"list_all is_cupcake_exp es\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_exp x1 x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        is_cupcake_exp x2))\n   ts es\n  list_all pre_strong_term_class.wellformed ts\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp es", "by induction auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp es\n\ngoal (4 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>name ts es.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             related_exp x1 x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              is_cupcake_exp x2))\n         ts es;\n        pre_strong_term_class.wellformed (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (Con (Some (Short (as_string name))) es)\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "thus ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. is_cupcake_exp (Con (Some (Short (as_string name))) es)", "by simp"], ["proof (state)\nthis:\n  is_cupcake_exp (Con (Some (Short (as_string name))) es)\n\ngoal (3 subgoals):\n 1. \\<And>name.\n       pre_strong_term_class.wellformed (Svar name) \\<Longrightarrow>\n       is_cupcake_exp (Var (Short (as_string name)))\n 2. \\<And>name.\n       \\<lbrakk>name |\\<notin>| C;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp (Var (Short (as_string name)))\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>related_exp t\\<^sub>1 u\\<^sub>1;\n        pre_strong_term_class.wellformed t\\<^sub>1 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>1;\n        related_exp t\\<^sub>2 u\\<^sub>2;\n        pre_strong_term_class.wellformed t\\<^sub>2 \\<Longrightarrow>\n        is_cupcake_exp u\\<^sub>2;\n        pre_strong_term_class.wellformed\n         (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_exp\n                          (exp0.App Opapp [u\\<^sub>1, u\\<^sub>2])", "qed auto"], ["", "definition related_fun :: \"(term \\<times> sterm) list \\<Rightarrow> name \\<Rightarrow> exp \\<Rightarrow> bool\" where\n\"related_fun cs n e \\<longleftrightarrow>\n  n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts \\<and> (case e of\n    (Ast.Mat (Ast.Var (Short n')) ml_cs) \\<Rightarrow>\n      n = Name n' \\<and> list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  | _ \\<Rightarrow> False)\""], ["", "lemma related_fun_alt_def:\n  \"related_fun cs n (Ast.Mat (Ast.Var (Short (as_string n))) ml_cs) \\<longleftrightarrow>\n    list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_fun cs n (Mat (Var (Short (as_string n))) ml_cs) =\n    (list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<and>\n     n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts)", "unfolding related_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n |\\<notin>| ids (Sabs cs) \\<and>\n     n |\\<notin>| all_consts \\<and>\n     (case Mat (Var (Short (as_string n))) ml_cs of\n      Mat (Var (Short n')) ml_cs \\<Rightarrow>\n        n = Name n' \\<and>\n        list_all2 (rel_prod related_pat related_exp) cs ml_cs\n      | Mat (Var (Long m id0a)) ml_cs \\<Rightarrow> False\n      | Mat _ ml_cs \\<Rightarrow> False | _ \\<Rightarrow> False)) =\n    (list_all2 (rel_prod related_pat related_exp) cs ml_cs \\<and>\n     n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts)", "by auto"], ["", "lemma related_funE:\n  assumes \"related_fun cs n e\"\n  obtains ml_cs\n    where \"e = Ast.Mat (Ast.Var (Short (as_string n))) ml_cs\" \"n |\\<notin>| ids (Sabs cs)\" \"n |\\<notin>| all_consts\"\n      and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ml_cs.\n        \\<lbrakk>e = Mat (Var (Short (as_string n))) ml_cs;\n         n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  related_fun cs n e\n\ngoal (1 subgoal):\n 1. (\\<And>ml_cs.\n        \\<lbrakk>e = Mat (Var (Short (as_string n))) ml_cs;\n         n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding related_fun_def"], ["proof (prove)\nusing this:\n  n |\\<notin>| ids (Sabs cs) \\<and>\n  n |\\<notin>| all_consts \\<and>\n  (case e of\n   Mat (Var (Short n')) ml_cs \\<Rightarrow>\n     n = Name n' \\<and>\n     list_all2 (rel_prod related_pat related_exp) cs ml_cs\n   | Mat (Var (Long m id0a)) ml_cs \\<Rightarrow> False\n   | Mat _ ml_cs \\<Rightarrow> False | _ \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. (\\<And>ml_cs.\n        \\<lbrakk>e = Mat (Var (Short (as_string n))) ml_cs;\n         n |\\<notin>| ids (Sabs cs); n |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp split: exp0.splits id0.splits)"], ["", "lemma related_exp_fun:\n  \"related_fun cs n e \\<longleftrightarrow> related_exp (Sabs cs) (Ast.Fun (as_string n) e) \\<and> n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_fun cs n e =\n    (related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n     n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n 2. related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and>\n    n |\\<notin>| all_consts \\<Longrightarrow>\n    related_fun cs n e", "assume ?rhs"], ["proof (state)\nthis:\n  related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n  n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n\ngoal (2 subgoals):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n 2. related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and>\n    n |\\<notin>| all_consts \\<Longrightarrow>\n    related_fun cs n e", "hence \"related_exp (Sabs cs) (Ast.Fun (as_string n) e)\""], ["proof (prove)\nusing this:\n  related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n  n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n\ngoal (1 subgoal):\n 1. related_exp (Sabs cs) (Fun (as_string n) e)", "by simp"], ["proof (state)\nthis:\n  related_exp (Sabs cs) (Fun (as_string n) e)\n\ngoal (2 subgoals):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n 2. related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and>\n    n |\\<notin>| all_consts \\<Longrightarrow>\n    related_fun cs n e", "thus ?lhs"], ["proof (prove)\nusing this:\n  related_exp (Sabs cs) (Fun (as_string n) e)\n\ngoal (1 subgoal):\n 1. related_fun cs n e", "by cases (auto simp: related_fun_def dest: name.expand)"], ["proof (state)\nthis:\n  related_fun cs n e\n\ngoal (1 subgoal):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts", "assume ?lhs"], ["proof (state)\nthis:\n  related_fun cs n e\n\ngoal (1 subgoal):\n 1. related_fun cs n e \\<Longrightarrow>\n    related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts", "thus ?rhs"], ["proof (prove)\nusing this:\n  related_fun cs n e\n\ngoal (1 subgoal):\n 1. related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n    n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts", "by (auto intro: related_exp.fun elim: related_funE)"], ["proof (state)\nthis:\n  related_exp (Sabs cs) (Fun (as_string n) e) \\<and>\n  n |\\<notin>| ids (Sabs cs) \\<and> n |\\<notin>| all_consts\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive related_v :: \"value \\<Rightarrow> v \\<Rightarrow> bool\" where\nconv:\n  \"list_all2 related_v us vs \\<Longrightarrow>\n    related_v (Vconstr name us) (Conv (Some (as_string name, _)) vs)\" |\nclosure:\n  \"related_fun cs n e \\<Longrightarrow>\n   fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma> (fmap_of_ns (sem_env.v env)) \\<Longrightarrow>\n    related_v (Vabs cs \\<Gamma>) (Closure env (as_string n) e)\" |\nrec_closure:\n  \"fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v \\<Gamma> (fmap_of_ns (sem_env.v env)) \\<Longrightarrow>\n   fmrel (\\<lambda>cs. \\<lambda>(n, e). related_fun cs n e) css (fmap_of_list (map (map_prod Name (map_prod Name id)) exps)) \\<Longrightarrow>\n    related_v (Vrecabs css name \\<Gamma>) (Recclosure env exps (as_string name))\""], ["", "abbreviation var_env :: \"(name, value) fmap \\<Rightarrow> (string \\<times> v) list \\<Rightarrow> bool\" where\n\"var_env \\<Gamma> ns \\<equiv> fmrel related_v \\<Gamma> (fmap_of_list (map (map_prod Name id) ns))\""], ["", "lemma related_v_ext:\n  assumes \"related_v v ml_v\"\n  assumes \"v' \\<approx>\\<^sub>e v\"\n  shows \"related_v v' ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v' ml_v", "using assms"], ["proof (prove)\nusing this:\n  related_v v ml_v\n  v' \\<approx>\\<^sub>e v\n\ngoal (1 subgoal):\n 1. related_v v' ml_v", "proof (induction arbitrary: v')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v'.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 us vs;\n        v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Conv (Some (as_string name, uu_)) vs)\n 2. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 3. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "case (conv us ml_us name)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n   us ml_us\n  v' \\<approx>\\<^sub>e Vconstr name us\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v'.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 us vs;\n        v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Conv (Some (as_string name, uu_)) vs)\n 2. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 3. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "obtain ts where \"v' = Vconstr name ts\" \"list_all2 erelated ts us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>v' = Vconstr name ts; list_all2 erelated ts us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v' \\<approx>\\<^sub>e Vconstr name us\\<close>"], ["proof (prove)\nusing this:\n  v' \\<approx>\\<^sub>e Vconstr name us\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>v' = Vconstr name ts; list_all2 erelated ts us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v' = Vconstr name ts\n  list_all2 erelated ts us\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v'.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 us vs;\n        v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Conv (Some (as_string name, uu_)) vs)\n 2. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 3. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "have \"list_all2 related_v ts ml_us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 related_v ts ml_us", "by (rule list_all2_trans[OF _ \\<open>list_all2 erelated ts us\\<close> conv(1)]) auto"], ["proof (state)\nthis:\n  list_all2 related_v ts ml_us\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v'.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 us vs;\n        v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Conv (Some (as_string name, uu_)) vs)\n 2. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 3. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 related_v ts ml_us\n\ngoal (1 subgoal):\n 1. related_v v' (Conv (Some (as_string name, uu_)) ml_us)", "using conv"], ["proof (prove)\nusing this:\n  list_all2 related_v ts ml_us\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n   us ml_us\n  v' \\<approx>\\<^sub>e Vconstr name us\n\ngoal (1 subgoal):\n 1. related_v v' (Conv (Some (as_string name, uu_)) ml_us)", "unfolding \\<open>v' = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2 related_v ts ml_us\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n   us ml_us\n  Vconstr name ts \\<approx>\\<^sub>e Vconstr name us\n\ngoal (1 subgoal):\n 1. related_v (Vconstr name ts) (Conv (Some (as_string name, uu_)) ml_us)", "by (auto intro: related_v.conv)"], ["proof (state)\nthis:\n  related_v v' (Conv (Some (as_string name, uu_)) ml_us)\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 2. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 2. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "case (closure cs n e \\<Gamma>\\<^sub>2 env)"], ["proof (state)\nthis:\n  related_fun cs n e\n  fmrel_on_fset (ids (Sabs cs))\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n   \\<Gamma>\\<^sub>2 (fmap_of_ns (sem_env.v env))\n  v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 2. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "obtain \\<Gamma>\\<^sub>1 where \"v' = Vabs cs \\<Gamma>\\<^sub>1\" \"fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>1.\n        \\<lbrakk>v' = Vabs cs \\<Gamma>\\<^sub>1;\n         fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1\n          \\<Gamma>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v' \\<approx>\\<^sub>e _\\<close>"], ["proof (prove)\nusing this:\n  v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>1.\n        \\<lbrakk>v' = Vabs cs \\<Gamma>\\<^sub>1;\n         fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1\n          \\<Gamma>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v' = Vabs cs \\<Gamma>\\<^sub>1\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 2. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "have \"fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>1 (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>1\n     (fmap_of_ns (sem_env.v env))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n       rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n        (fmlookup (fmap_of_ns (sem_env.v env)) x)", "subgoal premises prems for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (insert prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (drule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (ids (Sabs cs)) ?P1 ?m1 ?n1\n 2. rel_option ?P1 (fmlookup ?m1 x) (fmlookup ?n1 x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (rule closure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x1 x2.\n         related_v x1 x2 \\<and>\n         (\\<forall>x.\n             x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n     (fmlookup \\<Gamma>\\<^sub>2 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x1 x2.\n         related_v x1 x2 \\<and>\n         (\\<forall>x.\n             x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n     (fmlookup \\<Gamma>\\<^sub>2 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (insert prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_option\n              (\\<lambda>x1 x2.\n                  related_v x1 x2 \\<and>\n                  (\\<forall>x.\n                      x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                      related_v x x2))\n              (fmlookup \\<Gamma>\\<^sub>2 x)\n              (fmlookup (fmap_of_ns (sem_env.v env)) x);\n     x |\\<in>| ids (Sabs cs)\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                       (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (drule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_option\n     (\\<lambda>x1 x2.\n         related_v x1 x2 \\<and>\n         (\\<forall>x.\n             x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n     (fmlookup \\<Gamma>\\<^sub>2 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x) \\<Longrightarrow>\n    fmrel_on_fset (ids (Sabs cs)) ?P1 ?m1 ?n1\n 2. \\<lbrakk>rel_option\n              (\\<lambda>x1 x2.\n                  related_v x1 x2 \\<and>\n                  (\\<forall>x.\n                      x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                      related_v x x2))\n              (fmlookup \\<Gamma>\\<^sub>2 x)\n              (fmlookup (fmap_of_ns (sem_env.v env)) x);\n     rel_option ?P1 (fmlookup ?m1 x) (fmlookup ?n1 x)\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                       (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (rule \\<open>fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_option\n              (\\<lambda>x1 x2.\n                  related_v x1 x2 \\<and>\n                  (\\<forall>x.\n                      x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                      related_v x x2))\n              (fmlookup \\<Gamma>\\<^sub>2 x)\n              (fmlookup (fmap_of_ns (sem_env.v env)) x);\n     rel_option erelated (fmlookup \\<Gamma>\\<^sub>1 x)\n      (fmlookup \\<Gamma>\\<^sub>2 x)\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                       (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (metis (mono_tags, lifting) option.rel_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>1\n   (fmap_of_ns (sem_env.v env))\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v'.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Closure env (as_string n) e)\n 2. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v' (Closure env (as_string n) e)", "unfolding \\<open>v' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vabs cs \\<Gamma>\\<^sub>1) (Closure env (as_string n) e)", "by (rule related_v.closure) fact+"], ["proof (state)\nthis:\n  related_v v' (Closure env (as_string n) e)\n\ngoal (1 subgoal):\n 1. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "case (rec_closure css \\<Gamma>\\<^sub>2 env exps name)"], ["proof (state)\nthis:\n  fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n   \\<Gamma>\\<^sub>2 (fmap_of_ns (sem_env.v env))\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) exps))\n  v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "obtain \\<Gamma>\\<^sub>1 where \"v' = Vrecabs css name \\<Gamma>\\<^sub>1\" \"pred_fmap (\\<lambda>cs. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2) css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>1.\n        \\<lbrakk>v' = Vrecabs css name \\<Gamma>\\<^sub>1;\n         pred_fmap\n          (\\<lambda>cs.\n              fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1\n               \\<Gamma>\\<^sub>2)\n          css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v' \\<approx>\\<^sub>e _\\<close>"], ["proof (prove)\nusing this:\n  v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>1.\n        \\<lbrakk>v' = Vrecabs css name \\<Gamma>\\<^sub>1;\n         pred_fmap\n          (\\<lambda>cs.\n              fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1\n               \\<Gamma>\\<^sub>2)\n          css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v' = Vrecabs css name \\<Gamma>\\<^sub>1\n  pred_fmap\n   (\\<lambda>cs.\n       fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>1\n        \\<Gamma>\\<^sub>2)\n   css\n\ngoal (1 subgoal):\n 1. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "have \"fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v \\<Gamma>\\<^sub>1 (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n     \\<Gamma>\\<^sub>1 (fmap_of_ns (sem_env.v env))", "apply (rule fmrel_on_fsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fbind (fmran css) (ids \\<circ> Sabs) \\<Longrightarrow>\n       rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n        (fmlookup (fmap_of_ns (sem_env.v env)) x)", "subgoal premises prems for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (insert prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| fbind (fmran css) (ids \\<circ> Sabs) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (drule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) ?P1 ?m1 ?n1\n 2. rel_option ?P1 (fmlookup ?m1 x) (fmlookup ?n1 x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (rule rec_closure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x1 x2.\n         related_v x1 x2 \\<and>\n         (\\<forall>x.\n             x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n     (fmlookup \\<Gamma>\\<^sub>2 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x1 x2.\n         related_v x1 x2 \\<and>\n         (\\<forall>x.\n             x \\<approx>\\<^sub>e x1 \\<longrightarrow> related_v x x2))\n     (fmlookup \\<Gamma>\\<^sub>2 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n     (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (insert prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_option\n              (\\<lambda>x1 x2.\n                  related_v x1 x2 \\<and>\n                  (\\<forall>x.\n                      x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                      related_v x x2))\n              (fmlookup \\<Gamma>\\<^sub>2 x)\n              (fmlookup (fmap_of_ns (sem_env.v env)) x);\n     x |\\<in>| fbind (fmran css) (ids \\<circ> Sabs)\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                       (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (erule fbindE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        x |\\<in>| (ids \\<circ> Sabs) s; s |\\<in>| fmran css\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                          (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (drule pred_fmapD[OF \\<open>pred_fmap _ css\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        x |\\<in>| (ids \\<circ> Sabs) s;\n        fmrel_on_fset (ids (Sabs s)) erelated \\<Gamma>\\<^sub>1\n         \\<Gamma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                          (fmlookup (fmap_of_ns (sem_env.v env)) x)", "unfolding comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        x |\\<in>| ids (Sabs s);\n        fmrel_on_fset (ids (Sabs s)) erelated \\<Gamma>\\<^sub>1\n         \\<Gamma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                          (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (drule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        fmrel_on_fset (ids (Sabs s)) erelated \\<Gamma>\\<^sub>1\n         \\<Gamma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (ids (Sabs s)) (?P5 s) (?m5 s)\n                          (?n5 s)\n 2. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        fmrel_on_fset (ids (Sabs s)) erelated \\<Gamma>\\<^sub>1\n         \\<Gamma>\\<^sub>2;\n        rel_option (?P5 s) (fmlookup (?m5 s) x)\n         (fmlookup (?n5 s) x)\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                          (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>rel_option\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 (fmlookup \\<Gamma>\\<^sub>2 x)\n                 (fmlookup (fmap_of_ns (sem_env.v env)) x);\n        fmrel_on_fset (ids (Sabs s)) erelated \\<Gamma>\\<^sub>1\n         \\<Gamma>\\<^sub>2;\n        rel_option erelated (fmlookup \\<Gamma>\\<^sub>1 x)\n         (fmlookup \\<Gamma>\\<^sub>2 x)\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>\\<^sub>1 x)\n                          (fmlookup (fmap_of_ns (sem_env.v env)) x)", "apply (metis (mono_tags, lifting) option.rel_sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n   \\<Gamma>\\<^sub>1 (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. \\<And>css \\<Gamma> env exps name v'.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         x \\<approx>\\<^sub>e x1 \\<longrightarrow>\n                         related_v x x2))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        v' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> related_v v' (Recclosure env exps (as_string name))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v' (Recclosure env exps (as_string name))", "unfolding \\<open>v' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vrecabs css name \\<Gamma>\\<^sub>1)\n     (Recclosure env exps (as_string name))", "by (rule related_v.rec_closure) fact+"], ["proof (state)\nthis:\n  related_v v' (Recclosure env exps (as_string name))\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "private"], ["", "inductive match_result_related :: \"(string \\<times> v) list \\<Rightarrow> (string \\<times> v) list match_result \\<Rightarrow> (name, value) fmap option \\<Rightarrow> bool\" for eenv where\nno_match: \"match_result_related eenv No_match None\" |\nerror: \"match_result_related eenv Match_type_error _\" |\nmatch: \"var_env \\<Gamma> eenv_m \\<Longrightarrow> match_result_related eenv (Match (eenv_m @ eenv)) (Some \\<Gamma>)\""], ["", "private"], ["", "corollary match_result_related_empty: \"match_result_related eenv (Match eenv) (Some fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related eenv (Match eenv) (Some fmempty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. match_result_related eenv (Match eenv) (Some fmempty)", "have \"match_result_related eenv (Match ([] @ eenv)) (Some fmempty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related eenv (Match ([] @ eenv)) (Some fmempty)", "by (rule match_result_related.match) auto"], ["proof (state)\nthis:\n  match_result_related eenv (Match ([] @ eenv)) (Some fmempty)\n\ngoal (1 subgoal):\n 1. match_result_related eenv (Match eenv) (Some fmempty)", "thus ?thesis"], ["proof (prove)\nusing this:\n  match_result_related eenv (Match ([] @ eenv)) (Some fmempty)\n\ngoal (1 subgoal):\n 1. match_result_related eenv (Match eenv) (Some fmempty)", "by simp"], ["proof (state)\nthis:\n  match_result_related eenv (Match eenv) (Some fmempty)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "fun is_Match :: \"'a match_result \\<Rightarrow> bool\" where\n\"is_Match (Match _) \\<longleftrightarrow> True\" |\n\"is_Match _ \\<longleftrightarrow> False\""], ["", "lemma cupcake_pmatch_related:\n  assumes \"related_v v ml_v\"\n  shows \"match_result_related eenv (cupcake_pmatch as_static_cenv (mk_ml_pat pat) ml_v eenv) (vmatch pat v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat pat) ml_v eenv)\n     (vmatch pat v)", "using assms"], ["proof (prove)\nusing this:\n  related_v v ml_v\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat pat) ml_v eenv)\n     (vmatch pat v)", "proof (induction pat arbitrary: v ml_v eenv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x v ml_v eenv.\n       related_v v ml_v \\<Longrightarrow>\n       match_result_related eenv\n        (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar x)) ml_v eenv)\n        (vmatch (Patvar x) v)\n 2. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "case (Patvar name)"], ["proof (state)\nthis:\n  related_v v ml_v\n\ngoal (2 subgoals):\n 1. \\<And>x v ml_v eenv.\n       related_v v ml_v \\<Longrightarrow>\n       match_result_related eenv\n        (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar x)) ml_v eenv)\n        (vmatch (Patvar x) v)\n 2. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "have \"var_env (fmap_of_list [(name, v)]) [(as_string name, ml_v)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_env (fmap_of_list [(name, v)]) [(as_string name, ml_v)]", "using Patvar"], ["proof (prove)\nusing this:\n  related_v v ml_v\n\ngoal (1 subgoal):\n 1. var_env (fmap_of_list [(name, v)]) [(as_string name, ml_v)]", "by auto"], ["proof (state)\nthis:\n  var_env (fmap_of_list [(name, v)]) [(as_string name, ml_v)]\n\ngoal (2 subgoals):\n 1. \\<And>x v ml_v eenv.\n       related_v v ml_v \\<Longrightarrow>\n       match_result_related eenv\n        (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar x)) ml_v eenv)\n        (vmatch (Patvar x) v)\n 2. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "hence \"match_result_related eenv (Match ([(as_string name, ml_v)] @ eenv)) (Some (fmap_of_list [(name, v)]))\""], ["proof (prove)\nusing this:\n  var_env (fmap_of_list [(name, v)]) [(as_string name, ml_v)]\n\ngoal (1 subgoal):\n 1. match_result_related eenv (Match ([(as_string name, ml_v)] @ eenv))\n     (Some (fmap_of_list [(name, v)]))", "by (rule match_result_related.match)"], ["proof (state)\nthis:\n  match_result_related eenv (Match ([(as_string name, ml_v)] @ eenv))\n   (Some (fmap_of_list [(name, v)]))\n\ngoal (2 subgoals):\n 1. \\<And>x v ml_v eenv.\n       related_v v ml_v \\<Longrightarrow>\n       match_result_related eenv\n        (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar x)) ml_v eenv)\n        (vmatch (Patvar x) v)\n 2. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "thus ?case"], ["proof (prove)\nusing this:\n  match_result_related eenv (Match ([(as_string name, ml_v)] @ eenv))\n   (Some (fmap_of_list [(name, v)]))\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar name)) ml_v eenv)\n     (vmatch (Patvar name) v)", "by simp"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patvar name)) ml_v eenv)\n   (vmatch (Patvar name) v)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "case (Patconstr name ps v0)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a4 \\<in> set ps; related_v ?v4 ?ml_v4\\<rbrakk>\n  \\<Longrightarrow> match_result_related ?eenv4\n                     (cupcake_pmatch as_static_cenv (mk_ml_pat ?x2a4) ?ml_v4\n                       ?eenv4)\n                     (vmatch ?x2a4 ?v4)\n  related_v v0 ml_v\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 v ml_v eenv.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set x2; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr x1a x2)) ml_v eenv)\n                          (vmatch (Patconstr x1a x2) v)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "using Patconstr.prems"], ["proof (prove)\nusing this:\n  related_v v0 ml_v\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "proof (cases rule: related_v.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "case (conv us vs name' _)"], ["proof (state)\nthis:\n  v0 = Vconstr name' us\n  ml_v = Conv (Some (as_string name', uu_)) vs\n  list_all2 related_v us vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "define f where\n      \"f p v m =\n        (case m of\n          Match env \\<Rightarrow> cupcake_pmatch as_static_cenv p v env\n        | m \\<Rightarrow> m)\" for p v m"], ["proof (state)\nthis:\n  f ?p ?v ?m =\n  (case ?m of No_match \\<Rightarrow> No_match\n   | Match_type_error \\<Rightarrow> Match_type_error\n   | Match env \\<Rightarrow> cupcake_pmatch as_static_cenv ?p ?v env)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "{"], ["proof (state)\nthis:\n  f ?p ?v ?m =\n  (case ?m of No_match \\<Rightarrow> No_match\n   | Match_type_error \\<Rightarrow> Match_type_error\n   | Match env \\<Rightarrow> cupcake_pmatch as_static_cenv ?p ?v env)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "assume \"name = name'\""], ["proof (state)\nthis:\n  name = name'\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "assume \"length ps = length us\""], ["proof (state)\nthis:\n  length ps = length us\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "hence \"list_all2 (\\<lambda>_ _. True) us ps\""], ["proof (prove)\nusing this:\n  length ps = length us\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>_ _. True) us ps", "by (induct rule: list_induct2) auto"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>_ _. True) us ps\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "hence \"list_all3 (\\<lambda>t p v. related_v t v) us ps vs\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>_ _. True) us ps\n\ngoal (1 subgoal):\n 1. list_all3 (\\<lambda>t p. related_v t) us ps vs", "using \\<open>list_all2 related_v us vs\\<close>"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>_ _. True) us ps\n  list_all2 related_v us vs\n\ngoal (1 subgoal):\n 1. list_all3 (\\<lambda>t p. related_v t) us ps vs", "by (rule list_all3_from_list_all2s) auto"], ["proof (state)\nthis:\n  list_all3 (\\<lambda>t p. related_v t) us ps vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "hence *: \"match_result_related eenv\n                    (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match (eenv_m @ eenv)))\n                    (map_option (foldl (++\\<^sub>f) \\<Gamma>) (those (map2 vmatch ps us)))\" (is \"?rel\")\n          if \"var_env \\<Gamma> eenv_m\"\n          for eenv_m \\<Gamma>"], ["proof (prove)\nusing this:\n  list_all3 (\\<lambda>t p. related_v t) us ps vs\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch ps us)))", "using Patconstr.IH \\<open>related_v v0 ml_v\\<close> that"], ["proof (prove)\nusing this:\n  list_all3 (\\<lambda>t p. related_v t) us ps vs\n  \\<lbrakk>?x2a4 \\<in> set ps; related_v ?v4 ?ml_v4\\<rbrakk>\n  \\<Longrightarrow> match_result_related ?eenv4\n                     (cupcake_pmatch as_static_cenv (mk_ml_pat ?x2a4) ?ml_v4\n                       ?eenv4)\n                     (vmatch ?x2a4 ?v4)\n  related_v v0 ml_v\n  var_env \\<Gamma> eenv_m\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch ps us)))", "proof (induction us ps vs arbitrary: \\<Gamma> eenv_m rule: list_all3_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set []; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat []) [] (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n 2. \\<And>x xs y ys z zs \\<Gamma> eenv_m.\n       \\<lbrakk>related_v x z;\n        \\<And>\\<Gamma> eenv_m.\n           \\<lbrakk>\\<And>x2a v ml_v eenv.\n                       \\<lbrakk>x2a \\<in> set ys; related_v v ml_v\\<rbrakk>\n                       \\<Longrightarrow> match_result_related eenv\n    (cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv)\n    (vmatch x2a v);\n            related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (Matching.fold2 f Match_type_error\n                                (map mk_ml_pat ys) zs\n                                (Match (eenv_m @ eenv)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch ys xs)));\n        list_all3 (\\<lambda>t p. related_v t) xs ys zs;\n        \\<And>x2a v ml_v eenv.\n           \\<lbrakk>x2a \\<in> set (y # ys); related_v v ml_v\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (cupcake_pmatch as_static_cenv (mk_ml_pat x2a)\n                                ml_v eenv)\n                              (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (y # ys)) (z # zs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (y # ys) (x # xs))))", "case (Cons t us p ps v vs)"], ["proof (state)\nthis:\n  related_v t v\n  list_all3 (\\<lambda>t p. related_v t) us ps vs\n  \\<lbrakk>\\<And>x2a v ml_v eenv.\n              \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n              \\<Longrightarrow> match_result_related eenv\n                                 (cupcake_pmatch as_static_cenv\n                                   (mk_ml_pat x2a) ml_v eenv)\n                                 (vmatch x2a v);\n   related_v v0 ml_v; var_env ?\\<Gamma>4 ?eenv_m4\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (Matching.fold2 f Match_type_error (map mk_ml_pat ps)\n                       vs (Match (?eenv_m4 @ eenv)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n                       (those (Term_Utils.map2 vmatch ps us)))\n  \\<lbrakk>?x2a4 \\<in> set (p # ps); related_v ?v4 ?ml_v4\\<rbrakk>\n  \\<Longrightarrow> match_result_related ?eenv4\n                     (cupcake_pmatch as_static_cenv (mk_ml_pat ?x2a4) ?ml_v4\n                       ?eenv4)\n                     (vmatch ?x2a4 ?v4)\n  related_v v0 ml_v\n  var_env \\<Gamma> eenv_m\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set []; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat []) [] (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n 2. \\<And>x xs y ys z zs \\<Gamma> eenv_m.\n       \\<lbrakk>related_v x z;\n        \\<And>\\<Gamma> eenv_m.\n           \\<lbrakk>\\<And>x2a v ml_v eenv.\n                       \\<lbrakk>x2a \\<in> set ys; related_v v ml_v\\<rbrakk>\n                       \\<Longrightarrow> match_result_related eenv\n    (cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv)\n    (vmatch x2a v);\n            related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (Matching.fold2 f Match_type_error\n                                (map mk_ml_pat ys) zs\n                                (Match (eenv_m @ eenv)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch ys xs)));\n        list_all3 (\\<lambda>t p. related_v t) xs ys zs;\n        \\<And>x2a v ml_v eenv.\n           \\<lbrakk>x2a \\<in> set (y # ys); related_v v ml_v\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (cupcake_pmatch as_static_cenv (mk_ml_pat x2a)\n                                ml_v eenv)\n                              (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (y # ys)) (z # zs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (y # ys) (x # xs))))", "have \"match_result_related (eenv_m @ eenv) (cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv)) (vmatch p t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related (eenv_m @ eenv)\n     (cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv))\n     (vmatch p t)", "using Cons"], ["proof (prove)\nusing this:\n  related_v t v\n  list_all3 (\\<lambda>t p. related_v t) us ps vs\n  \\<lbrakk>\\<And>x2a v ml_v eenv.\n              \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n              \\<Longrightarrow> match_result_related eenv\n                                 (cupcake_pmatch as_static_cenv\n                                   (mk_ml_pat x2a) ml_v eenv)\n                                 (vmatch x2a v);\n   related_v v0 ml_v; var_env ?\\<Gamma>4 ?eenv_m4\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (Matching.fold2 f Match_type_error (map mk_ml_pat ps)\n                       vs (Match (?eenv_m4 @ eenv)))\n                     (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n                       (those (Term_Utils.map2 vmatch ps us)))\n  \\<lbrakk>?x2a4 \\<in> set (p # ps); related_v ?v4 ?ml_v4\\<rbrakk>\n  \\<Longrightarrow> match_result_related ?eenv4\n                     (cupcake_pmatch as_static_cenv (mk_ml_pat ?x2a4) ?ml_v4\n                       ?eenv4)\n                     (vmatch ?x2a4 ?v4)\n  related_v v0 ml_v\n  var_env \\<Gamma> eenv_m\n\ngoal (1 subgoal):\n 1. match_result_related (eenv_m @ eenv)\n     (cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv))\n     (vmatch p t)", "by simp"], ["proof (state)\nthis:\n  match_result_related (eenv_m @ eenv)\n   (cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv))\n   (vmatch p t)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set []; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat []) [] (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))\n 2. \\<And>x xs y ys z zs \\<Gamma> eenv_m.\n       \\<lbrakk>related_v x z;\n        \\<And>\\<Gamma> eenv_m.\n           \\<lbrakk>\\<And>x2a v ml_v eenv.\n                       \\<lbrakk>x2a \\<in> set ys; related_v v ml_v\\<rbrakk>\n                       \\<Longrightarrow> match_result_related eenv\n    (cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv)\n    (vmatch x2a v);\n            related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (Matching.fold2 f Match_type_error\n                                (map mk_ml_pat ys) zs\n                                (Match (eenv_m @ eenv)))\n                              (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                                (those (Term_Utils.map2 vmatch ys xs)));\n        list_all3 (\\<lambda>t p. related_v t) xs ys zs;\n        \\<And>x2a v ml_v eenv.\n           \\<lbrakk>x2a \\<in> set (y # ys); related_v v ml_v\\<rbrakk>\n           \\<Longrightarrow> match_result_related eenv\n                              (cupcake_pmatch as_static_cenv (mk_ml_pat x2a)\n                                ml_v eenv)\n                              (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (y # ys)) (z # zs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (y # ys) (x # xs))))", "thus ?case"], ["proof (prove)\nusing this:\n  match_result_related (eenv_m @ eenv)\n   (cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv))\n   (vmatch p t)\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             No_match;\n     vmatch p t = None\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2 f Match_type_error\n                         (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n    Match_type_error \\<Longrightarrow>\n    match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 3. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "case no_match"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) = No_match\n  vmatch p t = None\n\ngoal (3 subgoals):\n 1. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             No_match;\n     vmatch p t = None\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2 f Match_type_error\n                         (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n    Match_type_error \\<Longrightarrow>\n    match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 3. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) = No_match\n  vmatch p t = None\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "unfolding f_def"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) = No_match\n  vmatch p t = None\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2\n       (\\<lambda>a aa aaa.\n           case aaa of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv a aa x)\n       Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "apply (cases \"length (map mk_ml_pat ps) = length vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             No_match;\n     vmatch p t = None; length (map mk_ml_pat ps) = length vs\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2\n                         (\\<lambda>a aa aaa.\n                             case aaa of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match x \\<Rightarrow>\n                                 cupcake_pmatch as_static_cenv a aa x)\n                         Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             No_match;\n     vmatch p t = None;\n     length (map mk_ml_pat ps) \\<noteq> length vs\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2\n                         (\\<lambda>a aa aaa.\n                             case aaa of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match x \\<Rightarrow>\n                                 cupcake_pmatch as_static_cenv a aa x)\n                         Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "by (fastforce intro: match_result_related.intros simp:cup_pmatch_list_nomatch cup_pmatch_list_length_neq)+"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n     (Match (eenv_m @ eenv)))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n    Match_type_error \\<Longrightarrow>\n    match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n    Match_type_error \\<Longrightarrow>\n    match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "case error"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match_type_error\n\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n    Match_type_error \\<Longrightarrow>\n    match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match_type_error\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "unfolding f_def"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match_type_error\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2\n       (\\<lambda>a aa aaa.\n           case aaa of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv a aa x)\n       Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "apply (cases \"length (map mk_ml_pat ps) = length vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             Match_type_error;\n     length (map mk_ml_pat ps) = length vs\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2\n                         (\\<lambda>a aa aaa.\n                             case aaa of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match x \\<Rightarrow>\n                                 cupcake_pmatch as_static_cenv a aa x)\n                         Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n 2. \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n             Match_type_error;\n     length (map mk_ml_pat ps) \\<noteq> length vs\\<rbrakk>\n    \\<Longrightarrow> match_result_related eenv\n                       (Matching.fold2\n                         (\\<lambda>a aa aaa.\n                             case aaa of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match x \\<Rightarrow>\n                                 cupcake_pmatch as_static_cenv a aa x)\n                         Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n                         (Match (eenv_m @ eenv)))\n                       (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                         (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "by (fastforce intro: match_result_related.intros simp:cup_pmatch_list_typerr cup_pmatch_list_length_neq)+"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n     (Match (eenv_m @ eenv)))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "case (match \\<Gamma>' eenv_m')"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match (eenv_m' @ eenv_m @ eenv)\n  vmatch p t = Some \\<Gamma>'\n  var_env \\<Gamma>' eenv_m'\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "have \"match_result_related eenv\n                        (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match ((eenv_m' @ eenv_m) @ eenv)))\n                        (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>')) (those (map2 vmatch ps us)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n       (Match ((eenv_m' @ eenv_m) @ eenv)))\n     (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n       (those (Term_Utils.map2 vmatch ps us)))", "proof (rule Cons, rule Cons)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x2a v ml_v eenv.\n       \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> x2a \\<in> set (p # ps)\n 2. \\<And>x2a v ml_v eenv.\n       \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> related_v v ml_v\n 3. related_v v0 ml_v\n 4. var_env (\\<Gamma> ++\\<^sub>f \\<Gamma>') (eenv_m' @ eenv_m)", "show \"var_env (\\<Gamma> ++\\<^sub>f \\<Gamma>') (eenv_m' @ eenv_m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_env (\\<Gamma> ++\\<^sub>f \\<Gamma>') (eenv_m' @ eenv_m)", "using \\<open>var_env \\<Gamma> eenv_m\\<close> match"], ["proof (prove)\nusing this:\n  var_env \\<Gamma> eenv_m\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match (eenv_m' @ eenv_m @ eenv)\n  vmatch p t = Some \\<Gamma>'\n  var_env \\<Gamma>' eenv_m'\n\ngoal (1 subgoal):\n 1. var_env (\\<Gamma> ++\\<^sub>f \\<Gamma>') (eenv_m' @ eenv_m)", "by force"], ["proof (state)\nthis:\n  var_env (\\<Gamma> ++\\<^sub>f \\<Gamma>') (eenv_m' @ eenv_m)\n\ngoal (3 subgoals):\n 1. \\<And>x2a v ml_v eenv.\n       \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> x2a \\<in> set (p # ps)\n 2. \\<And>x2a v ml_v eenv.\n       \\<lbrakk>x2a \\<in> set ps; related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> related_v v ml_v\n 3. related_v v0 ml_v", "qed (simp | fact)+"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ((eenv_m' @ eenv_m) @ eenv)))\n   (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>cupcake_pmatch as_static_cenv (mk_ml_pat p) v\n                 (eenv_m @ eenv) =\n                Match (eenv_m @ eenv_m @ eenv);\n        vmatch p t = Some \\<Gamma>; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat (p # ps)) (v # vs)\n                            (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those\n                              (Term_Utils.map2 vmatch (p # ps) (t # us))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ((eenv_m' @ eenv_m) @ eenv)))\n   (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "using match"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ((eenv_m' @ eenv_m) @ eenv)))\n   (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n     (those (Term_Utils.map2 vmatch ps us)))\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match (eenv_m' @ eenv_m @ eenv)\n  vmatch p t = Some \\<Gamma>'\n  var_env \\<Gamma>' eenv_m'\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "unfolding f_def"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv p v x)\n     Match_type_error (map mk_ml_pat ps) vs\n     (Match ((eenv_m' @ eenv_m) @ eenv)))\n   (map_option (foldl (++\\<^sub>f) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n     (those (Term_Utils.map2 vmatch ps us)))\n  cupcake_pmatch as_static_cenv (mk_ml_pat p) v (eenv_m @ eenv) =\n  Match (eenv_m' @ eenv_m @ eenv)\n  vmatch p t = Some \\<Gamma>'\n  var_env \\<Gamma>' eenv_m'\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2\n       (\\<lambda>a aa aaa.\n           case aaa of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv a aa x)\n       Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n       (Match (eenv_m @ eenv)))\n     (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n       (those (Term_Utils.map2 vmatch (p # ps) (t # us))))", "by (auto simp: map_option.compositionality comp_def)"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n     (Match (eenv_m @ eenv)))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat (p # ps)) (v # vs)\n     (Match (eenv_m @ eenv)))\n   (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n     (those (Term_Utils.map2 vmatch (p # ps) (t # us))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> eenv_m.\n       \\<lbrakk>\\<And>x2a v ml_v eenv.\n                   \\<lbrakk>x2a \\<in> set []; related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> match_result_related eenv\n(cupcake_pmatch as_static_cenv (mk_ml_pat x2a) ml_v eenv) (vmatch x2a v);\n        related_v v0 ml_v; var_env \\<Gamma> eenv_m\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (Matching.fold2 f Match_type_error\n                            (map mk_ml_pat []) [] (Match (eenv_m @ eenv)))\n                          (map_option (foldl (++\\<^sub>f) \\<Gamma>)\n                            (those (Term_Utils.map2 vmatch [] [])))", "qed (auto intro: match_result_related.match)"], ["proof (state)\nthis:\n  var_env ?\\<Gamma>4 ?eenv_m4 \\<Longrightarrow>\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match (?eenv_m4 @ eenv)))\n   (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "moreover"], ["proof (state)\nthis:\n  var_env ?\\<Gamma>4 ?eenv_m4 \\<Longrightarrow>\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match (?eenv_m4 @ eenv)))\n   (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "have \"var_env fmempty []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_env fmempty []", "by force"], ["proof (state)\nthis:\n  var_env fmempty []\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "ultimately"], ["proof (chain)\npicking this:\n  var_env ?\\<Gamma>4 ?eenv_m4 \\<Longrightarrow>\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match (?eenv_m4 @ eenv)))\n   (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n     (those (Term_Utils.map2 vmatch ps us)))\n  var_env fmempty []", "have \"?rel [] fmempty\""], ["proof (prove)\nusing this:\n  var_env ?\\<Gamma>4 ?eenv_m4 \\<Longrightarrow>\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match (?eenv_m4 @ eenv)))\n   (map_option (foldl (++\\<^sub>f) ?\\<Gamma>4)\n     (those (Term_Utils.map2 vmatch ps us)))\n  var_env fmempty []\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n       (Match ([] @ eenv)))\n     (map_option (foldl (++\\<^sub>f) fmempty)\n       (those (Term_Utils.map2 vmatch ps us)))", "by fastforce"], ["proof (state)\nthis:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ([] @ eenv)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "hence ?thesis"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ([] @ eenv)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps us)))\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "using conv \\<open>length ps = length us\\<close>"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n     (Match ([] @ eenv)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps us)))\n  v0 = Vconstr name' us\n  ml_v = Conv (Some (as_string name', uu_)) vs\n  list_all2 related_v us vs\n  length ps = length us\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "unfolding f_def \\<open>name = name'\\<close>"], ["proof (prove)\nusing this:\n  match_result_related eenv\n   (Matching.fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv p v x)\n     Match_type_error (map mk_ml_pat ps) vs (Match ([] @ eenv)))\n   (map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps us)))\n  v0 = Vconstr name' us\n  ml_v = Conv (Some (as_string name', uu_)) vs\n  list_all2 related_v us vs\n  length ps = length us\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name' ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name' ps) v0)", "by (auto intro: match_result_related.intros split: option.splits elim: static_cenv_lookup)"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>name = name'; length ps = length us\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (cupcake_pmatch as_static_cenv\n                       (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                     (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>name = name'; length ps = length us\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (cupcake_pmatch as_static_cenv\n                       (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                     (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>name = name'; length ps = length us\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (cupcake_pmatch as_static_cenv\n                       (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                     (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "assume \"name \\<noteq> name'\""], ["proof (state)\nthis:\n  name \\<noteq> name'\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "with conv"], ["proof (chain)\npicking this:\n  v0 = Vconstr name' us\n  ml_v = Conv (Some (as_string name', uu_)) vs\n  list_all2 related_v us vs\n  name \\<noteq> name'", "have ?thesis"], ["proof (prove)\nusing this:\n  v0 = Vconstr name' us\n  ml_v = Conv (Some (as_string name', uu_)) vs\n  list_all2 related_v us vs\n  name \\<noteq> name'\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "by (auto intro: match_result_related.intros split: option.splits elim: same_ctor.elims simp: name.expand)"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "}"], ["proof (state)\nthis:\n  name \\<noteq> name' \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "moreover"], ["proof (state)\nthis:\n  name \\<noteq> name' \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "{"], ["proof (state)\nthis:\n  name \\<noteq> name' \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "let ?fold = \"Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "assume *: \"length ps \\<noteq> length us\""], ["proof (state)\nthis:\n  length ps \\<noteq> length us\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "moreover"], ["proof (state)\nthis:\n  length ps \\<noteq> length us\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "have \"length us = length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length us = length vs", "using \\<open>list_all2 related_v us vs\\<close>"], ["proof (prove)\nusing this:\n  list_all2 related_v us vs\n\ngoal (1 subgoal):\n 1. length us = length vs", "by (rule list_all2_lengthD)"], ["proof (state)\nthis:\n  length us = length vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "ultimately"], ["proof (chain)\npicking this:\n  length ps \\<noteq> length us\n  length us = length vs", "have \"length ps \\<noteq> length vs\""], ["proof (prove)\nusing this:\n  length ps \\<noteq> length us\n  length us = length vs\n\ngoal (1 subgoal):\n 1. length ps \\<noteq> length vs", "by simp"], ["proof (state)\nthis:\n  length ps \\<noteq> length vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "moreover"], ["proof (state)\nthis:\n  length ps \\<noteq> length vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "have \"\\<not> is_Match (Matching.fold2 f err xs ys init)\"\n          if \"\\<not> is_Match err\" and \"length xs \\<noteq> length ys\" for init err xs ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_Match (Matching.fold2 f err xs ys init)", "using that f_def"], ["proof (prove)\nusing this:\n  \\<not> is_Match err\n  length xs \\<noteq> length ys\n  f ?p ?v ?m =\n  (case ?m of No_match \\<Rightarrow> No_match\n   | Match_type_error \\<Rightarrow> Match_type_error\n   | Match env \\<Rightarrow> cupcake_pmatch as_static_cenv ?p ?v env)\n\ngoal (1 subgoal):\n 1. \\<not> is_Match (Matching.fold2 f err xs ys init)", "by (induct f err xs ys init rule: fold2.induct) (auto split: match_result.splits)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> is_Match ?err4; length ?xs4 \\<noteq> length ?ys4\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_Match\n                            (Matching.fold2 f ?err4 ?xs4 ?ys4 ?init4)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "ultimately"], ["proof (chain)\npicking this:\n  length ps \\<noteq> length vs\n  \\<lbrakk>\\<not> is_Match ?err4; length ?xs4 \\<noteq> length ?ys4\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_Match\n                            (Matching.fold2 f ?err4 ?xs4 ?ys4 ?init4)", "have \"\\<not> is_Match ?fold\""], ["proof (prove)\nusing this:\n  length ps \\<noteq> length vs\n  \\<lbrakk>\\<not> is_Match ?err4; length ?xs4 \\<noteq> length ?ys4\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_Match\n                            (Matching.fold2 f ?err4 ?xs4 ?ys4 ?init4)\n\ngoal (1 subgoal):\n 1. \\<not> is_Match\n            (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n              (Match eenv))", "by simp"], ["proof (state)\nthis:\n  \\<not> is_Match\n          (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n            (Match eenv))\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "hence \"?fold = Match_type_error \\<or> ?fold = No_match\""], ["proof (prove)\nusing this:\n  \\<not> is_Match\n          (Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs\n            (Match eenv))\n\ngoal (1 subgoal):\n 1. Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n    Match_type_error \\<or>\n    Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n    No_match", "by (cases ?fold) auto"], ["proof (state)\nthis:\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  Match_type_error \\<or>\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  No_match\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "with *"], ["proof (chain)\npicking this:\n  length ps \\<noteq> length us\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  Match_type_error \\<or>\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  No_match", "have ?thesis"], ["proof (prove)\nusing this:\n  length ps \\<noteq> length us\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  Match_type_error \\<or>\n  Matching.fold2 f Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  No_match\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "unfolding \\<open>ml_v = _\\<close> \\<open>v0 = _\\<close> f_def"], ["proof (prove)\nusing this:\n  length ps \\<noteq> length us\n  Matching.fold2\n   (\\<lambda>p v m.\n       case m of No_match \\<Rightarrow> No_match\n       | Match_type_error \\<Rightarrow> Match_type_error\n       | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv p v x)\n   Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  Match_type_error \\<or>\n  Matching.fold2\n   (\\<lambda>p v m.\n       case m of No_match \\<Rightarrow> No_match\n       | Match_type_error \\<Rightarrow> Match_type_error\n       | Match x \\<Rightarrow> cupcake_pmatch as_static_cenv p v x)\n   Match_type_error (map mk_ml_pat ps) vs (Match eenv) =\n  No_match\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps))\n       (Conv (Some (as_string name', uu_)) vs) eenv)\n     (vmatch (Patconstr name ps) (Vconstr name' us))", "by (auto intro: match_result_related.intros split: option.splits)"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "}"], ["proof (state)\nthis:\n  length ps \\<noteq> length us \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (3 subgoals):\n 1. \\<And>us vs namea uu_.\n       \\<lbrakk>v0 = Vconstr namea us;\n        ml_v = Conv (Some (as_string namea, uu_)) vs;\n        list_all2 related_v us vs\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 3. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>name = name'; length ps = length us\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (cupcake_pmatch as_static_cenv\n                       (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                     (vmatch (Patconstr name ps) v0)\n  name \\<noteq> name' \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n  length ps \\<noteq> length us \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>name = name'; length ps = length us\\<rbrakk>\n  \\<Longrightarrow> match_result_related eenv\n                     (cupcake_pmatch as_static_cenv\n                       (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                     (vmatch (Patconstr name ps) v0)\n  name \\<noteq> name' \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n  length ps \\<noteq> length us \\<Longrightarrow>\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (1 subgoal):\n 1. match_result_related eenv\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v\n       eenv)\n     (vmatch (Patconstr name ps) v0)", "by auto"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env.\n       \\<lbrakk>v0 = Vabs cs \\<Gamma>; ml_v = Closure env (as_string n) e;\n        related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)\n 2. \\<And>css \\<Gamma> env exps namea.\n       \\<lbrakk>v0 = Vrecabs css namea \\<Gamma>;\n        ml_v = Recclosure env exps (as_string namea);\n        fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list\n           (map (map_prod Name (map_prod Name id)) exps))\\<rbrakk>\n       \\<Longrightarrow> match_result_related eenv\n                          (cupcake_pmatch as_static_cenv\n                            (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n                          (vmatch (Patconstr name ps) v0)", "qed (auto intro: match_result_related.intros)"], ["proof (state)\nthis:\n  match_result_related eenv\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (Patconstr name ps)) ml_v eenv)\n   (vmatch (Patconstr name ps) v0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_all_related:\n  assumes \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\"\n  assumes \"list_all (\\<lambda>(pat, _). linear pat) cs\"\n  assumes \"related_v v ml_v\"\n  assumes \"cupcake_match_result as_static_cenv ml_v ml_cs Bindv = Rval (ml_rhs, ml_pat, eenv)\"\n  obtains rhs pat \\<Gamma> where\n    \"ml_pat = mk_ml_pat (mk_pat pat)\"\n    \"related_exp rhs ml_rhs\"\n    \"vfind_match cs v = Some (\\<Gamma>, pat, rhs)\"\n    \"var_env \\<Gamma> eenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs \\<Gamma>.\n        \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n         vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n         var_env \\<Gamma> eenv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs\n  related_v v ml_v\n  cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs \\<Gamma>.\n        \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n         vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n         var_env \\<Gamma> eenv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction cs ml_cs arbitrary: thesis ml_pat ml_rhs rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons c cs ml_c ml_cs)"], ["proof (state)\nthis:\n  rel_prod related_pat related_exp c ml_c\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n              \\<lbrakk>related_pat pat ?ml_pat4; related_exp rhs ?ml_rhs4;\n               vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n               var_env \\<Gamma> eenv\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n    cs;\n   related_v v ml_v;\n   cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n   Rval (?ml_rhs4, ?ml_pat4, eenv)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>related_pat ?pat4 ml_pat; related_exp ?rhs4 ml_rhs;\n   vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4);\n   var_env ?\\<Gamma>4 eenv\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n  related_v v ml_v\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  rel_prod related_pat related_exp c ml_c\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n              \\<lbrakk>related_pat pat ?ml_pat4; related_exp rhs ?ml_rhs4;\n               vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n               var_env \\<Gamma> eenv\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n    cs;\n   related_v v ml_v;\n   cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n   Rval (?ml_rhs4, ?ml_pat4, eenv)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>related_pat ?pat4 ml_pat; related_exp ?rhs4 ml_rhs;\n   vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4);\n   var_env ?\\<Gamma>4 eenv\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n  related_v v ml_v\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain pat0 rhs0 where \"c = (pat0, rhs0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat0 rhs0.\n        c = (pat0, rhs0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c = (pat0, rhs0)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  c = (pat0, rhs0)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain ml_pat0 ml_rhs0 where \"ml_c = (ml_pat0, ml_rhs0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ml_pat0 ml_rhs0.\n        ml_c = (ml_pat0, ml_rhs0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ml_c = (ml_pat0, ml_rhs0)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  rel_prod related_pat related_exp c ml_c\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n              \\<lbrakk>related_pat pat ?ml_pat4; related_exp rhs ?ml_rhs4;\n               vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n               var_env \\<Gamma> eenv\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n    cs;\n   related_v v ml_v;\n   cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n   Rval (?ml_rhs4, ?ml_pat4, eenv)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>related_pat ?pat4 ml_pat; related_exp ?rhs4 ml_rhs;\n   vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4);\n   var_env ?\\<Gamma>4 eenv\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n  related_v v ml_v\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n  c = (pat0, rhs0)\n  ml_c = (ml_pat0, ml_rhs0)", "have \"ml_pat0 = mk_ml_pat (mk_pat pat0)\" \"related_exp rhs0 ml_rhs0\""], ["proof (prove)\nusing this:\n  rel_prod related_pat related_exp c ml_c\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n              \\<lbrakk>related_pat pat ?ml_pat4; related_exp rhs ?ml_rhs4;\n               vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n               var_env \\<Gamma> eenv\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n    cs;\n   related_v v ml_v;\n   cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n   Rval (?ml_rhs4, ?ml_pat4, eenv)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>related_pat ?pat4 ml_pat; related_exp ?rhs4 ml_rhs;\n   vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4);\n   var_env ?\\<Gamma>4 eenv\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n  related_v v ml_v\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n  c = (pat0, rhs0)\n  ml_c = (ml_pat0, ml_rhs0)\n\ngoal (1 subgoal):\n 1. related_pat pat0 ml_pat0 &&& related_exp rhs0 ml_rhs0", "by auto"], ["proof (state)\nthis:\n  related_pat pat0 ml_pat0\n  related_exp rhs0 ml_rhs0\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"linear pat0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pats.linear pat0", "using Cons(5)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. Pats.linear pat0", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   ((pat0, rhs0) # cs)\n\ngoal (1 subgoal):\n 1. Pats.linear pat0", "by simp+"], ["proof (state)\nthis:\n  Pats.linear pat0\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have rel: \"match_result_related [] (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v []) (vmatch (mk_pat pat0) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result_related []\n     (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n     (vmatch (mk_pat pat0) v)", "by (rule cupcake_pmatch_related) fact+"], ["proof (state)\nthis:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n\ngoal (2 subgoals):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs y ys thesis ml_pat ml_rhs.\n       \\<lbrakk>rel_prod related_pat related_exp x y;\n        list_all2 (rel_prod related_pat related_exp) xs ys;\n        \\<And>thesis ml_pat ml_rhs.\n           \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                       \\<lbrakk>related_pat pat ml_pat;\n                        related_exp rhs ml_rhs;\n                        vfind_match xs v = Some (\\<Gamma>, pat, rhs);\n                        var_env \\<Gamma> eenv\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all (\\<lambda>(pat, uu_). Pats.linear pat) xs;\n            related_v v ml_v;\n            cupcake_match_result as_static_cenv ml_v ys Bindv =\n            Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>pat rhs \\<Gamma>.\n           \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n            vfind_match (x # xs) v = Some (\\<Gamma>, pat, rhs);\n            var_env \\<Gamma> eenv\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) (x # xs);\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v (y # ys) Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"cupcake_pmatch as_static_cenv ml_pat0 ml_v []\")"], ["proof (state)\ngoal (3 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    Match_type_error \\<Longrightarrow>\n    thesis\n 3. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "case Match_type_error"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match_type_error\n\ngoal (3 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    Match_type_error \\<Longrightarrow>\n    thesis\n 3. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "hence False"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match_type_error\n\ngoal (1 subgoal):\n 1. False", "using Cons(7)"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match_type_error\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>ml_c = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match_type_error\n  cupcake_match_result as_static_cenv ml_v ((ml_pat0, ml_rhs0) # ml_cs)\n   Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (1 subgoal):\n 1. False", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    Match_type_error \\<Longrightarrow>\n    thesis\n 3. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "thus thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "case No_match"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = No_match\n\ngoal (2 subgoals):\n 1. cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n    No_match \\<Longrightarrow>\n    thesis\n 2. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule Cons(3))"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ?ml_pat4; related_exp rhs ?ml_rhs4;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v\n 4. cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n    Rval (?ml_rhs4, ?ml_pat4, eenv)", "show \"cupcake_match_result as_static_cenv ml_v ml_cs Bindv = Rval (ml_rhs, ml_pat, eenv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n    Rval (ml_rhs, ml_pat, eenv)", "using Cons(7) No_match"], ["proof (prove)\nusing this:\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = No_match\n\ngoal (1 subgoal):\n 1. cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n    Rval (ml_rhs, ml_pat, eenv)", "unfolding \\<open>ml_c = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_match_result as_static_cenv ml_v ((ml_pat0, ml_rhs0) # ml_cs)\n   Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = No_match\n\ngoal (1 subgoal):\n 1. cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n    Rval (ml_rhs, ml_pat, eenv)", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  cupcake_match_result as_static_cenv ml_v ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "fix pat rhs \\<Gamma>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "assume \"ml_pat = mk_ml_pat (mk_pat pat)\""], ["proof (state)\nthis:\n  related_pat pat ml_pat\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "assume \"related_exp rhs ml_rhs\""], ["proof (state)\nthis:\n  related_exp rhs ml_rhs\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "assume \"vfind_match cs v = Some (\\<Gamma>, pat, rhs)\""], ["proof (state)\nthis:\n  vfind_match cs v = Some (\\<Gamma>, pat, rhs)\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "assume \"var_env \\<Gamma> eenv\""], ["proof (state)\nthis:\n  var_env \\<Gamma> eenv\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "from rel"], ["proof (chain)\npicking this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)", "have \"match_result_related [] No_match (vmatch (mk_pat pat0) v)\""], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n\ngoal (1 subgoal):\n 1. match_result_related [] No_match (vmatch (mk_pat pat0) v)", "using No_match"], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = No_match\n\ngoal (1 subgoal):\n 1. match_result_related [] No_match (vmatch (mk_pat pat0) v)", "unfolding \\<open>ml_pat0 = _\\<close>"], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n  cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [] = No_match\n\ngoal (1 subgoal):\n 1. match_result_related [] No_match (vmatch (mk_pat pat0) v)", "by simp"], ["proof (state)\nthis:\n  match_result_related [] No_match (vmatch (mk_pat pat0) v)\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "hence \"vmatch (mk_pat pat0) v = None\""], ["proof (prove)\nusing this:\n  match_result_related [] No_match (vmatch (mk_pat pat0) v)\n\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat0) v = None", "by (cases rule: match_result_related.cases)"], ["proof (state)\nthis:\n  vmatch (mk_pat pat0) v = None\n\ngoal (3 subgoals):\n 1. \\<And>pat rhs \\<Gamma>.\n       \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n        vfind_match cs v = Some (\\<Gamma>, pat, rhs);\n        var_env \\<Gamma> eenv\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 3. related_v v ml_v", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule Cons(4))"], ["proof (state)\ngoal (4 subgoals):\n 1. related_pat ?pat4 ml_pat\n 2. related_exp ?rhs4 ml_rhs\n 3. vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4)\n 4. var_env ?\\<Gamma>4 eenv", "show \"vfind_match (c # cs) v = Some (\\<Gamma>, pat, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match (c # cs) v = Some (\\<Gamma>, pat, rhs)", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ((pat0, rhs0) # cs) v = Some (\\<Gamma>, pat, rhs)", "using \\<open>vfind_match cs v = _\\<close> \\<open>vmatch (mk_pat pat0) v = _\\<close>"], ["proof (prove)\nusing this:\n  vfind_match cs v = Some (\\<Gamma>, pat, rhs)\n  vmatch (mk_pat pat0) v = None\n\ngoal (1 subgoal):\n 1. vfind_match ((pat0, rhs0) # cs) v = Some (\\<Gamma>, pat, rhs)", "by simp"], ["proof (state)\nthis:\n  vfind_match (c # cs) v = Some (\\<Gamma>, pat, rhs)\n\ngoal (3 subgoals):\n 1. related_pat pat ml_pat\n 2. related_exp rhs ml_rhs\n 3. var_env \\<Gamma> eenv", "qed fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 2. related_v v ml_v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat) cs\n 2. related_v v ml_v", "show \"list_all (\\<lambda>(pat, _). linear pat) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs", "using Cons(5)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>a. case a of (pat, uu_) \\<Rightarrow> Pats.linear pat)\n   (c # cs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs\n\ngoal (1 subgoal):\n 1. related_v v ml_v", "qed fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "case (Match eenv')"], ["proof (state)\nthis:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match eenv'\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "hence \"ml_rhs = ml_rhs0\" \"ml_pat = ml_pat0\" \"eenv = eenv'\""], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match eenv'\n\ngoal (1 subgoal):\n 1. ml_rhs = ml_rhs0 &&& ml_pat = ml_pat0 &&& eenv = eenv'", "using Cons(7)"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match eenv'\n  cupcake_match_result as_static_cenv ml_v (ml_c # ml_cs) Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (1 subgoal):\n 1. ml_rhs = ml_rhs0 &&& ml_pat = ml_pat0 &&& eenv = eenv'", "unfolding \\<open>ml_c = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match eenv'\n  cupcake_match_result as_static_cenv ml_v ((ml_pat0, ml_rhs0) # ml_cs)\n   Bindv =\n  Rval (ml_rhs, ml_pat, eenv)\n\ngoal (1 subgoal):\n 1. ml_rhs = ml_rhs0 &&& ml_pat = ml_pat0 &&& eenv = eenv'", "by (simp split: if_splits)+"], ["proof (state)\nthis:\n  ml_rhs = ml_rhs0\n  ml_pat = ml_pat0\n  eenv = eenv'\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "from rel"], ["proof (chain)\npicking this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)", "have \"match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v) \""], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n\ngoal (1 subgoal):\n 1. match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)", "using Match"], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n  cupcake_pmatch as_static_cenv ml_pat0 ml_v [] = Match eenv'\n\ngoal (1 subgoal):\n 1. match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)", "unfolding \\<open>ml_pat0 = _\\<close>"], ["proof (prove)\nusing this:\n  match_result_related []\n   (cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [])\n   (vmatch (mk_pat pat0) v)\n  cupcake_pmatch as_static_cenv (mk_ml_pat (mk_pat pat0)) ml_v [] =\n  Match eenv'\n\ngoal (1 subgoal):\n 1. match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)", "by simp"], ["proof (state)\nthis:\n  match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "then"], ["proof (chain)\npicking this:\n  match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)", "obtain \\<Gamma> where \"vmatch (mk_pat pat0) v = Some \\<Gamma>\" \"var_env \\<Gamma> eenv'\""], ["proof (prove)\nusing this:\n  match_result_related [] (Match eenv') (vmatch (mk_pat pat0) v)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>.\n        \\<lbrakk>vmatch (mk_pat pat0) v = Some \\<Gamma>;\n         var_env \\<Gamma> eenv'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: match_result_related.cases) auto"], ["proof (state)\nthis:\n  vmatch (mk_pat pat0) v = Some \\<Gamma>\n  var_env \\<Gamma> eenv'\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch as_static_cenv ml_pat0 ml_v [] =\n       Match x3 \\<Longrightarrow>\n       thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule Cons(4))"], ["proof (state)\ngoal (4 subgoals):\n 1. related_pat ?pat4 ml_pat\n 2. related_exp ?rhs4 ml_rhs\n 3. vfind_match (c # cs) v = Some (?\\<Gamma>4, ?pat4, ?rhs4)\n 4. var_env ?\\<Gamma>4 eenv", "show \"ml_pat = mk_ml_pat (mk_pat pat0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_pat pat0 ml_pat", "unfolding \\<open>ml_pat = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_pat pat0 ml_pat0", "by fact"], ["proof (state)\nthis:\n  related_pat pat0 ml_pat\n\ngoal (3 subgoals):\n 1. related_exp ?rhs4 ml_rhs\n 2. vfind_match (c # cs) v = Some (?\\<Gamma>4, pat0, ?rhs4)\n 3. var_env ?\\<Gamma>4 eenv", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. related_exp ?rhs4 ml_rhs\n 2. vfind_match (c # cs) v = Some (?\\<Gamma>4, pat0, ?rhs4)\n 3. var_env ?\\<Gamma>4 eenv", "show \"related_exp rhs0 ml_rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp rhs0 ml_rhs", "unfolding \\<open>ml_rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp rhs0 ml_rhs0", "by fact"], ["proof (state)\nthis:\n  related_exp rhs0 ml_rhs\n\ngoal (2 subgoals):\n 1. vfind_match (c # cs) v = Some (?\\<Gamma>4, pat0, rhs0)\n 2. var_env ?\\<Gamma>4 eenv", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. vfind_match (c # cs) v = Some (?\\<Gamma>4, pat0, rhs0)\n 2. var_env ?\\<Gamma>4 eenv", "show \"var_env \\<Gamma> eenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_env \\<Gamma> eenv", "unfolding \\<open>eenv = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. var_env \\<Gamma> eenv'", "by fact"], ["proof (state)\nthis:\n  var_env \\<Gamma> eenv\n\ngoal (1 subgoal):\n 1. vfind_match (c # cs) v = Some (\\<Gamma>, pat0, rhs0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vfind_match (c # cs) v = Some (\\<Gamma>, pat0, rhs0)", "show \"vfind_match (c # cs) v = Some (\\<Gamma>, pat0, rhs0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match (c # cs) v = Some (\\<Gamma>, pat0, rhs0)", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ((pat0, rhs0) # cs) v = Some (\\<Gamma>, pat0, rhs0)", "using \\<open>vmatch (mk_pat pat0) v = Some \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat0) v = Some \\<Gamma>\n\ngoal (1 subgoal):\n 1. vfind_match ((pat0, rhs0) # cs) v = Some (\\<Gamma>, pat0, rhs0)", "by simp"], ["proof (state)\nthis:\n  vfind_match (c # cs) v = Some (\\<Gamma>, pat0, rhs0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>thesis ml_pat ml_rhs.\n       \\<lbrakk>\\<And>pat rhs \\<Gamma>.\n                   \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n                    vfind_match [] v = Some (\\<Gamma>, pat, rhs);\n                    var_env \\<Gamma> eenv\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all (\\<lambda>(pat, uu_). Pats.linear pat) [];\n        related_v v ml_v;\n        cupcake_match_result as_static_cenv ml_v [] Bindv =\n        Rval (ml_rhs, ml_pat, eenv)\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed simp"], ["", "end"], ["", "end"], ["", "end"]]}