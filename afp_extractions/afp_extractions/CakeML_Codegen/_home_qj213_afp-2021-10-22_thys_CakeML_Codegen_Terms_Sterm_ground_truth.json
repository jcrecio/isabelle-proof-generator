{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Terms/Sterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma sterm_induct[case_names Sconst Svar Sabs Sapp]:\n  assumes \"\\<And>x. P (Sconst x)\"\n  assumes \"\\<And>x. P (Svar x)\"\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) \\<in> set cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Sabs cs)\"\n  assumes \"\\<And>t u. P t \\<Longrightarrow> P u \\<Longrightarrow> P (t $\\<^sub>s u)\"\n  shows \"P t\"", "lemma abs_pred_stermI[intro]:\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) \\<in> set cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Sabs cs)\"\n  shows \"abs_pred P t\"", "lemma no_abs_abs[simp]: \"\\<not> no_abs (Sabs cs)\"", "lemma closed_except_simps:\n  \"closed_except (Svar x) S \\<longleftrightarrow> x |\\<in>| S\"\n  \"closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S \\<longleftrightarrow> closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S\"\n  \"closed_except (Sabs cs) S \\<longleftrightarrow> list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\"\n  \"closed_except (Sconst name) S \\<longleftrightarrow> True\"", "lemma closed_except_sabs:\n  assumes \"closed (Sabs cs)\" \"(pat, rhs) \\<in> set cs\"\n  shows \"closed_except rhs (frees pat)\"", "lemma match_sabs[simp]: \"\\<not> is_free t \\<Longrightarrow> match t (Sabs cs) = None\"", "lemma welldefined_sabs: \"welldefined (Sabs cs) \\<longleftrightarrow> list_all (\\<lambda>(_, t). welldefined t) cs\"", "lemma shadows_consts_sterm_simps[simp]:\n  \"shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) \\<longleftrightarrow> shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2\"\n  \"shadows_consts (Svar name) \\<longleftrightarrow> name |\\<in>| all_consts\"\n  \"shadows_consts (Sabs cs) \\<longleftrightarrow> list_ex (\\<lambda>(pat, t). \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t) cs\"\n  \"shadows_consts (Sconst name) \\<longleftrightarrow> False\"", "lemma subst_shadows:\n  assumes \"\\<not> shadows_consts (t::sterm)\" \"not_shadows_consts_env \\<Gamma>\"\n  shows \"\\<not> shadows_consts (subst t \\<Gamma>)\""], "translations": [["", "lemma sterm_induct[case_names Sconst Svar Sabs Sapp]:\n  assumes \"\\<And>x. P (Sconst x)\"\n  assumes \"\\<And>x. P (Svar x)\"\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) \\<in> set cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Sabs cs)\"\n  assumes \"\\<And>t u. P t \\<Longrightarrow> P u \\<Longrightarrow> P (t $\\<^sub>s u)\"\n  shows \"P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "using assms"], ["proof (prove)\nusing this:\n  P (Sconst ?x)\n  P (Svar ?x)\n  (\\<And>pat t.\n      (pat, t) \\<in> set ?cs \\<Longrightarrow> P t) \\<Longrightarrow>\n  P (Sabs ?cs)\n  \\<lbrakk>P ?t; P ?u\\<rbrakk> \\<Longrightarrow> P (?t $\\<^sub>s ?u)\n\ngoal (1 subgoal):\n 1. P t", "apply induction_schema"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>x__. t = Sconst x__ \\<Longrightarrow> P;\n        \\<And>x__. t = Svar x__ \\<Longrightarrow> P;\n        \\<And>cs__. t = Sabs cs__ \\<Longrightarrow> P;\n        \\<And>ta__ u__. t = ta__ $\\<^sub>s u__ \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. wf ?R2\n 3. \\<And>cs__ pat__ ta__.\n       (pat__, ta__) \\<in> set cs__ \\<Longrightarrow>\n       (ta__, Sabs cs__) \\<in> ?R2\n 4. \\<And>ta__ u__. (ta__, ta__ $\\<^sub>s u__) \\<in> ?R2\n 5. \\<And>ta__ u__. (u__, ta__ $\\<^sub>s u__) \\<in> ?R2", "apply pat_completeness"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf ?R2\n 2. \\<And>cs__ pat__ ta__.\n       (pat__, ta__) \\<in> set cs__ \\<Longrightarrow>\n       (ta__, Sabs cs__) \\<in> ?R2\n 3. \\<And>ta__ u__. (ta__, ta__ $\\<^sub>s u__) \\<in> ?R2\n 4. \\<And>ta__ u__. (u__, ta__ $\\<^sub>s u__) \\<in> ?R2", "apply lexicographic_order"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation sterm :: pre_term begin"], ["", "definition app_sterm where\n\"app_sterm t u = t $\\<^sub>s u\""], ["", "fun unapp_sterm where\n\"unapp_sterm (t $\\<^sub>s u) = Some (t, u)\" |\n\"unapp_sterm _ = None\""], ["", "definition const_sterm where\n\"const_sterm = Sconst\""], ["", "fun unconst_sterm where\n\"unconst_sterm (Sconst name) = Some name\" |\n\"unconst_sterm _ = None\""], ["", "fun unfree_sterm where\n\"unfree_sterm (Svar name) = Some name\" |\n\"unfree_sterm _ = None\""], ["", "definition free_sterm where\n\"free_sterm = Svar\""], ["", "fun frees_sterm where\n\"frees_sterm (Svar name) = {|name|}\" |\n\"frees_sterm (Sconst _) = {||}\" |\n\"frees_sterm (Sabs cs) = ffUnion (fset_of_list (map (\\<lambda>(pat, rhs). frees_sterm rhs - frees pat) cs))\" |\n\"frees_sterm (t $\\<^sub>s u) = frees_sterm t |\\<union>| frees_sterm u\""], ["", "fun subst_sterm where\n\"subst_sterm (Svar s) env = (case fmlookup env s of Some t \\<Rightarrow> t | None \\<Rightarrow> Svar s)\" |\n\"subst_sterm (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) env = subst_sterm t\\<^sub>1 env $\\<^sub>s subst_sterm t\\<^sub>2 env\" |\n\"subst_sterm (Sabs cs) env = Sabs (map (\\<lambda>(pat, rhs). (pat, subst_sterm rhs (fmdrop_fset (frees pat) env))) cs)\" |\n\"subst_sterm t env = t\""], ["", "fun consts_sterm :: \"sterm \\<Rightarrow> name fset\" where\n\"consts_sterm (Svar _) = {||}\" |\n\"consts_sterm (Sconst name) = {|name|}\" |\n\"consts_sterm (Sabs cs) = ffUnion (fset_of_list (map (\\<lambda>(_, rhs). consts_sterm rhs) cs))\" |\n\"consts_sterm (t $\\<^sub>s u) = consts_sterm t |\\<union>| consts_sterm u\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(sterm, pre_term_class)", "by standard\n   (auto\n      simp: app_sterm_def const_sterm_def free_sterm_def\n      elim: unapp_sterm.elims unconst_sterm.elims unfree_sterm.elims\n      split: option.splits)"], ["", "end"], ["", "instantiation sterm :: \"term\" begin"], ["", "definition abs_pred_sterm :: \"(sterm \\<Rightarrow> bool) \\<Rightarrow> sterm \\<Rightarrow> bool\" where\n[code del]: \"abs_pred P t \\<longleftrightarrow> (\\<forall>cs. t = Sabs cs \\<longrightarrow> (\\<forall>pat t. (pat, t) \\<in> set cs \\<longrightarrow> P t) \\<longrightarrow> P t)\""], ["", "lemma abs_pred_stermI[intro]:\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) \\<in> set cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Sabs cs)\"\n  shows \"abs_pred P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred P t", "using assms"], ["proof (prove)\nusing this:\n  (\\<And>pat t.\n      (pat, t) \\<in> set ?cs \\<Longrightarrow> P t) \\<Longrightarrow>\n  P (Sabs ?cs)\n\ngoal (1 subgoal):\n 1. abs_pred P t", "unfolding abs_pred_sterm_def"], ["proof (prove)\nusing this:\n  (\\<And>pat t.\n      (pat, t) \\<in> set ?cs \\<Longrightarrow> P t) \\<Longrightarrow>\n  P (Sabs ?cs)\n\ngoal (1 subgoal):\n 1. \\<forall>cs.\n       t = Sabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) \\<in> set cs \\<longrightarrow> P t) \\<longrightarrow>\n       P t", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(sterm, term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (1 P t)"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (1 subgoal):\n 1. P t", "by (induction t) (auto simp: const_sterm_def free_sterm_def app_sterm_def abs_pred_sterm_def)"], ["proof (state)\nthis:\n  P t\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (2 t)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n     t", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>env.\n              id_env env \\<longrightarrow>\n              subst t env = t) \\<Longrightarrow>\n       \\<forall>env.\n          id_env env \\<longrightarrow> subst (Sabs cs) env = Sabs cs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      id_env env \\<longrightarrow> subst t env = t;\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>(pat, rhs).\n                                 (pat,\n                                  subst rhs (fmdrop_fset (frees pat) env)))\n                          cs =\n                         cs", "apply (subst (3) list.map_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      id_env env \\<longrightarrow> subst t env = t;\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>(pat, rhs).\n                                 (pat,\n                                  subst rhs (fmdrop_fset (frees pat) env)))\n                          cs =\n                         map id cs", "apply (rule list.map_cong0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env z.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      id_env env \\<longrightarrow> subst t env = t;\n        id_env env; z \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> (case z of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs (fmdrop_fset (frees pat) env))) =\n                         id z", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      id_env env \\<longrightarrow> subst t env = t;\n        id_env env; (a, b) \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> subst b (fmdrop_fset (frees a) env) = b", "by blast"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t. \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n   t\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (3 x t)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         x |\\<notin>| frees t \\<longrightarrow>\n         (\\<forall>env. subst t (fmdrop x env) = subst t env))\n     t", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           x |\\<notin>| frees t \\<longrightarrow>\n           (\\<forall>env.\n               subst t (fmdrop x env) = subst t env)) \\<Longrightarrow>\n       x |\\<notin>| frees (Sabs cs) \\<longrightarrow>\n       (\\<forall>env. subst (Sabs cs) (fmdrop x env) = subst (Sabs cs) env)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   x |\\<notin>| frees t \\<longrightarrow>\n                   (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs);\n        (a, b) \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> subst b (fmdrop x (fmdrop_fset (frees a) env)) =\n                         subst b (fmdrop_fset (frees a) env)", "subgoal for cs env pat rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "apply (cases \"x |\\<in>| frees pat\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)\n 2. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs; x |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "apply (rule arg_cong[where f = \"subst rhs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fmdrop x (fmdrop_fset (frees pat) env) =\n                      fmdrop_fset (frees pat) env", "by (auto intro: fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs \\<Longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs);\n     (pat, rhs) \\<in> set cs; x |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "subgoal premises prems[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop_fset (frees pat) env)", "apply (subst (2) prems(1)[symmetric, where pat = pat])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (pat, rhs) \\<in> set cs\n 2. x |\\<notin>| frees rhs\n 3. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. x |\\<notin>| frees rhs\n 2. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs; x |\\<notin>| frees ?t\\<rbrakk>\n  \\<Longrightarrow> subst ?t (fmdrop x ?env) = subst ?t ?env\n  x |\\<notin>|\n  ffUnion\n   ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)\n  (pat, rhs) \\<in> set cs\n  x |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "unfolding ffUnion_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs; x |\\<notin>| frees ?t\\<rbrakk>\n  \\<Longrightarrow> subst ?t (fmdrop x ?env) = subst ?t ?env\n  \\<not> fBex\n          ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n           fset_of_list cs)\n          ((|\\<in>|) x)\n  (pat, rhs) \\<in> set cs\n  x |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "by (auto simp add: fmember.rep_eq fset_of_list.rep_eq elim!: fBallE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "apply (rule arg_cong[where f = \"subst rhs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdrop x (fmdrop_fset (frees pat) env) =\n    fmdrop x (fmdrop_fset (frees pat) env)", "by (auto intro: fmap_ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       x |\\<notin>| frees t \\<longrightarrow>\n       (\\<forall>env. subst t (fmdrop x env) = subst t env))\n   t\n\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (4 t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env\\<^sub>1 env\\<^sub>2.\n            closed_env env\\<^sub>2 \\<longrightarrow>\n            fdisjnt (fmdom env\\<^sub>1)\n             (fmdom env\\<^sub>2) \\<longrightarrow>\n            subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n            subst (subst t env\\<^sub>2) env\\<^sub>1)\n     t", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>env\\<^sub>1 env\\<^sub>2.\n              closed_env env\\<^sub>2 \\<longrightarrow>\n              fdisjnt (fmdom env\\<^sub>1)\n               (fmdom env\\<^sub>2) \\<longrightarrow>\n              subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n              subst (subst t env\\<^sub>2) env\\<^sub>1) \\<Longrightarrow>\n       \\<forall>env\\<^sub>1 env\\<^sub>2.\n          closed_env env\\<^sub>2 \\<longrightarrow>\n          fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2) \\<longrightarrow>\n          subst (Sabs cs) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n          subst (subst (Sabs cs) env\\<^sub>2) env\\<^sub>1", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env\\<^sub>1 env\\<^sub>2 a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env\\<^sub>1 env\\<^sub>2.\n                      closed_env env\\<^sub>2 \\<longrightarrow>\n                      fdisjnt (fmdom env\\<^sub>1)\n                       (fmdom env\\<^sub>2) \\<longrightarrow>\n                      subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                      subst (subst t env\\<^sub>2) env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n        (a, b) \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> subst b\n                          (fmdrop_fset (frees a) env\\<^sub>1 ++\\<^sub>f\n                           fmdrop_fset (frees a) env\\<^sub>2) =\n                         subst (subst b (fmdrop_fset (frees a) env\\<^sub>2))\n                          (fmdrop_fset (frees a) env\\<^sub>1)", "subgoal premises prems[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst b_\n     (fmdrop_fset (frees a_) env\\<^sub>1_ ++\\<^sub>f\n      fmdrop_fset (frees a_) env\\<^sub>2_) =\n    subst (subst b_ (fmdrop_fset (frees a_) env\\<^sub>2_))\n     (fmdrop_fset (frees a_) env\\<^sub>1_)", "apply (rule prems(1)[OF prems(4)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env (fmdrop_fset (frees a_) env\\<^sub>2_)\n 2. fdisjnt (fmdom (fmdrop_fset (frees a_) env\\<^sub>1_))\n     (fmdom (fmdrop_fset (frees a_) env\\<^sub>2_))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env (fmdrop_fset (frees a_) env\\<^sub>2_)", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs_; closed_env ?env\\<^sub>2;\n   fdisjnt (fmdom ?env\\<^sub>1) (fmdom ?env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> subst ?t (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2) =\n                    subst (subst ?t ?env\\<^sub>2) ?env\\<^sub>1\n  closed_env env\\<^sub>2_\n  fdisjnt (fmdom env\\<^sub>1_) (fmdom env\\<^sub>2_)\n  (a_, b_) \\<in> set cs_\n\ngoal (1 subgoal):\n 1. closed_env (fmdrop_fset (frees a_) env\\<^sub>2_)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fmdom (fmdrop_fset (frees a_) env\\<^sub>1_))\n     (fmdom (fmdrop_fset (frees a_) env\\<^sub>2_))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fmdom (fmdrop_fset (frees a_) env\\<^sub>1_))\n     (fmdom (fmdrop_fset (frees a_) env\\<^sub>2_))", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs_; closed_env ?env\\<^sub>2;\n   fdisjnt (fmdom ?env\\<^sub>1) (fmdom ?env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> subst ?t (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2) =\n                    subst (subst ?t ?env\\<^sub>2) ?env\\<^sub>1\n  closed_env env\\<^sub>2_\n  fdisjnt (fmdom env\\<^sub>1_) (fmdom env\\<^sub>2_)\n  (a_, b_) \\<in> set cs_\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom (fmdrop_fset (frees a_) env\\<^sub>1_))\n     (fmdom (fmdrop_fset (frees a_) env\\<^sub>2_))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs_; closed_env ?env\\<^sub>2;\n   fmdom ?env\\<^sub>1 |\\<inter>| fmdom ?env\\<^sub>2 = {||}\\<rbrakk>\n  \\<Longrightarrow> subst ?t (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2) =\n                    subst (subst ?t ?env\\<^sub>2) ?env\\<^sub>1\n  closed_env env\\<^sub>2_\n  fmdom env\\<^sub>1_ |\\<inter>| fmdom env\\<^sub>2_ = {||}\n  (a_, b_) \\<in> set cs_\n\ngoal (1 subgoal):\n 1. fmdom (fmdrop_fset (frees a_) env\\<^sub>1_) |\\<inter>|\n    fmdom (fmdrop_fset (frees a_) env\\<^sub>2_) =\n    {||}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       \\<forall>env\\<^sub>1 env\\<^sub>2.\n          closed_env env\\<^sub>2 \\<longrightarrow>\n          fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2) \\<longrightarrow>\n          subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n          subst (subst t env\\<^sub>2) env\\<^sub>1)\n   t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env.\n            closed_env env \\<longrightarrow>\n            frees (subst t env) = frees t |-| fmdom env)\n     t_", "proof (intro abs_pred_stermI allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      closed_env env \\<longrightarrow>\n                      frees (subst t env) = frees t |-| fmdom env;\n        closed_env env\\<rbrakk>\n       \\<Longrightarrow> frees (subst (Sabs cs) env) =\n                         frees (Sabs cs) |-| fmdom env", "case (1 cs env)"], ["proof (state)\nthis:\n  (?pat, ?t) \\<in> set cs \\<Longrightarrow>\n  \\<forall>env.\n     closed_env env \\<longrightarrow>\n     frees (subst ?t env) = frees ?t |-| fmdom env\n  closed_env env\n\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   \\<forall>env.\n                      closed_env env \\<longrightarrow>\n                      frees (subst t env) = frees t |-| fmdom env;\n        closed_env env\\<rbrakk>\n       \\<Longrightarrow> frees (subst (Sabs cs) env) =\n                         frees (Sabs cs) |-| fmdom env", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst (Sabs cs) env) = frees (Sabs cs) |-| fmdom env", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "fix name"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "assume \"name |\\<in>| frees (subst (Sabs cs) env)\""], ["proof (state)\nthis:\n  name |\\<in>| frees (subst (Sabs cs) env)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "then"], ["proof (chain)\npicking this:\n  name |\\<in>| frees (subst (Sabs cs) env)", "obtain pat rhs\n            where \"(pat, rhs) \\<in> set cs\"\n              and \"name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env))\"\n              and \"name |\\<notin>| frees pat\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees (subst (Sabs cs) env)\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        \\<lbrakk>(pat, rhs) \\<in> set cs;\n         name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env));\n         name |\\<notin>| frees pat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: fset_of_list_elem case_prod_twice comp_def ffUnion_alt_def)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env))\n  name |\\<notin>| frees pat\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "hence \"name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env))\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)", "using 1"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env))\n  name |\\<notin>| frees pat\n  (?pat, ?t) \\<in> set cs \\<Longrightarrow>\n  \\<forall>env.\n     closed_env env \\<longrightarrow>\n     frees (subst ?t env) = frees ?t |-| fmdom env\n  closed_env env\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)", "by (simp add: fmpred_drop_fset)"], ["proof (state)\nthis:\n  name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "hence \"name |\\<in>| frees rhs |-| frees pat\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees rhs |-| frees pat", "using \\<open>name |\\<notin>| frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees rhs |-| frees pat", "by blast"], ["proof (state)\nthis:\n  name |\\<in>| frees rhs |-| frees pat\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x |\\<in>| frees (subst (Sabs cs) env) \\<Longrightarrow>\n       x |\\<in>| frees (Sabs cs)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "show \"name |\\<in>| frees (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sabs cs)", "apply (simp add: ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fset_of_list cs)\n     (\\<lambda>x.\n         name |\\<in>|\n         (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>|\n    (case (pat, rhs) of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "unfolding prod.case"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>| frees rhs |-| frees pat\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply (fact \\<open>name |\\<in>| frees rhs |-| frees pat\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| fset_of_list cs", "unfolding fset_of_list_elem"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by fact"], ["proof (state)\nthis:\n  name |\\<in>| frees (Sabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "assume \"name |\\<in>| fmdom env\""], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (subst (Sabs cs) env);\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "thus False"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\n\ngoal (1 subgoal):\n 1. False", "using \\<open>name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\\<close> \\<open>name |\\<notin>| frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\n  name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env)\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "assume \"name |\\<in>| frees (Sabs cs)\" \"name |\\<notin>| fmdom env\""], ["proof (state)\nthis:\n  name |\\<in>| frees (Sabs cs)\n  name |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "then"], ["proof (chain)\npicking this:\n  name |\\<in>| frees (Sabs cs)\n  name |\\<notin>| fmdom env", "obtain pat rhs\n            where \"(pat, rhs) \\<in> set cs\" \"name |\\<in>| frees rhs\" \"name |\\<notin>| frees pat\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees (Sabs cs)\n  name |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        \\<lbrakk>(pat, rhs) \\<in> set cs; name |\\<in>| frees rhs;\n         name |\\<notin>| frees pat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: fset_of_list_elem ffUnion_alt_def)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "moreover"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "hence \"name |\\<in>| frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>|\n    frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat", "using \\<open>name |\\<notin>| fmdom env\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n  name |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. name |\\<in>|\n    frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat", "by fastforce"], ["proof (state)\nthis:\n  name |\\<in>|\n  frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "ultimately"], ["proof (chain)\npicking this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n  name |\\<in>|\n  frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat", "have \"name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n  name |\\<in>|\n  frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>|\n    frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat", "using 1"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  name |\\<in>| frees rhs\n  name |\\<notin>| frees pat\n  name |\\<in>|\n  frees rhs |-| fmdom (fmdrop_fset (frees pat) env) |-| frees pat\n  (?pat, ?t) \\<in> set cs \\<Longrightarrow>\n  \\<forall>env.\n     closed_env env \\<longrightarrow>\n     frees (subst ?t env) = frees ?t |-| fmdom env\n  closed_env env\n\ngoal (1 subgoal):\n 1. name |\\<in>|\n    frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat", "by (simp add: fmpred_drop_fset)"], ["proof (state)\nthis:\n  name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| frees (Sabs cs); x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees (subst (Sabs cs) env)", "show \"name |\\<in>| frees (subst (Sabs cs) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| frees (subst (Sabs cs) env)", "apply (simp add: case_prod_twice comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>|\n    ffUnion\n     ((\\<lambda>(pat, rhs).\n          frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat) |`|\n      fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex\n     ((\\<lambda>(pat, rhs).\n          frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat) |`|\n      fset_of_list cs)\n     ((|\\<in>|) name)", "apply (rule fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>| ?x\n 2. ?x |\\<in>|\n    (\\<lambda>(pat, rhs).\n        frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat) |`|\n    fset_of_list cs", "apply (fact \\<open>name |\\<in>| frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat |\\<in>|\n    (\\<lambda>(pat, rhs).\n        frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat) |`|\n    fset_of_list cs", "apply (subst fimage_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fset_of_list cs)\n     (\\<lambda>x.\n         frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat =\n         (case x of\n          (pat, rhs) \\<Rightarrow>\n            frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat =\n    (case (pat, rhs) of\n     (pat, rhs) \\<Rightarrow>\n       frees (subst rhs (fmdrop_fset (frees pat) env)) |-| frees pat)\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| fset_of_list cs", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| fset_of_list cs", "by (auto simp: fset_of_list_elem)"], ["proof (state)\nthis:\n  name |\\<in>| frees (subst (Sabs cs) env)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frees (subst (Sabs cs) env) = frees (Sabs cs) |-| fmdom env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       \\<forall>env.\n          closed_env env \\<longrightarrow>\n          frees (subst t env) = frees t |-| fmdom env)\n   t_\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         \\<forall>x.\n            consts (subst a x) =\n            consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n     t_", "proof (intro abs_pred_stermI allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "case (1 cs env)\n\n      \\<comment> \\<open>some property on various operations that is only useful in here\\<close>"], ["proof (state)\nthis:\n  (?pat, ?t) \\<in> set cs \\<Longrightarrow>\n  \\<forall>x.\n     consts (subst ?t x) =\n     consts ?t |\\<union>| ffUnion (consts |`| fmimage x (frees ?t))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have *: \"fbind (fmimage m (fbind A g)) f = fbind A (\\<lambda>x. fbind (fmimage m (g x)) f)\"\n        for m A f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fmimage m (fbind A g)) f =\n    fbind A (\\<lambda>x. fbind (fmimage m (g x)) f)", "including fset.lifting fmap.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fmimage m (fbind A g)) f =\n    fbind A (\\<lambda>x. fbind (fmimage m (g x)) f)", "by transfer' force"], ["proof (state)\nthis:\n  fbind (fmimage ?m1 (fbind ?A1 ?g1)) ?f1 =\n  fbind ?A1 (\\<lambda>x. fbind (fmimage ?m1 (?g1 x)) ?f1)\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have \"consts (subst (Sabs cs) env) = fbind (fset_of_list cs) (\\<lambda>(pat, rhs). consts rhs |\\<union>| ffUnion (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (Sabs cs) env) =\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         consts rhs |\\<union>|\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))", "apply (simp add: funion_image_bind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs)\n     ((\\<lambda>(uu_, y). consts y) \\<circ>\n      (\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env)))) =\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         consts rhs |\\<union>|\n         fbind (fmimage env (frees rhs |-| frees pat)) consts)", "apply (rule fbind_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ((\\<lambda>(uu_, y). consts y) \\<circ>\n        (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) env))))\n        x =\n       (case x of\n        (pat, rhs) \\<Rightarrow>\n          consts rhs |\\<union>|\n          fbind (fmimage env (frees rhs |-| frees pat)) consts)", "apply (clarsimp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       consts (subst x2 (fmdrop_fset (frees x1) env)) =\n       consts x2 |\\<union>|\n       fbind (fmimage env (frees x2 |-| frees x1)) consts", "apply (subst 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (x1, x2) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       (?pat14 x1 x2, x2) \\<in> set cs\n 2. \\<And>x1 x2.\n       (x1, x2) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       consts x2 |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees x1) env) (frees x2)) =\n       consts x2 |\\<union>|\n       fbind (fmimage env (frees x2 |-| frees x1)) consts", "apply (subst (asm) fset_of_list_elem, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       consts x2 |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees x1) env) (frees x2)) =\n       consts x2 |\\<union>|\n       fbind (fmimage env (frees x2 |-| frees x1)) consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       consts x2 |\\<union>|\n       ffUnion (consts |`| fmimage env (frees x2 |-| frees x1)) =\n       consts x2 |\\<union>|\n       fbind (fmimage env (frees x2 |-| frees x1)) consts", "by (simp add: funion_image_bind_eq)"], ["proof (state)\nthis:\n  consts (subst (Sabs cs) env) =\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       consts rhs |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "also"], ["proof (state)\nthis:\n  consts (subst (Sabs cs) env) =\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       consts rhs |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have \"\\<dots> = fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>| fbind (fset_of_list cs) (\\<lambda>(pat, rhs). ffUnion (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         consts rhs |\\<union>|\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n    fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))", "apply (subst fbind_fun_funion[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         consts rhs |\\<union>|\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n    fbind (fset_of_list cs)\n     (\\<lambda>x.\n         (consts \\<circ> snd) x |\\<union>|\n         (case x of\n          (pat, rhs) \\<Rightarrow>\n            ffUnion\n             (consts |`|\n              fmimage (fmdrop_fset (frees pat) env) (frees rhs))))", "apply (rule fbind_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       (case x of\n        (pat, rhs) \\<Rightarrow>\n          consts rhs |\\<union>|\n          ffUnion\n           (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n       (consts \\<circ> snd) x |\\<union>|\n       (case x of\n        (pat, rhs) \\<Rightarrow>\n          ffUnion\n           (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))", "by auto"], ["proof (state)\nthis:\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       consts rhs |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "also"], ["proof (state)\nthis:\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       consts rhs |\\<union>|\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have \"\\<dots> = consts (Sabs cs) |\\<union>| fbind (fset_of_list cs) (\\<lambda>(pat, rhs). ffUnion (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n    consts (Sabs cs) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))", "apply (rule cong[OF cong, OF refl _ refl, where f1 = \"funion\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs) (consts \\<circ> snd) = consts (Sabs cs)", "apply (subst funion_image_bind_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion ((consts \\<circ> snd) |`| fset_of_list cs) = consts (Sabs cs)", "unfolding consts_sterm.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion ((consts \\<circ> snd) |`| fset_of_list cs) =\n    ffUnion (fset_of_list (map (\\<lambda>(uu_, y). consts y) cs))", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consts \\<circ> snd) |`| fset_of_list cs =\n    fset_of_list (map (\\<lambda>(uu_, y). consts y) cs)", "apply (subst fset_of_list_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consts \\<circ> snd) |`| fset_of_list cs =\n    (\\<lambda>(uu_, y). consts y) |`| fset_of_list cs", "apply (rule fset.map_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> fset (fset_of_list cs) \\<Longrightarrow>\n       (consts \\<circ> snd) z = (case z of (uu_, x) \\<Rightarrow> consts x)", "by auto"], ["proof (state)\nthis:\n  fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  consts (Sabs cs) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "also"], ["proof (state)\nthis:\n  fbind (fset_of_list cs) (consts \\<circ> snd) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  consts (Sabs cs) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have \"\\<dots> = consts (Sabs cs) |\\<union>| fbind (fmimage env (fbind (fset_of_list cs) (\\<lambda>(pat, rhs). frees rhs |-| frees pat))) consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         ffUnion\n          (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n    consts (Sabs cs) |\\<union>|\n    fbind\n     (fmimage env\n       (fbind (fset_of_list cs)\n         (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n     consts", "apply (subst funion_image_bind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         fbind (fmimage (fmdrop_fset (frees pat) env) (frees rhs)) consts) =\n    consts (Sabs cs) |\\<union>|\n    fbind\n     (fmimage env\n       (fbind (fset_of_list cs)\n         (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n     consts", "apply (subst fmimage_drop_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<union>|\n    fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         fbind (fmimage env (frees rhs |-| frees pat)) consts) =\n    consts (Sabs cs) |\\<union>|\n    fbind\n     (fmimage env\n       (fbind (fset_of_list cs)\n         (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n     consts", "apply (rule cong[OF cong, OF refl refl, where f1 = \"funion\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         fbind (fmimage env (frees rhs |-| frees pat)) consts) =\n    fbind\n     (fmimage env\n       (fbind (fset_of_list cs)\n         (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n     consts", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbind (fset_of_list cs)\n     (\\<lambda>(pat, rhs).\n         fbind (fmimage env (frees rhs |-| frees pat)) consts) =\n    fbind (fset_of_list cs)\n     (\\<lambda>x.\n         fbind\n          (fmimage env\n            (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat))\n          consts)", "apply (rule fbind_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       (case x of\n        (pat, rhs) \\<Rightarrow>\n          fbind (fmimage env (frees rhs |-| frees pat)) consts) =\n       fbind\n        (fmimage env\n          (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat))\n        consts", "by auto"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  consts (Sabs cs) |\\<union>|\n  fbind\n   (fmimage env\n     (fbind (fset_of_list cs)\n       (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n   consts\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "also"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<union>|\n  fbind (fset_of_list cs)\n   (\\<lambda>(pat, rhs).\n       ffUnion\n        (consts |`| fmimage (fmdrop_fset (frees pat) env) (frees rhs))) =\n  consts (Sabs cs) |\\<union>|\n  fbind\n   (fmimage env\n     (fbind (fset_of_list cs)\n       (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n   consts\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "have \"\\<dots> = consts (Sabs cs) |\\<union>| ffUnion (consts |`| fmimage env (frees (Sabs cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<union>|\n    fbind\n     (fmimage env\n       (fbind (fset_of_list cs)\n         (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n     consts =\n    consts (Sabs cs) |\\<union>|\n    ffUnion (consts |`| fmimage env (frees (Sabs cs)))", "by (simp only: frees_sterm.simps fset_of_list_map  fmimage_Union funion_image_bind_eq)"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<union>|\n  fbind\n   (fmimage env\n     (fbind (fset_of_list cs)\n       (\\<lambda>(pat, rhs). frees rhs |-| frees pat)))\n   consts =\n  consts (Sabs cs) |\\<union>|\n  ffUnion (consts |`| fmimage env (frees (Sabs cs)))\n\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           \\<forall>x.\n              consts (subst t x) =\n              consts t |\\<union>|\n              ffUnion (consts |`| fmimage x (frees t))) \\<Longrightarrow>\n       consts (subst (Sabs cs) x) =\n       consts (Sabs cs) |\\<union>|\n       ffUnion (consts |`| fmimage x (frees (Sabs cs)))", "finally"], ["proof (chain)\npicking this:\n  consts (subst (Sabs cs) env) =\n  consts (Sabs cs) |\\<union>|\n  ffUnion (consts |`| fmimage env (frees (Sabs cs)))", "show ?case"], ["proof (prove)\nusing this:\n  consts (subst (Sabs cs) env) =\n  consts (Sabs cs) |\\<union>|\n  ffUnion (consts |`| fmimage env (frees (Sabs cs)))\n\ngoal (1 subgoal):\n 1. consts (subst (Sabs cs) env) =\n    consts (Sabs cs) |\\<union>|\n    ffUnion (consts |`| fmimage env (frees (Sabs cs)))", "."], ["proof (state)\nthis:\n  consts (subst (Sabs cs) env) =\n  consts (Sabs cs) |\\<union>|\n  ffUnion (consts |`| fmimage env (frees (Sabs cs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       \\<forall>x.\n          consts (subst a x) =\n          consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n   t_\n\ngoal (1 subgoal):\n 1. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "qed (auto simp: abs_pred_sterm_def)"], ["", "end"], ["", "lemma no_abs_abs[simp]: \"\\<not> no_abs (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_abs (Sabs cs)", "by (subst no_abs.simps) (auto simp: term_cases_def)"], ["", "lemma closed_except_simps:\n  \"closed_except (Svar x) S \\<longleftrightarrow> x |\\<in>| S\"\n  \"closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S \\<longleftrightarrow> closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S\"\n  \"closed_except (Sabs cs) S \\<longleftrightarrow> list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\"\n  \"closed_except (Sconst name) S \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (closed_except (Svar x) S = (x |\\<in>| S) &&&\n     closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S =\n     (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)) &&&\n    closed_except (Sabs cs) S =\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs &&&\n    closed_except (Sconst name) S = True", "proof goal_cases"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_except (Svar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Sabs cs) S =\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs\n 4. closed_except (Sconst name) S = True", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. closed_except (Svar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Sabs cs) S =\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs\n 4. closed_except (Sconst name) S = True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) S =\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_except (Sabs cs) S \\<Longrightarrow>\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs\n 2. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs \\<Longrightarrow>\n    closed_except (Sabs cs) S", "case 1"], ["proof (state)\nthis:\n  closed_except (Sabs cs) S\n\ngoal (2 subgoals):\n 1. closed_except (Sabs cs) S \\<Longrightarrow>\n    list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs\n 2. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs \\<Longrightarrow>\n    closed_except (Sabs cs) S", "then"], ["proof (chain)\npicking this:\n  closed_except (Sabs cs) S", "show ?case"], ["proof (prove)\nusing this:\n  closed_except (Sabs cs) S\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs", "apply (auto simp: list_all_iff ffUnion_alt_def fset_of_list_elem closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>ffUnion\n                 ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                  fset_of_list cs) |\\<subseteq>|\n                S;\n        (a, b) \\<in> set cs; x |\\<in>| frees b;\n        x |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (drule ffUnion_least_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) \\<in> set cs; x |\\<in>| frees b;\n        x |\\<notin>| frees a;\n        fBall\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs)\n         (\\<lambda>X. X |\\<subseteq>| S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) \\<in> set cs; x |\\<in>| frees b;\n        x |\\<notin>| frees a;\n        fBall (fset_of_list cs)\n         (\\<lambda>x.\n             (case x of\n              (pat, rhs) \\<Rightarrow>\n                frees rhs |-| frees pat) |\\<subseteq>|\n             S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "by (smt case_prod_conv fbspec fimageI fminusI fset_of_list_elem fset_rev_mp)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs \\<Longrightarrow>\n    closed_except (Sabs cs) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs \\<Longrightarrow>\n    closed_except (Sabs cs) S", "case 2"], ["proof (state)\nthis:\n  list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n     cs \\<Longrightarrow>\n    closed_except (Sabs cs) S", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) S", "by (fastforce simp: list_all_iff ffUnion_alt_def fset_of_list_elem closed_except_def)"], ["proof (state)\nthis:\n  closed_except (Sabs cs) S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_except (Sabs cs) S =\n  list_all (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) cs\n\ngoal (3 subgoals):\n 1. closed_except (Svar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Sconst name) S = True", "qed (auto simp: ffUnion_alt_def closed_except_def)"], ["", "lemma closed_except_sabs:\n  assumes \"closed (Sabs cs)\" \"(pat, rhs) \\<in> set cs\"\n  shows \"closed_except rhs (frees pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "using assms"], ["proof (prove)\nusing this:\n  closed (Sabs cs)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (Sabs cs) |\\<subseteq>| {||}\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ffUnion\n                 ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                  fset_of_list cs) =\n                {||};\n        (pat, rhs) \\<in> set cs; x |\\<in>| frees rhs\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat", "by (metis bot.extremum_uniqueI fempty_iff ffUnion_subset_elem fimageI fminusI fset_of_list_elem old.prod.case)"], ["", "instantiation sterm :: strong_term  begin"], ["", "fun wellformed_sterm :: \"sterm \\<Rightarrow> bool\" where\n\"wellformed_sterm (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) \\<longleftrightarrow> wellformed_sterm t\\<^sub>1 \\<and> wellformed_sterm t\\<^sub>2\" |\n\"wellformed_sterm (Sabs cs) \\<longleftrightarrow> list_all (\\<lambda>(pat, t). linear pat \\<and> wellformed_sterm t) cs \\<and> distinct (map fst cs) \\<and> cs \\<noteq> []\" |\n\"wellformed_sterm _ \\<longleftrightarrow> True\""], ["", "primrec all_frees_sterm :: \"sterm \\<Rightarrow> name fset\" where\n\"all_frees_sterm (Svar x) = {|x|}\" |\n\"all_frees_sterm (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) = all_frees_sterm t\\<^sub>1 |\\<union>| all_frees_sterm t\\<^sub>2\" |\n\"all_frees_sterm (Sabs cs) = ffUnion (fset_of_list (map (\\<lambda>(P, T). P |\\<union>| T) (map (map_prod frees all_frees_sterm) cs)))\" |\n\"all_frees_sterm (Sconst _) = {||}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(sterm, strong_term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case (7 t)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 8. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t", "apply (intro abs_pred_stermI allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           frees t |\\<subseteq>| all_frees t) \\<Longrightarrow>\n       frees (Sabs cs) |\\<subseteq>| all_frees (Sabs cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           frees t |\\<subseteq>| all_frees t) \\<Longrightarrow>\n       ffUnion\n        ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n         fset_of_list cs) |\\<subseteq>|\n       ffUnion\n        (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n          map_prod frees all_frees) |`|\n         fset_of_list cs)", "apply (rule ffUnion_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       (\\<And>pat t.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           frees t |\\<subseteq>| all_frees t) \\<Longrightarrow>\n       fBall\n        ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)\n        (\\<lambda>X.\n            X |\\<subseteq>|\n            ffUnion\n             (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n               map_prod frees all_frees) |`|\n              fset_of_list cs))", "apply (rule fBallI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs x.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        x |\\<in>|\n        (\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n        fset_of_list cs\\<rbrakk>\n       \\<Longrightarrow> x |\\<subseteq>|\n                         ffUnion\n                          (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n                            map_prod frees all_frees) |`|\n                           fset_of_list cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs a b xa.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        (a, b) |\\<in>| fset_of_list cs; xa |\\<in>| frees b;\n        xa |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> xa |\\<in>|\n                         ffUnion\n                          (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n                            map_prod frees all_frees) |`|\n                           fset_of_list cs)", "apply (subst ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs a b xa.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        (a, b) |\\<in>| fset_of_list cs; xa |\\<in>| frees b;\n        xa |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> fBex\n                          (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n                            map_prod frees all_frees) |`|\n                           fset_of_list cs)\n                          ((|\\<in>|) xa)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs a b xa.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        (a, b) |\\<in>| fset_of_list cs; xa |\\<in>| frees b;\n        xa |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> fBex (fset_of_list cs)\n                          (\\<lambda>x.\n                              xa |\\<in>|\n                              (case map_prod frees all_frees x of\n                               (x, xa) \\<Rightarrow> x |\\<union>| xa))", "apply (rule_tac x = \"(a, b)\" in fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs a b xa.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        (a, b) |\\<in>| fset_of_list cs; xa |\\<in>| frees b;\n        xa |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> xa |\\<in>|\n                         (case map_prod frees all_frees (a, b) of\n                          (x, xa) \\<Rightarrow> x |\\<union>| xa)\n 2. \\<And>cs a b xa.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   frees t |\\<subseteq>| all_frees t;\n        (a, b) |\\<in>| fset_of_list cs; xa |\\<in>| frees b;\n        xa |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> (a, b) |\\<in>| fset_of_list cs", "by (auto simp: fset_of_list_elem)"], ["proof (state)\nthis:\n  abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n\ngoal (7 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case (8 t)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2\n 7. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                 env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         pre_strong_term_class.wellformed t \\<longrightarrow>\n         (\\<forall>env.\n             fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n              env \\<longrightarrow>\n             pre_strong_term_class.wellformed (subst t env)))\n     t", "apply (intro abs_pred_stermI allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        pre_strong_term_class.wellformed (Sabs cs);\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst (Sabs cs) env)", "apply (simp add: list.pred_map comp_def case_prod_twice, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs;\n        distinct (map fst cs); cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>x.\n                              case x of\n                              (pat, rhs) \\<Rightarrow>\n                                linear pat \\<and>\n                                pre_strong_term_class.wellformed\n                                 (subst rhs (fmdrop_fset (frees pat) env)))\n                          cs\n 2. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs;\n        distinct (map fst cs); cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   fst (case x of\n  (pat, rhs) \\<Rightarrow> (pat, subst rhs (fmdrop_fset (frees pat) env))))\n                            cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                pre_strong_term_class.wellformed t \\<longrightarrow>\n                (\\<forall>env.\n                    fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                     env \\<longrightarrow>\n                    pre_strong_term_class.wellformed (subst t env));\n     fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n     list_all\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t)\n      cs_;\n     distinct (map fst cs_); cs_ \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>x.\n                           case x of\n                           (pat, rhs) \\<Rightarrow>\n                             linear pat \\<and>\n                             pre_strong_term_class.wellformed\n                              (subst rhs (fmdrop_fset (frees pat) env_)))\n                       cs_", "apply (subst list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                pre_strong_term_class.wellformed t \\<longrightarrow>\n                (\\<forall>env.\n                    fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                     env \\<longrightarrow>\n                    pre_strong_term_class.wellformed (subst t env));\n     fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n     list_all\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t)\n      cs_;\n     distinct (map fst cs_); cs_ \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(pat, rhs)\\<in>set cs_.\n                         linear pat \\<and>\n                         pre_strong_term_class.wellformed\n                          (subst rhs (fmdrop_fset (frees pat) env_))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs_;\n        distinct (map fst cs_); cs_ \\<noteq> []; x \\<in> set cs_\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (pat, rhs) \\<Rightarrow>\n                           linear pat \\<and>\n                           pre_strong_term_class.wellformed\n                            (subst rhs (fmdrop_fset (frees pat) env_))", "apply safe[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs_;\n        distinct (map fst cs_); cs_ \\<noteq> [];\n        (a, b) \\<in> set cs_\\<rbrakk>\n       \\<Longrightarrow> linear a\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs_;\n        distinct (map fst cs_); cs_ \\<noteq> [];\n        (a, b) \\<in> set cs_\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst b (fmdrop_fset (frees a) env_))", "apply (fastforce simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs_;\n        distinct (map fst cs_); cs_ \\<noteq> [];\n        (a, b) \\<in> set cs_\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed\n                          (subst b (fmdrop_fset (frees a) env_))", "subgoal premises prems[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (subst b_ (fmdrop_fset (frees a_) env_))", "apply (rule prems)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (?pat, b_) \\<in> set cs_\n 2. pre_strong_term_class.wellformed b_\n 3. fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n     (fmdrop_fset (frees a_) env_)", "apply (fact prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed b_\n 2. fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n     (fmdrop_fset (frees a_) env_)", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs_; pre_strong_term_class.wellformed ?t;\n   fmpred (\\<lambda>_. pre_strong_term_class.wellformed) ?env\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (subst ?t ?env)\n  fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_\n  list_all\n   (\\<lambda>(pat, t). linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs_\n  distinct (map fst cs_)\n  cs_ \\<noteq> []\n  (a_, b_) \\<in> set cs_\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed b_\n 2. fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n     (fmdrop_fset (frees a_) env_)", "apply (fastforce simp: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n     (fmdrop_fset (frees a_) env_)", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) \\<in> set cs_; pre_strong_term_class.wellformed ?t;\n   fmpred (\\<lambda>_. pre_strong_term_class.wellformed) ?env\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed (subst ?t ?env)\n  fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_\n  list_all\n   (\\<lambda>(pat, t). linear pat \\<and> pre_strong_term_class.wellformed t)\n   cs_\n  distinct (map fst cs_)\n  cs_ \\<noteq> []\n  (a_, b_) \\<in> set cs_\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n     (fmdrop_fset (frees a_) env_)", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs;\n        distinct (map fst cs); cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   fst (case x of\n  (pat, rhs) \\<Rightarrow> (pat, subst rhs (fmdrop_fset (frees pat) env))))\n                            cs)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                pre_strong_term_class.wellformed t \\<longrightarrow>\n                (\\<forall>env.\n                    fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                     env \\<longrightarrow>\n                    pre_strong_term_class.wellformed (subst t env));\n     fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n     list_all\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t)\n      cs_;\n     distinct (map fst cs_); cs_ \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (\\<lambda>x.\n                                fst (case x of\n                                     (pat, rhs) \\<Rightarrow>\n (pat, subst rhs (fmdrop_fset (frees pat) env_))))\n                         cs_)", "apply (subst map_cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>pat t.\n                   (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                   pre_strong_term_class.wellformed t \\<longrightarrow>\n                   (\\<forall>env.\n                       fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                        env \\<longrightarrow>\n                       pre_strong_term_class.wellformed (subst t env));\n        fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n        list_all\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t)\n         cs_;\n        distinct (map fst cs_); cs_ \\<noteq> []; x \\<in> set cs_\\<rbrakk>\n       \\<Longrightarrow> fst (case x of\n                              (pat, rhs) \\<Rightarrow>\n                                (pat,\n                                 subst rhs\n                                  (fmdrop_fset (frees pat) env_))) =\n                         ?g x\n 2. \\<lbrakk>\\<And>pat t.\n                (pat, t) \\<in> set cs_ \\<Longrightarrow>\n                pre_strong_term_class.wellformed t \\<longrightarrow>\n                (\\<forall>env.\n                    fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n                     env \\<longrightarrow>\n                    pre_strong_term_class.wellformed (subst t env));\n     fmpred (\\<lambda>_. pre_strong_term_class.wellformed) env_;\n     list_all\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t)\n      cs_;\n     distinct (map fst cs_); cs_ \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> distinct (map ?g cs_)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       pre_strong_term_class.wellformed t \\<longrightarrow>\n       (\\<forall>env.\n           fmpred (\\<lambda>_. pre_strong_term_class.wellformed)\n            env \\<longrightarrow>\n           pre_strong_term_class.wellformed (subst t env)))\n   t\n\ngoal (6 subgoals):\n 1. \\<And>name. pre_strong_term_class.wellformed (const name)\n 2. \\<And>name. pre_strong_term_class.wellformed (free name)\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       pre_strong_term_class.wellformed (app u\\<^sub>1 u\\<^sub>2) =\n       (pre_strong_term_class.wellformed u\\<^sub>1 \\<and>\n        pre_strong_term_class.wellformed u\\<^sub>2)\n 4. \\<And>name. all_frees (const name) = {||}\n 5. \\<And>name. all_frees (free name) = {|name|}\n 6. \\<And>u\\<^sub>1 u\\<^sub>2.\n       all_frees (app u\\<^sub>1 u\\<^sub>2) =\n       all_frees u\\<^sub>1 |\\<union>| all_frees u\\<^sub>2", "qed (auto simp: const_sterm_def free_sterm_def app_sterm_def)"], ["", "end"], ["", "lemma match_sabs[simp]: \"\\<not> is_free t \\<Longrightarrow> match t (Sabs cs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_free t \\<Longrightarrow> match t (Sabs cs) = None", "by (cases t) auto"], ["", "context pre_constants begin"], ["", "lemma welldefined_sabs: \"welldefined (Sabs cs) \\<longleftrightarrow> list_all (\\<lambda>(_, t). welldefined t) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (consts (Sabs cs) |\\<subseteq>| all_consts) =\n    list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs", "apply (auto simp: list_all_iff ffUnion_alt_def dest!: ffUnion_least_rev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>fBall (fset_of_list cs)\n                 (\\<lambda>x.\n                     (case x of\n                      (uu_, x) \\<Rightarrow> consts x) |\\<subseteq>|\n                     all_consts);\n        (a, b) \\<in> set cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| all_consts\n 2. \\<And>x a b.\n       \\<lbrakk>\\<forall>x\\<in>set cs.\n                   case x of\n                   (uu_, t) \\<Rightarrow> consts t |\\<subseteq>| all_consts;\n        (a, b) |\\<in>| fset_of_list cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| all_consts", "apply (subst (asm) list_all_iff_fset[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     (case x of\n                      (uu_, x) \\<Rightarrow> consts x) |\\<subseteq>|\n                     all_consts)\n                 cs;\n        (a, b) \\<in> set cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| all_consts\n 2. \\<And>x a b.\n       \\<lbrakk>\\<forall>x\\<in>set cs.\n                   case x of\n                   (uu_, t) \\<Rightarrow> consts t |\\<subseteq>| all_consts;\n        (a, b) |\\<in>| fset_of_list cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| all_consts", "apply (auto simp: list_all_iff fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma shadows_consts_sterm_simps[simp]:\n  \"shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) \\<longleftrightarrow> shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2\"\n  \"shadows_consts (Svar name) \\<longleftrightarrow> name |\\<in>| all_consts\"\n  \"shadows_consts (Sabs cs) \\<longleftrightarrow> list_ex (\\<lambda>(pat, t). \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t) cs\"\n  \"shadows_consts (Sconst name) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) =\n     (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2) &&&\n     shadows_consts (Svar name) = (name |\\<in>| all_consts)) &&&\n    shadows_consts (Sabs cs) =\n    list_ex\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t)\n     cs &&&\n    shadows_consts (Sconst name) = False", "proof (goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Svar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Sabs cs) =\n    list_ex\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t)\n     cs\n 4. shadows_consts (Sconst name) = False", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Svar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Sabs cs) =\n    list_ex\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t)\n     cs\n 4. shadows_consts (Sconst name) = False", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadows_consts (Sabs cs) =\n    list_ex\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t)\n     cs", "unfolding shadows_consts_def list_ex_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> fdisjnt all_consts (all_frees (Sabs cs))) =\n    (\\<exists>(pat, t)\\<in>set cs.\n        \\<not> fdisjnt all_consts (frees pat) \\<or>\n        \\<not> fdisjnt all_consts (all_frees t))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> fdisjnt all_consts (all_frees (Sabs cs)) \\<Longrightarrow>\n    \\<exists>(pat, t)\\<in>set cs.\n       \\<not> fdisjnt all_consts (frees pat) \\<or>\n       \\<not> fdisjnt all_consts (all_frees t)\n 2. \\<exists>(pat, t)\\<in>set cs.\n       \\<not> fdisjnt all_consts (frees pat) \\<or>\n       \\<not> fdisjnt all_consts (all_frees t) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Sabs cs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> fdisjnt all_consts (all_frees (Sabs cs)) \\<Longrightarrow>\n    \\<exists>(pat, t)\\<in>set cs.\n       \\<not> fdisjnt all_consts (frees pat) \\<or>\n       \\<not> fdisjnt all_consts (all_frees t)", "by (force simp: ffUnion_alt_def fset_of_list_elem fdisjnt_alt_def elim!: ballE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(pat, t)\\<in>set cs.\n       \\<not> fdisjnt all_consts (frees pat) \\<or>\n       \\<not> fdisjnt all_consts (all_frees t) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Sabs cs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(pat, t)\\<in>set cs.\n       \\<not> fdisjnt all_consts (frees pat) \\<or>\n       \\<not> fdisjnt all_consts (all_frees t) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Sabs cs))", "apply (auto simp: fset_of_list_elem fdisjnt_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) \\<in> set cs;\n        all_consts |\\<inter>|\n        ffUnion\n         (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n           map_prod frees all_frees) |`|\n          fset_of_list cs) =\n        {||};\n        x |\\<in>| all_consts; x |\\<in>| frees a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b x.\n       \\<lbrakk>(a, b) \\<in> set cs;\n        all_consts |\\<inter>|\n        ffUnion\n         (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n           map_prod frees all_frees) |`|\n          fset_of_list cs) =\n        {||};\n        x |\\<in>| all_consts; x |\\<in>| all_frees b\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp: fset_eq_empty_iff ffUnion_alt_def fset_of_list_elem elim!: allE fBallE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  shadows_consts (Sabs cs) =\n  list_ex\n   (\\<lambda>(pat, t).\n       \\<not> fdisjnt all_consts (frees pat) \\<or> shadows_consts t)\n   cs\n\ngoal (3 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Svar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Sconst name) = False", "qed (auto simp: shadows_consts_def fdisjnt_alt_def)"], ["", "(* FIXME derive from axioms? *)"], ["", "lemma subst_shadows:\n  assumes \"\\<not> shadows_consts (t::sterm)\" \"not_shadows_consts_env \\<Gamma>\"\n  shows \"\\<not> shadows_consts (subst t \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (subst t \\<Gamma>)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts t\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (subst t \\<Gamma>)", "proof (induction t arbitrary: \\<Gamma> rule: sterm_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Sconst x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Sconst x) \\<Gamma>)\n 2. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Svar x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Svar x) \\<Gamma>)\n 3. \\<And>cs \\<Gamma>.\n       \\<lbrakk>\\<And>pat t \\<Gamma>.\n                   \\<lbrakk>(pat, t) \\<in> set cs; \\<not> shadows_consts t;\n                    not_shadows_consts_env \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (subst t \\<Gamma>);\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Sabs cs) \\<Gamma>)\n 4. \\<And>t u \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   \\<lbrakk>\\<not> shadows_consts t;\n                    not_shadows_consts_env \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (subst t \\<Gamma>);\n        \\<And>\\<Gamma>.\n           \\<lbrakk>\\<not> shadows_consts u;\n            not_shadows_consts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> shadows_consts (subst u \\<Gamma>);\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (subst (t $\\<^sub>s u) \\<Gamma>)", "case (Sabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?pat3, ?t3) \\<in> set cs; \\<not> shadows_consts ?t3;\n   not_shadows_consts_env ?\\<Gamma>3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts (subst ?t3 ?\\<Gamma>3)\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_consts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Sconst x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Sconst x) \\<Gamma>)\n 2. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Svar x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Svar x) \\<Gamma>)\n 3. \\<And>cs \\<Gamma>.\n       \\<lbrakk>\\<And>pat t \\<Gamma>.\n                   \\<lbrakk>(pat, t) \\<in> set cs; \\<not> shadows_consts t;\n                    not_shadows_consts_env \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (subst t \\<Gamma>);\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Sabs cs) \\<Gamma>)\n 4. \\<And>t u \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   \\<lbrakk>\\<not> shadows_consts t;\n                    not_shadows_consts_env \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (subst t \\<Gamma>);\n        \\<And>\\<Gamma>.\n           \\<lbrakk>\\<not> shadows_consts u;\n            not_shadows_consts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> shadows_consts (subst u \\<Gamma>);\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (subst (t $\\<^sub>s u) \\<Gamma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (subst (Sabs cs) \\<Gamma>)", "apply (simp add: list_ex_iff case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set cs.\n       \\<not> (case x of\n               (pat, rhs) \\<Rightarrow>\n                 fdisjnt all_consts (frees pat) \\<longrightarrow>\n                 shadows_consts\n                  (subst rhs (fmdrop_fset (frees pat) \\<Gamma>)))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set cs \\<Longrightarrow>\n       \\<not> (case x of\n               (pat, rhs) \\<Rightarrow>\n                 fdisjnt all_consts (frees pat) \\<longrightarrow>\n                 shadows_consts\n                  (subst rhs (fmdrop_fset (frees pat) \\<Gamma>)))", "subgoal for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> set cs \\<Longrightarrow>\n    \\<not> (case c of\n            (pat, rhs) \\<Rightarrow>\n              fdisjnt all_consts (frees pat) \\<longrightarrow>\n              shadows_consts (subst rhs (fmdrop_fset (frees pat) \\<Gamma>)))", "apply (cases c, hypsubst_thin, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       fdisjnt all_consts (frees a) \\<and>\n       \\<not> shadows_consts (subst b (fmdrop_fset (frees a) \\<Gamma>))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow> fdisjnt all_consts (frees a)\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       \\<not> shadows_consts (subst b (fmdrop_fset (frees a) \\<Gamma>))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow> fdisjnt all_consts (frees a_)", "using Sabs(2)"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow> fdisjnt all_consts (frees a_)", "by (fastforce simp: list_ex_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       \\<not> shadows_consts (subst b (fmdrop_fset (frees a) \\<Gamma>))", "apply (rule Sabs(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow> (?pat10 a b, b) \\<in> set cs\n 2. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> \\<not> shadows_consts b\n 3. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       not_shadows_consts_env (fmdrop_fset (frees a) \\<Gamma>)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<in> set cs \\<Longrightarrow> \\<not> shadows_consts b\n 2. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       not_shadows_consts_env (fmdrop_fset (frees a) \\<Gamma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow> \\<not> shadows_consts b_", "using Sabs(2)"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow> \\<not> shadows_consts b_", "by (fastforce simp: list_ex_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       not_shadows_consts_env (fmdrop_fset (frees a) \\<Gamma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    not_shadows_consts_env (fmdrop_fset (frees a_) \\<Gamma>)", "using Sabs(3)"], ["proof (prove)\nusing this:\n  not_shadows_consts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set cs \\<Longrightarrow>\n    not_shadows_consts_env (fmdrop_fset (frees a_) \\<Gamma>)", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> shadows_consts (subst (Sabs cs) \\<Gamma>)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Sconst x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Sconst x) \\<Gamma>)\n 2. \\<And>x \\<Gamma>.\n       \\<lbrakk>\\<not> shadows_consts (Svar x);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts (subst (Svar x) \\<Gamma>)\n 3. \\<And>t u \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   \\<lbrakk>\\<not> shadows_consts t;\n                    not_shadows_consts_env \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> shadows_consts\n       (subst t \\<Gamma>);\n        \\<And>\\<Gamma>.\n           \\<lbrakk>\\<not> shadows_consts u;\n            not_shadows_consts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> shadows_consts (subst u \\<Gamma>);\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_consts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts\n                                 (subst (t $\\<^sub>s u) \\<Gamma>)", "qed (auto split: option.splits)"], ["", "end"], ["", "end"]]}