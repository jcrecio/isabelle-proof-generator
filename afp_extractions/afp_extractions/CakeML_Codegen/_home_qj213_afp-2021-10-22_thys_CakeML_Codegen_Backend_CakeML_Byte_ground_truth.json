{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Backend/CakeML_Byte.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma cake_plus_correct:\n  assumes \"evaluate env s u = (s', Rval (Litv (IntLit y)))\"\n  assumes \"evaluate env s' t = (s'', Rval (Litv (IntLit x)))\"\n  shows \"evaluate env s (cake_plus t u) = (s'', Rval (Litv (IntLit (x + y))))\"", "lemma cake_times_correct:\n  assumes \"evaluate env s u = (s', Rval (Litv (IntLit y)))\"\n  assumes \"evaluate env s' t = (s'', Rval (Litv (IntLit x)))\"\n  shows \"evaluate env s (cake_times t u) = (s'', Rval (Litv (IntLit (x * y))))\""], "translations": [["", "lemma cake_plus_correct:\n  assumes \"evaluate env s u = (s', Rval (Litv (IntLit y)))\"\n  assumes \"evaluate env s' t = (s'', Rval (Litv (IntLit x)))\"\n  shows \"evaluate env s (cake_plus t u) = (s'', Rval (Litv (IntLit (x + y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (cake_plus t u) =\n    (s'', Rval (Litv (IntLit (x + y))))", "unfolding cake_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (App (Opn Plus) [t, u]) =\n    (s'', Rval (Litv (IntLit (x + y))))", "using assms"], ["proof (prove)\nusing this:\n  Evaluate_Single.evaluate env s u = (s', Rval (Litv (IntLit y)))\n  Evaluate_Single.evaluate env s' t = (s'', Rval (Litv (IntLit x)))\n\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (App (Opn Plus) [t, u]) =\n    (s'', Rval (Litv (IntLit (x + y))))", "by simp"], ["", "definition cake_times :: \"exp \\<Rightarrow> exp \\<Rightarrow> exp\" where\n\"cake_times t u = Ast.App (Ast.Opn Ast.Times) [t, u]\""], ["", "lemma cake_times_correct:\n  assumes \"evaluate env s u = (s', Rval (Litv (IntLit y)))\"\n  assumes \"evaluate env s' t = (s'', Rval (Litv (IntLit x)))\"\n  shows \"evaluate env s (cake_times t u) = (s'', Rval (Litv (IntLit (x * y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (cake_times t u) =\n    (s'', Rval (Litv (IntLit (x * y))))", "unfolding cake_times_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (App (Opn Times) [t, u]) =\n    (s'', Rval (Litv (IntLit (x * y))))", "using assms"], ["proof (prove)\nusing this:\n  Evaluate_Single.evaluate env s u = (s', Rval (Litv (IntLit y)))\n  Evaluate_Single.evaluate env s' t = (s'', Rval (Litv (IntLit x)))\n\ngoal (1 subgoal):\n 1. Evaluate_Single.evaluate env s (App (Opn Times) [t, u]) =\n    (s'', Rval (Litv (IntLit (x * y))))", "by simp"], ["", "definition cake_int_of_bool :: \"exp \\<Rightarrow> exp\" where\n\"cake_int_of_bool e = Ast.Mat e\n  [(Ast.Pcon (Some (Short ''HOL_False'')) [], Lit (IntLit 0)),\n   (Ast.Pcon (Some (Short ''HOL_True'')) [], Lit (IntLit 1))]\""], ["", "definition summands :: \"exp list\" where\n\"summands = map (\\<lambda>n. cake_times (Lit (IntLit (2 ^ n))) (cake_int_of_bool (Ast.Var (Short (''b'' @ show n))))) [0..<8]\""], ["", "definition cake_int_of_byte :: \"exp\" where\n\"cake_int_of_byte =\n  Ast.Fun ''x'' (Ast.Mat (Ast.Var (Short ''x'')) [(pat, foldl cake_plus (Lit (IntLit 0)) summands)])\""], ["", "end"]]}