{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Big_Step_Value_ML.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma veval'_sabs_svarE:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar n \\<down> v\"\n  obtains u' env pat rhs\n    where \"fmlookup \\<Gamma> n = Some u'\"\n          \"vfind_match cs u' = Some (env, pat, rhs)\"\n          \"\\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\"", "lemma veval'_wellformed:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  shows \"vwellformed v\"", "lemma (in constants) veval'_shadows:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"not_shadows_vconsts_env \\<Gamma>\" \"\\<not> shadows_consts t\"\n  shows \"not_shadows_vconsts v\"", "lemma veval'_closed:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"closed_except t (fmdom \\<Gamma>)\" \"closed_venv \\<Gamma>\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  shows \"vclosed v\"", "lemma vmatch_welldefined':\n  assumes \"vmatch pat v = Some env\" \"vwelldefined' v\"\n  shows \"fmpred (\\<lambda>_. vwelldefined') env\"", "lemma sconsts_list_comb:\n   \"consts (list_comb f xs) |\\<subseteq>| S \\<longleftrightarrow> consts f |\\<subseteq>| S \\<and> list_all (\\<lambda>x. consts x |\\<subseteq>| S) xs\"", "lemma sconsts_sabs:\n  \"consts (Sabs cs) |\\<subseteq>| S \\<longleftrightarrow> list_all (\\<lambda>(_, t). consts t |\\<subseteq>| S) cs\"", "lemma (in constants) veval'_welldefined':\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  shows \"vwelldefined' v\"", "lemma veval'_correct:\n  assumes \"\\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>2\" \"wellformed t\" \"wellformed_venv \\<Gamma>\\<^sub>2\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\\<^sub>2\"\n  assumes \"welldefined t\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\"\n  assumes \"fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\"\n  assumes \"fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\"\n  obtains v\\<^sub>1 where \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\" \"\\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\"", "lemma veval'_correct':\n  assumes \"\\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>2\" \"wellformed t\" \"wellformed_venv \\<Gamma>\\<^sub>2\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\\<^sub>2\"\n  assumes \"welldefined t\"\n  assumes \"closed t\"\n  assumes \"fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\"\n  obtains v\\<^sub>1 where \"rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\" \"\\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\"", "lemma (in constants) veval'_agree_eq:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\" \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  obtains v' where \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v'\" \"v' \\<approx>\\<^sub>e v\""], "translations": [["", "lemma veval'_sabs_svarE:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar n \\<down> v\"\n  obtains u' env pat rhs\n    where \"fmlookup \\<Gamma> n = Some u'\"\n          \"vfind_match cs u' = Some (env, pat, rhs)\"\n          \"\\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' env pat rhs.\n        \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n         vfind_match cs u' = Some (env, pat, rhs);\n         \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar n \\<down> v\n\ngoal (1 subgoal):\n 1. (\\<And>u' env pat rhs.\n        \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n         vfind_match cs u' = Some (env, pat, rhs);\n         \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name ts us.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Sabs cs $\\<^sub>s Svar n = name $$ ts; v = Vconstr name us;\n        name |\\<in>| C; list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (constr name ts)"], ["proof (state)\nthis:\n  Sabs cs $\\<^sub>s Svar n = name $$ ts\n  v = Vconstr name us_\n  name |\\<in>| C\n  list_all2 (veval' \\<Gamma>) ts us_\n\ngoal (3 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name ts us.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Sabs cs $\\<^sub>s Svar n = name $$ ts; v = Vconstr name us;\n        name |\\<in>| C; list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"strip_comb (Sabs cs $\\<^sub>s Svar n) = strip_comb (name $$ ts)\""], ["proof (prove)\nusing this:\n  Sabs cs $\\<^sub>s Svar n = name $$ ts\n  v = Vconstr name us_\n  name |\\<in>| C\n  list_all2 (veval' \\<Gamma>) ts us_\n\ngoal (1 subgoal):\n 1. strip_comb (Sabs cs $\\<^sub>s Svar n) = strip_comb (name $$ ts)", "by simp"], ["proof (state)\nthis:\n  strip_comb (Sabs cs $\\<^sub>s Svar n) = strip_comb (name $$ ts)\n\ngoal (3 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name ts us.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Sabs cs $\\<^sub>s Svar n = name $$ ts; v = Vconstr name us;\n        name |\\<in>| C; list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence False"], ["proof (prove)\nusing this:\n  strip_comb (Sabs cs $\\<^sub>s Svar n) = strip_comb (name $$ ts)\n\ngoal (1 subgoal):\n 1. False", "apply (fold app_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (app (Sabs cs) (Svar n)) =\n    strip_comb (name $$ ts) \\<Longrightarrow>\n    False", "apply (simp add: strip_list_comb_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sabs cs = const name \\<and> [Svar n] = ts \\<Longrightarrow> False", "apply (simp add: const_sterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name ts us.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Sabs cs $\\<^sub>s Svar n = name $$ ts; v = Vconstr name us;\n        name |\\<in>| C; list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "case rec_comb"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n  Vrecabs css_ name_ \\<Gamma>'_\n  fmlookup css_ name_ = Some cs_\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uv_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f mk_rec_env css_ \\<Gamma>'_ ++\\<^sub>f env_\n  \\<turnstile>\\<^sub>v rhs_ \\<down> v\n\ngoal (2 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence False"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n  Vrecabs css_ name_ \\<Gamma>'_\n  fmlookup css_ name_ = Some cs_\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uv_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f mk_rec_env css_ \\<Gamma>'_ ++\\<^sub>f env_\n  \\<turnstile>\\<^sub>v rhs_ \\<down> v\n\ngoal (1 subgoal):\n 1. False", "by cases"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>css name \\<Gamma>' csa u' env uv_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down>\n        Vrecabs css name \\<Gamma>';\n        fmlookup css name = Some csa;\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (comb cs' \\<Gamma>' u' env pat rhs)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n  vfind_match cs' u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n  vfind_match cs' u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmlookup \\<Gamma> n = Some u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> n = Some u'", "using \\<open>\\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> n = Some u'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma> n = Some u' \\<Longrightarrow>\n    fmlookup \\<Gamma> n = Some u'\n 2. \\<And>name ts us.\n       \\<lbrakk>Svar n = name $$ ts; u' = Vconstr name us; name |\\<in>| C;\n        list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> fmlookup \\<Gamma> n = Some u'", "case (constr name ts)"], ["proof (state)\nthis:\n  Svar n = name $$ ts\n  u' = Vconstr name us_\n  name |\\<in>| C\n  list_all2 (veval' \\<Gamma>) ts us_\n\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma> n = Some u' \\<Longrightarrow>\n    fmlookup \\<Gamma> n = Some u'\n 2. \\<And>name ts us.\n       \\<lbrakk>Svar n = name $$ ts; u' = Vconstr name us; name |\\<in>| C;\n        list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> fmlookup \\<Gamma> n = Some u'", "hence False"], ["proof (prove)\nusing this:\n  Svar n = name $$ ts\n  u' = Vconstr name us_\n  name |\\<in>| C\n  list_all2 (veval' \\<Gamma>) ts us_\n\ngoal (1 subgoal):\n 1. False", "by (fold free_sterm_def) simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma> n = Some u' \\<Longrightarrow>\n    fmlookup \\<Gamma> n = Some u'\n 2. \\<And>name ts us.\n       \\<lbrakk>Svar n = name $$ ts; u' = Vconstr name us; name |\\<in>| C;\n        list_all2 (veval' \\<Gamma>) ts us\\<rbrakk>\n       \\<Longrightarrow> fmlookup \\<Gamma> n = Some u'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> n = Some u'", "by simp"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> n = Some u'\n\ngoal (1 subgoal):\n 1. fmlookup \\<Gamma> n = Some u' \\<Longrightarrow>\n    fmlookup \\<Gamma> n = Some u'", "qed auto"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> n = Some u'\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> n = Some u'\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"cs = cs'\" \"\\<Gamma> = \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = cs' &&& \\<Gamma> = \\<Gamma>'", "using \\<open>\\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n\ngoal (1 subgoal):\n 1. cs = cs' &&& \\<Gamma> = \\<Gamma>'", "by (cases; auto)+"], ["proof (state)\nthis:\n  cs = cs'\n  \\<Gamma> = \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>csa \\<Gamma>' u' env uu_ rhs.\n       \\<lbrakk>\\<And>u' env pat rhs.\n                   \\<lbrakk>fmlookup \\<Gamma> n = Some u';\n                    vfind_match cs u' = Some (env, pat, rhs);\n                    \\<Gamma> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n                    v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs csa \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u';\n        vfind_match csa u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n  vfind_match cs' u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\n  fmlookup \\<Gamma> n = Some u'\n  cs = cs'\n  \\<Gamma> = \\<Gamma>'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n  vfind_match cs' u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\n  fmlookup \\<Gamma> n = Some u'\n  cs = cs'\n  \\<Gamma> = \\<Gamma>'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs cs' \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v Svar n \\<down> u'\n  vfind_match cs' u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\n  fmlookup \\<Gamma> n = Some u'\n  cs = cs'\n  \\<Gamma> = \\<Gamma>'\n  \\<lbrakk>fmlookup \\<Gamma> n = Some ?u'1;\n   vfind_match cs ?u'1 = Some (?env1, ?pat1, ?rhs1);\n   \\<Gamma> ++\\<^sub>f ?env1 \\<turnstile>\\<^sub>v ?rhs1 \\<down> v\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma veval'_wellformed:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  shows \"vwellformed v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwellformed v", "proof induction"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "case comb"], ["proof (state)\nthis:\n  \\<Gamma>_ \\<turnstile>\\<^sub>v t_ \\<down> Vabs cs_ \\<Gamma>'_\n  \\<Gamma>_ \\<turnstile>\\<^sub>v u_ \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uu_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f env_ \\<turnstile>\\<^sub>v rhs_ \\<down> val_\n  \\<lbrakk>pre_strong_term_class.wellformed t_;\n   wellformed_venv \\<Gamma>_\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vabs cs_ \\<Gamma>'_)\n  \\<lbrakk>pre_strong_term_class.wellformed u_;\n   wellformed_venv \\<Gamma>_\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'_\n  \\<lbrakk>pre_strong_term_class.wellformed rhs_;\n   wellformed_venv (\\<Gamma>'_ ++\\<^sub>f env_)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val_\n  pre_strong_term_class.wellformed (t_ $\\<^sub>s u_)\n  wellformed_venv \\<Gamma>_\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed val_", "apply (rule comb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs_\n 2. wellformed_venv (\\<Gamma>'_ ++\\<^sub>f env_)", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>_ \\<turnstile>\\<^sub>v t_ \\<down> Vabs cs_ \\<Gamma>'_\n  \\<Gamma>_ \\<turnstile>\\<^sub>v u_ \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uu_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f env_ \\<turnstile>\\<^sub>v rhs_ \\<down> val_\n  \\<lbrakk>pre_strong_term_class.wellformed t_;\n   wellformed_venv \\<Gamma>_\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vabs cs_ \\<Gamma>'_)\n  \\<lbrakk>pre_strong_term_class.wellformed u_;\n   wellformed_venv \\<Gamma>_\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'_\n  \\<lbrakk>pre_strong_term_class.wellformed rhs_;\n   wellformed_venv (\\<Gamma>'_ ++\\<^sub>f env_)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val_\n  pre_strong_term_class.wellformed (t_ $\\<^sub>s u_)\n  wellformed_venv \\<Gamma>_\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs_\n 2. wellformed_venv (\\<Gamma>'_ ++\\<^sub>f env_)", "by (auto simp: list_all_iff dest: vfind_match_elem intro: vwellformed.vmatch_env)"], ["proof (state)\nthis:\n  vwellformed val_\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "case (rec_comb \\<Gamma> t css name \\<Gamma>' cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwellformed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwellformed val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed val", "proof (rule rec_comb)"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"wellformed_venv (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "proof (intro fmpred_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv \\<Gamma>'\n 2. wellformed_venv (mk_rec_env css \\<Gamma>')\n 3. wellformed_venv env", "show \"wellformed_venv \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (2 subgoals):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')\n 2. wellformed_venv env", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')\n 2. wellformed_venv env", "show \"wellformed_venv env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_venv env", "by (auto dest: vfind_match_elem intro: vwellformed.vmatch_env)"], ["proof (state)\nthis:\n  wellformed_venv env\n\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "show \"wellformed_venv (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_venv\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "have \"vwellformed (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>')", "by (auto intro: fmdom'I)"], ["proof (state)\nthis:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "thus \"wellformed rhs\""], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> rec_comb"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwellformed u'\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwellformed val\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vwellformed val\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n   ts us\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "have \"list_all vwellformed us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all vwellformed us", "using \\<open>list_all2 _ _ _\\<close> \\<open>wellformed (_ $$ _)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n   ts us\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all vwellformed us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all vwellformed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 vwellformed b21);\n        pre_strong_term_class.wellformed (name $$ a22) \\<Longrightarrow>\n        list_all vwellformed b22;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vwellformed (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all vwellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all vwellformed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 vwellformed b21);\n        pre_strong_term_class.wellformed (name $$ a22) \\<Longrightarrow>\n        list_all vwellformed b22;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vwellformed (b21 # b22)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all vwellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all vwellformed (u # us)", "using constr"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed u)\n  pre_strong_term_class.wellformed (name $$ vs) \\<Longrightarrow>\n  list_all vwellformed us\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n   ts us__\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all vwellformed (u # us)", "by (auto simp: app_sterm_def wellformed.list_comb)"], ["proof (state)\nthis:\n  list_all vwellformed (u # us)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (name $$ []) \\<Longrightarrow>\n    list_all vwellformed []", "qed simp"], ["proof (state)\nthis:\n  list_all vwellformed us\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vwellformed x2))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vconstr name us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all vwellformed us\n\ngoal (1 subgoal):\n 1. vwellformed (Vconstr name us)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  vwellformed (Vconstr name us)\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwellformed (Vabs cs \\<Gamma>)", "qed auto"], ["", "lemma (in constants) veval'_shadows:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"not_shadows_vconsts_env \\<Gamma>\" \"\\<not> shadows_consts t\"\n  shows \"not_shadows_vconsts v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts v", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts v", "proof induction"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "case comb"], ["proof (state)\nthis:\n  \\<Gamma>_ \\<turnstile>\\<^sub>v t_ \\<down> Vabs cs_ \\<Gamma>'_\n  \\<Gamma>_ \\<turnstile>\\<^sub>v u_ \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uu_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f env_ \\<turnstile>\\<^sub>v rhs_ \\<down> val_\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>_;\n   \\<not> shadows_consts t_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vabs cs_ \\<Gamma>'_)\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>_;\n   \\<not> shadows_consts u_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'_\n  \\<lbrakk>not_shadows_vconsts_env (\\<Gamma>'_ ++\\<^sub>f env_);\n   \\<not> shadows_consts rhs_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val_\n  not_shadows_vconsts_env \\<Gamma>_\n  \\<not> shadows_consts (t_ $\\<^sub>s u_)\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts val_", "apply (rule comb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env (\\<Gamma>'_ ++\\<^sub>f env_)\n 2. \\<not> shadows_consts rhs_", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>_ \\<turnstile>\\<^sub>v t_ \\<down> Vabs cs_ \\<Gamma>'_\n  \\<Gamma>_ \\<turnstile>\\<^sub>v u_ \\<down> u'_\n  vfind_match cs_ u'_ = Some (env_, uu_, rhs_)\n  \\<Gamma>'_ ++\\<^sub>f env_ \\<turnstile>\\<^sub>v rhs_ \\<down> val_\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>_;\n   \\<not> shadows_consts t_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vabs cs_ \\<Gamma>'_)\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>_;\n   \\<not> shadows_consts u_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'_\n  \\<lbrakk>not_shadows_vconsts_env (\\<Gamma>'_ ++\\<^sub>f env_);\n   \\<not> shadows_consts rhs_\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val_\n  not_shadows_vconsts_env \\<Gamma>_\n  \\<not> shadows_consts (t_ $\\<^sub>s u_)\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env (\\<Gamma>'_ ++\\<^sub>f env_)\n 2. \\<not> shadows_consts rhs_", "by (auto simp: list_all_iff dest: vfind_match_elem intro: not_shadows_vconsts.vmatch_env)"], ["proof (state)\nthis:\n  not_shadows_vconsts val_\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "case (rec_comb \\<Gamma> t css name \\<Gamma>' cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts t\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n         \\<not> shadows_consts u\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>not_shadows_vconsts_env\n                  (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                   env);\n         \\<not> shadows_consts rhs\\<rbrakk>\n        \\<Longrightarrow> not_shadows_vconsts val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts val", "proof (rule rec_comb)"], ["proof (state)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs", "show \"not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "proof (intro fmpred_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>'\n 2. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n 3. not_shadows_vconsts_env env", "show \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "by (auto dest: vfind_match_elem intro: not_shadows_vconsts.vmatch_env)"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>'\n 2. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>'\n 2. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')", "show \"not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "show \"not_shadows_vconsts_env \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "have \"not_shadows_vconsts (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vrecabs css name \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vrecabs css name \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "thus \"\\<not> shadows_consts rhs\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> rec_comb"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n   \\<not> shadows_consts u\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts u'\n  \\<lbrakk>not_shadows_vconsts_env\n            (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs\\<rbrakk>\n  \\<Longrightarrow> not_shadows_vconsts val\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  not_shadows_vconsts val\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow> not_shadows_vconsts x2))\n   ts us\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "have \"list_all (not_shadows_vconsts) us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all not_shadows_vconsts us", "using \\<open>list_all2 _ _ _\\<close> \\<open>\\<not> shadows_consts (name $$ ts)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow> not_shadows_vconsts x2))\n   ts us\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all not_shadows_vconsts us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all not_shadows_vconsts []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts a21 \\<longrightarrow>\n                 not_shadows_vconsts b21);\n        \\<not> shadows_consts (name $$ a22) \\<Longrightarrow>\n        list_all not_shadows_vconsts b22;\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all not_shadows_vconsts (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow> not_shadows_vconsts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all not_shadows_vconsts us\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all not_shadows_vconsts []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts a21 \\<longrightarrow>\n                 not_shadows_vconsts b21);\n        \\<not> shadows_consts (name $$ a22) \\<Longrightarrow>\n        list_all not_shadows_vconsts b22;\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all not_shadows_vconsts (b21 # b22)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow> not_shadows_vconsts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all not_shadows_vconsts us\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all not_shadows_vconsts (u # us)", "using constr"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow> not_shadows_vconsts u)\n  \\<not> shadows_consts (name $$ vs) \\<Longrightarrow>\n  list_all not_shadows_vconsts us\n  \\<not> shadows_consts (name $$ (v # vs))\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow> not_shadows_vconsts x2))\n   ts us__\n  not_shadows_vconsts_env \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all not_shadows_vconsts (u # us)", "by (auto simp: shadows.list_comb app_sterm_def)"], ["proof (state)\nthis:\n  list_all not_shadows_vconsts (u # us)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (name $$ []) \\<Longrightarrow>\n    list_all not_shadows_vconsts []", "qed simp"], ["proof (state)\nthis:\n  list_all not_shadows_vconsts us\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts x2))\n         ts us;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vconstr name us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all not_shadows_vconsts us\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vconstr name us)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vconstr name us)\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Svar name)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>not_shadows_vconsts_env \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts (Vabs cs \\<Gamma>)", "qed (auto simp: list_all_iff list_ex_iff)"], ["", "lemma veval'_closed:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"closed_except t (fmdom \\<Gamma>)\" \"closed_venv \\<Gamma>\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  shows \"vclosed v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\n  closed_except t (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. vclosed v", "proof induction"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "case (comb \\<Gamma> t cs \\<Gamma>' u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   closed_venv (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"vclosed (Vabs cs \\<Gamma>')\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   closed_venv (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. vclosed (Vabs cs \\<Gamma>')", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed (Vabs cs \\<Gamma>')\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "have \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) u' = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) u' = Some env", "by (rule vfind_match_elem; fact)+"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) u' = Some env\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"fmdom env = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) u' = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = patvars (mk_pat pat)", "by (simp add: vmatch_dom)"], ["proof (state)\nthis:\n  fmdom env = patvars (mk_pat pat)\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "have \"vwellformed (Vabs cs \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>')", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   closed_venv (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. patvars (mk_pat pat) = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         closed_venv (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed val", "proof (rule comb)"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. closed_venv (\\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. closed_venv (\\<Gamma>' ++\\<^sub>f env)\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. closed_venv (\\<Gamma>' ++\\<^sub>f env)\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "show \"closed_venv (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv (\\<Gamma>' ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv \\<Gamma>'\n 2. closed_venv env", "using \\<open>vclosed (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>')\n\ngoal (2 subgoals):\n 1. closed_venv \\<Gamma>'\n 2. closed_venv env", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat6 ?v6 = Some env\n 2. vclosed ?v6", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs9 ?v6 = Some (env, ?pat9, ?rhs9)\n 2. vclosed ?v6", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   closed_venv (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (2 subgoals):\n 1. vfind_match ?cs9 ?v6 = Some (env, ?pat9, ?rhs9)\n 2. vclosed ?v6", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_venv (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "show \"closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))", "using \\<open>vclosed (Vabs cs \\<Gamma>')\\<close> \\<open>fmdom env = frees pat\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>')\n  fmdom env = frees pat\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "show \"wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv \\<Gamma>'\n 2. wellformed_venv env", "using \\<open>vwellformed (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (2 subgoals):\n 1. wellformed_venv \\<Gamma>'\n 2. wellformed_venv env", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat6 ?v6 = Some env\n 2. vwellformed ?v6", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs9 ?v6 = Some (env, ?pat9, ?rhs9)\n 2. vwellformed ?v6", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed u'", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>12 \\<turnstile>\\<^sub>v ?t12 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t12\n 3. wellformed_venv ?\\<Gamma>12", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   closed_venv (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>12 \\<turnstile>\\<^sub>v ?t12 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t12\n 3. wellformed_venv ?\\<Gamma>12", "by auto"], ["proof (state)\nthis:\n  wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vclosed val\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "case (rec_comb \\<Gamma> t css name \\<Gamma>' cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "have \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) u' = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) u' = Some env", "by (rule vfind_match_elem; fact)+"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) u' = Some env\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"fmdom env = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) u' = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = patvars (mk_pat pat)", "by (simp add: vmatch_dom)"], ["proof (state)\nthis:\n  fmdom env = patvars (mk_pat pat)\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "have \"vwellformed (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>')", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"wellformed_clauses cs\""], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_clauses cs", "using rec_comb"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_clauses cs", "by auto"], ["proof (state)\nthis:\n  wellformed_clauses cs\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  wellformed_clauses cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. patvars (mk_pat pat) = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n         pre_strong_term_class.wellformed u;\n         wellformed_venv \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vclosed u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>closed_except rhs\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         closed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vclosed val;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed val", "proof (rule rec_comb)"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. closed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"closed_venv (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "proof (intro fmpred_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. closed_venv \\<Gamma>'\n 2. closed_venv (mk_rec_env css \\<Gamma>')\n 3. closed_venv env", "show \"closed_venv \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv \\<Gamma>'", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_venv \\<Gamma>'", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_venv \\<Gamma>'\n\ngoal (2 subgoals):\n 1. closed_venv (mk_rec_env css \\<Gamma>')\n 2. closed_venv env", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_venv (mk_rec_env css \\<Gamma>')\n 2. closed_venv env", "show \"closed_venv env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_venv env", "by (auto simp: closed_except_def dest: vfind_match_elem intro: vclosed.vmatch_env)"], ["proof (state)\nthis:\n  closed_venv env\n\ngoal (1 subgoal):\n 1. closed_venv (mk_rec_env css \\<Gamma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_venv (mk_rec_env css \\<Gamma>')", "show \"closed_venv (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. closed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto simp: closed_except_def intro: fmdomI)"], ["proof (state)\nthis:\n  closed_venv (mk_rec_env css \\<Gamma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_venv (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (3 subgoals):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"vclosed (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed (Vrecabs css name \\<Gamma>')", "using mk_rec_env_def"], ["proof (prove)\nusing this:\n  mk_rec_env ?css ?\\<Gamma>' =\n  fmmap_keys (\\<lambda>name cs. Vrecabs ?css name ?\\<Gamma>') ?css\n\ngoal (1 subgoal):\n 1. vclosed (Vrecabs css name \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  mk_rec_env ?css ?\\<Gamma>' =\n  fmmap_keys (\\<lambda>name cs. Vrecabs ?css name ?\\<Gamma>') ?css\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. vclosed (Vrecabs css name \\<Gamma>')", "by (auto simp: closed_except_def intro: fmdom'I)"], ["proof (state)\nthis:\n  vclosed (Vrecabs css name \\<Gamma>')\n\ngoal (3 subgoals):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "hence \"closed_except rhs (fmdom \\<Gamma>' |\\<union>| frees pat)\""], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma>' |\\<union>| frees pat)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv \\<Gamma>' \\<and>\n    fmpred\n     (\\<lambda>_.\n         list_all\n          (\\<lambda>(pat, t).\n              closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat)))\n     css \\<and>\n    name |\\<in>| fmdom css \\<Longrightarrow>\n    closed_except rhs (fmdom \\<Gamma>' |\\<union>| frees pat)", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_venv \\<Gamma>';\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat)))\n      css;\n     name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (fmdom \\<Gamma>' |\\<union>| frees pat)", "apply (drule fmpredD[where m = css])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_venv \\<Gamma>'; name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> fmlookup css ?x3 = Some ?y3\n 2. \\<lbrakk>closed_venv \\<Gamma>'; name |\\<in>| fmdom css;\n     list_all\n      (\\<lambda>(pat, t).\n          closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat))\n      ?y3\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (fmdom \\<Gamma>' |\\<union>| frees pat)", "apply (rule rec_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_venv \\<Gamma>'; name |\\<in>| fmdom css;\n     list_all\n      (\\<lambda>(pat, t).\n          closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat))\n      cs\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (fmdom \\<Gamma>' |\\<union>| frees pat)", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_venv \\<Gamma>'; name |\\<in>| fmdom css;\n     list_all\n      (\\<lambda>(pat, t).\n          closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat))\n      cs\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (fmdom \\<Gamma>' |\\<union>| frees pat)", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_venv \\<Gamma>'; name |\\<in>| fmdom css;\n     \\<forall>(pat, t)\\<in>set cs.\n        closed_except t (fmdom \\<Gamma>' |\\<union>| frees pat)\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (fmdom \\<Gamma>' |\\<union>| frees pat)", "by auto"], ["proof (state)\nthis:\n  closed_except rhs (fmdom \\<Gamma>' |\\<union>| frees pat)\n\ngoal (3 subgoals):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "thus \"closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom \\<Gamma>' |\\<union>| frees pat)\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| frees pat\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>|\n    fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "using \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| frees pat\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>|\n    fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "by auto"], ["proof (state)\nthis:\n  closed_except rhs\n   (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>wellformed_clauses cs\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  wellformed_clauses cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"wellformed_venv (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "proof (intro fmpred_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv \\<Gamma>'\n 2. wellformed_venv (mk_rec_env css \\<Gamma>')\n 3. wellformed_venv env", "show \"wellformed_venv \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "using \\<open>vwellformed (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (2 subgoals):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')\n 2. wellformed_venv env", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')\n 2. wellformed_venv env", "show \"wellformed_venv env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>closed_except t (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>closed_except u (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vclosed u'\n  \\<lbrakk>closed_except rhs\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   closed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vclosed val\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_venv env", "by (auto dest: vfind_match_elem intro: veval'_wellformed vwellformed.vmatch_env)"], ["proof (state)\nthis:\n  wellformed_venv env\n\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "show \"wellformed_venv (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using \\<open>vwellformed (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wellformed_venv\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vclosed val\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_venv \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n   ts us\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "have \"list_all vclosed us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all vclosed us", "using \\<open>list_all2 _ _ _\\<close> \\<open>closed_except (_ $$ _) _\\<close> \\<open>wellformed (_ $$ _)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_venv \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n   ts us\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all vclosed us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_except (name $$ []) (fmdom \\<Gamma>);\n     pre_strong_term_class.wellformed (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vclosed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow> vclosed b21);\n        \\<lbrakk>closed_except (name $$ a22) (fmdom \\<Gamma>);\n         pre_strong_term_class.wellformed (name $$ a22)\\<rbrakk>\n        \\<Longrightarrow> list_all vclosed b22;\n        closed_except (name $$ (a21 # a22)) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vclosed (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (closed_except v (fmdom \\<Gamma>) \\<longrightarrow>\n   closed_venv \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vclosed u)\n  \\<lbrakk>closed_except (name $$ vs) (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vclosed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_except (name $$ []) (fmdom \\<Gamma>);\n     pre_strong_term_class.wellformed (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vclosed []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow> vclosed b21);\n        \\<lbrakk>closed_except (name $$ a22) (fmdom \\<Gamma>);\n         pre_strong_term_class.wellformed (name $$ a22)\\<rbrakk>\n        \\<Longrightarrow> list_all vclosed b22;\n        closed_except (name $$ (a21 # a22)) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vclosed (b21 # b22)", "with constr"], ["proof (chain)\npicking this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_venv \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n   ts us__\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (closed_except v (fmdom \\<Gamma>) \\<longrightarrow>\n   closed_venv \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vclosed u)\n  \\<lbrakk>closed_except (name $$ vs) (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vclosed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (name $$ (v # vs))", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_venv \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n   ts us__\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (closed_except v (fmdom \\<Gamma>) \\<longrightarrow>\n   closed_venv \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vclosed u)\n  \\<lbrakk>closed_except (name $$ vs) (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vclosed us\n  closed_except (name $$ (v # vs)) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all vclosed (u # us)", "unfolding closed.list_comb wellformed.list_comb"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n        closed_venv \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n   ts us__\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n  closed_venv \\<Gamma>\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed ts\n  wellformed_venv \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (closed_except v (fmdom \\<Gamma>) \\<longrightarrow>\n   closed_venv \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow> vclosed u)\n  \\<lbrakk>closed_except (const name) (fmdom \\<Gamma>) \\<and>\n           list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) vs;\n   pre_strong_term_class.wellformed (const name) \\<and>\n   list_all pre_strong_term_class.wellformed vs\\<rbrakk>\n  \\<Longrightarrow> list_all vclosed us\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) (v # vs)\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed (v # vs)\n\ngoal (1 subgoal):\n 1. list_all vclosed (u # us)", "by (auto simp: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  list_all vclosed (u # us)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_except (name $$ []) (fmdom \\<Gamma>);\n     pre_strong_term_class.wellformed (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vclosed []", "qed simp"], ["proof (state)\nthis:\n  list_all vclosed us\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n              closed_venv \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow> vclosed x2))\n         ts us;\n        closed_except (name $$ ts) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vconstr name us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all vclosed us\n\ngoal (1 subgoal):\n 1. vclosed (Vconstr name us)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  vclosed (Vconstr name us)\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        closed_except (Sconst name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        closed_except (Svar name) (fmdom \\<Gamma>); closed_venv \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>closed_except (Sabs cs) (fmdom \\<Gamma>);\n        closed_venv \\<Gamma>; pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vclosed (Vabs cs \\<Gamma>)", "qed (auto simp: Sterm.closed_except_simps)"], ["", "primrec vwelldefined' :: \"value \\<Rightarrow> bool\" where\n\"vwelldefined' (Vconstr name vs) \\<longleftrightarrow> list_all vwelldefined' vs\" |\n\"vwelldefined' (Vabs cs \\<Gamma>) \\<longleftrightarrow>\n  pred_fmap id (fmmap vwelldefined' \\<Gamma>) \\<and>\n  list_all (\\<lambda>(pat, t). consts t |\\<subseteq>| (fmdom \\<Gamma> |\\<union>| C)) cs \\<and>\n  fdisjnt C (fmdom \\<Gamma>)\" |\n\"vwelldefined' (Vrecabs css name \\<Gamma>) \\<longleftrightarrow>\n  pred_fmap id (fmmap vwelldefined' \\<Gamma>) \\<and>\n  pred_fmap (\\<lambda>cs.\n    list_all (\\<lambda>(pat, t). consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| (C |\\<union>| fmdom css)) cs \\<and>\n    fdisjnt C (fmdom \\<Gamma>)) css \\<and>\n  name |\\<in>| fmdom css \\<and>\n  fdisjnt C (fmdom css)\""], ["", "lemma vmatch_welldefined':\n  assumes \"vmatch pat v = Some env\" \"vwelldefined' v\"\n  shows \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "using assms"], ["proof (prove)\nusing this:\n  vmatch pat v = Some env\n  vwelldefined' v\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "proof (induction pat v arbitrary: env rule: vmatch_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "case (constr name ps name' vs)"], ["proof (state)\nthis:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x1 \\<in> set ps;\n   ?y1 \\<in> set vs; vmatch ?x1 ?y1 = Some ?env1; vwelldefined' ?y1\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') ?env1\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n  vwelldefined' (Vconstr name' vs)\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "hence\n    \"map_option (foldl (++\\<^sub>f) fmempty) (those (map2 vmatch ps vs)) = Some env\"\n    \"name = name'\" \"length ps = length vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x1 \\<in> set ps;\n   ?y1 \\<in> set vs; vmatch ?x1 ?y1 = Some ?env1; vwelldefined' ?y1\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') ?env1\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some env\n  vwelldefined' (Vconstr name' vs)\n\ngoal (1 subgoal):\n 1. map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 vmatch ps vs)) =\n    Some env &&&\n    name = name' &&& length ps = length vs", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "then"], ["proof (chain)\npicking this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs", "obtain envs where \"env = foldl (++\\<^sub>f) fmempty envs\" \"map2 vmatch ps vs = map Some envs\""], ["proof (prove)\nusing this:\n  map_option (foldl (++\\<^sub>f) fmempty)\n   (those (Term_Utils.map2 vmatch ps vs)) =\n  Some env\n  name = name'\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>envs.\n        \\<lbrakk>env = foldl (++\\<^sub>f) fmempty envs;\n         Term_Utils.map2 vmatch ps vs = map Some envs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: those_someD)"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "moreover"], ["proof (state)\nthis:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "have \"fmpred (\\<lambda>_. vwelldefined') env\" if \"env \\<in> set envs\" for env"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "from that"], ["proof (chain)\npicking this:\n  env \\<in> set envs", "have \"Some env \\<in> set (map2 vmatch ps vs)\""], ["proof (prove)\nusing this:\n  env \\<in> set envs\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "unfolding \\<open>map2 _ _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  env \\<in> set envs\n\ngoal (1 subgoal):\n 1. Some env \\<in> set (map Some envs)", "by simp"], ["proof (state)\nthis:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "then"], ["proof (chain)\npicking this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)", "obtain p v where \"p \\<in> set ps\" \"v \\<in> set vs\" \"vmatch p v = Some env\""], ["proof (prove)\nusing this:\n  Some env \\<in> set (Term_Utils.map2 vmatch ps vs)\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>p \\<in> set ps; v \\<in> set vs;\n         vmatch p v = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: map2_elemE)"], ["proof (state)\nthis:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "hence \"vwelldefined' v\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n\ngoal (1 subgoal):\n 1. vwelldefined' v", "using constr"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  v \\<in> set vs\n  vmatch p v = Some env\n  \\<lbrakk>name = name' \\<and> length ps = length vs; ?x1 \\<in> set ps;\n   ?y1 \\<in> set vs; vmatch ?x1 ?y1 = Some ?env1; vwelldefined' ?y1\\<rbrakk>\n  \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') ?env1\n  vmatch (Patconstr name ps) (Vconstr name' vs) = Some enva__\n  vwelldefined' (Vconstr name' vs)\n\ngoal (1 subgoal):\n 1. vwelldefined' v", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  vwelldefined' v\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by (rule constr; safe?) fact+"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?env1 \\<in> set envs \\<Longrightarrow>\n  fmpred (\\<lambda>_. vwelldefined') ?env1\n\ngoal (4 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>name ps name' vs env.\n       \\<lbrakk>\\<And>x y env.\n                   \\<lbrakk>name = name' \\<and> length ps = length vs;\n                    x \\<in> set ps; y \\<in> set vs; vmatch x y = Some env;\n                    vwelldefined' y\\<rbrakk>\n                   \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env;\n        vmatch (Patconstr name ps) (Vconstr name' vs) = Some env;\n        vwelldefined' (Vconstr name' vs)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 4. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "ultimately"], ["proof (chain)\npicking this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  ?env1 \\<in> set envs \\<Longrightarrow>\n  fmpred (\\<lambda>_. vwelldefined') ?env1", "show ?case"], ["proof (prove)\nusing this:\n  env = foldl (++\\<^sub>f) fmempty envs\n  Term_Utils.map2 vmatch ps vs = map Some envs\n  ?env1 \\<in> set envs \\<Longrightarrow>\n  fmpred (\\<lambda>_. vwelldefined') ?env1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by auto"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (3 subgoals):\n 1. \\<And>name v env.\n       \\<lbrakk>vmatch (Patvar name) v = Some env; vwelldefined' v\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 2. \\<And>v va vb vc env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vabs vb vc) = Some env;\n        vwelldefined' (Vabs vb vc)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env\n 3. \\<And>v va vb vc vd env.\n       \\<lbrakk>vmatch (Patconstr v va) (Vrecabs vb vc vd) = Some env;\n        vwelldefined' (Vrecabs vb vc vd)\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined') env", "qed auto"], ["", "(* FIXME ad hoc rules after introduction of \"constants\" locale *)"], ["", "lemma sconsts_list_comb:\n   \"consts (list_comb f xs) |\\<subseteq>| S \\<longleftrightarrow> consts f |\\<subseteq>| S \\<and> list_all (\\<lambda>x. consts x |\\<subseteq>| S) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (consts (list_comb f xs) |\\<subseteq>| S) =\n    (consts f |\\<subseteq>| S \\<and>\n     list_all (\\<lambda>x. consts x |\\<subseteq>| S) xs)", "by (induction xs arbitrary: f) auto"], ["", "lemma sconsts_sabs:\n  \"consts (Sabs cs) |\\<subseteq>| S \\<longleftrightarrow> list_all (\\<lambda>(_, t). consts t |\\<subseteq>| S) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (consts (Sabs cs) |\\<subseteq>| S) =\n    list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| S) cs", "apply (auto simp: list_all_iff ffUnion_alt_def dest!: ffUnion_least_rev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>fBall (fset_of_list cs)\n                 (\\<lambda>x.\n                     (case x of\n                      (uu_, x) \\<Rightarrow> consts x) |\\<subseteq>|\n                     S);\n        (a, b) \\<in> set cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S\n 2. \\<And>x a b.\n       \\<lbrakk>\\<forall>x\\<in>set cs.\n                   case x of\n                   (uu_, t) \\<Rightarrow> consts t |\\<subseteq>| S;\n        (a, b) |\\<in>| fset_of_list cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (subst (asm) list_all_iff_fset[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>list_all\n                 (\\<lambda>x.\n                     (case x of\n                      (uu_, x) \\<Rightarrow> consts x) |\\<subseteq>|\n                     S)\n                 cs;\n        (a, b) \\<in> set cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S\n 2. \\<And>x a b.\n       \\<lbrakk>\\<forall>x\\<in>set cs.\n                   case x of\n                   (uu_, t) \\<Rightarrow> consts t |\\<subseteq>| S;\n        (a, b) |\\<in>| fset_of_list cs; x |\\<in>| consts b\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (auto simp: list_all_iff fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in constants) veval'_welldefined':\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  shows \"vwelldefined' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' v", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\n  fdisjnt C (fmdom \\<Gamma>)\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' v", "proof induction"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> cs.\n       \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>)\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 6. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "thus ?case"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>)", "unfolding sconsts_sabs"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>)\n  list_all\n   (\\<lambda>(uu_, t). consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   cs\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>)", "by (auto simp: list_all_iff list_ex_iff)"], ["proof (state)\nthis:\n  vwelldefined' (Vabs cs \\<Gamma>)\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "case (comb \\<Gamma> t cs \\<Gamma>' u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (auto dest: vfind_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "moreover"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwelldefined' (Vabs cs \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>')", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vabs cs \\<Gamma>')\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "ultimately"], ["proof (chain)\npicking this:\n  (pat, rhs) \\<in> set cs\n  vwelldefined' (Vabs cs \\<Gamma>')", "have \"consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| C\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwelldefined' (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| C", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| C\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwellformed (Vabs cs \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>')", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vfind_match ?cs3 ?v1 = Some (env, pat, ?rhs3)", "apply (rule comb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"not_shadows_vconsts (Vabs cs \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>')", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vabs cs \\<Gamma>')\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwelldefined' (Vabs cs \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>')", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vabs cs \\<Gamma>')\n\ngoal (5 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>');\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n         consts rhs |\\<subseteq>|\n         fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 5. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' val", "proof (rule comb)"], ["proof (state)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n 4. pre_strong_term_class.wellformed rhs\n 5. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "show \"consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C", "using \\<open>consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| C\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| C\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C", "by auto"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C\n\ngoal (6 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"vwelldefined' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' u'", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' u'", "by auto"], ["proof (state)\nthis:\n  vwelldefined' u'\n\ngoal (6 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "hence \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\nusing this:\n  vwelldefined' u'\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "using comb"], ["proof (prove)\nusing this:\n  vwelldefined' u'\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by (auto intro: vmatch_welldefined' dest: vfind_match_elem)"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (6 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "thus \"fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)", "using \\<open>vwelldefined' (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n  vwelldefined' (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)", "by auto"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"fdisjnt C (fmdom \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>')", "using \\<open>vwelldefined' (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>')", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_all_iff all_consts_def fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt C (fmdom \\<Gamma>')\n  fdisjnt C (fmdom env)", "show \"fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>')\n  fdisjnt C (fmdom env)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom \\<Gamma>' = {||}\n  C |\\<inter>| fmdom env = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>| fmdom (\\<Gamma>' ++\\<^sub>f env) = {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env))\n\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"wellformed_venv \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "using \\<open>vwellformed (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "by simp"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"wellformed_venv env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. vwellformed ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. vwellformed ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed u'", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "by auto"], ["proof (state)\nthis:\n  wellformed_venv env\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  wellformed_venv \\<Gamma>'\n  wellformed_venv env", "show \"wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  wellformed_venv \\<Gamma>'\n  wellformed_venv env\n\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>' ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  wellformed_venv (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"not_shadows_vconsts_env \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>')\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "by simp"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. not_shadows_vconsts ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. not_shadows_vconsts ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts u'", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vabs cs \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n   consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>' ++\\<^sub>f env); \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  not_shadows_vconsts_env \\<Gamma>'\n  not_shadows_vconsts_env env", "show \"not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env \\<Gamma>'\n  not_shadows_vconsts_env env\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>')\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vwelldefined' val\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "case (rec_comb \\<Gamma> t css name \\<Gamma>' cs u u' env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (auto dest: vfind_match_elem)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "moreover"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwelldefined' (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "ultimately"], ["proof (chain)\npicking this:\n  (pat, rhs) \\<in> set cs\n  vwelldefined' (Vrecabs css name \\<Gamma>')", "have \"consts rhs |\\<subseteq>| fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)", "using \\<open>fmlookup css name = Some cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n  fmlookup css name = Some cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)", "by (auto simp: list_all_iff dest!: fmpredD[where m = css])"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwellformed (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>')", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"wellformed_clauses cs\""], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_clauses cs", "using rec_comb"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. wellformed_clauses cs", "by auto"], ["proof (state)\nthis:\n  wellformed_clauses cs\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  wellformed_clauses cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vfind_match ?cs3 ?v1 = Some (env, pat, ?rhs3)", "apply (rule rec_comb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"not_shadows_vconsts (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vrecabs css name \\<Gamma>')", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vrecabs css name \\<Gamma>'\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"vwelldefined' (Vrecabs css name \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>');\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n         consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n         \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<lbrakk>fdisjnt C\n                  (fmdom\n                    (\\<Gamma>' ++\\<^sub>f\n                     mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                     env));\n         consts rhs |\\<subseteq>|\n         fmdom\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env) |\\<union>|\n         C;\n         fmpred (\\<lambda>_. vwelldefined')\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         pre_strong_term_class.wellformed rhs;\n         wellformed_venv\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n         \\<not> shadows_consts rhs;\n         not_shadows_vconsts_env\n          (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n           env)\\<rbrakk>\n        \\<Longrightarrow> vwelldefined' val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 4. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' val", "proof (rule rec_comb)"], ["proof (state)\ngoal (7 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. pre_strong_term_class.wellformed rhs\n 5. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"consts rhs |\\<subseteq>| fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n      env) |\\<union>|\n    C", "using \\<open>consts rhs |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n      env) |\\<union>|\n    C", "unfolding mk_rec_env_def"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>' |\\<union>| (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>' ++\\<^sub>f\n      fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>')\n       css ++\\<^sub>f\n      env) |\\<union>|\n    C", "by auto"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env) |\\<union>|\n  C\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'", "using \\<open>vwelldefined' (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by (auto dest: vfind_match_elem intro: vmatch_welldefined')"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (6 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'\n  fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')\n  fmpred (\\<lambda>_. vwelldefined') env", "show \"fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'\n  fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>')\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fdisjnt C (fmdom \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>')", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>')", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "using \\<open>fmlookup css name = Some cs\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  fmlookup css name = Some cs\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmlookup css name = Some cs; (pat, rhs) \\<in> set cs;\n     not_shadows_vconsts_env \\<Gamma>';\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> fdisjnt C (frees pat)", "apply (drule fmpredD[where m = css])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmlookup css name = Some cs; (pat, rhs) \\<in> set cs;\n     not_shadows_vconsts_env \\<Gamma>'; name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> fmlookup css ?x5 = Some ?y5\n 2. \\<lbrakk>fmlookup css name = Some cs; (pat, rhs) \\<in> set cs;\n     not_shadows_vconsts_env \\<Gamma>'; name |\\<in>| fmdom css;\n     list_all\n      (\\<lambda>(pat, t).\n          fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n      ?y5\\<rbrakk>\n    \\<Longrightarrow> fdisjnt C (frees pat)", "by (auto simp: list_all_iff all_consts_def fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"fdisjnt C (fmdom (mk_rec_env css \\<Gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (mk_rec_env css \\<Gamma>'))", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css))", "using \\<open>vwelldefined' (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css))", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (mk_rec_env css \\<Gamma>'))\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n 2. pre_strong_term_class.wellformed rhs\n 3. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt C (fmdom \\<Gamma>')\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom (mk_rec_env css \\<Gamma>'))", "show \"fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>')\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom (mk_rec_env css \\<Gamma>'))\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom \\<Gamma>' = {||}\n  C |\\<inter>| fmdom env = {||}\n  C |\\<inter>| fmdom (mk_rec_env css \\<Gamma>') = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>|\n    fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env) =\n    {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C\n   (fmdom (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env))\n\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>wellformed_clauses cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"wellformed_venv \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "using \\<open>vwellformed (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "by simp"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"wellformed_venv (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using \\<open>vwellformed (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"wellformed_venv env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. vwellformed ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. vwellformed ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed u'", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "by auto"], ["proof (state)\nthis:\n  wellformed_venv env\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  wellformed_venv \\<Gamma>'\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n  wellformed_venv env", "show \"wellformed_venv (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  wellformed_venv \\<Gamma>'\n  wellformed_venv (mk_rec_env css \\<Gamma>')\n  wellformed_venv env\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  wellformed_venv\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"not_shadows_vconsts_env \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "using \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "by simp"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "using \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>')\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>') css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. not_shadows_vconsts ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. not_shadows_vconsts ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts u'", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. \\<not> shadows_consts rhs\n 2. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  not_shadows_vconsts_env \\<Gamma>'\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n  not_shadows_vconsts_env env", "show \"not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env \\<Gamma>'\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>')\n  not_shadows_vconsts_env env\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using rec_comb \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>')\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u'\n  vfind_match cs u' = Some (env, pat, rhs)\n  \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts t; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' (Vrecabs css name \\<Gamma>')\n  \\<lbrakk>fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   \\<not> shadows_consts u; not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' u'\n  \\<lbrakk>fdisjnt C\n            (fmdom\n              (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n               env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> vwelldefined' val\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>')\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vwelldefined' val\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "have \"list_all vwelldefined' us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all vwelldefined' us", "using \\<open>list_all2 _ _ _\\<close> \\<open>consts (name $$ ts) |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. list_all vwelldefined' us", "using \\<open>wellformed (name $$ ts)\\<close> \\<open>\\<not> shadows_consts (name $$ ts)\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  pre_strong_term_class.wellformed (name $$ ts)\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. list_all vwelldefined' us", "proof (induction ts us rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>consts (name $$ []) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n     pre_strong_term_class.wellformed (name $$ []);\n     \\<not> shadows_consts (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vwelldefined' []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts a21 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts a21 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n                 vwelldefined' b21);\n        \\<lbrakk>consts (name $$ a22) |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C;\n         pre_strong_term_class.wellformed (name $$ a22);\n         \\<not> shadows_consts (name $$ a22)\\<rbrakk>\n        \\<Longrightarrow> list_all vwelldefined' b22;\n        consts (name $$ (a21 # a22)) |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22));\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vwelldefined' (b21 # b22)", "case (Cons v vs u us)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n   consts v |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow>\n   not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> vwelldefined' u)\n  \\<lbrakk>consts (name $$ vs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   pre_strong_term_class.wellformed (name $$ vs);\n   \\<not> shadows_consts (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vwelldefined' us\n  consts (name $$ (v # vs)) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>consts (name $$ []) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n     pre_strong_term_class.wellformed (name $$ []);\n     \\<not> shadows_consts (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vwelldefined' []\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts a21 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts a21 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n                 vwelldefined' b21);\n        \\<lbrakk>consts (name $$ a22) |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C;\n         pre_strong_term_class.wellformed (name $$ a22);\n         \\<not> shadows_consts (name $$ a22)\\<rbrakk>\n        \\<Longrightarrow> list_all vwelldefined' b22;\n        consts (name $$ (a21 # a22)) |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C;\n        pre_strong_term_class.wellformed (name $$ (a21 # a22));\n        \\<not> shadows_consts (name $$ (a21 # a22))\\<rbrakk>\n       \\<Longrightarrow> list_all vwelldefined' (b21 # b22)", "with constr"], ["proof (chain)\npicking this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us__\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n   consts v |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow>\n   not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> vwelldefined' u)\n  \\<lbrakk>consts (name $$ vs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   pre_strong_term_class.wellformed (name $$ vs);\n   \\<not> shadows_consts (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vwelldefined' us\n  consts (name $$ (v # vs)) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n  \\<not> shadows_consts (name $$ (v # vs))", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us__\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n   consts v |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow>\n   not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> vwelldefined' u)\n  \\<lbrakk>consts (name $$ vs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   pre_strong_term_class.wellformed (name $$ vs);\n   \\<not> shadows_consts (name $$ vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vwelldefined' us\n  consts (name $$ (v # vs)) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  pre_strong_term_class.wellformed (name $$ (v # vs))\n  \\<not> shadows_consts (name $$ (v # vs))\n\ngoal (1 subgoal):\n 1. list_all vwelldefined' (u # us)", "unfolding wellformed.list_comb shadows.list_comb"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n        consts x1 |\\<subseteq>|\n        fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n        pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma> \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n        vwelldefined' x2))\n   ts us__\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed ts\n  wellformed_venv \\<Gamma>\n  \\<not> (shadows_consts (const name) \\<or> list_ex shadows_consts ts)\n  not_shadows_vconsts_env \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v v \\<down> u \\<and>\n  (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n   consts v |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n   pre_strong_term_class.wellformed v \\<longrightarrow>\n   wellformed_venv \\<Gamma> \\<longrightarrow>\n   \\<not> shadows_consts v \\<longrightarrow>\n   not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> vwelldefined' u)\n  \\<lbrakk>consts (name $$ vs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   pre_strong_term_class.wellformed (const name) \\<and>\n   list_all pre_strong_term_class.wellformed vs;\n   \\<not> (shadows_consts (const name) \\<or>\n           list_ex shadows_consts vs)\\<rbrakk>\n  \\<Longrightarrow> list_all vwelldefined' us\n  consts (name $$ (v # vs)) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed (v # vs)\n  \\<not> (shadows_consts (const name) \\<or> list_ex shadows_consts (v # vs))\n\ngoal (1 subgoal):\n 1. list_all vwelldefined' (u # us)", "by (auto simp: consts_list_comb)"], ["proof (state)\nthis:\n  list_all vwelldefined' (u # us)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consts (name $$ []) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n     pre_strong_term_class.wellformed (name $$ []);\n     \\<not> shadows_consts (name $$ [])\\<rbrakk>\n    \\<Longrightarrow> list_all vwelldefined' []", "qed simp"], ["proof (state)\nthis:\n  list_all vwelldefined' us\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 3. \\<And>name \\<Gamma> ts us.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n              consts x1 |\\<subseteq>|\n              fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n              fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n              pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              vwelldefined' x2))\n         ts us;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' (Vconstr name us)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all vwelldefined' us\n\ngoal (1 subgoal):\n 1. vwelldefined' (Vconstr name us)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  vwelldefined' (Vconstr name us)\n\ngoal (2 subgoals):\n 1. \\<And>name \\<Gamma> val.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val\n 2. \\<And>\\<Gamma> name val.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' val", "qed auto"], ["", "end"], ["", "subsubsection (in special_constants) \\<open>Correctness wrt @{const veval}\\<close>"], ["", "context vrules begin"], ["", "text \\<open>\n  The following relation can be characterized as follows:\n  \\<^item> Values have to have the same structure. (We prove an interpretation of @{const value_struct_rel}.)\n  \\<^item> For closures, the captured environments must agree on constants and variables occurring in the\n    body.\n  The first @{typ value} argument is from @{const veval} (i.e. from\n  @{theory CakeML_Codegen.Big_Step_Value}), the second from @{const veval'}.\n\\<close>"], ["", "(* FIXME move into locale *)"], ["", "coinductive vrelated :: \"value \\<Rightarrow> value \\<Rightarrow> bool\" (\"\\<turnstile>\\<^sub>v/ _ \\<approx> _\" [0, 50] 50) where\nconstr: \"list_all2 vrelated ts us \\<Longrightarrow> \\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name us\" |\nabs:\n  \"fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<Longrightarrow>\n   fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2 \\<Longrightarrow>\n     \\<turnstile>\\<^sub>v Vabs cs \\<Gamma>\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\\<^sub>2\" |\nrec_abs:\n  \"pred_fmap (\\<lambda>cs.\n    fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n    fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) (\\<Gamma>\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>2)) css \\<Longrightarrow>\n     name |\\<in>| fmdom css \\<Longrightarrow>\n     \\<turnstile>\\<^sub>v Vrecabs css name \\<Gamma>\\<^sub>1 \\<approx> Vrecabs css name \\<Gamma>\\<^sub>2\""], ["", "text \\<open>\n  Perhaps unexpectedly, @{term vrelated} is not reflexive. The reason is that it does not just check\n  syntactic equality including captured environments, but also adherence to the external rules.\n\\<close>"], ["", "sublocale vrelated: value_struct_rel vrelated"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_struct_rel vrelated", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "fix t\\<^sub>1 t\\<^sub>2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "assume \"\\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2\""], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2 \\<Longrightarrow>\n       veq_structure t\\<^sub>1 t\\<^sub>2\n 2. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "thus \"veq_structure t\\<^sub>1 t\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v t\\<^sub>1 \\<approx> t\\<^sub>2\n\ngoal (1 subgoal):\n 1. veq_structure t\\<^sub>1 t\\<^sub>2", "apply (induction t\\<^sub>1 arbitrary: t\\<^sub>2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vconstr x1 x2 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vconstr x1 x2) t\\<^sub>2\n 2. \\<And>x1 x2 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vabs x1 x2 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vabs x1 x2) t\\<^sub>2\n 3. \\<And>x1 x2 x3 t\\<^sub>2.\n       \\<lbrakk>\\<And>x3a t\\<^sub>2.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    \\<turnstile>\\<^sub>v x3a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x3a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vrecabs x1 x2 x3 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vrecabs x1 x2 x3) t\\<^sub>2", "apply (erule vrelated.cases; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts us.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ts;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        list_all2 vrelated ts us\\<rbrakk>\n       \\<Longrightarrow> list_all2 veq_structure ts us\n 2. \\<And>x1 x2 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vabs x1 x2 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vabs x1 x2) t\\<^sub>2\n 3. \\<And>x1 x2 x3 t\\<^sub>2.\n       \\<lbrakk>\\<And>x3a t\\<^sub>2.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    \\<turnstile>\\<^sub>v x3a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x3a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vrecabs x1 x2 x3 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vrecabs x1 x2 x3) t\\<^sub>2", "apply (erule list.rel_mono_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts us z yb.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> set ts;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        z \\<in> set ts; yb \\<in> set us;\n        \\<turnstile>\\<^sub>v z \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> veq_structure z yb\n 2. \\<And>x1 x2 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vabs x1 x2 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vabs x1 x2) t\\<^sub>2\n 3. \\<And>x1 x2 x3 t\\<^sub>2.\n       \\<lbrakk>\\<And>x3a t\\<^sub>2.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    \\<turnstile>\\<^sub>v x3a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x3a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vrecabs x1 x2 x3 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vrecabs x1 x2 x3) t\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 t\\<^sub>2.\n       \\<lbrakk>\\<And>x2a t\\<^sub>2.\n                   \\<lbrakk>x2a \\<in> fmran' x2;\n                    \\<turnstile>\\<^sub>v x2a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x2a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vabs x1 x2 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vabs x1 x2) t\\<^sub>2\n 2. \\<And>x1 x2 x3 t\\<^sub>2.\n       \\<lbrakk>\\<And>x3a t\\<^sub>2.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    \\<turnstile>\\<^sub>v x3a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x3a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vrecabs x1 x2 x3 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vrecabs x1 x2 x3) t\\<^sub>2", "apply (erule vrelated.cases; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 t\\<^sub>2.\n       \\<lbrakk>\\<And>x3a t\\<^sub>2.\n                   \\<lbrakk>x3a \\<in> fmran' x3;\n                    \\<turnstile>\\<^sub>v x3a \\<approx> t\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> veq_structure x3a t\\<^sub>2;\n        \\<turnstile>\\<^sub>v Vrecabs x1 x2 x3 \\<approx> t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> veq_structure (Vrecabs x1 x2 x3) t\\<^sub>2", "apply (erule vrelated.cases; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  veq_structure t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "fix name name' and ts us :: \"value list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name ts name' us.\n       (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n       (name = name' \\<and> list_all2 vrelated ts us)", "show \"\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us \\<longleftrightarrow> (name = name' \\<and> list_all2 vrelated ts us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n    (name = name' \\<and> list_all2 vrelated ts us)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<turnstile>\\<^sub>v\n    Vconstr name ts \\<approx> Vconstr name' us \\<Longrightarrow>\n    name = name'\n 2. \\<turnstile>\\<^sub>v\n    Vconstr name ts \\<approx> Vconstr name' us \\<Longrightarrow>\n    list_all2 vrelated ts us\n 3. \\<lbrakk>list_all2 vrelated ts us; name = name'\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>v\n                      Vconstr name' ts \\<approx> Vconstr name' us", "assume \"\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us\""], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us\n\ngoal (3 subgoals):\n 1. \\<turnstile>\\<^sub>v\n    Vconstr name ts \\<approx> Vconstr name' us \\<Longrightarrow>\n    name = name'\n 2. \\<turnstile>\\<^sub>v\n    Vconstr name ts \\<approx> Vconstr name' us \\<Longrightarrow>\n    list_all2 vrelated ts us\n 3. \\<lbrakk>list_all2 vrelated ts us; name = name'\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>v\n                      Vconstr name' ts \\<approx> Vconstr name' us", "thus \"name = name'\" \"list_all2 vrelated ts us\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us\n\ngoal (1 subgoal):\n 1. name = name' &&& list_all2 vrelated ts us", "by (cases; auto)+"], ["proof (state)\nthis:\n  name = name'\n  list_all2 vrelated ts us\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 vrelated ts us; name = name'\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>v\n                      Vconstr name' ts \\<approx> Vconstr name' us", "qed (auto intro: vrelated.intros)"], ["proof (state)\nthis:\n  (\\<turnstile>\\<^sub>v Vconstr name ts \\<approx> Vconstr name' us) =\n  (name = name' \\<and> list_all2 vrelated ts us)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The technically involved relation @{term vrelated} implies a weaker, but more intuitive property:\n  If @{prop \"\\<turnstile>\\<^sub>v t \\<approx> u\"} then \\<open>t\\<close> and \\<open>u\\<close> are equal after termification (i.e. conversion with\n  @{term value_to_sterm}). In fact, if both terms are ground terms, it collapses to equality. This\n  follows directly from the interpretation of @{const value_struct_rel}.\n\\<close>"], ["", "lemma veval'_correct:\n  assumes \"\\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>2\" \"wellformed t\" \"wellformed_venv \\<Gamma>\\<^sub>2\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\\<^sub>2\"\n  assumes \"welldefined t\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\"\n  assumes \"fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\"\n  assumes \"fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\"\n  obtains v\\<^sub>1 where \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\" \"\\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n                 v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1 \\<and>\n       \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>2\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts t |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1 \\<and>\n       \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2", "proof (induction arbitrary: \\<Gamma>\\<^sub>1)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case (const name \\<Gamma>\\<^sub>2 val\\<^sub>2)"], ["proof (state)\nthis:\n  name |\\<notin>| C\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Sconst name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"fmrel_on_fset {|name|} vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\""], ["proof (prove)\nusing this:\n  name |\\<notin>| C\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Sconst name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmrel_on_fset {|name|} vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  fmrel_on_fset {|name|} vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"rel_option vrelated (fmlookup (fmap_of_list rs) name) (fmlookup \\<Gamma>\\<^sub>2 name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup \\<Gamma>\\<^sub>2 name)", "apply (rule fmrel_on_fsetD[where S = \"{|name|}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>| {|name|}\n 2. fmrel_on_fset {|name|} vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset {|name|} vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)", "obtain val\\<^sub>1 where \"fmlookup (fmap_of_list rs) name = Some val\\<^sub>1\" \"\\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>fmlookup (fmap_of_list rs) name = Some val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using const"], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n  name |\\<notin>| C\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Sconst name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>fmlookup (fmap_of_list rs) name = Some val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmlookup (fmap_of_list rs) name = Some val\\<^sub>1\n  \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"(name, val\\<^sub>1) \\<in> set rs\""], ["proof (prove)\nusing this:\n  fmlookup (fmap_of_list rs) name = Some val\\<^sub>1\n  \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (1 subgoal):\n 1. (name, val\\<^sub>1) \\<in> set rs", "by (auto dest: fmap_of_list_SomeD)"], ["proof (state)\nthis:\n  (name, val\\<^sub>1) \\<in> set rs\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sconst name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sconst name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Sconst name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sconst name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Sconst name \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Sconst name \\<down> ?v\\<^sub>1\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (rule veval.const)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (name, ?v\\<^sub>1) \\<in> set rs\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Sconst name \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case (var \\<Gamma>\\<^sub>2 name val\\<^sub>2)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Svar name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"fmrel_on_fset {|name|} vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\""], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Svar name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmrel_on_fset {|name|} vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  fmrel_on_fset {|name|} vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name) (fmlookup \\<Gamma>\\<^sub>2 name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name)\n     (fmlookup \\<Gamma>\\<^sub>2 name)", "apply (rule fmrel_on_fsetD[where S = \"{|name|}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. name |\\<in>| {|name|}\n 2. fmrel_on_fset {|name|} vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset {|name|} vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)", "obtain val\\<^sub>1 where \"fmlookup \\<Gamma>\\<^sub>1 name = Some val\\<^sub>1\" \"\\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>fmlookup \\<Gamma>\\<^sub>1 name = Some val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using var"], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup \\<Gamma>\\<^sub>1 name)\n   (fmlookup \\<Gamma>\\<^sub>2 name)\n  fmlookup \\<Gamma>\\<^sub>2 name = Some val\\<^sub>2\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (Svar name) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>fmlookup \\<Gamma>\\<^sub>1 name = Some val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>\\<^sub>1 name = Some val\\<^sub>1\n  \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Svar name) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Svar name)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (Svar name)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Svar name \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Svar name \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Svar name \\<down> ?v\\<^sub>1\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (rule veval.var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma>\\<^sub>1 name = Some ?v\\<^sub>1\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Svar name \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case abs"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (Sabs cs_)\n  wellformed_venv \\<Gamma>_\n  \\<not> shadows_consts (Sabs cs_)\n  not_shadows_vconsts_env \\<Gamma>_\n  consts (Sabs cs_) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs_)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>_\n  fmrel_on_fset (consts (Sabs cs_)) vrelated (fmap_of_list rs) \\<Gamma>_\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>\\<^sub>1.\n       \\<lbrakk>pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (Sabs cs) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n        fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            Sabs cs \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "thus ?case"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (Sabs cs_)\n  wellformed_venv \\<Gamma>_\n  \\<not> shadows_consts (Sabs cs_)\n  not_shadows_vconsts_env \\<Gamma>_\n  consts (Sabs cs_) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs_)) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>_\n  fmrel_on_fset (consts (Sabs cs_)) vrelated (fmap_of_list rs) \\<Gamma>_\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Sabs cs_ \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n       v\\<^sub>1 \\<approx> Vabs cs_ \\<Gamma>_", "by (auto intro!: veval.abs vrelated.abs)"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v Sabs cs_ \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     v\\<^sub>1 \\<approx> Vabs cs_ \\<Gamma>_\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case (comb \\<Gamma>\\<^sub>2 t cs \\<Gamma>'\\<^sub>2 u u'\\<^sub>2 env\\<^sub>2 pat rhs val\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"\\<exists>v. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and> \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n       \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2", "obtain v where \"\\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\" \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2;\n         rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v", "obtain \\<Gamma>'\\<^sub>1\n    where \"v = Vabs cs \\<Gamma>'\\<^sub>1\"\n      and \"fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1 \\<Gamma>'\\<^sub>2\"\n      and \"fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) \\<Gamma>'\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'\\<^sub>1.\n        \\<lbrakk>v = Vabs cs \\<Gamma>'\\<^sub>1;\n         fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n          \\<Gamma>'\\<^sub>2;\n         fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n          \\<Gamma>'\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v = Vabs cs \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n  v = Vabs cs \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   \\<Gamma>'\\<^sub>2", "have \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n  v = Vabs cs \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n    Vabs cs \\<Gamma>'\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n  Vabs cs \\<Gamma>'\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"\\<exists>u\\<^sub>1'. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and> \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1'.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n       \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1'.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n       \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "obtain u'\\<^sub>1 where \"\\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2\" \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u'\\<^sub>1.\n        \\<lbrakk>\\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2;\n         rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down>\n         u'\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1) (vfind_match cs u'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n     (vfind_match cs u'\\<^sub>2)", "by (rule vrelated.vfind_match_rel') fact"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)", "obtain env\\<^sub>1 where \"vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs)\" \"fmrel vrelated env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs);\n         fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>vfind_match cs u'\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs);\n         fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs)\n  fmrel vrelated env\\<^sub>1 env\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "using \\<open>wellformed (t $\\<^sub>s u)\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"wellformed_venv \\<Gamma>'\\<^sub>2\""], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"vwelldefined v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined v", "apply (rule veval_welldefined)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs, ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\n 2. fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\n 3. consts ?t |\\<subseteq>| all_consts", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by simp"], ["proof (state)\nthis:\n  vwelldefined v\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\""], ["proof (prove)\nusing this:\n  vwelldefined v\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "unfolding \\<open>v = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "."], ["proof (state)\nthis:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"linear pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"fmdom env\\<^sub>1 = patvars (mk_pat pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>1 = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat) ?v = Some env\\<^sub>1", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ?cs2 ?v = Some (env\\<^sub>1, pat, ?rhs2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "with \\<open>linear pat\\<close>"], ["proof (chain)\npicking this:\n  linear pat\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)", "have \"fmdom env\\<^sub>1 = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>1 = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>1 = frees pat\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"fmdom env\\<^sub>2 = patvars (mk_pat pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat) ?v = Some env\\<^sub>2", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ?cs2 ?v = Some (env\\<^sub>2, pat, ?rhs2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "with \\<open>linear pat\\<close>"], ["proof (chain)\npicking this:\n  linear pat\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)", "have \"fmdom env\\<^sub>2 = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"\\<exists>val\\<^sub>1. rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>val\\<^sub>1.\n       rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n       rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n       val\\<^sub>1 \\<approx> val\\<^sub>2", "proof (rule comb)"], ["proof (state)\ngoal (8 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 8. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "show \"fmrel_on_fset (frees rhs) vrelated (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "assume \"name |\\<in>| frees rhs\""], ["proof (state)\nthis:\n  name |\\<in>| frees rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "show \"rel_option vrelated (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name) (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "proof (cases \"name |\\<in>| frees pat\")"], ["proof (state)\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "case True"], ["proof (state)\nthis:\n  name |\\<in>| frees pat\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "hence \"name |\\<in>| fmdom env\\<^sub>1\" \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>1 &&& name |\\<in>| fmdom env\\<^sub>2", "using \\<open>fmdom env\\<^sub>1 = frees pat\\<close> \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| frees pat\n  fmdom env\\<^sub>1 = frees pat\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>1 &&& name |\\<in>| fmdom env\\<^sub>2", "by simp+"], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>1\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "hence \"fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name = fmlookup env\\<^sub>1 name\" \"fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name = fmlookup env\\<^sub>2 name\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>1\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup env\\<^sub>1 name &&&\n    fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n    fmlookup env\\<^sub>2 name", "by auto"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup env\\<^sub>2 name\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup env\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "using \\<open>fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup env\\<^sub>2 name\n  fmrel vrelated env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "by auto"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "case False"], ["proof (state)\nthis:\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "hence \"name |\\<notin>| fmdom env\\<^sub>1\" \"name |\\<notin>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>1 &&& name |\\<notin>| fmdom env\\<^sub>2", "using \\<open>fmdom env\\<^sub>1 = frees pat\\<close> \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n  fmdom env\\<^sub>1 = frees pat\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>1 &&& name |\\<notin>| fmdom env\\<^sub>2", "by simp+"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "hence \"fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name = fmlookup \\<Gamma>'\\<^sub>1 name\" \"fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name = fmlookup \\<Gamma>'\\<^sub>2 name\""], ["proof (prove)\nusing this:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup \\<Gamma>'\\<^sub>1 name &&&\n    fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n    fmlookup \\<Gamma>'\\<^sub>2 name", "by auto"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "moreover"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "have \"name |\\<in>| frees (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sabs cs)", "using False \\<open>name |\\<in>| frees rhs\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n  name |\\<in>| frees rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sabs cs)", "apply (auto simp: ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       (fset_of_list\n                         (map (\\<lambda>(pat, rhs). frees rhs |-| frees pat)\n                           cs))\n                       ((|\\<in>|) name)", "apply (rule fBexI[where x = \"frees rhs |-| frees pat\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> name |\\<in>| frees rhs |-| frees pat\n 2. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> frees rhs |-| frees pat |\\<in>|\n                      fset_of_list\n                       (map (\\<lambda>(pat, rhs). frees rhs |-| frees pat)\n                         cs)", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  name |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "ultimately"], ["proof (chain)\npicking this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "using \\<open>fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1 \\<Gamma>'\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (frees rhs) vrelated\n   (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "have \"not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "thus \"\\<not> shadows_consts rhs\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (6 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "show \"not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n 2. not_shadows_vconsts_env env\\<^sub>2", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n 2. not_shadows_vconsts_env env\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env\\<^sub>2", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\\<^sub>2\n 2. not_shadows_vconsts ?v4", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs7 ?v4 = Some (env\\<^sub>2, ?pat7, ?rhs7)\n 2. not_shadows_vconsts ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts u'\\<^sub>2", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>10 \\<turnstile>\\<^sub>v ?t10 \\<down> u'\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>10\n 3. \\<not> shadows_consts ?t10", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 2. \\<not> shadows_consts u", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n\ngoal (5 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 5. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "show \"fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "assume \"name |\\<in>| consts rhs\""], ["proof (state)\nthis:\n  name |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "hence \"name |\\<in>| consts (Sabs cs)\""], ["proof (prove)\nusing this:\n  name |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. name |\\<in>| consts (Sabs cs)", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| consts rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. name |\\<in>| consts (Sabs cs)", "by (auto intro!: fBexI simp: fset_of_list_elem ffUnion_alt_def)"], ["proof (state)\nthis:\n  name |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "hence \"rel_option vrelated (fmlookup (fmap_of_list rs) name) (fmlookup \\<Gamma>'\\<^sub>2 name)\""], ["proof (prove)\nusing this:\n  name |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup \\<Gamma>'\\<^sub>2 name)", "using \\<open>fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) \\<Gamma>'\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| consts (Sabs cs)\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup \\<Gamma>'\\<^sub>2 name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>'\\<^sub>2 name)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "moreover"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>'\\<^sub>2 name)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "have \"name |\\<notin>| fmdom env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "assume \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"fmlookup env\\<^sub>2 name \\<noteq> None\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup env\\<^sub>2 name \\<noteq> None", "by (meson fmdom_notI)"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>2 name \\<noteq> None\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fmlookup env\\<^sub>2 name \\<noteq> None", "obtain v where \"fmlookup env\\<^sub>2 name = Some v\""], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>2 name \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        fmlookup env\\<^sub>2 name = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>2 name = Some v\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>2 name = Some v\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| frees pat\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees pat", "using \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees pat", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "have \"welldefined rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using \\<open>vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\""], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs |\\<union>| C", "using \\<open>name |\\<in>| consts rhs\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n  name |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs |\\<union>| C", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "have \"\\<not> shadows_consts pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts pat", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts pat", "by (auto simp: list_all_iff shadows_consts_def all_consts_def)"], ["proof (state)\nthis:\n  \\<not> shadows_consts pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat", "show False"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat\n\ngoal (1 subgoal):\n 1. False", "using \\<open>name |\\<in>| frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. False", "unfolding shadows_consts_def fdisjnt_alt_def all_consts_def"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> fst |`| fset_of_list rs |\\<union>| C |\\<inter>|\n         all_frees pat \\<noteq>\n         {||}\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) x)", "ultimately"], ["proof (chain)\npicking this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>'\\<^sub>2 name)\n  name |\\<notin>| fmdom env\\<^sub>2", "show \"rel_option vrelated (fmlookup (fmap_of_list rs) name) (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\""], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup \\<Gamma>'\\<^sub>2 name)\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)", "by simp"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"wellformed_venv \\<Gamma>'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'\\<^sub>2", "by fact"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"wellformed_venv env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env\\<^sub>2", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\\<^sub>2\n 2. vwellformed ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env\\<^sub>2, ?pat3, ?rhs3)\n 2. vwellformed ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed u'\\<^sub>2", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "using \\<open>wellformed (t $\\<^sub>s u)\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv env\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n  wellformed_venv env\\<^sub>2", "show \"wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\nusing this:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n  wellformed_venv env\\<^sub>2\n\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>| all_consts\n 2. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>| all_consts\n 2. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "show \"welldefined rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using \\<open>vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1", "using \\<open>vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1", "apply (rule vwelldefined.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\\<^sub>1\n 2. vwelldefined ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env\\<^sub>1, ?pat3, ?rhs3)\n 2. vwelldefined ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined u'\\<^sub>1", "apply (rule veval_welldefined)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs, ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\\<^sub>1\n 2. fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>6\n 3. consts ?t6 |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n 2. consts u |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2 \\<turnstile>\\<^sub>v rhs \\<down>\n  val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1", "show \"fmpred (\\<lambda>_. vwelldefined) (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "by blast"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined)\n   (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2", "obtain val\\<^sub>1 where \"rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1\" \"\\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1\n                 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n  rhs \\<down> val\\<^sub>1\n  \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vabs cs \\<Gamma>';\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n    ?v\\<^sub>1\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (rule veval.comb)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n    Vabs ?cs2 ?\\<Gamma>'2\n 2. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 4. rs, ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down>\n    ?v\\<^sub>1\n 5. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "next\n  \\<comment> \\<open>Almost verbatim copy from \\<open>comb\\<close> case.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case (rec_comb \\<Gamma>\\<^sub>2 t css name \\<Gamma>'\\<^sub>2 cs u u'\\<^sub>2 env\\<^sub>2 pat rhs val\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"\\<exists>v. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and> \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n       \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2", "obtain v where \"\\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\" \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n     \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<turnstile>\\<^sub>v\n                 v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2;\n         rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "moreover"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v", "obtain \\<Gamma>'\\<^sub>1\n    where \"v = Vrecabs css name \\<Gamma>'\\<^sub>1\"\n      and \"fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1 \\<Gamma>'\\<^sub>2\"\n      and \"fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'\\<^sub>1.\n        \\<lbrakk>v = Vrecabs css name \\<Gamma>'\\<^sub>1;\n         fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n          \\<Gamma>'\\<^sub>2;\n         fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>fmlookup css name = Some cs\\<close>"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n  fmlookup css name = Some cs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'\\<^sub>1.\n        \\<lbrakk>v = Vrecabs css name \\<Gamma>'\\<^sub>1;\n         fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n          \\<Gamma>'\\<^sub>2;\n         fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v = Vrecabs css name \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n  v = Vrecabs css name \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)", "have \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>'\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>v v \\<approx> Vrecabs css name \\<Gamma>'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> v\n  v = Vrecabs css name \\<Gamma>'\\<^sub>1\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n    Vrecabs css name \\<Gamma>'\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"\\<exists>u\\<^sub>1'. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and> \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1'.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n       \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1'.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n       \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2", "obtain u'\\<^sub>1 where \"\\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2\" \"rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1'.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u\\<^sub>1' \\<and>\n     \\<turnstile>\\<^sub>v u\\<^sub>1' \\<approx> u'\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u'\\<^sub>1.\n        \\<lbrakk>\\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2;\n         rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down>\n         u'\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>v u'\\<^sub>1 \\<approx> u'\\<^sub>2\n  rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1) (vfind_match cs u'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n     (vfind_match cs u'\\<^sub>2)", "by (rule vrelated.vfind_match_rel') fact"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)", "obtain env\\<^sub>1 where \"vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs)\" \"fmrel vrelated env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs);\n         fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>vfind_match cs u'\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel vrelated) (=)) (vfind_match cs u'\\<^sub>1)\n   (vfind_match cs u'\\<^sub>2)\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs);\n         fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  vfind_match cs u'\\<^sub>1 = Some (env\\<^sub>1, pat, rhs)\n  fmrel vrelated env\\<^sub>1 env\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>'\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "using \\<open>wellformed (t $\\<^sub>s u)\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"wellformed_venv \\<Gamma>'\\<^sub>2\" \"vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'\\<^sub>2 &&&\n    vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)", "using rec_comb"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'\\<^sub>2 &&&\n    vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"vwelldefined v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined v", "apply (rule veval_welldefined)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs, ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\n 2. fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\n 3. consts ?t |\\<subseteq>| all_consts", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by simp"], ["proof (state)\nthis:\n  vwelldefined v\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)\""], ["proof (prove)\nusing this:\n  vwelldefined v\n\ngoal (1 subgoal):\n 1. vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)", "unfolding \\<open>v = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)", "."], ["proof (state)\nthis:\n  vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "hence \"vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\""], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "using rec_comb"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name \\<Gamma>'\\<^sub>1)\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"linear pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"fmdom env\\<^sub>1 = patvars (mk_pat pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>1 = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat) ?v = Some env\\<^sub>1", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ?cs2 ?v = Some (env\\<^sub>1, pat, ?rhs2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "with \\<open>linear pat\\<close>"], ["proof (chain)\npicking this:\n  linear pat\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)", "have \"fmdom env\\<^sub>1 = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n  fmdom env\\<^sub>1 = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>1 = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>1 = frees pat\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"fmdom env\\<^sub>2 = patvars (mk_pat pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat) ?v = Some env\\<^sub>2", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vfind_match ?cs2 ?v = Some (env\\<^sub>2, pat, ?rhs2)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "with \\<open>linear pat\\<close>"], ["proof (chain)\npicking this:\n  linear pat\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)", "have \"fmdom env\\<^sub>2 = frees pat\""], ["proof (prove)\nusing this:\n  linear pat\n  fmdom env\\<^sub>2 = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "note fset_of_list_map[simp del]"], ["proof (state)\nthis:\n  fset_of_list (map ?f ?xs) = ?f |`| fset_of_list ?xs\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"\\<exists>val\\<^sub>1. rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>val\\<^sub>1.\n       rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n       rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n       val\\<^sub>1 \\<approx> val\\<^sub>2", "proof (rule rec_comb)"], ["proof (state)\ngoal (8 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 8. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "have \"not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>'\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (8 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 5. consts rhs |\\<subseteq>| all_consts\n 6. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 7. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 8. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "thus \"\\<not> shadows_consts rhs\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> rec_comb"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n  (pat, rhs) \\<in> set cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "hence \"fdisjnt all_consts (frees rhs)\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees rhs)", "by (rule shadows_consts_frees)"], ["proof (state)\nthis:\n  fdisjnt all_consts (frees rhs)\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "have \"not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'\\<^sub>2", "using \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "have \"not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2) css)", "using \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2) css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "have \"not_shadows_vconsts_env env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env\\<^sub>2", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\\<^sub>2\n 2. not_shadows_vconsts ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env\\<^sub>2, ?pat3, ?rhs3)\n 2. not_shadows_vconsts ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts u'\\<^sub>2", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 2. \\<not> shadows_consts u", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts u", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\\<^sub>2\n\ngoal (7 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 4. consts rhs |\\<subseteq>| all_consts\n 5. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 6. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 7. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)\n  not_shadows_vconsts_env env\\<^sub>2", "show \"not_shadows_vconsts_env (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env \\<Gamma>'\\<^sub>2\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>'\\<^sub>2)\n  not_shadows_vconsts_env env\\<^sub>2\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n\ngoal (6 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 5. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 6. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "have \"not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)", "using \\<open>not_shadows_vconsts (Vrecabs _ _ _)\\<close> rec_comb"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>'\\<^sub>2)\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (6 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 5. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 6. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "show \"fmrel_on_fset (frees rhs) vrelated (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees rhs) vrelated\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "assume \"name |\\<in>| frees rhs\""], ["proof (state)\nthis:\n  name |\\<in>| frees rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "moreover"], ["proof (state)\nthis:\n  name |\\<in>| frees rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "have \"fmdom css |\\<subseteq>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom css |\\<subseteq>| all_consts", "using \\<open>vwelldefined (Vrecabs _ _ _)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name__ \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. fmdom css |\\<subseteq>| all_consts", "unfolding all_consts_def"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name__ \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. fmdom css |\\<subseteq>| fst |`| fset_of_list rs |\\<union>| C", "by auto"], ["proof (state)\nthis:\n  fmdom css |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "ultimately"], ["proof (chain)\npicking this:\n  name |\\<in>| frees rhs\n  fmdom css |\\<subseteq>| all_consts", "have \"name |\\<notin>| fmdom css\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees rhs\n  fmdom css |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom css", "using \\<open>fdisjnt _ (frees rhs)\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| frees rhs\n  fmdom css |\\<subseteq>| all_consts\n  fdisjnt all_consts (frees rhs)\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom css", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  name |\\<in>| frees rhs\n  fmdom css |\\<subseteq>| all_consts\n  all_consts |\\<inter>| frees rhs = {||}\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom css", "by (metis (full_types) fempty_iff finterI fset_rev_mp)"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom css\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees rhs \\<Longrightarrow>\n       rel_option vrelated\n        (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "show \"rel_option vrelated (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name) (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "proof (cases \"name |\\<in>| frees pat\")"], ["proof (state)\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "case True"], ["proof (state)\nthis:\n  name |\\<in>| frees pat\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "hence \"name |\\<in>| fmdom env\\<^sub>1\" \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>1 &&& name |\\<in>| fmdom env\\<^sub>2", "using \\<open>fmdom env\\<^sub>1 = frees pat\\<close> \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| frees pat\n  fmdom env\\<^sub>1 = frees pat\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>1 &&& name |\\<in>| fmdom env\\<^sub>2", "by simp+"], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>1\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "hence\n                \"fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name = fmlookup env\\<^sub>1 name\"\n                \"fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name = fmlookup env\\<^sub>2 name\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>1\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup env\\<^sub>1 name &&&\n    fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name =\n    fmlookup env\\<^sub>2 name", "by auto"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup env\\<^sub>2 name\n\ngoal (2 subgoals):\n 1. name |\\<in>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)\n 2. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup env\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "using \\<open>fmrel vrelated env\\<^sub>1 env\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup env\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup env\\<^sub>2 name\n  fmrel vrelated env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "by auto"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name)\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "case False"], ["proof (state)\nthis:\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "hence \"name |\\<notin>| fmdom env\\<^sub>1\" \"name |\\<notin>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>1 &&& name |\\<notin>| fmdom env\\<^sub>2", "using \\<open>fmdom env\\<^sub>1 = frees pat\\<close> \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n  fmdom env\\<^sub>1 = frees pat\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>1 &&& name |\\<notin>| fmdom env\\<^sub>2", "by simp+"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "hence\n                \"fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name = fmlookup \\<Gamma>'\\<^sub>1 name\"\n                \"fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name = fmlookup \\<Gamma>'\\<^sub>2 name\""], ["proof (prove)\nusing this:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup \\<Gamma>'\\<^sub>1 name &&&\n    fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name =\n    fmlookup \\<Gamma>'\\<^sub>2 name", "unfolding mk_rec_env_def"], ["proof (prove)\nusing this:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup \\<Gamma>'\\<^sub>1 name &&&\n    fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2)\n       css ++\\<^sub>f\n      env\\<^sub>2)\n     name =\n    fmlookup \\<Gamma>'\\<^sub>2 name", "using \\<open>name |\\<notin>| fmdom css\\<close>"], ["proof (prove)\nusing this:\n  name |\\<notin>| fmdom env\\<^sub>1\n  name |\\<notin>| fmdom env\\<^sub>2\n  name |\\<notin>| fmdom css\n\ngoal (1 subgoal):\n 1. fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n    fmlookup \\<Gamma>'\\<^sub>1 name &&&\n    fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2)\n       css ++\\<^sub>f\n      env\\<^sub>2)\n     name =\n    fmlookup \\<Gamma>'\\<^sub>2 name", "by auto"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "moreover"], ["proof (state)\nthis:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "have \"name |\\<in>| frees (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sabs cs)", "using False \\<open>name |\\<in>| frees rhs\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  name |\\<notin>| frees pat\n  name |\\<in>| frees rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sabs cs)", "apply (auto simp: ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       (fset_of_list\n                         (map (\\<lambda>(pat, rhs). frees rhs |-| frees pat)\n                           cs))\n                       ((|\\<in>|) name)", "apply (rule fBexI[where x = \"frees rhs |-| frees pat\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> name |\\<in>| frees rhs |-| frees pat\n 2. \\<lbrakk>name |\\<notin>| frees pat; name |\\<in>| frees rhs;\n     (pat, rhs) \\<in> set cs\\<rbrakk>\n    \\<Longrightarrow> frees rhs |-| frees pat |\\<in>|\n                      fset_of_list\n                       (map (\\<lambda>(pat, rhs). frees rhs |-| frees pat)\n                         cs)", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  name |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. name |\\<notin>| frees pat \\<Longrightarrow>\n    rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "ultimately"], ["proof (chain)\npicking this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "using \\<open>fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1 \\<Gamma>'\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name =\n  fmlookup \\<Gamma>'\\<^sub>1 name\n  fmlookup\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n   name =\n  fmlookup \\<Gamma>'\\<^sub>2 name\n  name |\\<in>| frees (Sabs cs)\n  fmrel_on_fset (frees (Sabs cs)) vrelated \\<Gamma>'\\<^sub>1\n   \\<Gamma>'\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated\n     (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option vrelated\n   (fmlookup (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1) name)\n   (fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (frees rhs) vrelated\n   (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n\ngoal (5 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n 5. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "show \"fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "assume \"name |\\<in>| consts rhs\""], ["proof (state)\nthis:\n  name |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "hence \"name |\\<in>| consts (Sabs cs)\""], ["proof (prove)\nusing this:\n  name |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. name |\\<in>| consts (Sabs cs)", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| consts rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. name |\\<in>| consts (Sabs cs)", "by (auto intro!: fBexI simp: fset_of_list_elem ffUnion_alt_def)"], ["proof (state)\nthis:\n  name |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "hence \"rel_option vrelated (fmlookup (fmap_of_list rs) name) (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2) name)\""], ["proof (prove)\nusing this:\n  name |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2) name)", "using \\<open>fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs) (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| consts (Sabs cs)\n  fmrel_on_fset (consts (Sabs cs)) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2) name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n     name)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "moreover"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n     name)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "have \"name |\\<notin>| fmdom env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom env\\<^sub>2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "assume \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"fmlookup env\\<^sub>2 name \\<noteq> None\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmlookup env\\<^sub>2 name \\<noteq> None", "by (meson fmdom_notI)"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>2 name \\<noteq> None\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fmlookup env\\<^sub>2 name \\<noteq> None", "obtain v where \"fmlookup env\\<^sub>2 name = Some v\""], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>2 name \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        fmlookup env\\<^sub>2 name = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>2 name = Some v\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>2 name = Some v\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| frees pat\""], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees pat", "using \\<open>fmdom env\\<^sub>2 = frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom env\\<^sub>2\n  fmdom env\\<^sub>2 = frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees pat", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "have \"vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "using \\<open>vwelldefined (Vrecabs css _ \\<Gamma>'\\<^sub>1)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name__ \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "using rec_comb"], ["proof (prove)\nusing this:\n  vwelldefined (Vrecabs css name__ \\<Gamma>'\\<^sub>1)\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name__ \\<Gamma>'\\<^sub>2\n  fmlookup css name__ = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name__\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"welldefined rhs\""], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using \\<open>(pat, rhs) \\<in> set cs\\<close> rec_comb"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n  (pat, rhs) \\<in> set cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name__ \\<Gamma>'\\<^sub>2\n  fmlookup css name__ = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name__\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "hence \"name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\""], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs |\\<union>| C", "using \\<open>name |\\<in>| consts rhs\\<close> all_consts_def"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n  name |\\<in>| consts rhs\n  all_consts = fst |`| fset_of_list rs |\\<union>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs |\\<union>| C", "by blast"], ["proof (state)\nthis:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "have \"\\<not> shadows_consts pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts pat", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>'\\<^sub>2)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts pat", "by (auto simp: list_all_iff shadows_consts_def all_consts_def)"], ["proof (state)\nthis:\n  \\<not> shadows_consts pat\n\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom env\\<^sub>2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat", "show False"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat\n\ngoal (1 subgoal):\n 1. False", "using \\<open>name |\\<in>| frees pat\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> shadows_consts pat\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. False", "unfolding shadows_consts_def fdisjnt_alt_def all_consts_def"], ["proof (prove)\nusing this:\n  name |\\<in>| fst |`| fset_of_list rs |\\<union>| C\n  \\<not> fst |`| fset_of_list rs |\\<union>| C |\\<inter>|\n         all_frees pat \\<noteq>\n         {||}\n  name |\\<in>| frees pat\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| consts rhs \\<Longrightarrow>\n       rel_option vrelated (fmlookup (fmap_of_list rs) x)\n        (fmlookup\n          (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n           env\\<^sub>2)\n          x)", "ultimately"], ["proof (chain)\npicking this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n     name)\n  name |\\<notin>| fmdom env\\<^sub>2", "show \"rel_option vrelated (fmlookup (fmap_of_list rs) name) (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2) name)\""], ["proof (prove)\nusing this:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2)\n     name)\n  name |\\<notin>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option vrelated (fmlookup (fmap_of_list rs) name)\n     (fmlookup\n       (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n        env\\<^sub>2)\n       name)", "by simp"], ["proof (state)\nthis:\n  rel_option vrelated (fmlookup (fmap_of_list rs) name)\n   (fmlookup\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n     name)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 3. consts rhs |\\<subseteq>| all_consts\n 4. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"wellformed_venv \\<Gamma>'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'\\<^sub>2", "by fact"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"wellformed_venv env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env\\<^sub>2", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\\<^sub>2\n 2. vwellformed ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env\\<^sub>2, ?pat3, ?rhs3)\n 2. vwellformed ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed u'\\<^sub>2", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t6\n 3. wellformed_venv ?\\<Gamma>6", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "using \\<open>wellformed (t $\\<^sub>s u)\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv env\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  wellformed_venv env\\<^sub>2\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"wellformed_venv (mk_rec_env css \\<Gamma>'\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>'\\<^sub>2)", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2) css)", "using \\<open>vwellformed (Vrecabs _ _ _)\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmmap_keys (\\<lambda>name cs. Vrecabs css name \\<Gamma>'\\<^sub>2) css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  wellformed_venv (mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (3 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)\n 2. consts rhs |\\<subseteq>| all_consts\n 3. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n  wellformed_venv env\\<^sub>2\n  wellformed_venv (mk_rec_env css \\<Gamma>'\\<^sub>2)", "show \"wellformed_venv (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\nusing this:\n  wellformed_venv \\<Gamma>'\\<^sub>2\n  wellformed_venv env\\<^sub>2\n  wellformed_venv (mk_rec_env css \\<Gamma>'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n      env\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  wellformed_venv\n   (\\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n    env\\<^sub>2)\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>| all_consts\n 2. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>| all_consts\n 2. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "show \"welldefined rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using \\<open>vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1", "using \\<open>vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined (Vabs cs \\<Gamma>'\\<^sub>1)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "have \"fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1", "apply (rule vwelldefined.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\\<^sub>1\n 2. vwelldefined ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env\\<^sub>1, ?pat3, ?rhs3)\n 2. vwelldefined ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined u'\\<^sub>1", "apply (rule veval_welldefined)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs, ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> u'\\<^sub>1\n 2. fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>6\n 3. consts ?t6 |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n 2. consts u |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>'\\<^sub>2\n  fmlookup css name = Some cs\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v u \\<down> u'\\<^sub>2\n  vfind_match cs u'\\<^sub>2 = Some (env\\<^sub>2, pat, rhs)\n  \\<Gamma>'\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n  env\\<^sub>2\n  \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts t |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees t) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v t \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> Vrecabs css name\n      \\<Gamma>'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed u;\n   wellformed_venv \\<Gamma>\\<^sub>2; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<^sub>2;\n   consts u |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees u) vrelated ?\\<Gamma>\\<^sub>14 \\<Gamma>\\<^sub>2;\n   fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n    \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v u \\<down>\n                       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> u'\\<^sub>2\n  \\<lbrakk>pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   consts rhs |\\<subseteq>| all_consts;\n   fmpred (\\<lambda>_. vwelldefined) ?\\<Gamma>\\<^sub>14;\n   fmrel_on_fset (frees rhs) vrelated ?\\<Gamma>\\<^sub>14\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2);\n   fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n    (\\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     mk_rec_env css \\<Gamma>'\\<^sub>2 ++\\<^sub>f\n     env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                       rs, ?\\<Gamma>\\<^sub>14 \\<turnstile>\\<^sub>v\n                       rhs \\<down> v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                       v\\<^sub>1 \\<approx> val\\<^sub>2\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (t $\\<^sub>s u) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. consts u |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1", "show \"fmpred (\\<lambda>_. vwelldefined) (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>'\\<^sub>1\n  fmpred (\\<lambda>_. vwelldefined) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined)\n     (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)", "by blast"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined)\n   (\\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2", "obtain val\\<^sub>1 where \"rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1\" \"\\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>val\\<^sub>1.\n     rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n     rhs \\<down> val\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>val\\<^sub>1.\n        \\<lbrakk>rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1\n                 \\<turnstile>\\<^sub>v rhs \\<down> val\\<^sub>1;\n         \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs, \\<Gamma>'\\<^sub>1 ++\\<^sub>f env\\<^sub>1 \\<turnstile>\\<^sub>v\n  rhs \\<down> val\\<^sub>1\n  \\<turnstile>\\<^sub>v val\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val\n       \\<Gamma>\\<^sub>1.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts t |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts t) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                t \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> Vrecabs css name\n               \\<Gamma>';\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed u;\n            wellformed_venv \\<Gamma>; \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>;\n            consts u |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees u) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>;\n            fmrel_on_fset (consts u) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                u \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> u';\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>\\<^sub>1.\n           \\<lbrakk>pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            consts rhs |\\<subseteq>| all_consts;\n            fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n            fmrel_on_fset (frees rhs) vrelated \\<Gamma>\\<^sub>1\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fmrel_on_fset (consts rhs) vrelated (fmap_of_list rs)\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                                rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                                rhs \\<down> v\\<^sub>1 \\<and>\n                                \\<turnstile>\\<^sub>v\n                                v\\<^sub>1 \\<approx> val;\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (t $\\<^sub>s u) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (t $\\<^sub>s u)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (t $\\<^sub>s u)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            t $\\<^sub>s u \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (intro conjI exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n    ?v\\<^sub>1\n 2. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply (rule veval.rec_comb)"], ["proof (prove)\ngoal (6 subgoals):\n 1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n    Vrecabs ?css2 ?name2 ?\\<Gamma>'2\n 2. fmlookup ?css2 ?name2 = Some ?cs2\n 3. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v u \\<down> ?u'2\n 4. vfind_match ?cs2 ?u'2 = Some (?env2, ?uv2, ?rhs2)\n 5. rs, ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down>\n    ?v\\<^sub>1\n 6. \\<turnstile>\\<^sub>v ?v\\<^sub>1 \\<approx> val\\<^sub>2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> val\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "case (constr name \\<Gamma>\\<^sub>2 ts us\\<^sub>2)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (name $$ ts) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "have \"list_all2 (\\<lambda>t u\\<^sub>2. (\\<exists>u\\<^sub>1. rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v u\\<^sub>1 \\<approx> u\\<^sub>2)) ts us\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>t u\\<^sub>2.\n         \\<exists>u\\<^sub>1.\n            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n            u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n            u\\<^sub>1 \\<approx> u\\<^sub>2)\n     ts us\\<^sub>2", "using \\<open>list_all2 _ ts us\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>t u\\<^sub>2.\n         \\<exists>u\\<^sub>1.\n            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n            u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n            u\\<^sub>1 \\<approx> u\\<^sub>2)\n     ts us\\<^sub>2", "proof (rule list.rel_mono_strong, elim conjE impE allE exE)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed z\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>2\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts z\n 4. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 5. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> consts z |\\<subseteq>| all_consts\n 6. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined) (?x9 z yb)\n 7. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated (?x9 z yb)\n                          \\<Gamma>\\<^sub>2\n 8. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 9. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, ?x9 z yb \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "fix t u\\<^sub>2"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed z\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>2\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts z\n 4. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 5. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> consts z |\\<subseteq>| all_consts\n 6. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined) (?x9 z yb)\n 7. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated (?x9 z yb)\n                          \\<Gamma>\\<^sub>2\n 8. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 9. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, ?x9 z yb \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "assume \"t \\<in> set ts\" \"u\\<^sub>2 \\<in> set us\\<^sub>2\""], ["proof (state)\nthis:\n  t \\<in> set ts\n  u\\<^sub>2 \\<in> set us\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed z\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>2\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts z\n 4. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 5. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> consts z |\\<subseteq>| all_consts\n 6. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined) (?x9 z yb)\n 7. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated (?x9 z yb)\n                          \\<Gamma>\\<^sub>2\n 8. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 9. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, ?x9 z yb \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "assume \"\\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> u\\<^sub>2\""], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> u\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed z\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>2\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> \\<not> shadows_consts z\n 4. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 5. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> consts z |\\<subseteq>| all_consts\n 6. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined) (?x9 z yb)\n 7. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated (?x9 z yb)\n                          \\<Gamma>\\<^sub>2\n 8. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 9. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, ?x9 z yb \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "show \"wellformed t\" \"welldefined t\" \"\\<not> shadows_consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t &&&\n    consts t |\\<subseteq>| all_consts &&& \\<not> shadows_consts t", "using constr \\<open>t \\<in> set ts\\<close>"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (name $$ ts) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t &&&\n    consts t |\\<subseteq>| all_consts &&& \\<not> shadows_consts t", "unfolding welldefined.list_comb wellformed.list_comb shadows.list_comb"], ["proof (prove)\nusing this:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed ts\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> (shadows_consts (const name) \\<or> list_ex shadows_consts ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (const name) |\\<subseteq>| all_consts \\<and>\n  list_all (\\<lambda>t. consts t |\\<subseteq>| all_consts) ts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t &&&\n    consts t |\\<subseteq>| all_consts &&& \\<not> shadows_consts t", "by (auto simp: list_all_iff list_ex_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| all_consts\n  \\<not> shadows_consts t\n\ngoal (6 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>2\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 3. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined) (?x9 z yb)\n 4. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated (?x9 z yb)\n                          \\<Gamma>\\<^sub>2\n 5. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 6. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, ?x9 z yb \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "show\n        \"wellformed_venv \\<Gamma>\\<^sub>2\"\n        \"not_shadows_vconsts_env \\<Gamma>\\<^sub>2\"\n        \"fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>\\<^sub>2 &&&\n    not_shadows_vconsts_env \\<Gamma>\\<^sub>2 &&&\n    fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1", "by fact+"], ["proof (state)\nthis:\n  wellformed_venv \\<Gamma>\\<^sub>2\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 3. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "have \"consts t |\\<in>| fset_of_list (map consts ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<in>| fset_of_list (map consts ts)", "using \\<open>t \\<in> set ts\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. consts t |\\<in>| fset_of_list (map consts ts)", "by (simp add: fset_of_list_elem)"], ["proof (state)\nthis:\n  consts t |\\<in>| fset_of_list (map consts ts)\n\ngoal (3 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 3. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "hence \"consts t |\\<subseteq>| consts (name $$ ts)\""], ["proof (prove)\nusing this:\n  consts t |\\<in>| fset_of_list (map consts ts)\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| consts (name $$ ts)", "unfolding consts_list_comb"], ["proof (prove)\nusing this:\n  consts t |\\<in>| fset_of_list (map consts ts)\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>|\n    consts (const name) |\\<union>| ffUnion (fset_of_list (map consts ts))", "by (metis ffUnion_subset_elem le_supI2)"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| consts (name $$ ts)\n\ngoal (3 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (consts z) vrelated (fmap_of_list rs)\n                          \\<Gamma>\\<^sub>2\n 3. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "thus \"fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\""], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2", "using constr"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| consts (name $$ ts)\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (name $$ ts) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2", "by (blast intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "have \"frees t |\\<in>| fset_of_list (map frees ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<in>| fset_of_list (map frees ts)", "using \\<open>t \\<in> set ts\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. frees t |\\<in>| fset_of_list (map frees ts)", "by (simp add: fset_of_list_elem)"], ["proof (state)\nthis:\n  frees t |\\<in>| fset_of_list (map frees ts)\n\ngoal (2 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "hence \"frees t |\\<subseteq>| frees (name $$ ts)\""], ["proof (prove)\nusing this:\n  frees t |\\<in>| fset_of_list (map frees ts)\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees (name $$ ts)", "unfolding frees_list_comb const_sterm_def freess_def"], ["proof (prove)\nusing this:\n  frees t |\\<in>| fset_of_list (map frees ts)\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>|\n    frees (Sconst name) |\\<union>|\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) ts", "by (auto intro!: ffUnion_subset_elem)"], ["proof (state)\nthis:\n  frees t |\\<subseteq>| frees (name $$ ts)\n\ngoal (2 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb\\<rbrakk>\n       \\<Longrightarrow> fmrel_on_fset (frees z) vrelated \\<Gamma>\\<^sub>1\n                          \\<Gamma>\\<^sub>2\n 2. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "thus \"fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\""], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| frees (name $$ ts)\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2", "using constr"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| frees (name $$ ts)\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (name $$ ts) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2", "by (blast intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  fmrel_on_fset (frees t) vrelated \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>z yb v\\<^sub>1.\n       \\<lbrakk>z \\<in> set ts; yb \\<in> set us\\<^sub>2;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma>\\<^sub>2 \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us\\<^sub>2;\n        \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v z \\<down> yb;\n        rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v z \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> yb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            z \\<down> u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n                            u\\<^sub>1 \\<approx> yb", "qed auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>t u\\<^sub>2.\n       \\<exists>u\\<^sub>1.\n          rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n          u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n          u\\<^sub>1 \\<approx> u\\<^sub>2)\n   ts us\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "then"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>t u\\<^sub>2.\n       \\<exists>u\\<^sub>1.\n          rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n          u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n          u\\<^sub>1 \\<approx> u\\<^sub>2)\n   ts us\\<^sub>2", "obtain us\\<^sub>1 where \"list_all2 (veval rs \\<Gamma>\\<^sub>1) ts us\\<^sub>1\" \"list_all2 vrelated us\\<^sub>1 us\\<^sub>2\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>t u\\<^sub>2.\n       \\<exists>u\\<^sub>1.\n          rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v t \\<down>\n          u\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n          u\\<^sub>1 \\<approx> u\\<^sub>2)\n   ts us\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>us\\<^sub>1.\n        \\<lbrakk>list_all2 (veval rs \\<Gamma>\\<^sub>1) ts us\\<^sub>1;\n         list_all2 vrelated us\\<^sub>1 us\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induction auto"], ["proof (state)\nthis:\n  list_all2 (veval rs \\<Gamma>\\<^sub>1) ts us\\<^sub>1\n  list_all2 vrelated us\\<^sub>1 us\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>\\<^sub>1.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n              wellformed_venv \\<Gamma> \\<longrightarrow>\n              \\<not> shadows_consts x1 \\<longrightarrow>\n              not_shadows_vconsts_env \\<Gamma> \\<longrightarrow>\n              consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n              (\\<forall>x.\n                  fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n                  fmrel_on_fset (frees x1) vrelated x\n                   \\<Gamma> \\<longrightarrow>\n                  fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n                   \\<Gamma> \\<longrightarrow>\n                  (\\<exists>v\\<^sub>1.\n                      rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                      \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n         ts us;\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>;\n        consts (name $$ ts) |\\<subseteq>| all_consts;\n        fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1;\n        fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n         \\<Gamma>;\n        fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n         \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1.\n                            rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v\n                            name $$ ts \\<down> v\\<^sub>1 \\<and>\n                            \\<turnstile>\\<^sub>v\n                            v\\<^sub>1 \\<approx> Vconstr name us", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 (veval rs \\<Gamma>\\<^sub>1) ts us\\<^sub>1\n  list_all2 vrelated us\\<^sub>1 us\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v name $$ ts \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n       v\\<^sub>1 \\<approx> Vconstr name us\\<^sub>2", "using constr"], ["proof (prove)\nusing this:\n  list_all2 (veval rs \\<Gamma>\\<^sub>1) ts us\\<^sub>1\n  list_all2 vrelated us\\<^sub>1 us\\<^sub>2\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (pre_strong_term_class.wellformed x1 \\<longrightarrow>\n        wellformed_venv \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        \\<not> shadows_consts x1 \\<longrightarrow>\n        not_shadows_vconsts_env \\<Gamma>\\<^sub>2 \\<longrightarrow>\n        consts x1 |\\<subseteq>| all_consts \\<longrightarrow>\n        (\\<forall>x.\n            fmpred (\\<lambda>_. vwelldefined) x \\<longrightarrow>\n            fmrel_on_fset (frees x1) vrelated x\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            fmrel_on_fset (consts x1) vrelated (fmap_of_list rs)\n             \\<Gamma>\\<^sub>2 \\<longrightarrow>\n            (\\<exists>v\\<^sub>1.\n                rs, x \\<turnstile>\\<^sub>v x1 \\<down> v\\<^sub>1 \\<and>\n                \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> x2))))\n   ts us\\<^sub>2\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\\<^sub>2\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n  consts (name $$ ts) |\\<subseteq>| all_consts\n  fmpred (\\<lambda>_. vwelldefined) \\<Gamma>\\<^sub>1\n  fmrel_on_fset (frees (name $$ ts)) vrelated \\<Gamma>\\<^sub>1\n   \\<Gamma>\\<^sub>2\n  fmrel_on_fset (consts (name $$ ts)) vrelated (fmap_of_list rs)\n   \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1.\n       rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v name $$ ts \\<down>\n       v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n       v\\<^sub>1 \\<approx> Vconstr name us\\<^sub>2", "by (auto intro: veval.constr vrelated.constr)"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1.\n     rs, \\<Gamma>\\<^sub>1 \\<turnstile>\\<^sub>v name $$ ts \\<down>\n     v\\<^sub>1 \\<and> \\<turnstile>\\<^sub>v\n     v\\<^sub>1 \\<approx> Vconstr name us\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma veval'_correct':\n  assumes \"\\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>2\" \"wellformed t\" \"wellformed_venv \\<Gamma>\\<^sub>2\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\\<^sub>2\"\n  assumes \"welldefined t\"\n  assumes \"closed t\"\n  assumes \"fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\"\n  obtains v\\<^sub>1 where \"rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\" \"\\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule veval'_correct[where \\<Gamma>\\<^sub>1 = fmempty])"], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?\\<Gamma>\\<^sub>26 \\<turnstile>\\<^sub>v ?t6 \\<down> ?v\\<^sub>26\n 2. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 3. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>\\<^sub>26\n 4. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts ?t6\n 5. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env ?\\<Gamma>\\<^sub>26\n 6. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| all_consts\n 7. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined) fmempty\n 8. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (frees ?t6) vrelated fmempty ?\\<Gamma>\\<^sub>26\n 9. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (consts ?t6) vrelated (fmap_of_list rs) ?\\<Gamma>\\<^sub>26\n 10. \\<And>v\\<^sub>1.\n        \\<lbrakk>\\<And>v\\<^sub>1.\n                    \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                             v\\<^sub>1;\n                     \\<turnstile>\\<^sub>v\n                     v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         rs, fmempty \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> ?v\\<^sub>26\\<rbrakk>\n        \\<Longrightarrow> thesis", "show \"fmpred (\\<lambda>_. vwelldefined) fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined) fmempty", "by simp"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined) fmempty\n\ngoal (9 subgoals):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?\\<Gamma>\\<^sub>26 \\<turnstile>\\<^sub>v ?t6 \\<down> ?v\\<^sub>26\n 2. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 3. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>\\<^sub>26\n 4. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts ?t6\n 5. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env ?\\<Gamma>\\<^sub>26\n 6. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| all_consts\n 7. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (frees ?t6) vrelated fmempty ?\\<Gamma>\\<^sub>26\n 8. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (consts ?t6) vrelated (fmap_of_list rs) ?\\<Gamma>\\<^sub>26\n 9. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                            v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v\n                    v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs, fmempty \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> ?v\\<^sub>26\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?\\<Gamma>\\<^sub>26 \\<turnstile>\\<^sub>v ?t6 \\<down> ?v\\<^sub>26\n 2. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 3. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>\\<^sub>26\n 4. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts ?t6\n 5. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env ?\\<Gamma>\\<^sub>26\n 6. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| all_consts\n 7. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (frees ?t6) vrelated fmempty ?\\<Gamma>\\<^sub>26\n 8. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (consts ?t6) vrelated (fmap_of_list rs) ?\\<Gamma>\\<^sub>26\n 9. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                            v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v\n                    v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs, fmempty \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> ?v\\<^sub>26\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmrel_on_fset (frees t) vrelated fmempty \\<Gamma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t) vrelated fmempty \\<Gamma>\\<^sub>2", "using \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  closed t\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t) vrelated fmempty \\<Gamma>\\<^sub>2", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t) vrelated fmempty \\<Gamma>\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (frees t) vrelated fmempty \\<Gamma>\\<^sub>2\n\ngoal (8 subgoals):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<Gamma>\\<^sub>2 \\<turnstile>\\<^sub>v t \\<down> ?v\\<^sub>26\n 2. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 3. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\\<^sub>2\n 4. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts t\n 5. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env \\<Gamma>\\<^sub>2\n 6. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| all_consts\n 7. (\\<And>v\\<^sub>1.\n        \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (consts t) vrelated (fmap_of_list rs) \\<Gamma>\\<^sub>2\n 8. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>rs, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                            v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v\n                    v\\<^sub>1 \\<approx> v\\<^sub>2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> ?v\\<^sub>26\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (rule assms)+"], ["", "end"], ["", "subsubsection \\<open>Preservation of extensional equality\\<close>"], ["", "lemma (in constants) veval'_agree_eq:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\" \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  obtains v' where \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v'\" \"v' \\<approx>\\<^sub>e v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: \\<Gamma>' thesis)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sconst name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (const name \\<Gamma> val)"], ["proof (state)\nthis:\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sconst name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"name |\\<in>| ids (Sconst name)\""], ["proof (prove)\nusing this:\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. name |\\<in>| ids (Sconst name)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (frees (Sconst name) |\\<union>| consts (Sconst name))\n   erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Sconst name) |\\<union>| consts (Sconst name)", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| ids (Sconst name)\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sconst name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "with const"], ["proof (chain)\npicking this:\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n  name |\\<in>| ids (Sconst name)", "have \"rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\""], ["proof (prove)\nusing this:\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n  name |\\<in>| ids (Sconst name)\n\ngoal (1 subgoal):\n 1. rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sconst name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)", "obtain val' where \"fmlookup \\<Gamma>' name = Some val'\" \"val' \\<approx>\\<^sub>e val\""], ["proof (prove)\nusing this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>fmlookup \\<Gamma>' name = Some val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>fmlookup \\<Gamma> name = Some val\\<close>"], ["proof (prove)\nusing this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n  fmlookup \\<Gamma> name = Some val\n\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>fmlookup \\<Gamma>' name = Some val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (6 subgoals):\n 1. \\<And>name \\<Gamma> val \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<notin>| C; fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sconst name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sconst name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sconst name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (1 subgoal):\n 1. thesis", "using const"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n  name |\\<notin>| C\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sconst name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sconst name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sconst name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sconst name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sconst name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sconst name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: veval'.const)"], ["proof (state)\nthis:\n  thesis\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (var \\<Gamma> name val)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"name |\\<in>| ids (Svar name)\""], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. name |\\<in>| ids (Svar name)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (frees (Svar name) |\\<union>| consts (Svar name)) erelated\n   \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees (Svar name) |\\<union>| consts (Svar name)", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| ids (Svar name)\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "with var"], ["proof (chain)\npicking this:\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n  name |\\<in>| ids (Svar name)", "have \"rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\""], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n  name |\\<in>| ids (Svar name)\n\ngoal (1 subgoal):\n 1. rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)", "by (auto dest: fmrel_on_fsetD)"], ["proof (state)\nthis:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)", "obtain val' where \"fmlookup \\<Gamma>' name = Some val'\" \"val' \\<approx>\\<^sub>e val\""], ["proof (prove)\nusing this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>fmlookup \\<Gamma>' name = Some val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>fmlookup \\<Gamma> name = Some val\\<close>"], ["proof (prove)\nusing this:\n  rel_option erelated (fmlookup \\<Gamma>' name) (fmlookup \\<Gamma> name)\n  fmlookup \\<Gamma> name = Some val\n\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>fmlookup \\<Gamma>' name = Some val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> name val \\<Gamma>' thesis.\n       \\<lbrakk>fmlookup \\<Gamma> name = Some val;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Svar name) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Svar name);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Svar name);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (1 subgoal):\n 1. thesis", "using var"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma>' name = Some val'\n  val' \\<approx>\\<^sub>e val\n  fmlookup \\<Gamma> name = Some val\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Svar name \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Svar name)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Svar name) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Svar name)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Svar name) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Svar name)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: veval'.var)"], ["proof (state)\nthis:\n  thesis\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (abs \\<Gamma> cs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"Vabs cs \\<Gamma>' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. Vabs cs \\<Gamma>' \\<approx>\\<^sub>e Vabs cs \\<Gamma>", "by (auto intro: erelated.abs)"], ["proof (state)\nthis:\n  Vabs cs \\<Gamma>' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> cs \\<Gamma>' thesis.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down>\n                            v';\n                    v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (Sabs cs) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (Sabs cs);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (Sabs cs);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  Vabs cs \\<Gamma>' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "using abs"], ["proof (prove)\nusing this:\n  Vabs cs \\<Gamma>' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v Sabs cs \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (Sabs cs)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (Sabs cs)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: veval'.abs)"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (comb \\<Gamma> t cs \\<Gamma>\\<^sub>\\<Lambda> u v\\<^sub>2 env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S erelated \\<Gamma>' \\<Gamma>\n 2. ids t |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids t |\\<subseteq>| ids (t $\\<^sub>s u)", "unfolding ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<union>| consts t |\\<subseteq>|\n    frees (t $\\<^sub>s u) |\\<union>| consts (t $\\<^sub>s u)", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>", "obtain v\\<^sub>1' where \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\" \"v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1';\n         v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs\n \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using comb"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1';\n         v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs\n \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>\\<Lambda>", "obtain \\<Gamma>\\<^sub>\\<Lambda>' where \"v\\<^sub>1' = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'\" \"fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>\\<Lambda>'.\n        \\<lbrakk>v\\<^sub>1' = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>';\n         fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n          \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: erelated.cases)"], ["proof (state)\nthis:\n  v\\<^sub>1' = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n   \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S erelated \\<Gamma>' \\<Gamma>\n 2. ids u |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids u |\\<subseteq>| ids (t $\\<^sub>s u)", "unfolding ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees u |\\<union>| consts u |\\<subseteq>|\n    frees (t $\\<^sub>s u) |\\<union>| consts (t $\\<^sub>s u)", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>", "obtain v\\<^sub>2' where \"\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2'\" \"v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>2'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2';\n         v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v\\<^sub>2'.\n                \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down>\n                         v\\<^sub>2';\n                 v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule comb.IH(2))"], ["proof (prove)\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n 2. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_venv \\<Gamma>\n 3. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_except u (fmdom \\<Gamma>)\n 4. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    pre_strong_term_class.wellformed u\n 5. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\n 6. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fdisjnt C (fmdom \\<Gamma>)\n 7. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 8. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 9. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    \\<not> shadows_consts u\n 10. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n     not_shadows_vconsts_env \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n 2. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_venv \\<Gamma>\n 3. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_except u (fmdom \\<Gamma>)\n 4. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    pre_strong_term_class.wellformed u\n 5. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\n 6. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fdisjnt C (fmdom \\<Gamma>)\n 7. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 8. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 9. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    \\<not> shadows_consts u\n 10. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n     not_shadows_vconsts_env \\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2'\n  v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2') (vfind_match cs v\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n     (vfind_match cs v\\<^sub>2)", "using \\<open>v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n     (vfind_match cs v\\<^sub>2)", "by (rule erelated.vfind_match_rel')"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)", "obtain env' where \"fmrel erelated env' env\" \"vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\""], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>fmrel erelated env' env;\n         vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using comb"], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>fmrel erelated env' env;\n         vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmrel erelated env' env\n  vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vclosed v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed v\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "."], ["proof (state)\nthis:\n  frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vfind_match ?cs3 ?v1 = Some (env, pat, ?rhs3)", "apply (rule comb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| C\" \"fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| C &&&\n    fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| C &&&\n    fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain val' where \"\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down> val'\" \"val' \\<approx>\\<^sub>e val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env'\n                 \\<turnstile>\\<^sub>v rhs \\<down> val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (erule comb.IH)"], ["proof (state)\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. pre_strong_term_class.wellformed rhs\n 5. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 7. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. \\<not> shadows_consts rhs\n 10. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_venv env", "using \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. closed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_venv env", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vclosed ?v4", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs7 ?v4 = Some (env, ?pat7, ?rhs7)\n 2. vclosed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (9 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 6. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. \\<not> shadows_consts rhs\n 9. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 6. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. \\<not> shadows_consts rhs\n 9. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (8 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 5. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. \\<not> shadows_consts rhs\n 8. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 5. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. \\<not> shadows_consts rhs\n 8. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. wellformed_venv env", "using \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. wellformed_venv env", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vwellformed ?v4", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs7 ?v4 = Some (env, ?pat7, ?rhs7)\n 2. vwellformed ?v4", "apply (rule comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>2", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>9 \\<turnstile>\\<^sub>v ?t9 \\<down> v\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t9\n 3. wellformed_venv ?\\<Gamma>9", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (7 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close> \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "have \"fmdom env = fmdom env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = fmdom env'", "using \\<open>fmrel erelated env' env\\<close>"], ["proof (prove)\nusing this:\n  fmrel erelated env' env\n\ngoal (1 subgoal):\n 1. fmdom env = fmdom env'", "by (metis fmrel_fmdom_eq)"], ["proof (state)\nthis:\n  fmdom env = fmdom env'\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"fmrel_on_fset (ids rhs) erelated (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') x)\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) x)", "fix id"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') x)\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) x)", "assume \"id |\\<in>| ids rhs\""], ["proof (state)\nthis:\n  id |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') x)\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) x)", "thus \"rel_option erelated (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id) (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\""], ["proof (prove)\nusing this:\n  id |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs |\\<union>| consts rhs\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "case A"], ["proof (state)\nthis:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "using \\<open>closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n  closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n  frees rhs |\\<subseteq>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "thus ?thesis"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "case A"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env\n\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<in>| fmdom env'\""], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env'", "using \\<open>fmdom env = frees pat\\<close> \\<open>fmdom env = fmdom env'\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  fmdom env = frees pat\n  fmdom env = fmdom env'\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env'", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env'\n\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "with A"], ["proof (chain)\npicking this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'", "show ?thesis"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "using \\<open>fmrel erelated env' env\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'\n  fmrel erelated env' env\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "by auto"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "case B"], ["proof (state)\nthis:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<notin>| frees pat\""], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "using \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "by simp"], ["proof (state)\nthis:\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<in>| frees (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    ffUnion\n     ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    fBex\n     ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)\n     ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    fBex (fset_of_list cs)\n     (\\<lambda>x.\n         id |\\<in>|\n         (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    (case (pat, rhs) of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "using \\<open>id |\\<in>| frees rhs\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    (case (pat, rhs) of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "unfolding fset_of_list_elem"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<in>| ids (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| ids (Sabs cs)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs) |\\<union>| consts (Sabs cs)", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "have \"id |\\<notin>| fmdom env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "using B"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "unfolding \\<open>fmdom env = fmdom env'\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "by simp"], ["proof (state)\nthis:\n  id |\\<notin>| fmdom env'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "thus ?thesis"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "using \\<open>id |\\<notin>| fmdom env\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n  id |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S2\n 2. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S2 erelated \\<Gamma>\\<^sub>\\<Lambda>'\n                       \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>id |\\<in>| ids (Sabs cs)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids (Sabs cs)) erelated\n                       \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "case B"], ["proof (state)\nthis:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "have \"id |\\<in>| consts (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<in>| consts (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<in>| ffUnion ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs) ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fset_of_list cs)\n     (\\<lambda>x. id |\\<in>| (case x of (uu_, x) \\<Rightarrow> consts x))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<in>| (case (pat, rhs) of (uu_, x) \\<Rightarrow> consts x)\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<in>| consts rhs\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| fset_of_list cs", "unfolding fset_of_list_elem"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "hence \"id |\\<in>| ids (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| ids (Sabs cs)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs) |\\<union>| consts (Sabs cs)", "by auto"], ["proof (state)\nthis:\n  id |\\<in>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n                         id)\n                       (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n                         id)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "using \\<open>fmdom env = fmdom env'\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = fmdom env'\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n     (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env'; id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 2. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrelD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env'; id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel erelated env' env\n 2. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>fmrel erelated env' env\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S11\n 2. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S11 erelated \\<Gamma>\\<^sub>\\<Lambda>'\n                       \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>id |\\<in>| ids (Sabs cs)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmdom env = fmdom env'; id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids (Sabs cs)) erelated\n                       \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id)\n   (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) erelated\n   (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env')\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n 2. fmpred (\\<lambda>_. vwelldefined') env", "have \"vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n 2. fmpred (\\<lambda>_. vwelldefined') env", "thus \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>", "by simp"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "have \"vwelldefined' v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' v\\<^sub>2", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed u\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts u\n 7. not_shadows_vconsts_env \\<Gamma>", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed u\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts u\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "show \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "apply (rule vmatch_welldefined')"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. vwelldefined' ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. vwelldefined' ?v", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (4 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "have \"fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (4 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (4 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_all_iff all_consts_def fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (4 subgoals):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n  fdisjnt C (fmdom env)", "show \"fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n  fdisjnt C (fmdom env)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom \\<Gamma>\\<^sub>\\<Lambda> = {||}\n  C |\\<inter>| fmdom env = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) = {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (3 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "have \"not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. not_shadows_vconsts ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. not_shadows_vconsts ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts v\\<^sub>2", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n 2. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "ultimately"], ["proof (chain)\npicking this:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n  not_shadows_vconsts_env env", "show \"not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n  not_shadows_vconsts_env env\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C", "show \"consts rhs |\\<subseteq>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C", "using \\<open>consts rhs |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| C\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C", "by auto"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down>\n  val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down>\n  val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'", "proof (rule veval'.comb)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vabs ?cs ?\\<Gamma>'\n 2. \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> ?u'\n 3. vfind_match ?cs ?u' = Some (?env, ?uu, ?rhs)\n 4. ?\\<Gamma>' ++\\<^sub>f ?env \\<turnstile>\\<^sub>v ?rhs \\<down> val'", "show \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'", "using \\<open>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'", "unfolding \\<open>v\\<^sub>1' = _\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'", "."], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>'\n\ngoal (3 subgoals):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> ?u'\n 2. vfind_match cs ?u' = Some (?env, ?uu, ?rhs)\n 3. \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f ?env \\<turnstile>\\<^sub>v\n    ?rhs \\<down> val'", "qed fact+"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> t cs \\<Gamma>' u u' env uu_ rhs val \\<Gamma>'' thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vabs cs \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uu_, rhs);\n        \\<Gamma>' ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f env);\n            closed_venv (\\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv (\\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C (fmdom (\\<Gamma>' ++\\<^sub>f env));\n            consts rhs |\\<subseteq>|\n            fmdom (\\<Gamma>' ++\\<^sub>f env) |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env (\\<Gamma>' ++\\<^sub>f env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down>\n  val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down>\n  val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n\ngoal (1 subgoal):\n 1. thesis", "using comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down>\n  val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vabs cs\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env));\n   consts rhs |\\<subseteq>|\n   fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (rec_comb \\<Gamma> t css name \\<Gamma>\\<^sub>\\<Lambda> cs u v\\<^sub>2 env pat rhs val)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S erelated \\<Gamma>' \\<Gamma>\n 2. ids t |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids t |\\<subseteq>| ids (t $\\<^sub>s u)", "unfolding ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<union>| consts t |\\<subseteq>|\n    frees (t $\\<^sub>s u) |\\<union>| consts (t $\\<^sub>s u)", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>", "obtain v\\<^sub>1' where \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\" \"v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1';\n         v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name\n \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rec_comb"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1';\n         v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name\n \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>", "obtain \\<Gamma>\\<^sub>\\<Lambda>'\n    where \"v\\<^sub>1' = Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'\"\n      and \"pred_fmap (\\<lambda>cs. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>) css\""], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n  v\\<^sub>1' \\<approx>\\<^sub>e Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>\\<^sub>\\<Lambda>'.\n        \\<lbrakk>v\\<^sub>1' = Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>';\n         pred_fmap\n          (\\<lambda>cs.\n              fmrel_on_fset (ids (Sabs cs)) erelated\n               \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>)\n          css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: erelated.cases)"], ["proof (state)\nthis:\n  v\\<^sub>1' = Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'\n  pred_fmap\n   (\\<lambda>cs.\n       fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n        \\<Gamma>\\<^sub>\\<Lambda>)\n   css\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S erelated \\<Gamma>' \\<Gamma>\n 2. ids u |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids u |\\<subseteq>| ids (t $\\<^sub>s u)", "unfolding ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees u |\\<union>| consts u |\\<subseteq>|\n    frees (t $\\<^sub>s u) |\\<union>| consts (t $\\<^sub>s u)", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>", "obtain v\\<^sub>2' where \"\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2'\" \"v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>2'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2';\n         v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v\\<^sub>2'.\n                \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down>\n                         v\\<^sub>2';\n                 v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule rec_comb.IH(2))"], ["proof (prove)\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n 2. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_venv \\<Gamma>\n 3. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_except u (fmdom \\<Gamma>)\n 4. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    pre_strong_term_class.wellformed u\n 5. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\n 6. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fdisjnt C (fmdom \\<Gamma>)\n 7. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 8. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 9. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    \\<not> shadows_consts u\n 10. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n     not_shadows_vconsts_env \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>\n 2. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_venv \\<Gamma>\n 3. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    closed_except u (fmdom \\<Gamma>)\n 4. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    pre_strong_term_class.wellformed u\n 5. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\n 6. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fdisjnt C (fmdom \\<Gamma>)\n 7. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 8. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 9. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n    \\<not> shadows_consts u\n 10. fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma> \\<Longrightarrow>\n     not_shadows_vconsts_env \\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2'\n  v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2') (vfind_match cs v\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n     (vfind_match cs v\\<^sub>2)", "using \\<open>v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>2' \\<approx>\\<^sub>e v\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n     (vfind_match cs v\\<^sub>2)", "by (rule erelated.vfind_match_rel')"], ["proof (state)\nthis:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)", "obtain env' where \"fmrel erelated env' env\" \"vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\""], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>fmrel erelated env' env;\n         vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rec_comb"], ["proof (prove)\nusing this:\n  rel_option (rel_prod (fmrel erelated) (=)) (vfind_match cs v\\<^sub>2')\n   (vfind_match cs v\\<^sub>2)\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>fmrel erelated env' env;\n         vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmrel erelated env' env\n  vfind_match cs v\\<^sub>2' = Some (env', pat, rhs)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "using rec_comb"], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vclosed v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed v\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: Sterm.closed_except_simps)"], ["proof (state)\nthis:\n  closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  closed_except (Sabs cs) (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "."], ["proof (state)\nthis:\n  frees (Sabs cs) |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "using rec_comb"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"linear pat\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. linear pat", "using \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vfind_match ?cs3 ?v1 = Some (env, pat, ?rhs3)", "apply (rule rec_comb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"consts rhs |\\<subseteq>| fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css)\" \"fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css) &&&\n    fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>fmlookup css name = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n  (pat, rhs) \\<in> set cs\n  fmlookup css name = Some cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css) &&&\n    fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by (auto simp: list_all_iff dest!: fmpredD[where m = css])"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css)\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "using rec_comb"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain val' where \"\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env' \\<turnstile>\\<^sub>v rhs \\<down> val'\" \"val' \\<approx>\\<^sub>e val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>val'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                 env'\n                 \\<turnstile>\\<^sub>v rhs \\<down> val';\n         val' \\<approx>\\<^sub>e val\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (erule rec_comb.IH)"], ["proof (state)\ngoal (10 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 3. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 4. pre_strong_term_class.wellformed rhs\n 5. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 6. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 7. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 9. \\<not> shadows_consts rhs\n 10. not_shadows_vconsts_env\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env)", "show \"closed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. closed_venv env", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. closed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv env", "using \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. closed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. closed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv env", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. closed_venv env", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)\n 2. closed_venv env", "using \\<open>vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. closed_venv\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)\n 2. closed_venv env", "apply (auto intro: fmdomI)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat19 ?v19 = Some env\n 2. vclosed ?v19", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs22 ?v19 = Some (env, ?pat22, ?rhs22)\n 2. vclosed ?v19", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_venv\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n\ngoal (9 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 6. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 8. \\<not> shadows_consts rhs\n 9. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. pre_strong_term_class.wellformed rhs\n 4. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 6. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 8. \\<not> shadows_consts rhs\n 9. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (8 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 4. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 5. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 7. \\<not> shadows_consts rhs\n 8. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 4. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 5. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 7. \\<not> shadows_consts rhs\n 8. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "show \"wellformed_venv (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. wellformed_venv env", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. wellformed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. wellformed_venv env", "using \\<open>vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. wellformed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. wellformed_venv env", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. wellformed_venv env", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)\n 2. wellformed_venv env", "using \\<open>vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. wellformed_venv\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)\n 2. wellformed_venv env", "apply (auto intro: fmdomI)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat19 ?v19 = Some env\n 2. vwellformed ?v19", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs22 ?v19 = Some (env, ?pat22, ?rhs22)\n 2. vwellformed ?v19", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>2", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>25 \\<turnstile>\\<^sub>v ?t25 \\<down> v\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t25\n 3. wellformed_venv ?\\<Gamma>25", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed u\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  wellformed_venv\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n\ngoal (7 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 4. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 4. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close> \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "by (auto simp: list_all_iff closed_except_def)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (7 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 4. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 6. \\<not> shadows_consts rhs\n 7. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "thus \"closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees rhs |\\<subseteq>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "by auto"], ["proof (state)\nthis:\n  closed_except rhs\n   (fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env))\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fmdom env = fmdom env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = fmdom env'", "using \\<open>fmrel erelated env' env\\<close>"], ["proof (prove)\nusing this:\n  fmrel erelated env' env\n\ngoal (1 subgoal):\n 1. fmdom env = fmdom env'", "by (metis fmrel_fmdom_eq)"], ["proof (state)\nthis:\n  fmdom env = fmdom env'\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fmrel_on_fset (ids rhs) erelated (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>') (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>') css)\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup\n          (fmmap_keys\n            (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>')\n            css)\n          x)\n        (fmlookup\n          (fmmap_keys\n            (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n            css)\n          x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (map_option (\\<lambda>cs. Vrecabs css x \\<Gamma>\\<^sub>\\<Lambda>')\n          (fmlookup css x))\n        (map_option (\\<lambda>cs. Vrecabs css x \\<Gamma>\\<^sub>\\<Lambda>)\n          (fmlookup css x))", "unfolding option.rel_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option\n        (\\<lambda>xa y.\n            Vrecabs css x\n             \\<Gamma>\\<^sub>\\<Lambda>' \\<approx>\\<^sub>e Vrecabs css x\n                    \\<Gamma>\\<^sub>\\<Lambda>)\n        (fmlookup css x) (fmlookup css x)", "apply (rule option.rel_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       Vrecabs css x\n        \\<Gamma>\\<^sub>\\<Lambda>' \\<approx>\\<^sub>e Vrecabs css x\n               \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule erelated.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       pred_fmap\n        (\\<lambda>cs.\n            fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n             \\<Gamma>\\<^sub>\\<Lambda>)\n        css", "apply (rule \\<open>pred_fmap (\\<lambda>cs. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>) css\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) erelated\n   (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n   (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n     \\<Gamma>\\<^sub>\\<Lambda>", "using \\<open>pred_fmap (\\<lambda>cs. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>) css\\<close> rec_comb"], ["proof (prove)\nusing this:\n  pred_fmap\n   (\\<lambda>cs.\n       fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n        \\<Gamma>\\<^sub>\\<Lambda>)\n   css\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n     \\<Gamma>\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>'\n   \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) = fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n    fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css) =\n    fmdom\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>') css)", "by auto"], ["proof (state)\nthis:\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n\ngoal (6 subgoals):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 2. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 3. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 5. \\<not> shadows_consts rhs\n 6. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "show \"fmrel_on_fset (ids rhs) erelated (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           env')\n          x)\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           env)\n          x)", "fix id"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           env')\n          x)\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           env)\n          x)", "assume \"id |\\<in>| ids rhs\""], ["proof (state)\nthis:\n  id |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n           env')\n          x)\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           env)\n          x)", "thus \"rel_option erelated (fmlookup (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f env') id) (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) id)\""], ["proof (prove)\nusing this:\n  id |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs |\\<union>| consts rhs\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "case A"], ["proof (state)\nthis:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "using \\<open>closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n  closed_except rhs (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n  frees rhs |\\<subseteq>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "thus ?thesis"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env |\\<union>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "case A"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env\n\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<in>| fmdom env'\""], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env'", "using \\<open>fmdom env = frees pat\\<close> \\<open>fmdom env = fmdom env'\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  fmdom env = frees pat\n  fmdom env = fmdom env'\n\ngoal (1 subgoal):\n 1. id |\\<in>| fmdom env'", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| fmdom env'\n\ngoal (2 subgoals):\n 1. id |\\<in>| fmdom env \\<Longrightarrow>\n    rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "with A"], ["proof (chain)\npicking this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'", "show ?thesis"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "using \\<open>fmrel erelated env' env\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| fmdom env\n  id |\\<in>| fmdom env'\n  fmrel erelated env' env\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "by auto"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     id)\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     id)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "case B"], ["proof (state)\nthis:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<notin>| frees pat\""], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "using \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "by simp"], ["proof (state)\nthis:\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<in>| frees (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    ffUnion\n     ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    fBex\n     ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)\n     ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    fBex (fset_of_list cs)\n     (\\<lambda>x.\n         id |\\<in>|\n         (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    (case (pat, rhs) of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "using \\<open>id |\\<in>| frees rhs\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    id |\\<in>|\n    (case (pat, rhs) of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow>\n    (pat, rhs) |\\<in>| fset_of_list cs", "unfolding fset_of_list_elem"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<in>| ids (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| ids (Sabs cs)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs) |\\<union>| consts (Sabs cs)", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "have \"id |\\<notin>| fmdom env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "using B"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "unfolding \\<open>fmdom env = fmdom env'\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n  id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. id |\\<notin>| fmdom env'", "by simp"], ["proof (state)\nthis:\n  id |\\<notin>| fmdom env'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env;\n     id |\\<in>| fmdom \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "thus ?thesis"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "using \\<open>id |\\<notin>| fmdom env\\<close> \\<open>fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) = fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| fmdom env'\n  id |\\<notin>| fmdom env\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                         id)\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         id)\n 2. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S10\n 2. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S10 erelated\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>id |\\<in>| ids rhs\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids rhs) erelated\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>fmrel_on_fset (ids rhs) erelated (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>') (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S13\n 2. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S13 erelated \\<Gamma>\\<^sub>\\<Lambda>'\n                       \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>id |\\<in>| ids (Sabs cs)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| fmdom env'; id |\\<notin>| fmdom env;\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids (Sabs cs)) erelated\n                       \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     id)\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     id)\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     id)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "case B"], ["proof (state)\nthis:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "have \"id |\\<in>| consts (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<in>| consts (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<in>| ffUnion ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs) ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fset_of_list cs)\n     (\\<lambda>x. id |\\<in>| (case x of (uu_, x) \\<Rightarrow> consts x))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<in>| (case (pat, rhs) of (uu_, x) \\<Rightarrow> consts x)\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. id |\\<in>| consts rhs\n 2. (pat, rhs) |\\<in>| fset_of_list cs", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| fset_of_list cs", "unfolding fset_of_list_elem"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "hence \"id |\\<in>| ids (Sabs cs)\""], ["proof (prove)\nusing this:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| ids (Sabs cs)", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs) |\\<union>| consts (Sabs cs)", "by auto"], ["proof (state)\nthis:\n  id |\\<in>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          mk_rec_env css\n                           \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n                          env')\n                         id)\n                       (fmlookup\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          env)\n                         id)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "using \\<open>fmdom env = fmdom env'\\<close> \\<open>fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) = fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = fmdom env'\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n  fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n\ngoal (1 subgoal):\n 1. rel_option erelated\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n        env')\n       id)\n     (fmlookup\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env)\n       id)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                         id)\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         id)\n 3. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 4. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrelD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel erelated env' env\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                         id)\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         id)\n 3. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 4. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>fmrel erelated env' env\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                         id)\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         id)\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 3. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S21\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S21 erelated\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 4. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>id |\\<in>| ids rhs\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids rhs) erelated\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>')\n                       (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 3. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>fmrel_on_fset (ids rhs) erelated (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>') (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env' id)\n                       (fmlookup env id)\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrelD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<in>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel erelated env' env\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule \\<open>fmrel erelated env' env\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda>' id)\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> id)", "apply (rule fmrel_on_fsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| ?S26\n 2. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset ?S26 erelated \\<Gamma>\\<^sub>\\<Lambda>'\n                       \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>id |\\<in>| ids (Sabs cs)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmdom env = fmdom env';\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) =\n     fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>');\n     id |\\<notin>| fmdom env'\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (ids (Sabs cs)) erelated\n                       \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>", "apply (rule \\<open>fmrel_on_fset (ids (Sabs cs)) erelated \\<Gamma>\\<^sub>\\<Lambda>' \\<Gamma>\\<^sub>\\<Lambda>\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     id)\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option erelated\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n      env')\n     id)\n   (fmlookup\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) erelated\n   (\\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n    env')\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n 4. \\<not> shadows_consts rhs\n 5. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "show \"fmpred (\\<lambda>_. vwelldefined') (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "proof (intro fmpred_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. fmpred (\\<lambda>_. vwelldefined') env", "have \"vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (3 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n 2. fmpred (\\<lambda>_. vwelldefined')\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n 3. fmpred (\\<lambda>_. vwelldefined') env", "thus \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\" \"fmpred (\\<lambda>_. vwelldefined') (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda> &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding mk_rec_env_def"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda> &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>\n  fmpred (\\<lambda>_. vwelldefined')\n   (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "have \"vwelldefined' v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' v\\<^sub>2", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed u\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts u\n 7. not_shadows_vconsts_env \\<Gamma>", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed u\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts u\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "show \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "apply (rule vmatch_welldefined')"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. vwelldefined' ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. vwelldefined' ?v", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n\ngoal (4 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_all_iff all_consts_def fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (4 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (4 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"fdisjnt C (fmdom css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom css)", "using \\<open>vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom css)", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom css)\n\ngoal (4 subgoals):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))\n 2. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. \\<not> shadows_consts rhs\n 4. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)", "show \"fdisjnt C (fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))", "using \\<open>fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env))", "unfolding fdisjnt_alt_def mk_rec_env_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom env = {||}\n  C |\\<inter>| fmdom css = {||}\n  C |\\<inter>| fmdom \\<Gamma>\\<^sub>\\<Lambda> = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n       css ++\\<^sub>f\n      env) =\n    {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C\n   (fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env))\n\ngoal (3 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. \\<not> shadows_consts rhs\n 3. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>", "using \\<open>not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat ?v = Some env\n 2. not_shadows_vconsts ?v", "apply (rule vfind_match_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vfind_match ?cs3 ?v = Some (env, ?pat3, ?rhs3)\n 2. not_shadows_vconsts ?v", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts v\\<^sub>2", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (3 subgoals):\n 1. ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> v\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>6\n 3. \\<not> shadows_consts ?t6", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "moreover"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "have \"not_shadows_vconsts_env (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)", "using \\<open>not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 2. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "ultimately"], ["proof (chain)\npicking this:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n  not_shadows_vconsts_env env\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)", "show \"not_shadows_vconsts_env (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n  not_shadows_vconsts_env env\n  not_shadows_vconsts_env (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "show \"consts rhs |\\<subseteq>| fmdom (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "using \\<open>consts rhs |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "unfolding mk_rec_env_def"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>|\n  fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      fmmap_keys\n       (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n       css ++\\<^sub>f\n      env) |\\<union>|\n    C", "by auto"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env) |\\<union>|\n  C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  env'\n  \\<turnstile>\\<^sub>v rhs \\<down> val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  env'\n  \\<turnstile>\\<^sub>v rhs \\<down> val'\n  val' \\<approx>\\<^sub>e val\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'", "proof (rule veval'.rec_comb)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vrecabs ?css ?name ?\\<Gamma>'\n 2. fmlookup ?css ?name = Some ?cs\n 3. \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> ?u'\n 4. vfind_match ?cs ?u' = Some (?env, ?uv, ?rhs)\n 5. ?\\<Gamma>' ++\\<^sub>f mk_rec_env ?css ?\\<Gamma>' ++\\<^sub>f ?env\n    \\<turnstile>\\<^sub>v ?rhs \\<down> val'", "show \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'", "using \\<open>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'", "unfolding \\<open>v\\<^sub>1' = _\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n    Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'", "."], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>'\n\ngoal (4 subgoals):\n 1. fmlookup css name = Some ?cs\n 2. \\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> ?u'\n 3. vfind_match ?cs ?u' = Some (?env, ?uv, ?rhs)\n 4. \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n    ?env\n    \\<turnstile>\\<^sub>v ?rhs \\<down> val'", "qed fact+"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> t css name \\<Gamma>' cs u u' env uv_ rhs val \\<Gamma>''\n       thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                Vrecabs css name \\<Gamma>';\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e Vrecabs css name\n        \\<Gamma>'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids t) erelated \\<Gamma>'' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmlookup css name = Some cs;\n        \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> u';\n        \\<And>\\<Gamma>' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v u \\<down> v';\n                        v' \\<approx>\\<^sub>e u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids u) erelated \\<Gamma>' \\<Gamma>;\n            closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n            pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n            fdisjnt C (fmdom \\<Gamma>);\n            consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            \\<not> shadows_consts u;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        vfind_match cs u' = Some (env, uv_, rhs);\n        \\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env\n        \\<turnstile>\\<^sub>v rhs \\<down> val;\n        \\<And>\\<Gamma>'' thesis.\n           \\<lbrakk>\\<And>v'.\n                       \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v rhs \\<down>\n                                v';\n                        v' \\<approx>\\<^sub>e val\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            fmrel_on_fset (ids rhs) erelated \\<Gamma>''\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            closed_except rhs\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            pre_strong_term_class.wellformed rhs;\n            wellformed_venv\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            fdisjnt C\n             (fmdom\n               (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n                env));\n            consts rhs |\\<subseteq>|\n            fmdom\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env) |\\<union>|\n            C;\n            fmpred (\\<lambda>_. vwelldefined')\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f env);\n            \\<not> shadows_consts rhs;\n            not_shadows_vconsts_env\n             (\\<Gamma>' ++\\<^sub>f mk_rec_env css \\<Gamma>' ++\\<^sub>f\n              env)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>'' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down>\n                    v';\n            v' \\<approx>\\<^sub>e val\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>'' \\<Gamma>;\n        closed_venv \\<Gamma>;\n        closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (t $\\<^sub>s u);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (t $\\<^sub>s u);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  env'\n  \\<turnstile>\\<^sub>v rhs \\<down> val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  env'\n  \\<turnstile>\\<^sub>v rhs \\<down> val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n\ngoal (1 subgoal):\n 1. thesis", "using rec_comb"], ["proof (prove)\nusing this:\n  \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>' ++\\<^sub>f\n  env'\n  \\<turnstile>\\<^sub>v rhs \\<down> val'\n  val' \\<approx>\\<^sub>e val\n  \\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> val'\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n  Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>\n  fmlookup css name = Some cs\n  \\<Gamma> \\<turnstile>\\<^sub>v u \\<down> v\\<^sub>2\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> val\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v t \\<down> v';\n               v' \\<approx>\\<^sub>e Vrecabs css name\n                                     \\<Gamma>\\<^sub>\\<Lambda>\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids t) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v u \\<down> v';\n               v' \\<approx>\\<^sub>e v\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids u) erelated ?\\<Gamma>'4 \\<Gamma>;\n   closed_venv \\<Gamma>; closed_except u (fmdom \\<Gamma>);\n   pre_strong_term_class.wellformed u; wellformed_venv \\<Gamma>;\n   fdisjnt C (fmdom \\<Gamma>);\n   consts u |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>; \\<not> shadows_consts u;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<And>v'.\n              \\<lbrakk>?\\<Gamma>'4 \\<turnstile>\\<^sub>v rhs \\<down> v';\n               v' \\<approx>\\<^sub>e val\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'4\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   closed_except rhs\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   pre_strong_term_class.wellformed rhs;\n   wellformed_venv\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   fdisjnt C\n    (fmdom\n      (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n       env));\n   consts rhs |\\<subseteq>|\n   fmdom\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env) |\\<union>|\n   C;\n   fmpred (\\<lambda>_. vwelldefined')\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env);\n   \\<not> shadows_consts rhs;\n   not_shadows_vconsts_env\n    (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n     env)\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t $\\<^sub>s u \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e val\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (t $\\<^sub>s u)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t $\\<^sub>s u) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (t $\\<^sub>s u)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (t $\\<^sub>s u) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (t $\\<^sub>s u)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (constr name \\<Gamma> ts us)"], ["proof (state)\nthis:\n  name |\\<in>| C\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (\\<forall>x xa.\n           (\\<forall>xb.\n               x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n               xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n               xa) \\<longrightarrow>\n           fmrel_on_fset (ids x1) erelated x \\<Gamma> \\<longrightarrow>\n           closed_venv \\<Gamma> \\<longrightarrow>\n           closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n           pre_strong_term_class.wellformed x1 \\<longrightarrow>\n           wellformed_venv \\<Gamma> \\<longrightarrow>\n           fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n           consts x1 |\\<subseteq>|\n           fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n           fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n           \\<not> shadows_consts x1 \\<longrightarrow>\n           not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n   ts us\n  \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> ?v'4;\n   ?v'4 \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed (name $$ ts)\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  \\<not> shadows_consts (name $$ ts)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"list_all (\\<lambda>t. fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and> closed_except t (fmdom \\<Gamma>) \\<and> wellformed t \\<and> consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and> \\<not> shadows_consts t) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>t.\n         fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n         closed_except t (fmdom \\<Gamma>) \\<and>\n         pre_strong_term_class.wellformed t \\<and>\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n         \\<not> shadows_consts t)\n     ts", "apply (rule list_allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (ids x) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except x (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed x \\<and>\n       consts x |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts x", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (ids x) erelated \\<Gamma>' \\<Gamma>\n 2. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       closed_except x (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed x \\<and>\n       consts x |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts x", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (?S5 x) erelated \\<Gamma>' \\<Gamma>\n 2. \\<And>x. x \\<in> set ts \\<Longrightarrow> ids x |\\<subseteq>| ?S5 x\n 3. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       closed_except x (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed x \\<and>\n       consts x |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts x", "apply (rule constr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow> ids x |\\<subseteq>| ids (name $$ ts)\n 2. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       closed_except x (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed x \\<and>\n       consts x |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> ids x_ |\\<subseteq>| ids (name $$ ts)", "unfolding ids_list_comb"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    ids x_ |\\<subseteq>|\n    ids (const name) |\\<union>| ffUnion (fset_of_list (map ids ts))", "by (induct ts; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       closed_except x (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed x \\<and>\n       consts x |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    closed_except x_ (fmdom \\<Gamma>) \\<and>\n    pre_strong_term_class.wellformed x_ \\<and>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n    \\<not> shadows_consts x_", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. x_ \\<in> set ts \\<Longrightarrow> closed_except x_ (fmdom \\<Gamma>)\n 2. x_ \\<in> set ts \\<Longrightarrow> pre_strong_term_class.wellformed x_\n 3. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 4. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> closed_except x_ (fmdom \\<Gamma>)", "using \\<open>closed_except (name $$ ts) (fmdom \\<Gamma>)\\<close>"], ["proof (prove)\nusing this:\n  closed_except (name $$ ts) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> closed_except x_ (fmdom \\<Gamma>)", "unfolding closed.list_comb"], ["proof (prove)\nusing this:\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> closed_except x_ (fmdom \\<Gamma>)", "by (auto simp: list_all_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x_ \\<in> set ts \\<Longrightarrow> pre_strong_term_class.wellformed x_\n 2. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> pre_strong_term_class.wellformed x_", "using \\<open>wellformed (name $$ ts)\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (name $$ ts)\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> pre_strong_term_class.wellformed x_", "unfolding wellformed.list_comb"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed ts\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> pre_strong_term_class.wellformed x_", "by (auto simp: list_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 2. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "using \\<open>consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\\<close>"], ["proof (prove)\nusing this:\n  consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "unfolding consts_list_comb"], ["proof (prove)\nusing this:\n  consts (const name) |\\<union>|\n  ffUnion (fset_of_list (map consts ts)) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow>\n    consts x_ |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "by (metis Ball_set constr.prems(8) special_constants.sconsts_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "using \\<open>\\<not> shadows_consts (name $$ ts)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (name $$ ts)\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "unfolding shadows.list_comb"], ["proof (prove)\nusing this:\n  \\<not> (shadows_consts (const name) \\<or> list_ex shadows_consts ts)\n\ngoal (1 subgoal):\n 1. x_ \\<in> set ts \\<Longrightarrow> \\<not> shadows_consts x_", "by (auto simp: list_ex_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   ts\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain us' where \"list_all3 (\\<lambda>t u u'. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and> u' \\<approx>\\<^sub>e u) ts us us'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us'.\n        list_all3\n         (\\<lambda>t u u'.\n             \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n             u' \\<approx>\\<^sub>e u)\n         ts us us' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>list_all2 _ _ _\\<close> \\<open>list_all _ ts\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n       (\\<forall>x xa.\n           (\\<forall>xb.\n               x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n               xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n               xa) \\<longrightarrow>\n           fmrel_on_fset (ids x1) erelated x \\<Gamma> \\<longrightarrow>\n           closed_venv \\<Gamma> \\<longrightarrow>\n           closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n           pre_strong_term_class.wellformed x1 \\<longrightarrow>\n           wellformed_venv \\<Gamma> \\<longrightarrow>\n           fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n           consts x1 |\\<subseteq>|\n           fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n           fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n           \\<not> shadows_consts x1 \\<longrightarrow>\n           not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n   ts us\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   ts\n\ngoal (1 subgoal):\n 1. (\\<And>us'.\n        list_all3\n         (\\<lambda>t u u'.\n             \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n             u' \\<approx>\\<^sub>e u)\n         ts us us' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: thesis rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (\\<forall>x xa.\n                    (\\<forall>xb.\n                        x \\<turnstile>\\<^sub>v a21 \\<down>\n                        xb \\<longrightarrow>\n                        xb \\<approx>\\<^sub>e b21 \\<longrightarrow>\n                        xa) \\<longrightarrow>\n                    fmrel_on_fset (ids a21) erelated x\n                     \\<Gamma> \\<longrightarrow>\n                    closed_venv \\<Gamma> \\<longrightarrow>\n                    closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                    pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                    wellformed_venv \\<Gamma> \\<longrightarrow>\n                    fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                    consts a21 |\\<subseteq>|\n                    fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                    fmpred (\\<lambda>_. vwelldefined')\n                     \\<Gamma> \\<longrightarrow>\n                    \\<not> shadows_consts a21 \\<longrightarrow>\n                    not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>us'.\n                       list_all3\n                        (\\<lambda>t u u'.\n                            \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n                            u' \\<and> u' \\<approx>\\<^sub>e u)\n                        a22 b22 us' \\<Longrightarrow>\n                       thesis;\n            list_all\n             (\\<lambda>t.\n                 fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n                 closed_except t (fmdom \\<Gamma>) \\<and>\n                 pre_strong_term_class.wellformed t \\<and>\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n                 \\<not> shadows_consts t)\n             a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us'.\n           list_all3\n            (\\<lambda>t u u'.\n                \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                u' \\<approx>\\<^sub>e u)\n            (a21 # a22) (b21 # b22) us' \\<Longrightarrow>\n           thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons t ts u us)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \\<and>\n  (\\<forall>x xa.\n      (\\<forall>xb.\n          x \\<turnstile>\\<^sub>v t \\<down> xb \\<longrightarrow>\n          xb \\<approx>\\<^sub>e u \\<longrightarrow> xa) \\<longrightarrow>\n      fmrel_on_fset (ids t) erelated x \\<Gamma> \\<longrightarrow>\n      closed_venv \\<Gamma> \\<longrightarrow>\n      closed_except t (fmdom \\<Gamma>) \\<longrightarrow>\n      pre_strong_term_class.wellformed t \\<longrightarrow>\n      wellformed_venv \\<Gamma> \\<longrightarrow>\n      fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n      consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n      fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n      \\<not> shadows_consts t \\<longrightarrow>\n      not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa)\n  \\<lbrakk>\\<And>us'.\n              list_all3\n               (\\<lambda>t u u'.\n                   \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                   u' \\<approx>\\<^sub>e u)\n               ts us us' \\<Longrightarrow>\n              ?thesis4;\n   list_all\n    (\\<lambda>t.\n        fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n        closed_except t (fmdom \\<Gamma>) \\<and>\n        pre_strong_term_class.wellformed t \\<and>\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n        \\<not> shadows_consts t)\n    ts\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   (t # ts) (u # us) ?us'4 \\<Longrightarrow>\n  thesis\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   (t # ts)\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (\\<forall>x xa.\n                    (\\<forall>xb.\n                        x \\<turnstile>\\<^sub>v a21 \\<down>\n                        xb \\<longrightarrow>\n                        xb \\<approx>\\<^sub>e b21 \\<longrightarrow>\n                        xa) \\<longrightarrow>\n                    fmrel_on_fset (ids a21) erelated x\n                     \\<Gamma> \\<longrightarrow>\n                    closed_venv \\<Gamma> \\<longrightarrow>\n                    closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                    pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                    wellformed_venv \\<Gamma> \\<longrightarrow>\n                    fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                    consts a21 |\\<subseteq>|\n                    fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                    fmpred (\\<lambda>_. vwelldefined')\n                     \\<Gamma> \\<longrightarrow>\n                    \\<not> shadows_consts a21 \\<longrightarrow>\n                    not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>us'.\n                       list_all3\n                        (\\<lambda>t u u'.\n                            \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n                            u' \\<and> u' \\<approx>\\<^sub>e u)\n                        a22 b22 us' \\<Longrightarrow>\n                       thesis;\n            list_all\n             (\\<lambda>t.\n                 fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n                 closed_except t (fmdom \\<Gamma>) \\<and>\n                 pre_strong_term_class.wellformed t \\<and>\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n                 \\<not> shadows_consts t)\n             a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us'.\n           list_all3\n            (\\<lambda>t u u'.\n                \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                u' \\<approx>\\<^sub>e u)\n            (a21 # a22) (b21 # b22) us' \\<Longrightarrow>\n           thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \\<and>\n  (\\<forall>x xa.\n      (\\<forall>xb.\n          x \\<turnstile>\\<^sub>v t \\<down> xb \\<longrightarrow>\n          xb \\<approx>\\<^sub>e u \\<longrightarrow> xa) \\<longrightarrow>\n      fmrel_on_fset (ids t) erelated x \\<Gamma> \\<longrightarrow>\n      closed_venv \\<Gamma> \\<longrightarrow>\n      closed_except t (fmdom \\<Gamma>) \\<longrightarrow>\n      pre_strong_term_class.wellformed t \\<longrightarrow>\n      wellformed_venv \\<Gamma> \\<longrightarrow>\n      fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n      consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n      fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n      \\<not> shadows_consts t \\<longrightarrow>\n      not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa)\n  \\<lbrakk>\\<And>us'.\n              list_all3\n               (\\<lambda>t u u'.\n                   \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                   u' \\<approx>\\<^sub>e u)\n               ts us us' \\<Longrightarrow>\n              ?thesis4;\n   list_all\n    (\\<lambda>t.\n        fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n        closed_except t (fmdom \\<Gamma>) \\<and>\n        pre_strong_term_class.wellformed t \\<and>\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n        \\<not> shadows_consts t)\n    ts\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   (t # ts) (u # us) ?us'4 \\<Longrightarrow>\n  thesis\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   (t # ts)", "obtain us' where \"list_all3 (\\<lambda>t u u'. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and> u' \\<approx>\\<^sub>e u) ts us us'\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \\<and>\n  (\\<forall>x xa.\n      (\\<forall>xb.\n          x \\<turnstile>\\<^sub>v t \\<down> xb \\<longrightarrow>\n          xb \\<approx>\\<^sub>e u \\<longrightarrow> xa) \\<longrightarrow>\n      fmrel_on_fset (ids t) erelated x \\<Gamma> \\<longrightarrow>\n      closed_venv \\<Gamma> \\<longrightarrow>\n      closed_except t (fmdom \\<Gamma>) \\<longrightarrow>\n      pre_strong_term_class.wellformed t \\<longrightarrow>\n      wellformed_venv \\<Gamma> \\<longrightarrow>\n      fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n      consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n      fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n      \\<not> shadows_consts t \\<longrightarrow>\n      not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa)\n  \\<lbrakk>\\<And>us'.\n              list_all3\n               (\\<lambda>t u u'.\n                   \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                   u' \\<approx>\\<^sub>e u)\n               ts us us' \\<Longrightarrow>\n              ?thesis4;\n   list_all\n    (\\<lambda>t.\n        fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n        closed_except t (fmdom \\<Gamma>) \\<and>\n        pre_strong_term_class.wellformed t \\<and>\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n        \\<not> shadows_consts t)\n    ts\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   (t # ts) (u # us) ?us'4 \\<Longrightarrow>\n  thesisc__\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   (t # ts)\n\ngoal (1 subgoal):\n 1. (\\<And>us'.\n        list_all3\n         (\\<lambda>t u u'.\n             \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n             u' \\<approx>\\<^sub>e u)\n         ts us us' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   ts us us'\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (\\<forall>x xa.\n                    (\\<forall>xb.\n                        x \\<turnstile>\\<^sub>v a21 \\<down>\n                        xb \\<longrightarrow>\n                        xb \\<approx>\\<^sub>e b21 \\<longrightarrow>\n                        xa) \\<longrightarrow>\n                    fmrel_on_fset (ids a21) erelated x\n                     \\<Gamma> \\<longrightarrow>\n                    closed_venv \\<Gamma> \\<longrightarrow>\n                    closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                    pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                    wellformed_venv \\<Gamma> \\<longrightarrow>\n                    fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                    consts a21 |\\<subseteq>|\n                    fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                    fmpred (\\<lambda>_. vwelldefined')\n                     \\<Gamma> \\<longrightarrow>\n                    \\<not> shadows_consts a21 \\<longrightarrow>\n                    not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>us'.\n                       list_all3\n                        (\\<lambda>t u u'.\n                            \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n                            u' \\<and> u' \\<approx>\\<^sub>e u)\n                        a22 b22 us' \\<Longrightarrow>\n                       thesis;\n            list_all\n             (\\<lambda>t.\n                 fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n                 closed_except t (fmdom \\<Gamma>) \\<and>\n                 pre_strong_term_class.wellformed t \\<and>\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n                 \\<not> shadows_consts t)\n             a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us'.\n           list_all3\n            (\\<lambda>t u u'.\n                \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                u' \\<approx>\\<^sub>e u)\n            (a21 # a22) (b21 # b22) us' \\<Longrightarrow>\n           thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have\n        \"fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n        \"wellformed t\" \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"\\<not> shadows_consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> &&&\n     closed_except t (fmdom \\<Gamma>)) &&&\n    pre_strong_term_class.wellformed t &&&\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C &&&\n    \\<not> shadows_consts t", "using Cons"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \\<and>\n  (\\<forall>x xa.\n      (\\<forall>xb.\n          x \\<turnstile>\\<^sub>v t \\<down> xb \\<longrightarrow>\n          xb \\<approx>\\<^sub>e u \\<longrightarrow> xa) \\<longrightarrow>\n      fmrel_on_fset (ids t) erelated x \\<Gamma> \\<longrightarrow>\n      closed_venv \\<Gamma> \\<longrightarrow>\n      closed_except t (fmdom \\<Gamma>) \\<longrightarrow>\n      pre_strong_term_class.wellformed t \\<longrightarrow>\n      wellformed_venv \\<Gamma> \\<longrightarrow>\n      fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n      consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n      fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n      \\<not> shadows_consts t \\<longrightarrow>\n      not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa)\n  \\<lbrakk>\\<And>us'.\n              list_all3\n               (\\<lambda>t u u'.\n                   \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                   u' \\<approx>\\<^sub>e u)\n               ts us us' \\<Longrightarrow>\n              ?thesis4;\n   list_all\n    (\\<lambda>t.\n        fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n        closed_except t (fmdom \\<Gamma>) \\<and>\n        pre_strong_term_class.wellformed t \\<and>\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n        \\<not> shadows_consts t)\n    ts\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   (t # ts) (u # us) ?us'4 \\<Longrightarrow>\n  thesis\n  list_all\n   (\\<lambda>t.\n       fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n       closed_except t (fmdom \\<Gamma>) \\<and>\n       pre_strong_term_class.wellformed t \\<and>\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n       \\<not> shadows_consts t)\n   (t # ts)\n\ngoal (1 subgoal):\n 1. (fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> &&&\n     closed_except t (fmdom \\<Gamma>)) &&&\n    pre_strong_term_class.wellformed t &&&\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C &&&\n    \\<not> shadows_consts t", "by auto"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  \\<not> shadows_consts t\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (\\<forall>x xa.\n                    (\\<forall>xb.\n                        x \\<turnstile>\\<^sub>v a21 \\<down>\n                        xb \\<longrightarrow>\n                        xb \\<approx>\\<^sub>e b21 \\<longrightarrow>\n                        xa) \\<longrightarrow>\n                    fmrel_on_fset (ids a21) erelated x\n                     \\<Gamma> \\<longrightarrow>\n                    closed_venv \\<Gamma> \\<longrightarrow>\n                    closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                    pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                    wellformed_venv \\<Gamma> \\<longrightarrow>\n                    fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                    consts a21 |\\<subseteq>|\n                    fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                    fmpred (\\<lambda>_. vwelldefined')\n                     \\<Gamma> \\<longrightarrow>\n                    \\<not> shadows_consts a21 \\<longrightarrow>\n                    not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>us'.\n                       list_all3\n                        (\\<lambda>t u u'.\n                            \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n                            u' \\<and> u' \\<approx>\\<^sub>e u)\n                        a22 b22 us' \\<Longrightarrow>\n                       thesis;\n            list_all\n             (\\<lambda>t.\n                 fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n                 closed_except t (fmdom \\<Gamma>) \\<and>\n                 pre_strong_term_class.wellformed t \\<and>\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n                 \\<not> shadows_consts t)\n             a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us'.\n           list_all3\n            (\\<lambda>t u u'.\n                \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                u' \\<approx>\\<^sub>e u)\n            (a21 # a22) (b21 # b22) us' \\<Longrightarrow>\n           thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  \\<not> shadows_consts t", "obtain u' where \"\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u'\" \"u' \\<approx>\\<^sub>e u\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u';\n         u' \\<approx>\\<^sub>e u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>closed_venv \\<Gamma>\\<close> \\<open>wellformed_venv \\<Gamma>\\<close> \\<open>fdisjnt C (fmdom \\<Gamma>)\\<close> \\<open>fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  \\<not> shadows_consts t\n  closed_venv \\<Gamma>\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u';\n         u' \\<approx>\\<^sub>e u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>not_shadows_vconsts_env \\<Gamma>\\<close> Cons.hyps"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  pre_strong_term_class.wellformed t\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  \\<not> shadows_consts t\n  closed_venv \\<Gamma>\n  wellformed_venv \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  not_shadows_vconsts_env \\<Gamma>\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \\<and>\n  (\\<forall>x xa.\n      (\\<forall>xb.\n          x \\<turnstile>\\<^sub>v t \\<down> xb \\<longrightarrow>\n          xb \\<approx>\\<^sub>e u \\<longrightarrow> xa) \\<longrightarrow>\n      fmrel_on_fset (ids t) erelated x \\<Gamma> \\<longrightarrow>\n      closed_venv \\<Gamma> \\<longrightarrow>\n      closed_except t (fmdom \\<Gamma>) \\<longrightarrow>\n      pre_strong_term_class.wellformed t \\<longrightarrow>\n      wellformed_venv \\<Gamma> \\<longrightarrow>\n      fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n      consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n      fmpred (\\<lambda>_. vwelldefined') \\<Gamma> \\<longrightarrow>\n      \\<not> shadows_consts t \\<longrightarrow>\n      not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa)\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u';\n         u' \\<approx>\\<^sub>e u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u'\n  u' \\<approx>\\<^sub>e u\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 thesis.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v a21 \\<down> b21 \\<and>\n                (\\<forall>x xa.\n                    (\\<forall>xb.\n                        x \\<turnstile>\\<^sub>v a21 \\<down>\n                        xb \\<longrightarrow>\n                        xb \\<approx>\\<^sub>e b21 \\<longrightarrow>\n                        xa) \\<longrightarrow>\n                    fmrel_on_fset (ids a21) erelated x\n                     \\<Gamma> \\<longrightarrow>\n                    closed_venv \\<Gamma> \\<longrightarrow>\n                    closed_except a21 (fmdom \\<Gamma>) \\<longrightarrow>\n                    pre_strong_term_class.wellformed a21 \\<longrightarrow>\n                    wellformed_venv \\<Gamma> \\<longrightarrow>\n                    fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                    consts a21 |\\<subseteq>|\n                    fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                    fmpred (\\<lambda>_. vwelldefined')\n                     \\<Gamma> \\<longrightarrow>\n                    \\<not> shadows_consts a21 \\<longrightarrow>\n                    not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>us'.\n                       list_all3\n                        (\\<lambda>t u u'.\n                            \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down>\n                            u' \\<and> u' \\<approx>\\<^sub>e u)\n                        a22 b22 us' \\<Longrightarrow>\n                       thesis;\n            list_all\n             (\\<lambda>t.\n                 fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n                 closed_except t (fmdom \\<Gamma>) \\<and>\n                 pre_strong_term_class.wellformed t \\<and>\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n                 \\<not> shadows_consts t)\n             a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us'.\n           list_all3\n            (\\<lambda>t u u'.\n                \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                u' \\<approx>\\<^sub>e u)\n            (a21 # a22) (b21 # b22) us' \\<Longrightarrow>\n           thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule Cons.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all3\n     (\\<lambda>t u u'.\n         \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n         u' \\<approx>\\<^sub>e u)\n     (t # ts) (u # us) ?us'4", "apply (rule list_all3_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all3\n     (\\<lambda>t u u'.\n         \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n         u' \\<approx>\\<^sub>e u)\n     ts us ?zs6\n 2. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> ?z6 \\<and>\n    ?z6 \\<approx>\\<^sub>e u", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> ?z6 \\<and>\n    ?z6 \\<approx>\\<^sub>e u", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> ?z6\n 2. ?z6 \\<approx>\\<^sub>e u", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>us'.\n                   list_all3\n                    (\\<lambda>t u u'.\n                        \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n                        u' \\<approx>\\<^sub>e u)\n                    [] [] us' \\<Longrightarrow>\n                   thesis;\n        list_all\n         (\\<lambda>t.\n             fmrel_on_fset (ids t) erelated \\<Gamma>' \\<Gamma> \\<and>\n             closed_except t (fmdom \\<Gamma>) \\<and>\n             pre_strong_term_class.wellformed t \\<and>\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C \\<and>\n             \\<not> shadows_consts t)\n         []\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["proof (state)\nthis:\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   ts us us'\n\ngoal (1 subgoal):\n 1. \\<And>name \\<Gamma> ts us \\<Gamma>' thesis.\n       \\<lbrakk>name |\\<in>| C;\n        list_all2\n         (\\<lambda>x1 x2.\n             \\<Gamma> \\<turnstile>\\<^sub>v x1 \\<down> x2 \\<and>\n             (\\<forall>x xa.\n                 (\\<forall>xb.\n                     x \\<turnstile>\\<^sub>v x1 \\<down> xb \\<longrightarrow>\n                     xb \\<approx>\\<^sub>e x2 \\<longrightarrow>\n                     xa) \\<longrightarrow>\n                 fmrel_on_fset (ids x1) erelated x\n                  \\<Gamma> \\<longrightarrow>\n                 closed_venv \\<Gamma> \\<longrightarrow>\n                 closed_except x1 (fmdom \\<Gamma>) \\<longrightarrow>\n                 pre_strong_term_class.wellformed x1 \\<longrightarrow>\n                 wellformed_venv \\<Gamma> \\<longrightarrow>\n                 fdisjnt C (fmdom \\<Gamma>) \\<longrightarrow>\n                 consts x1 |\\<subseteq>|\n                 fmdom \\<Gamma> |\\<union>| C \\<longrightarrow>\n                 fmpred (\\<lambda>_. vwelldefined')\n                  \\<Gamma> \\<longrightarrow>\n                 \\<not> shadows_consts x1 \\<longrightarrow>\n                 not_shadows_vconsts_env \\<Gamma> \\<longrightarrow> xa))\n         ts us;\n        \\<And>v'.\n           \\<lbrakk>\\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> v';\n            v' \\<approx>\\<^sub>e Vconstr name us\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        fmrel_on_fset (ids (name $$ ts)) erelated \\<Gamma>' \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except (name $$ ts) (fmdom \\<Gamma>);\n        pre_strong_term_class.wellformed (name $$ ts);\n        wellformed_venv \\<Gamma>; fdisjnt C (fmdom \\<Gamma>);\n        consts (name $$ ts) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        \\<not> shadows_consts (name $$ ts);\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule constr.prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>v name $$ ts \\<down> ?v'4\n 2. ?v'4 \\<approx>\\<^sub>e Vconstr name us", "apply (rule veval'.constr[where us = us'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. name |\\<in>| C\n 2. list_all2 (veval' \\<Gamma>') ts us'\n 3. Vconstr name us' \\<approx>\\<^sub>e Vconstr name us", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (veval' \\<Gamma>') ts us'\n 2. Vconstr name us' \\<approx>\\<^sub>e Vconstr name us", "using \\<open>list_all3 _ ts us us'\\<close>"], ["proof (prove)\nusing this:\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   ts us us'\n\ngoal (2 subgoals):\n 1. list_all2 (veval' \\<Gamma>') ts us'\n 2. Vconstr name us' \\<approx>\\<^sub>e Vconstr name us", "apply (induct; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vconstr name us' \\<approx>\\<^sub>e Vconstr name us", "apply (rule erelated.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 erelated us' us", "using \\<open>list_all3 _ ts us us'\\<close>"], ["proof (prove)\nusing this:\n  list_all3\n   (\\<lambda>t u u'.\n       \\<Gamma>' \\<turnstile>\\<^sub>v t \\<down> u' \\<and>\n       u' \\<approx>\\<^sub>e u)\n   ts us us'\n\ngoal (1 subgoal):\n 1. list_all2 erelated us' us", "apply (induct; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}