{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Rewriting/Rewriting_Pterm_Elim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma (in pre_irules) irulesI:\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> arity_compatibles irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> is_fmap irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> patterns_compatibles irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> irs \\<noteq> {||}\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> linears pats\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> abs_ish pats rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> fdisjnt (freess pats) all_consts\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> closed_except rhs (freess pats)\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> wellformed rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> \\<not> shadows_consts rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> welldefined rhs\"\n  assumes \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  shows \"irules C_info rs\"", "lemmas irulesI[intro!] = pre_irules.irulesI[unfolded pre_irules_def]", "lemma nterm_to_pterm_inj: \"nterm_to_pterm x = nterm_to_pterm y \\<Longrightarrow> x = y\"", "lemma nterm_to_pterm:\n  assumes \"no_abs t\"\n  shows \"nterm_to_pterm t = convert_term t\"", "lemma nterm_to_pterm_frees[simp]: \"frees (nterm_to_pterm t) = frees t\"", "lemma closed_nterm_to_pterm[intro]: \"closed_except (nterm_to_pterm t) (frees t)\"", "lemma (in constants) shadows_nterm_to_pterm[simp]: \"shadows_consts (nterm_to_pterm t) = shadows_consts t\"", "lemma wellformed_nterm_to_pterm[intro]: \"wellformed (nterm_to_pterm t)\"", "lemma consts_nterm_to_pterm[simp]: \"consts (nterm_to_pterm t) = consts t\"", "lemma compile_heads: \"fst |`| compile rs = fst |`| rs\"", "lemma (in crules) compile_rules: \"irules C_info (compile rs)\"", "lemma arity_compatibles_transform_irules:\n  assumes \"arity_compatibles rs\"\n  shows \"arity_compatibles (transform_irules rs)\"", "lemma arity_transform_irules:\n  assumes \"arity_compatibles rs\" \"rs \\<noteq> {||}\"\n  shows \"arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\"", "lemma transform_irule_set_heads: \"fst |`| transform_irule_set rs = fst |`| rs\"", "lemma (in irules) rules_transform: \"irules C_info (transform_irule_set rs)\"", "lemma irewrite_stepI:\n  assumes \"match (name $$ pats) t = Some env\" \"subst rhs env = u\"\n  shows \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> u\"", "lemma (in irules) irewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> u\" \"closed t\"\n  shows \"closed u\"", "lemma irelated_vars: \"t \\<approx>\\<^sub>i u \\<Longrightarrow> frees t = frees u\"", "lemma irelated_no_abs:\n  assumes \"t \\<approx>\\<^sub>i u\"\n  shows \"no_abs t \\<longleftrightarrow> no_abs u\"", "lemma irelated_subst:\n  assumes \"t \\<approx>\\<^sub>i u\" \"irelated.P_env nenv penv\"\n  shows \"subst t nenv \\<approx>\\<^sub>i subst u penv\"", "lemma related_irewrite_step:\n  assumes \"name, pats, nterm_to_pterm rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\" \"t \\<approx>\\<^sub>i u\"\n  obtains t' where \"unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>i u'\"", "theorem (in nrules) compile_correct:\n  assumes \"compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\" \"t \\<approx>\\<^sub>i u\" \"closed t\"\n  obtains t' where \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"t' \\<approx>\\<^sub>i u'\"", "lemma (in nrules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"closed t\"\n  shows \"compile (consts_of rs) \\<turnstile>\\<^sub>i nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\"", "lemma prelated_refl[intro!]: \"t \\<approx>\\<^sub>p t\"", "lemma prelated_pvars:\n  assumes \"t \\<approx>\\<^sub>p u\"\n  shows \"frees t = frees u\"", "lemma prelated_no_abs_right:\n  assumes \"t \\<approx>\\<^sub>p u\" \"no_abs u\"\n  shows \"t = u\"", "lemma prelated_subst:\n  assumes \"t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\" \"prelated.P_env env\\<^sub>1 env\\<^sub>2\"\n  shows \"subst t\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p subst t\\<^sub>2 env\\<^sub>2\"", "lemma prelated_step:\n  assumes \"name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\" \"t \\<approx>\\<^sub>p u\"\n  obtains t' where \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>p u'\"", "lemma prelated_beta: \\<comment> \\<open>same problem as @{thm [source=true] prelated.related_match}\\<close>\n  assumes \"(pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\" \"rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\" \"t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\"\n  obtains u\\<^sub>1 where \"(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow> u\\<^sub>1\" \"u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\"", "theorem transform_correct:\n  assumes \"transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\" \"t \\<approx>\\<^sub>p u\" \"closed t\"\n  obtains t' where \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\" \\<comment> \\<open>zero or one step\\<close> and \"t' \\<approx>\\<^sub>p u'\"", "lemma (in irules) transform_completeness:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\" \"closed t\"\n  shows \"transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\""], "translations": [["", "lemma (in pre_irules) irulesI:\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> arity_compatibles irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> is_fmap irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> patterns_compatibles irs\"\n  assumes \"\\<And>name irs. (name, irs) |\\<in>| rs \\<Longrightarrow> irs \\<noteq> {||}\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> linears pats\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> abs_ish pats rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> fdisjnt (freess pats) all_consts\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> closed_except rhs (freess pats)\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> wellformed rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> \\<not> shadows_consts rhs\"\n  assumes \"\\<And>name irs pats rhs. (name, irs) |\\<in>| rs \\<Longrightarrow> (pats, rhs) |\\<in>| irs \\<Longrightarrow> welldefined rhs\"\n  assumes \"is_fmap rs\" \"rs \\<noteq> {||}\"\n  shows \"irules C_info rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info rs", "using assms"], ["proof (prove)\nusing this:\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow>\n  Rewriting_Nterm.arity_compatibles ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> is_fmap ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> patterns_compatibles ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> ?irs3 \\<noteq> {||}\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> linears ?pats3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> abs_ish ?pats3 ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> fdisjnt (freess ?pats3) all_consts\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> closed_except ?rhs3 (freess ?pats3)\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> consts ?rhs3 |\\<subseteq>| all_consts\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. irules C_info rs", "unfolding irules_axioms_def irules_def"], ["proof (prove)\nusing this:\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow>\n  Rewriting_Nterm.arity_compatibles ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> is_fmap ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> patterns_compatibles ?irs3\n  (?name3, ?irs3) |\\<in>| rs \\<Longrightarrow> ?irs3 \\<noteq> {||}\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> linears ?pats3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> abs_ish ?pats3 ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> fdisjnt (freess ?pats3) all_consts\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> closed_except ?rhs3 (freess ?pats3)\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> pre_strong_term_class.wellformed ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> \\<not> shadows_consts ?rhs3\n  \\<lbrakk>(?name3, ?irs3) |\\<in>| rs;\n   (?pats3, ?rhs3) |\\<in>| ?irs3\\<rbrakk>\n  \\<Longrightarrow> consts ?rhs3 |\\<subseteq>| all_consts\n  is_fmap rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. pre_irules C_info rs \\<and>\n    is_fmap rs \\<and>\n    rs \\<noteq> {||} \\<and>\n    fBall rs\n     (\\<lambda>(uu_, irs).\n         Rewriting_Nterm.arity_compatibles irs \\<and>\n         is_fmap irs \\<and>\n         patterns_compatibles irs \\<and>\n         irs \\<noteq> {||} \\<and>\n         fBall irs\n          (\\<lambda>(pats, rhs).\n              linears pats \\<and>\n              abs_ish pats rhs \\<and>\n              closed_except rhs (freess pats) \\<and>\n              fdisjnt (freess pats) all_consts \\<and>\n              pre_strong_term_class.wellformed rhs \\<and>\n              \\<not> shadows_consts rhs \\<and>\n              consts rhs |\\<subseteq>| all_consts))", "by (auto simp: prod_fBallI intro: pre_irules_axioms)"], ["", "lemmas irulesI[intro!] = pre_irules.irulesI[unfolded pre_irules_def]"], ["", "subsubsection \\<open>Translation from @{typ nterm} to @{typ pterm}\\<close>"], ["", "fun nterm_to_pterm :: \"nterm \\<Rightarrow> pterm\" where\n\"nterm_to_pterm (Nvar s) = Pvar s\" |\n\"nterm_to_pterm (Nconst s) = Pconst s\" |\n\"nterm_to_pterm (t\\<^sub>1 $\\<^sub>n t\\<^sub>2) = nterm_to_pterm t\\<^sub>1 $\\<^sub>p nterm_to_pterm t\\<^sub>2\" |\n\"nterm_to_pterm (\\<Lambda>\\<^sub>n x. t) = (\\<Lambda>\\<^sub>p x. nterm_to_pterm t)\""], ["", "lemma nterm_to_pterm_inj: \"nterm_to_pterm x = nterm_to_pterm y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_pterm x = nterm_to_pterm y \\<Longrightarrow> x = y", "by (induction y arbitrary: x) (auto elim: nterm_to_pterm.elims)"], ["", "lemma nterm_to_pterm:\n  assumes \"no_abs t\"\n  shows \"nterm_to_pterm t = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_pterm t = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. nterm_to_pterm t = convert_term t", "apply induction"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name. nterm_to_pterm (free name) = convert_term (free name)\n 2. \\<And>name. nterm_to_pterm (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>nterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; nterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> nterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name. nterm_to_pterm (free name) = free name\n 2. \\<And>name. nterm_to_pterm (const name) = const name\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>nterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; nterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> nterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         app (convert_term t\\<^sub>1)\n                          (convert_term t\\<^sub>2)", "by (auto simp: free_nterm_def free_pterm_def const_nterm_def const_pterm_def app_nterm_def app_pterm_def)"], ["", "lemma nterm_to_pterm_frees[simp]: \"frees (nterm_to_pterm t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm t) = frees t", "by (induct t) auto"], ["", "lemma closed_nterm_to_pterm[intro]: \"closed_except (nterm_to_pterm t) (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (nterm_to_pterm t) (frees t)", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm t) |\\<subseteq>| frees t", "by simp"], ["", "lemma (in constants) shadows_nterm_to_pterm[simp]: \"shadows_consts (nterm_to_pterm t) = shadows_consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shadows_consts (nterm_to_pterm t) = shadows_consts t", "by (induct t) (auto simp: shadows_consts_def fdisjnt_alt_def)"], ["", "lemma wellformed_nterm_to_pterm[intro]: \"wellformed (nterm_to_pterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (nterm_to_pterm t)", "by (induct t) auto"], ["", "lemma consts_nterm_to_pterm[simp]: \"consts (nterm_to_pterm t) = consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (nterm_to_pterm t) = consts t", "by (induct t) auto"], ["", "subsubsection \\<open>Translation from @{typ crule_set} to @{typ irule_set}\\<close>"], ["", "definition translate_crules :: \"crules \\<Rightarrow> irules\" where\n\"translate_crules = fimage (map_prod id nterm_to_pterm)\""], ["", "definition compile :: \"crule_set \\<Rightarrow> irule_set\" where\n\"compile = fimage (map_prod id translate_crules)\""], ["", "lemma compile_heads: \"fst |`| compile rs = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| compile rs = fst |`| rs", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| map_prod id translate_crules |`| rs = fst |`| rs", "by simp"], ["", "lemma (in crules) compile_rules: \"irules C_info (compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (compile rs)", "proof"], ["proof (state)\ngoal (14 subgoals):\n 1. constants C_info (fst |`| compile rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 14 subgoals...", "have \"is_fmap rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "using fmap"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap rs", "by simp"], ["proof (state)\nthis:\n  is_fmap rs\n\ngoal (14 subgoals):\n 1. constants C_info (fst |`| compile rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 14 subgoals...", "thus \"is_fmap (compile rs)\""], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (compile rs)", "unfolding compile_def map_prod_def id_apply"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, translate_crules y)) |`| rs)", "by (rule is_fmap_image)"], ["proof (state)\nthis:\n  is_fmap (compile rs)\n\ngoal (13 subgoals):\n 1. constants C_info (fst |`| compile rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 13 subgoals...", "show \"compile rs \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile rs \\<noteq> {||}", "using nonempty"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. compile rs \\<noteq> {||}", "unfolding compile_def"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. map_prod id translate_crules |`| rs \\<noteq> {||}", "by auto"], ["proof (state)\nthis:\n  compile rs \\<noteq> {||}\n\ngoal (12 subgoals):\n 1. constants C_info (fst |`| compile rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 12 subgoals...", "show \"constants C_info (fst |`| compile rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constants C_info (fst |`| compile rs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (fst |`| compile rs) C\n 2. distinct all_constructors", "show \"fdisjnt (fst |`| compile rs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| compile rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| compile rs) C", "unfolding compile_def"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| map_prod id translate_crules |`| rs) C", "by force"], ["proof (state)\nthis:\n  fdisjnt (fst |`| compile rs) C\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  constants C_info (fst |`| compile rs)\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| compile rs) rhs\nA total of 11 subgoals...", "fix name irs"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| compile rs) rhs\nA total of 11 subgoals...", "assume irs: \"(name, irs) |\\<in>| compile rs\""], ["proof (state)\nthis:\n  (name, irs) |\\<in>| compile rs\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| compile rs) rhs\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  (name, irs) |\\<in>| compile rs", "obtain irs' where \"(name, irs') |\\<in>| rs\" \"irs = translate_crules irs'\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| compile rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs'.\n        \\<lbrakk>(name, irs') |\\<in>| rs;\n         irs = translate_crules irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| map_prod id translate_crules |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs'.\n        \\<lbrakk>(name, irs') |\\<in>| rs;\n         irs = translate_crules irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (name, irs') |\\<in>| rs\n  irs = translate_crules irs'\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| compile rs) rhs\nA total of 11 subgoals...", "hence \"arity_compatibles irs'\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  irs = translate_crules irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs'", "using inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  irs = translate_crules irs'\n  fBall rs\n   (\\<lambda>(uu_, crs).\n       Rewriting_Nterm.arity_compatibles crs \\<and>\n       is_fmap crs \\<and>\n       patterns_compatibles crs \\<and>\n       crs \\<noteq> {||} \\<and>\n       fBall crs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            pats \\<noteq> [] \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            frees rhs |\\<subseteq>| freess pats \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs'", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| compile rs) rhs\nA total of 11 subgoals...", "thus \"arity_compatibles irs\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "unfolding \\<open>irs = translate_crules irs'\\<close> translate_crules_def"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles (map_prod id nterm_to_pterm |`| irs')", "by (force dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (10 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| compile rs)", "have \"patterns_compatibles irs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatibles irs'", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, crs).\n       Rewriting_Nterm.arity_compatibles crs \\<and>\n       is_fmap crs \\<and>\n       patterns_compatibles crs \\<and>\n       crs \\<noteq> {||} \\<and>\n       fBall crs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            pats \\<noteq> [] \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            frees rhs |\\<subseteq>| freess pats \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. patterns_compatibles irs'", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatibles irs'\n\ngoal (10 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| compile rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| compile rs)", "thus \"patterns_compatibles irs\""], ["proof (prove)\nusing this:\n  patterns_compatibles irs'\n\ngoal (1 subgoal):\n 1. patterns_compatibles irs", "unfolding \\<open>irs = _\\<close> translate_crules_def"], ["proof (prove)\nusing this:\n  patterns_compatibles irs'\n\ngoal (1 subgoal):\n 1. patterns_compatibles (map_prod id nterm_to_pterm |`| irs')", "by (auto dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatibles irs\n\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "have \"is_fmap irs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs'", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, crs).\n       Rewriting_Nterm.arity_compatibles crs \\<and>\n       is_fmap crs \\<and>\n       patterns_compatibles crs \\<and>\n       crs \\<noteq> {||} \\<and>\n       fBall crs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            pats \\<noteq> [] \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            frees rhs |\\<subseteq>| freess pats \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. is_fmap irs'", "by auto"], ["proof (state)\nthis:\n  is_fmap irs'\n\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "thus \"is_fmap irs\""], ["proof (prove)\nusing this:\n  is_fmap irs'\n\ngoal (1 subgoal):\n 1. is_fmap irs", "unfolding \\<open>irs = translate_crules irs'\\<close> translate_crules_def map_prod_def id_apply"], ["proof (prove)\nusing this:\n  is_fmap irs'\n\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, nterm_to_pterm y)) |`| irs')", "by (rule is_fmap_image)"], ["proof (state)\nthis:\n  is_fmap irs\n\ngoal (8 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "have \"irs' \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irs' \\<noteq> {||}", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, crs).\n       Rewriting_Nterm.arity_compatibles crs \\<and>\n       is_fmap crs \\<and>\n       patterns_compatibles crs \\<and>\n       crs \\<noteq> {||} \\<and>\n       fBall crs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            pats \\<noteq> [] \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            frees rhs |\\<subseteq>| freess pats \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. irs' \\<noteq> {||}", "by auto"], ["proof (state)\nthis:\n  irs' \\<noteq> {||}\n\ngoal (8 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| compile rs \\<Longrightarrow> irs \\<noteq> {||}\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "thus \"irs \\<noteq> {||}\""], ["proof (prove)\nusing this:\n  irs' \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. irs \\<noteq> {||}", "unfolding \\<open>irs = translate_crules irs'\\<close> translate_crules_def"], ["proof (prove)\nusing this:\n  irs' \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. map_prod id nterm_to_pterm |`| irs' \\<noteq> {||}", "by simp"], ["proof (state)\nthis:\n  irs \\<noteq> {||}\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "fix pats rhs"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "assume \"(pats, rhs) |\\<in>| irs\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| irs\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "then"], ["proof (chain)\npicking this:\n  (pats, rhs) |\\<in>| irs", "obtain rhs' where \"(pats, rhs') |\\<in>| irs'\" \"rhs = nterm_to_pterm rhs'\""], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>(pats, rhs') |\\<in>| irs';\n         rhs = nterm_to_pterm rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>irs = translate_crules irs'\\<close> translate_crules_def"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| map_prod id nterm_to_pterm |`| irs'\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>(pats, rhs') |\\<in>| irs';\n         rhs = nterm_to_pterm rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, rhs') |\\<in>| irs'\n  rhs = nterm_to_pterm rhs'\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "hence \"linears pats\" \"pats \\<noteq> []\" \"frees rhs' |\\<subseteq>| freess pats\" \"\\<not> shadows_consts rhs'\""], ["proof (prove)\nusing this:\n  (pats, rhs') |\\<in>| irs'\n  rhs = nterm_to_pterm rhs'\n\ngoal (1 subgoal):\n 1. (linears pats &&& pats \\<noteq> []) &&&\n    frees rhs' |\\<subseteq>| freess pats &&& \\<not> shadows_consts rhs'", "using fbspec[OF inner \\<open>(name, irs') |\\<in>| rs\\<close>]"], ["proof (prove)\nusing this:\n  (pats, rhs') |\\<in>| irs'\n  rhs = nterm_to_pterm rhs'\n  case (name, irs') of\n  (uu_, crs) \\<Rightarrow>\n    Rewriting_Nterm.arity_compatibles crs \\<and>\n    is_fmap crs \\<and>\n    patterns_compatibles crs \\<and>\n    crs \\<noteq> {||} \\<and>\n    fBall crs\n     (\\<lambda>(pats, rhs).\n         linears pats \\<and>\n         pats \\<noteq> [] \\<and>\n         fdisjnt (freess pats) all_consts \\<and>\n         \\<not> shadows_consts rhs \\<and>\n         frees rhs |\\<subseteq>| freess pats \\<and>\n         consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. (linears pats &&& pats \\<noteq> []) &&&\n    frees rhs' |\\<subseteq>| freess pats &&& \\<not> shadows_consts rhs'", "by blast+"], ["proof (state)\nthis:\n  linears pats\n  pats \\<noteq> []\n  frees rhs' |\\<subseteq>| freess pats\n  \\<not> shadows_consts rhs'\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "show \"linears pats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats", "by fact"], ["proof (state)\nthis:\n  linears pats\n\ngoal (6 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "show \"closed_except rhs (freess pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "unfolding \\<open>rhs = nterm_to_pterm rhs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (nterm_to_pterm rhs') (freess pats)", "using \\<open>frees rhs' |\\<subseteq>| freess pats\\<close>"], ["proof (prove)\nusing this:\n  frees rhs' |\\<subseteq>| freess pats\n\ngoal (1 subgoal):\n 1. closed_except (nterm_to_pterm rhs') (freess pats)", "by (metis dual_order.trans closed_nterm_to_pterm closed_except_def)"], ["proof (state)\nthis:\n  closed_except rhs (freess pats)\n\ngoal (5 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "unfolding \\<open>rhs = nterm_to_pterm rhs'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (nterm_to_pterm rhs')", "by auto"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (4 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "have \"fdisjnt (freess pats) all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "using \\<open>(pats, rhs') |\\<in>| irs'\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats, rhs') |\\<in>| irs'\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, crs).\n       Rewriting_Nterm.arity_compatibles crs \\<and>\n       is_fmap crs \\<and>\n       patterns_compatibles crs \\<and>\n       crs \\<noteq> {||} \\<and>\n       fBall crs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            pats \\<noteq> [] \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            frees rhs |\\<subseteq>| freess pats \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "by blast"], ["proof (state)\nthis:\n  fdisjnt (freess pats) all_consts\n\ngoal (4 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| compile rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "thus \"fdisjnt (freess pats) (pre_constants.all_consts C_info (fst |`| compile rs))\""], ["proof (prove)\nusing this:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats)\n     (pre_constants.all_consts C_info (fst |`| compile rs))", "unfolding compile_def"], ["proof (prove)\nusing this:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats)\n     (pre_constants.all_consts C_info\n       (fst |`| map_prod id translate_crules |`| rs))", "by simp"], ["proof (state)\nthis:\n  fdisjnt (freess pats)\n   (pre_constants.all_consts C_info (fst |`| compile rs))\n\ngoal (3 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (nterm_to_pterm rhs')", "using \\<open>\\<not> shadows_consts _\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs'\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (nterm_to_pterm rhs')", "by simp"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| compile rs) rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "thus \"\\<not> pre_constants.shadows_consts C_info (fst |`| compile rs) rhs\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<not> pre_constants.shadows_consts C_info (fst |`| compile rs) rhs", "unfolding compile_heads"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "."], ["proof (state)\nthis:\n  \\<not> pre_constants.shadows_consts C_info (fst |`| compile rs) rhs\n\ngoal (2 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "show \"abs_ish pats rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "using \\<open>pats \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  pats \\<noteq> []\n\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "unfolding abs_ish_def"], ["proof (prove)\nusing this:\n  pats \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats \\<noteq> [] \\<or> is_abs rhs", "by simp"], ["proof (state)\nthis:\n  abs_ish pats rhs\n\ngoal (1 subgoal):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "have \"welldefined rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs' |\\<subseteq>| all_consts", "using fbspec[OF inner \\<open>(name, irs') |\\<in>| rs\\<close>, simplified]"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs' \\<and>\n  is_fmap irs' \\<and>\n  patterns_compatibles irs' \\<and>\n  irs' \\<noteq> {||} \\<and>\n  fBall irs'\n   (\\<lambda>(pats, rhs).\n       linears pats \\<and>\n       pats \\<noteq> [] \\<and>\n       fdisjnt (freess pats) all_consts \\<and>\n       \\<not> shadows_consts rhs \\<and>\n       frees rhs |\\<subseteq>| freess pats \\<and>\n       consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. consts rhs' |\\<subseteq>| all_consts", "using \\<open>(pats, rhs') |\\<in>| irs'\\<close>"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs' \\<and>\n  is_fmap irs' \\<and>\n  patterns_compatibles irs' \\<and>\n  irs' \\<noteq> {||} \\<and>\n  fBall irs'\n   (\\<lambda>(pats, rhs).\n       linears pats \\<and>\n       pats \\<noteq> [] \\<and>\n       fdisjnt (freess pats) all_consts \\<and>\n       \\<not> shadows_consts rhs \\<and>\n       frees rhs |\\<subseteq>| freess pats \\<and>\n       consts rhs |\\<subseteq>| all_consts)\n  (pats, rhs') |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. consts rhs' |\\<subseteq>| all_consts", "by blast"], ["proof (state)\nthis:\n  consts rhs' |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| compile rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| compile rs)", "thus \"pre_constants.welldefined C_info (fst |`| compile rs) rhs\""], ["proof (prove)\nusing this:\n  consts rhs' |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    pre_constants.all_consts C_info (fst |`| compile rs)", "unfolding compile_def \\<open>rhs = _\\<close>"], ["proof (prove)\nusing this:\n  consts rhs' |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts (nterm_to_pterm rhs') |\\<subseteq>|\n    pre_constants.all_consts C_info\n     (fst |`| map_prod id translate_crules |`| rs)", "by simp"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  pre_constants.all_consts C_info (fst |`| compile rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale crules \\<subseteq> crules_as_irules: irules C_info \"compile rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (compile rs)", "by (fact compile_rules)"], ["", "subsubsection \\<open>Transformation of @{typ irule_set}\\<close>"], ["", "definition transform_irules :: \"irules \\<Rightarrow> irules\" where\n\"transform_irules rs = (\n  if arity rs = 0 then rs\n  else map_prod id Pabs |`| fgroup_by (\\<lambda>(pats, rhs). (butlast pats, (last pats, rhs))) rs)\""], ["", "lemma arity_compatibles_transform_irules:\n  assumes \"arity_compatibles rs\"\n  shows \"arity_compatibles (transform_irules rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles (transform_irules rs)", "proof (cases \"arity rs = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity rs = 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)\n 2. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "case True"], ["proof (state)\nthis:\n  arity rs = 0\n\ngoal (2 subgoals):\n 1. arity rs = 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)\n 2. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity rs = 0\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles (transform_irules rs)", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs = 0\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles\n     (if arity rs = 0 then rs\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            rs)", "using assms"], ["proof (prove)\nusing this:\n  arity rs = 0\n  Rewriting_Nterm.arity_compatibles rs\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles\n     (if arity rs = 0 then rs\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            rs)", "by simp"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles (transform_irules rs)\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "case False"], ["proof (state)\nthis:\n  arity rs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "let ?rs' = \"transform_irules rs\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "let ?f = \"\\<lambda>(pats, rhs). (butlast pats, (last pats, rhs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "let ?grp = \"fgroup_by ?f rs\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "have rs': \"?rs' = map_prod id Pabs |`| ?grp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irules rs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs", "using False"], ["proof (prove)\nusing this:\n  arity rs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. transform_irules rs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity rs = 0 then rs\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           rs) =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs", "by simp"], ["proof (state)\nthis:\n  transform_irules rs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    Rewriting_Nterm.arity_compatibles (transform_irules rs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles (transform_irules rs)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "fix pats\\<^sub>1 rhs\\<^sub>1 pats\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "assume \"(pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| ?rs'\" \"(pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| ?rs'\""], ["proof (state)\nthis:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| transform_irules rs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| transform_irules rs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "then"], ["proof (chain)\npicking this:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| transform_irules rs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| transform_irules rs", "obtain rhs\\<^sub>1' rhs\\<^sub>2' where \"(pats\\<^sub>1, rhs\\<^sub>1') |\\<in>| ?grp\" \"(pats\\<^sub>2, rhs\\<^sub>2') |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| transform_irules rs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| transform_irules rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1' rhs\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1, rhs\\<^sub>1') |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs;\n         (pats\\<^sub>2, rhs\\<^sub>2') |\\<in>|\n         fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n          rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rs'"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>|\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>|\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1' rhs\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1, rhs\\<^sub>1') |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs;\n         (pats\\<^sub>2, rhs\\<^sub>2') |\\<in>|\n         fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n          rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats\\<^sub>1, rhs\\<^sub>1') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  (pats\\<^sub>2, rhs\\<^sub>2') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "then"], ["proof (chain)\npicking this:\n  (pats\\<^sub>1, rhs\\<^sub>1') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  (pats\\<^sub>2, rhs\\<^sub>2') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs", "obtain pats\\<^sub>1' pats\\<^sub>2' x y \\<comment> \\<open>dummies\\<close>\n        where \"fst (?f (pats\\<^sub>1', x)) = pats\\<^sub>1\" \"(pats\\<^sub>1', x) |\\<in>| rs\"\n          and \"fst (?f (pats\\<^sub>2', y)) = pats\\<^sub>2\" \"(pats\\<^sub>2', y) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1, rhs\\<^sub>1') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  (pats\\<^sub>2, rhs\\<^sub>2') |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' x pats\\<^sub>2' y.\n        \\<lbrakk>fst (case (pats\\<^sub>1', x) of\n                      (pats, rhs) \\<Rightarrow>\n                        (butlast pats, last pats, rhs)) =\n                 pats\\<^sub>1;\n         (pats\\<^sub>1', x) |\\<in>| rs;\n         fst (case (pats\\<^sub>2', y) of\n              (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         pats\\<^sub>2;\n         (pats\\<^sub>2', y) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: split_beta elim: fgroup_byE2)"], ["proof (state)\nthis:\n  fst (case (pats\\<^sub>1', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>1\n  (pats\\<^sub>1', x) |\\<in>| rs\n  fst (case (pats\\<^sub>2', y) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>2\n  (pats\\<^sub>2', y) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "hence \"pats\\<^sub>1 = butlast pats\\<^sub>1'\" \"pats\\<^sub>2 = butlast pats\\<^sub>2'\" \"length pats\\<^sub>1' = length pats\\<^sub>2'\""], ["proof (prove)\nusing this:\n  fst (case (pats\\<^sub>1', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>1\n  (pats\\<^sub>1', x) |\\<in>| rs\n  fst (case (pats\\<^sub>2', y) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>2\n  (pats\\<^sub>2', y) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1 = butlast pats\\<^sub>1' &&&\n    pats\\<^sub>2 = butlast pats\\<^sub>2' &&&\n    length pats\\<^sub>1' = length pats\\<^sub>2'", "using assms"], ["proof (prove)\nusing this:\n  fst (case (pats\\<^sub>1', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>1\n  (pats\\<^sub>1', x) |\\<in>| rs\n  fst (case (pats\\<^sub>2', y) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\\<^sub>2\n  (pats\\<^sub>2', y) |\\<in>| rs\n  Rewriting_Nterm.arity_compatibles rs\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1 = butlast pats\\<^sub>1' &&&\n    pats\\<^sub>2 = butlast pats\\<^sub>2' &&&\n    length pats\\<^sub>1' = length pats\\<^sub>2'", "by (force dest: fpairwiseD)+"], ["proof (state)\nthis:\n  pats\\<^sub>1 = butlast pats\\<^sub>1'\n  pats\\<^sub>2 = butlast pats\\<^sub>2'\n  length pats\\<^sub>1' = length pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| transform_irules rs;\n        (aa, ba) |\\<in>| transform_irules rs\\<rbrakk>\n       \\<Longrightarrow> length a = length aa", "thus \"length pats\\<^sub>1 = length pats\\<^sub>2\""], ["proof (prove)\nusing this:\n  pats\\<^sub>1 = butlast pats\\<^sub>1'\n  pats\\<^sub>2 = butlast pats\\<^sub>2'\n  length pats\\<^sub>1' = length pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. length pats\\<^sub>1 = length pats\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  length pats\\<^sub>1 = length pats\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles (transform_irules rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arity_transform_irules:\n  assumes \"arity_compatibles rs\" \"rs \\<noteq> {||}\"\n  shows \"arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "proof (cases \"arity rs = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity rs = 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\n 2. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "case True"], ["proof (state)\nthis:\n  arity rs = 0\n\ngoal (2 subgoals):\n 1. arity rs = 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\n 2. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity rs = 0\n\ngoal (1 subgoal):\n 1. arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs = 0\n\ngoal (1 subgoal):\n 1. arity\n     (if arity rs = 0 then rs\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            rs) =\n    (if arity rs = 0 then 0 else arity rs - 1)", "by simp"], ["proof (state)\nthis:\n  arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "case False"], ["proof (state)\nthis:\n  arity rs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "let ?f = \"\\<lambda>(pats, rhs). (butlast pats, (last pats, rhs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "let ?grp = \"fgroup_by ?f rs\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "let ?rs' = \"map_prod id Pabs |`| ?grp\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "have \"arity ?rs' = arity rs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity\n     (map_prod id Pabs |`|\n      fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs) =\n    arity rs - 1", "proof (rule arityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fBall\n     (map_prod id Pabs |`|\n      fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs)\n     (\\<lambda>(pats, uu_). length pats = arity rs - 1)\n 2. map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs \\<noteq>\n    {||}", "show \"fBall ?rs' (\\<lambda>(pats, _). length pats = arity rs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall\n     (map_prod id Pabs |`|\n      fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs)\n     (\\<lambda>(pats, uu_). length pats = arity rs - 1)", "proof (rule prod_fBallI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "fix pats rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "assume \"(pats, rhs) |\\<in>| ?rs'\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>|\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "then"], ["proof (chain)\npicking this:\n  (pats, rhs) |\\<in>|\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>|\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs;\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "then"], ["proof (chain)\npicking this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  rhs = Pabs cs", "obtain pats' x \\<comment> \\<open>dummy\\<close>\n            where \"pats = butlast pats'\" \"(pats', x) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats' x.\n        \\<lbrakk>pats = butlast pats'; (pats', x) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: split_beta elim: fgroup_byE2)"], ["proof (state)\nthis:\n  pats = butlast pats'\n  (pats', x) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "hence \"length pats' = arity rs\""], ["proof (prove)\nusing this:\n  pats = butlast pats'\n  (pats', x) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. length pats' = arity rs", "using assms"], ["proof (prove)\nusing this:\n  pats = butlast pats'\n  (pats', x) |\\<in>| rs\n  Rewriting_Nterm.arity_compatibles rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. length pats' = arity rs", "by (metis arity_compatible_length)"], ["proof (state)\nthis:\n  length pats' = arity rs\n\ngoal (1 subgoal):\n 1. \\<And>pats uu_.\n       (pats, uu_) |\\<in>|\n       map_prod id Pabs |`|\n       fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n        rs \\<Longrightarrow>\n       length pats = arity rs - 1", "thus \"length pats = arity rs - 1\""], ["proof (prove)\nusing this:\n  length pats' = arity rs\n\ngoal (1 subgoal):\n 1. length pats = arity rs - 1", "unfolding \\<open>pats = butlast pats'\\<close>"], ["proof (prove)\nusing this:\n  length pats' = arity rs\n\ngoal (1 subgoal):\n 1. length (butlast pats') = arity rs - 1", "using False"], ["proof (prove)\nusing this:\n  length pats' = arity rs\n  arity rs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (butlast pats') = arity rs - 1", "by simp"], ["proof (state)\nthis:\n  length pats = arity rs - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fBall\n   (map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs)\n   (\\<lambda>(pats, uu_). length pats = arity rs - 1)\n\ngoal (1 subgoal):\n 1. map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs \\<noteq>\n    {||}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs \\<noteq>\n    {||}", "show \"?rs' \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs \\<noteq>\n    {||}", "using assms"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles rs\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs \\<noteq>\n    {||}", "by (simp add: fgroup_by_nonempty)"], ["proof (state)\nthis:\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs \\<noteq>\n  {||}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arity\n   (map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs) =\n  arity rs - 1\n\ngoal (1 subgoal):\n 1. arity rs \\<noteq> 0 \\<Longrightarrow>\n    arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "with False"], ["proof (chain)\npicking this:\n  arity rs \\<noteq> 0\n  arity\n   (map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs) =\n  arity rs - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  arity rs \\<noteq> 0\n  arity\n   (map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs) =\n  arity rs - 1\n\ngoal (1 subgoal):\n 1. arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs \\<noteq> 0\n  arity\n   (map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) rs) =\n  arity rs - 1\n\ngoal (1 subgoal):\n 1. arity\n     (if arity rs = 0 then rs\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            rs) =\n    (if arity rs = 0 then 0 else arity rs - 1)", "by simp"], ["proof (state)\nthis:\n  arity (transform_irules rs) = (if arity rs = 0 then 0 else arity rs - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition transform_irule_set :: \"irule_set \\<Rightarrow> irule_set\" where\n\"transform_irule_set = fimage (map_prod id transform_irules)\""], ["", "lemma transform_irule_set_heads: \"fst |`| transform_irule_set rs = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| transform_irule_set rs = fst |`| rs", "unfolding transform_irule_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| map_prod id transform_irules |`| rs = fst |`| rs", "by simp"], ["", "lemma (in irules) rules_transform: \"irules C_info (transform_irule_set rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (transform_irule_set rs)", "proof"], ["proof (state)\ngoal (14 subgoals):\n 1. constants C_info (fst |`| transform_irule_set rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 14 subgoals...", "have \"is_fmap rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap rs", "using fmap"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap rs", "by simp"], ["proof (state)\nthis:\n  is_fmap rs\n\ngoal (14 subgoals):\n 1. constants C_info (fst |`| transform_irule_set rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 14 subgoals...", "thus \"is_fmap (transform_irule_set rs)\""], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap (transform_irule_set rs)", "unfolding transform_irule_set_def map_prod_def id_apply"], ["proof (prove)\nusing this:\n  is_fmap rs\n\ngoal (1 subgoal):\n 1. is_fmap ((\\<lambda>(x, y). (x, transform_irules y)) |`| rs)", "by (rule is_fmap_image)"], ["proof (state)\nthis:\n  is_fmap (transform_irule_set rs)\n\ngoal (13 subgoals):\n 1. constants C_info (fst |`| transform_irule_set rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 13 subgoals...", "show \"transform_irule_set rs \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<noteq> {||}", "using nonempty"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<noteq> {||}", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. map_prod id transform_irules |`| rs \\<noteq> {||}", "by auto"], ["proof (state)\nthis:\n  transform_irule_set rs \\<noteq> {||}\n\ngoal (12 subgoals):\n 1. constants C_info (fst |`| transform_irule_set rs)\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 5. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> pre_strong_term_class.wellformed rhs\nA total of 12 subgoals...", "show \"constants C_info (fst |`| transform_irule_set rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constants C_info (fst |`| transform_irule_set rs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (fst |`| transform_irule_set rs) C\n 2. distinct all_constructors", "show \"fdisjnt (fst |`| transform_irule_set rs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| transform_irule_set rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| transform_irule_set rs) C", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| map_prod id transform_irules |`| rs) C", "by force"], ["proof (state)\nthis:\n  fdisjnt (fst |`| transform_irule_set rs) C\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  constants C_info (fst |`| transform_irule_set rs)\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| transform_irule_set rs) rhs\nA total of 11 subgoals...", "fix name irs"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| transform_irule_set rs) rhs\nA total of 11 subgoals...", "assume irs: \"(name, irs) |\\<in>| transform_irule_set rs\""], ["proof (state)\nthis:\n  (name, irs) |\\<in>| transform_irule_set rs\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| transform_irule_set rs) rhs\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  (name, irs) |\\<in>| transform_irule_set rs", "obtain irs' where \"(name, irs') |\\<in>| rs\" \"irs = transform_irules irs'\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| transform_irule_set rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs'.\n        \\<lbrakk>(name, irs') |\\<in>| rs;\n         irs = transform_irules irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| map_prod id transform_irules |`| rs\n\ngoal (1 subgoal):\n 1. (\\<And>irs'.\n        \\<lbrakk>(name, irs') |\\<in>| rs;\n         irs = transform_irules irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (name, irs') |\\<in>| rs\n  irs = transform_irules irs'\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| transform_irule_set rs) rhs\nA total of 11 subgoals...", "hence \"arity_compatibles irs'\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  irs = transform_irules irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs'", "using inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  irs = transform_irules irs'\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs'", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (11 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       Rewriting_Nterm.arity_compatibles irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 4. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                  (fst |`| transform_irule_set rs) rhs\nA total of 11 subgoals...", "thus \"arity_compatibles irs\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs", "unfolding \\<open>irs = transform_irules irs'\\<close>"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs'\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles (transform_irules irs')", "by (rule arity_compatibles_transform_irules)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n\ngoal (10 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| transform_irule_set rs)", "have \"irs' \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irs' \\<noteq> {||}", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. irs' \\<noteq> {||}", "by blast"], ["proof (state)\nthis:\n  irs' \\<noteq> {||}\n\ngoal (10 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       irs \\<noteq> {||}\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 10. \\<And>name irs pats rhs.\n        \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n         (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> consts rhs |\\<subseteq>|\n                          pre_constants.all_consts C_info\n                           (fst |`| transform_irule_set rs)", "thus \"irs \\<noteq> {||}\""], ["proof (prove)\nusing this:\n  irs' \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. irs \\<noteq> {||}", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  irs' \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') \\<noteq>\n    {||}", "by (simp add: fgroup_by_nonempty)"], ["proof (state)\nthis:\n  irs \\<noteq> {||}\n\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "let ?f = \"\\<lambda>(pats, rhs). (butlast pats, (last pats, rhs))\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "let ?grp = \"fgroup_by ?f irs'\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "have \"patterns_compatibles irs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatibles irs'", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. patterns_compatibles irs'", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatibles irs'\n\ngoal (9 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       patterns_compatibles irs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 9. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"patterns_compatibles irs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatibles irs", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> patterns_compatibles irs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> patterns_compatibles irs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. patterns_compatibles irs", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. patterns_compatibles\n     (if arity irs' = 0 then irs'\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            irs')", "using \\<open>patterns_compatibles irs'\\<close>"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  patterns_compatibles irs'\n\ngoal (1 subgoal):\n 1. patterns_compatibles\n     (if arity irs' = 0 then irs'\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            irs')", "by simp"], ["proof (state)\nthis:\n  patterns_compatibles irs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> patterns_compatibles irs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatibles irs", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "fix pats\\<^sub>1 rhs\\<^sub>1 pats\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "assume \"(pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| irs\" \"(pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| irs\""], ["proof (state)\nthis:\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| irs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "with irs'"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| irs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| irs", "obtain cs\\<^sub>1 cs\\<^sub>2 where \"(pats\\<^sub>1, cs\\<^sub>1) |\\<in>| ?grp\" \"(pats\\<^sub>2, cs\\<^sub>2) |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>1, rhs\\<^sub>1) |\\<in>| irs\n  (pats\\<^sub>2, rhs\\<^sub>2) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs\\<^sub>1 cs\\<^sub>2.\n        \\<lbrakk>(pats\\<^sub>1, cs\\<^sub>1) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         (pats\\<^sub>2, cs\\<^sub>2) |\\<in>|\n         fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n          irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats\\<^sub>1, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>2, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "then"], ["proof (chain)\npicking this:\n  (pats\\<^sub>1, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>2, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain pats\\<^sub>1' pats\\<^sub>2' and x y \\<comment> \\<open>dummies\\<close>\n            where \"(pats\\<^sub>1', x) |\\<in>| irs'\" \"(pats\\<^sub>2', y) |\\<in>| irs'\"\n              and \"pats\\<^sub>1 = butlast pats\\<^sub>1'\" \"pats\\<^sub>2 = butlast pats\\<^sub>2'\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>2, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' x pats\\<^sub>2' y.\n        \\<lbrakk>(pats\\<^sub>1', x) |\\<in>| irs';\n         (pats\\<^sub>2', y) |\\<in>| irs';\n         pats\\<^sub>1 = butlast pats\\<^sub>1';\n         pats\\<^sub>2 = butlast pats\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding irs'"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats\\<^sub>2, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' x pats\\<^sub>2' y.\n        \\<lbrakk>(pats\\<^sub>1', x) |\\<in>| irs';\n         (pats\\<^sub>2', y) |\\<in>| irs';\n         pats\\<^sub>1 = butlast pats\\<^sub>1';\n         pats\\<^sub>2 = butlast pats\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim: fgroup_byE2)"], ["proof (state)\nthis:\n  (pats\\<^sub>1', x) |\\<in>| irs'\n  (pats\\<^sub>2', y) |\\<in>| irs'\n  pats\\<^sub>1 = butlast pats\\<^sub>1'\n  pats\\<^sub>2 = butlast pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "hence \"patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', x) |\\<in>| irs'\n  (pats\\<^sub>2', y) |\\<in>| irs'\n  pats\\<^sub>1 = butlast pats\\<^sub>1'\n  pats\\<^sub>2 = butlast pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1' pats\\<^sub>2'", "using \\<open>patterns_compatibles irs'\\<close>"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', x) |\\<in>| irs'\n  (pats\\<^sub>2', y) |\\<in>| irs'\n  pats\\<^sub>1 = butlast pats\\<^sub>1'\n  pats\\<^sub>2 = butlast pats\\<^sub>2'\n  patterns_compatibles irs'\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1' pats\\<^sub>2'", "by (auto dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| irs; (aa, ba) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> patterns_compatible a aa", "thus \"patterns_compatible pats\\<^sub>1 pats\\<^sub>2\""], ["proof (prove)\nusing this:\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1 pats\\<^sub>2", "unfolding \\<open>pats\\<^sub>1 = _\\<close> \\<open>pats\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. patterns_compatible (butlast pats\\<^sub>1') (butlast pats\\<^sub>2')", "by auto"], ["proof (state)\nthis:\n  patterns_compatible pats\\<^sub>1 pats\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  patterns_compatibles irs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  patterns_compatibles irs\n\ngoal (8 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "have \"is_fmap irs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs'", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. is_fmap irs'", "by blast"], ["proof (state)\nthis:\n  is_fmap irs'\n\ngoal (8 subgoals):\n 1. \\<And>name irs.\n       (name, irs) |\\<in>| transform_irule_set rs \\<Longrightarrow>\n       is_fmap irs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 8. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"is_fmap irs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> is_fmap irs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> is_fmap irs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. is_fmap irs", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. is_fmap\n     (if arity irs' = 0 then irs'\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            irs')", "using \\<open>is_fmap irs'\\<close>"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  is_fmap irs'\n\ngoal (1 subgoal):\n 1. is_fmap\n     (if arity irs' = 0 then irs'\n      else map_prod id Pabs |`|\n           fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n            irs')", "by simp"], ["proof (state)\nthis:\n  is_fmap irs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> is_fmap irs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap irs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "fix pats rhs\\<^sub>1 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "assume \"(pats, rhs\\<^sub>1) |\\<in>| irs\" \"(pats, rhs\\<^sub>2) |\\<in>| irs\""], ["proof (state)\nthis:\n  (pats, rhs\\<^sub>1) |\\<in>| irs\n  (pats, rhs\\<^sub>2) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "with irs'"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs\\<^sub>1) |\\<in>| irs\n  (pats, rhs\\<^sub>2) |\\<in>| irs", "obtain cs\\<^sub>1 cs\\<^sub>2\n            where \"(pats, cs\\<^sub>1) |\\<in>| ?grp\" \"rhs\\<^sub>1 = Pabs cs\\<^sub>1\"\n              and \"(pats, cs\\<^sub>2) |\\<in>| ?grp\" \"rhs\\<^sub>2 = Pabs cs\\<^sub>2\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs\\<^sub>1) |\\<in>| irs\n  (pats, rhs\\<^sub>2) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs\\<^sub>1 cs\\<^sub>2.\n        \\<lbrakk>(pats, cs\\<^sub>1) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs\\<^sub>1 = Pabs cs\\<^sub>1;\n         (pats, cs\\<^sub>2) |\\<in>|\n         fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n          irs';\n         rhs\\<^sub>2 = Pabs cs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>1 = Pabs cs\\<^sub>1\n  (pats, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>2 = Pabs cs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (pats, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>1 = Pabs cs\\<^sub>1\n  (pats, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>2 = Pabs cs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "have \"is_fmap ?grp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap\n     (fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs')", "by auto"], ["proof (state)\nthis:\n  is_fmap\n   (fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs')\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| irs;\n        (a, b\\<^sub>2) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (pats, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>1 = Pabs cs\\<^sub>1\n  (pats, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>2 = Pabs cs\\<^sub>2\n  is_fmap\n   (fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs')", "show \"rhs\\<^sub>1 = rhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  (pats, cs\\<^sub>1) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>1 = Pabs cs\\<^sub>1\n  (pats, cs\\<^sub>2) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs\\<^sub>2 = Pabs cs\\<^sub>2\n  is_fmap\n   (fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs')\n\ngoal (1 subgoal):\n 1. rhs\\<^sub>1 = rhs\\<^sub>2", "by (auto dest: is_fmapD)"], ["proof (state)\nthis:\n  rhs\\<^sub>1 = rhs\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_fmap irs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_fmap irs\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "fix pats rhs"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "assume \"(pats, rhs) |\\<in>| irs\""], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| irs\n\ngoal (7 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> linears pats\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 7. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"linears pats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> linears pats\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> linears pats\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. linears pats", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  linears pats\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (pats, cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (pats, cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "then"], ["proof (chain)\npicking this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain pats' x \\<comment> \\<open>dummy\\<close>\n        where \"fst (?f (pats', x)) = pats\" \"(pats', x) |\\<in>| irs'\""], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats' x.\n        \\<lbrakk>fst (case (pats', x) of\n                      (pats, rhs) \\<Rightarrow>\n                        (butlast pats, last pats, rhs)) =\n                 pats;\n         (pats', x) |\\<in>| irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: split_beta elim: fgroup_byE2)"], ["proof (state)\nthis:\n  fst (case (pats', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\n  (pats', x) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "hence \"pats = butlast pats'\""], ["proof (prove)\nusing this:\n  fst (case (pats', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\n  (pats', x) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. pats = butlast pats'", "by simp"], ["proof (state)\nthis:\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "moreover"], ["proof (state)\nthis:\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "have \"linears pats'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats'", "using \\<open>(pats', x) |\\<in>| irs'\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', x) |\\<in>| irs'\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats'", "by blast"], ["proof (state)\nthis:\n  linears pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> linears pats", "ultimately"], ["proof (chain)\npicking this:\n  pats = butlast pats'\n  linears pats'", "show ?thesis"], ["proof (prove)\nusing this:\n  pats = butlast pats'\n  linears pats'\n\ngoal (1 subgoal):\n 1. linears pats", "by auto"], ["proof (state)\nthis:\n  linears pats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  linears pats\n\ngoal (6 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "have \"fdisjnt (freess pats) all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (pats, cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (pats, cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "then"], ["proof (chain)\npicking this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain pats' x \\<comment> \\<open>dummy\\<close>\n        where \"fst (?f (pats', x)) = pats\" \"(pats', x) |\\<in>| irs'\""], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats' x.\n        \\<lbrakk>fst (case (pats', x) of\n                      (pats, rhs) \\<Rightarrow>\n                        (butlast pats, last pats, rhs)) =\n                 pats;\n         (pats', x) |\\<in>| irs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: split_beta elim: fgroup_byE2)"], ["proof (state)\nthis:\n  fst (case (pats', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\n  (pats', x) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "hence \"pats = butlast pats'\""], ["proof (prove)\nusing this:\n  fst (case (pats', x) of\n       (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  pats\n  (pats', x) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. pats = butlast pats'", "by simp"], ["proof (state)\nthis:\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "moreover"], ["proof (state)\nthis:\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "have \"fdisjnt (freess pats') all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess pats') all_consts", "using \\<open>(pats', x) |\\<in>| irs'\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', x) |\\<in>| irs'\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats') all_consts", "by blast"], ["proof (state)\nthis:\n  fdisjnt (freess pats') all_consts\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> fdisjnt (freess pats) all_consts", "ultimately"], ["proof (chain)\npicking this:\n  pats = butlast pats'\n  fdisjnt (freess pats') all_consts", "show ?thesis"], ["proof (prove)\nusing this:\n  pats = butlast pats'\n  fdisjnt (freess pats') all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) all_consts", "by (metis subsetI in_set_butlastD freess_subset fdisjnt_subset_left)"], ["proof (state)\nthis:\n  fdisjnt (freess pats) all_consts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fdisjnt (freess pats) all_consts\n\ngoal (6 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess pats)\n                          (pre_constants.all_consts C_info\n                            (fst |`| transform_irule_set rs))\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 6. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "thus \"fdisjnt (freess pats) (pre_constants.all_consts C_info (fst |`| transform_irule_set rs))\""], ["proof (prove)\nusing this:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats)\n     (pre_constants.all_consts C_info (fst |`| transform_irule_set rs))", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  fdisjnt (freess pats) all_consts\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats)\n     (pre_constants.all_consts C_info\n       (fst |`| map_prod id transform_irules |`| rs))", "by simp"], ["proof (state)\nthis:\n  fdisjnt (freess pats)\n   (pre_constants.all_consts C_info (fst |`| transform_irule_set rs))\n\ngoal (5 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> closed_except rhs (freess pats)\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 5. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"closed_except rhs (freess pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> closed_except rhs (freess pats)\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> closed_except rhs (freess pats)\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  closed_except rhs (freess pats)\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> closed_except rhs (freess pats)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "unfolding \\<open>rhs = Pabs cs\\<close> closed_except_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall cs\n     (\\<lambda>(pat, t). closed_except t (freess pats |\\<union>| frees pat))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "fix pat t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "assume \"(pat, t) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat, t) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "then"], ["proof (chain)\npicking this:\n  (pat, t) |\\<in>| cs", "obtain pats' where \"(pats', t) |\\<in>| irs'\" \"?f (pats', t) = (pats, (pat, t))\""], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs';\n         (case (pats', t) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs';\n         (case (pats', t) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n  (case (pats', t) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "hence \"closed_except t (freess pats')\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  (case (pats', t) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t)\n\ngoal (1 subgoal):\n 1. closed_except t (freess pats')", "using \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  (case (pats', t) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t)\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. closed_except t (freess pats')", "by blast"], ["proof (state)\nthis:\n  closed_except t (freess pats')\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "have \"pats' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "using \\<open>arity_compatibles irs'\\<close> \\<open>(pats', t) |\\<in>| irs'\\<close> False"], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs'\n  (pats', t) |\\<in>| irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)"], ["proof (state)\nthis:\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "hence \"pats' = pats @ [pat]\""], ["proof (prove)\nusing this:\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats' = pats @ [pat]", "using \\<open>?f (pats', t) = (pats, (pat, t))\\<close>"], ["proof (prove)\nusing this:\n  pats' \\<noteq> []\n  (case (pats', t) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t)\n\ngoal (1 subgoal):\n 1. pats' = pats @ [pat]", "by (fastforce simp: split_beta snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "hence \"freess pats |\\<union>| frees pat = freess pats'\""], ["proof (prove)\nusing this:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. freess pats |\\<union>| frees pat = freess pats'", "unfolding freess_def"], ["proof (prove)\nusing this:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. (ffUnion \\<circ> fset_of_list \\<circ> map frees) pats |\\<union>|\n    frees pat =\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) pats'", "by auto"], ["proof (state)\nthis:\n  freess pats |\\<union>| frees pat = freess pats'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       closed_except b (freess pats |\\<union>| frees a)", "thus \"closed_except t (freess pats |\\<union>| frees pat)\""], ["proof (prove)\nusing this:\n  freess pats |\\<union>| frees pat = freess pats'\n\ngoal (1 subgoal):\n 1. closed_except t (freess pats |\\<union>| frees pat)", "using \\<open>closed_except t (freess pats')\\<close>"], ["proof (prove)\nusing this:\n  freess pats |\\<union>| frees pat = freess pats'\n  closed_except t (freess pats')\n\ngoal (1 subgoal):\n 1. closed_except t (freess pats |\\<union>| frees pat)", "by simp"], ["proof (state)\nthis:\n  closed_except t (freess pats |\\<union>| frees pat)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_except rhs (freess pats)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_except rhs (freess pats)\n\ngoal (4 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 4. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "unfolding \\<open>rhs = Pabs cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Pabs cs)", "proof (rule wellformed_PabsI)"], ["proof (state)\ngoal (5 subgoals):\n 1. is_fmap cs\n 2. pattern_compatibles cs\n 3. cs \\<noteq> {||}\n 4. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 5. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "show \"cs \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs \\<noteq> {||}", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close> \\<open>irs' \\<noteq> {||}\\<close>"], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  irs' \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. cs \\<noteq> {||}", "by (meson femptyE fgroup_by_nonempty_inner)"], ["proof (state)\nthis:\n  cs \\<noteq> {||}\n\ngoal (4 subgoals):\n 1. is_fmap cs\n 2. pattern_compatibles cs\n 3. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 4. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. is_fmap cs\n 2. pattern_compatibles cs\n 3. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 4. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "show \"is_fmap cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fmap cs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "fix pat t\\<^sub>1 t\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "assume \"(pat, t\\<^sub>1) |\\<in>| cs\" \"(pat, t\\<^sub>2) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat, t\\<^sub>1) |\\<in>| cs\n  (pat, t\\<^sub>2) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  (pat, t\\<^sub>1) |\\<in>| cs\n  (pat, t\\<^sub>2) |\\<in>| cs", "obtain pats\\<^sub>1' pats\\<^sub>2'\n                where \"(pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\" \"?f (pats\\<^sub>1', t\\<^sub>1) = (pats, (pat, t\\<^sub>1))\"\n                  and \"(pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\" \"?f (pats\\<^sub>2', t\\<^sub>2) = (pats, (pat, t\\<^sub>2))\""], ["proof (prove)\nusing this:\n  (pat, t\\<^sub>1) |\\<in>| cs\n  (pat, t\\<^sub>2) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' pats\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs';\n         (case (pats\\<^sub>1', t\\<^sub>1) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t\\<^sub>1);\n         (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs';\n         (case (pats\\<^sub>2', t\\<^sub>2) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat, t\\<^sub>1) |\\<in>| cs\n  (pat, t\\<^sub>2) |\\<in>| cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' pats\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs';\n         (case (pats\\<^sub>1', t\\<^sub>1) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t\\<^sub>1);\n         (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs';\n         (case (pats\\<^sub>2', t\\<^sub>2) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat, t\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "hence \"pats\\<^sub>1' \\<noteq> []\" \"pats\\<^sub>2' \\<noteq> []\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "using \\<open>arity_compatibles irs'\\<close> False"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "unfolding prod.case"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (butlast pats\\<^sub>1', last pats\\<^sub>1', t\\<^sub>1) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (butlast pats\\<^sub>2', last pats\\<^sub>2', t\\<^sub>2) =\n  (pats, pat, t\\<^sub>2)\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)+"], ["proof (state)\nthis:\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []", "have \"pats\\<^sub>1' = pats @ [pat]\" \"pats\\<^sub>2' = pats @ [pat]\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', t\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', t\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat, t\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' = pats @ [pat] &&& pats\\<^sub>2' = pats @ [pat]", "unfolding split_beta fst_conv snd_conv"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (butlast pats\\<^sub>1', last pats\\<^sub>1', t\\<^sub>1) =\n  (pats, pat, t\\<^sub>1)\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n  (butlast pats\\<^sub>2', last pats\\<^sub>2', t\\<^sub>2) =\n  (pats, pat, t\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' = pats @ [pat] &&& pats\\<^sub>2' = pats @ [pat]", "by (metis prod.inject snoc_eq_iff_butlast)+"], ["proof (state)\nthis:\n  pats\\<^sub>1' = pats @ [pat]\n  pats\\<^sub>2' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. \\<And>a b\\<^sub>1 b\\<^sub>2.\n       \\<lbrakk>(a, b\\<^sub>1) |\\<in>| cs;\n        (a, b\\<^sub>2) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> b\\<^sub>1 = b\\<^sub>2", "with \\<open>is_fmap irs'\\<close>"], ["proof (chain)\npicking this:\n  is_fmap irs'\n  pats\\<^sub>1' = pats @ [pat]\n  pats\\<^sub>2' = pats @ [pat]", "show \"t\\<^sub>1 = t\\<^sub>2\""], ["proof (prove)\nusing this:\n  is_fmap irs'\n  pats\\<^sub>1' = pats @ [pat]\n  pats\\<^sub>2' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. t\\<^sub>1 = t\\<^sub>2", "using \\<open>(pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\\<close> \\<open>(pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\\<close>"], ["proof (prove)\nusing this:\n  is_fmap irs'\n  pats\\<^sub>1' = pats @ [pat]\n  pats\\<^sub>2' = pats @ [pat]\n  (pats\\<^sub>1', t\\<^sub>1) |\\<in>| irs'\n  (pats\\<^sub>2', t\\<^sub>2) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. t\\<^sub>1 = t\\<^sub>2", "by (blast dest: is_fmapD)"], ["proof (state)\nthis:\n  t\\<^sub>1 = t\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_fmap cs\n\ngoal (3 subgoals):\n 1. pattern_compatibles cs\n 2. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 3. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. pattern_compatibles cs\n 2. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 3. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "show \"pattern_compatibles cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern_compatibles cs", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "fix pat\\<^sub>1 rhs\\<^sub>1 pat\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "assume \"(pat\\<^sub>1, rhs\\<^sub>1) |\\<in>| cs\" \"(pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat\\<^sub>1, rhs\\<^sub>1) |\\<in>| cs\n  (pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "then"], ["proof (chain)\npicking this:\n  (pat\\<^sub>1, rhs\\<^sub>1) |\\<in>| cs\n  (pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs", "obtain pats\\<^sub>1' pats\\<^sub>2'\n                where \"(pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\" \"?f (pats\\<^sub>1', rhs\\<^sub>1) = (pats, (pat\\<^sub>1, rhs\\<^sub>1))\"\n                  and \"(pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\" \"?f (pats\\<^sub>2', rhs\\<^sub>2) = (pats, (pat\\<^sub>2, rhs\\<^sub>2))\""], ["proof (prove)\nusing this:\n  (pat\\<^sub>1, rhs\\<^sub>1) |\\<in>| cs\n  (pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' pats\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs';\n         (case (pats\\<^sub>1', rhs\\<^sub>1) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat\\<^sub>1, rhs\\<^sub>1);\n         (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs';\n         (case (pats\\<^sub>2', rhs\\<^sub>2) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat\\<^sub>2, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat\\<^sub>1, rhs\\<^sub>1) |\\<in>| cs\n  (pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>1' pats\\<^sub>2'.\n        \\<lbrakk>(pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs';\n         (case (pats\\<^sub>1', rhs\\<^sub>1) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat\\<^sub>1, rhs\\<^sub>1);\n         (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs';\n         (case (pats\\<^sub>2', rhs\\<^sub>2) of\n          (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n         (pats, pat\\<^sub>2, rhs\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "moreover"], ["proof (state)\nthis:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "hence \"pats\\<^sub>1' \\<noteq> []\" \"pats\\<^sub>2' \\<noteq> []\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "using \\<open>arity_compatibles irs'\\<close> False"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "unfolding prod.case"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (butlast pats\\<^sub>1', last pats\\<^sub>1', rhs\\<^sub>1) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (butlast pats\\<^sub>2', last pats\\<^sub>2', rhs\\<^sub>2) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' \\<noteq> [] &&& pats\\<^sub>2' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)+"], ["proof (state)\nthis:\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "ultimately"], ["proof (chain)\npicking this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []", "have \"pats\\<^sub>1' = pats @ [pat\\<^sub>1]\" \"pats\\<^sub>2' = pats @ [pat\\<^sub>2]\""], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (case (pats\\<^sub>1', rhs\\<^sub>1) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (case (pats\\<^sub>2', rhs\\<^sub>2) of\n   (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' = pats @ [pat\\<^sub>1] &&&\n    pats\\<^sub>2' = pats @ [pat\\<^sub>2]", "unfolding split_beta fst_conv snd_conv"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (butlast pats\\<^sub>1', last pats\\<^sub>1', rhs\\<^sub>1) =\n  (pats, pat\\<^sub>1, rhs\\<^sub>1)\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  (butlast pats\\<^sub>2', last pats\\<^sub>2', rhs\\<^sub>2) =\n  (pats, pat\\<^sub>2, rhs\\<^sub>2)\n  pats\\<^sub>1' \\<noteq> []\n  pats\\<^sub>2' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pats\\<^sub>1' = pats @ [pat\\<^sub>1] &&&\n    pats\\<^sub>2' = pats @ [pat\\<^sub>2]", "by (metis prod.inject snoc_eq_iff_butlast)+"], ["proof (state)\nthis:\n  pats\\<^sub>1' = pats @ [pat\\<^sub>1]\n  pats\\<^sub>2' = pats @ [pat\\<^sub>2]\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "moreover"], ["proof (state)\nthis:\n  pats\\<^sub>1' = pats @ [pat\\<^sub>1]\n  pats\\<^sub>2' = pats @ [pat\\<^sub>2]\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "have \"patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1' pats\\<^sub>2'", "using \\<open>(pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\\<close> \\<open>(pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\\<close> \\<open>patterns_compatibles irs'\\<close>"], ["proof (prove)\nusing this:\n  (pats\\<^sub>1', rhs\\<^sub>1) |\\<in>| irs'\n  (pats\\<^sub>2', rhs\\<^sub>2) |\\<in>| irs'\n  patterns_compatibles irs'\n\ngoal (1 subgoal):\n 1. patterns_compatible pats\\<^sub>1' pats\\<^sub>2'", "by (auto dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) |\\<in>| cs; (aa, ba) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> pattern_compatible a aa", "ultimately"], ["proof (chain)\npicking this:\n  pats\\<^sub>1' = pats @ [pat\\<^sub>1]\n  pats\\<^sub>2' = pats @ [pat\\<^sub>2]\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'", "show \"pattern_compatible pat\\<^sub>1 pat\\<^sub>2\""], ["proof (prove)\nusing this:\n  pats\\<^sub>1' = pats @ [pat\\<^sub>1]\n  pats\\<^sub>2' = pats @ [pat\\<^sub>2]\n  patterns_compatible pats\\<^sub>1' pats\\<^sub>2'\n\ngoal (1 subgoal):\n 1. pattern_compatible pat\\<^sub>1 pat\\<^sub>2", "by (auto elim: rev_accum_rel_snoc_eqE)"], ["proof (state)\nthis:\n  pattern_compatible pat\\<^sub>1 pat\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pattern_compatibles cs\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "fix pat t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "assume \"(pat, t) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat, t) |\\<in>| cs\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "then"], ["proof (chain)\npicking this:\n  (pat, t) |\\<in>| cs", "obtain pats' where \"(pats', t) |\\<in>| irs'\" \"pat = last pats'\""], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs'; pat = last pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs'; pat = last pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "moreover"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "hence \"pats' \\<noteq> []\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "using \\<open>arity_compatibles irs'\\<close> False"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)"], ["proof (state)\nthis:\n  pats' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "ultimately"], ["proof (chain)\npicking this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  pats' \\<noteq> []", "have \"pat \\<in> set pats'\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pat \\<in> set pats'", "by auto"], ["proof (state)\nthis:\n  pat \\<in> set pats'\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "moreover"], ["proof (state)\nthis:\n  pat \\<in> set pats'\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "have \"linears pats'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats'", "using \\<open>(pats', t) |\\<in>| irs'\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats'", "by blast"], ["proof (state)\nthis:\n  linears pats'\n\ngoal (2 subgoals):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\n 2. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "ultimately"], ["proof (chain)\npicking this:\n  pat \\<in> set pats'\n  linears pats'", "show \"linear pat\""], ["proof (prove)\nusing this:\n  pat \\<in> set pats'\n  linears pats'\n\ngoal (1 subgoal):\n 1. linear pat", "by (metis linears_linear)"], ["proof (state)\nthis:\n  linear pat\n\ngoal (1 subgoal):\n 1. \\<And>pat t.\n       (pat, t) |\\<in>| cs \\<Longrightarrow>\n       pre_strong_term_class.wellformed t", "show \"wellformed t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t", "using \\<open>(pats', t) |\\<in>| irs'\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t", "by blast"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> \\<not> shadows_consts rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> \\<not> shadows_consts rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> \\<not> shadows_consts rhs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Pabs cs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "assume \"shadows_consts (Pabs cs)\""], ["proof (state)\nthis:\n  shadows_consts (Pabs cs)\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  shadows_consts (Pabs cs)", "obtain pat t where \"(pat, t) |\\<in>| cs\" \"shadows_consts t \\<or> shadows_consts pat\""], ["proof (prove)\nusing this:\n  shadows_consts (Pabs cs)\n\ngoal (1 subgoal):\n 1. (\\<And>pat t.\n        \\<lbrakk>(pat, t) |\\<in>| cs;\n         shadows_consts t \\<or> shadows_consts pat\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pat, t) |\\<in>| cs\n  shadows_consts t \\<or> shadows_consts pat\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (pat, t) |\\<in>| cs\n  shadows_consts t \\<or> shadows_consts pat", "obtain pats' where \"(pats', t) |\\<in>| irs'\" \"pat = last pats'\""], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n  shadows_consts t \\<or> shadows_consts pat\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs'; pat = last pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n  shadows_consts t \\<or> shadows_consts pat\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', t) |\\<in>| irs'; pat = last pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "hence \"pats' \\<noteq> []\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "using \\<open>arity_compatibles irs'\\<close> False"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  Rewriting_Nterm.arity_compatibles irs'\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)"], ["proof (state)\nthis:\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  pats' \\<noteq> []", "have \"pat \\<in> set pats'\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  pat = last pats'\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pat \\<in> set pats'", "by auto"], ["proof (state)\nthis:\n  pat \\<in> set pats'\n\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>shadows_consts t \\<or> shadows_consts pat\\<close>"], ["proof (prove)\nusing this:\n  shadows_consts t \\<or> shadows_consts pat\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. shadows_consts t \\<Longrightarrow> False\n 2. shadows_consts pat \\<Longrightarrow> False", "assume \"shadows_consts t\""], ["proof (state)\nthis:\n  shadows_consts t\n\ngoal (2 subgoals):\n 1. shadows_consts t \\<Longrightarrow> False\n 2. shadows_consts pat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  shadows_consts t\n\ngoal (1 subgoal):\n 1. False", "using \\<open>(name, irs') |\\<in>| rs\\<close> \\<open>(pats', t) |\\<in>| irs'\\<close> inner"], ["proof (prove)\nusing this:\n  shadows_consts t\n  (name, irs') |\\<in>| rs\n  (pats', t) |\\<in>| irs'\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. shadows_consts pat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. shadows_consts pat \\<Longrightarrow> False", "assume \"shadows_consts pat\""], ["proof (state)\nthis:\n  shadows_consts pat\n\ngoal (1 subgoal):\n 1. shadows_consts pat \\<Longrightarrow> False", "have \"fdisjnt (freess pats') all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess pats') all_consts", "using \\<open>(name, irs') |\\<in>| rs\\<close> \\<open>(pats', t) |\\<in>| irs'\\<close> inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', t) |\\<in>| irs'\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats') all_consts", "by blast"], ["proof (state)\nthis:\n  fdisjnt (freess pats') all_consts\n\ngoal (1 subgoal):\n 1. shadows_consts pat \\<Longrightarrow> False", "have \"fdisjnt (frees pat) all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees pat) all_consts", "apply (rule fdisjnt_subset_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees pat |\\<subseteq>| ?N\n 2. fdisjnt ?N all_consts", "apply (subst freess_single[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. freess [pat] |\\<subseteq>| ?N\n 2. fdisjnt ?N all_consts", "apply (rule freess_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set [pat] \\<subseteq> set ?ys6\n 2. fdisjnt (freess ?ys6) all_consts", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. pat \\<in> set ?ys6\n 2. fdisjnt (freess ?ys6) all_consts", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fdisjnt (frees pat) all_consts\n\ngoal (1 subgoal):\n 1. shadows_consts pat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  fdisjnt (frees pat) all_consts\n\ngoal (1 subgoal):\n 1. False", "using \\<open>shadows_consts pat\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt (frees pat) all_consts\n  shadows_consts pat\n\ngoal (1 subgoal):\n 1. False", "unfolding shadows_consts_def fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  frees pat |\\<inter>| all_consts = {||}\n  all_consts |\\<inter>| all_frees pat \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> \\<not> pre_constants.shadows_consts C_info\n                                 (fst |`| transform_irule_set rs) rhs\n 3. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "thus \"\\<not> pre_constants.shadows_consts C_info (fst |`| transform_irule_set rs) rhs\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<not> pre_constants.shadows_consts C_info\n            (fst |`| transform_irule_set rs) rhs", "by (simp add: transform_irule_set_heads)"], ["proof (state)\nthis:\n  \\<not> pre_constants.shadows_consts C_info\n          (fst |`| transform_irule_set rs) rhs\n\ngoal (2 subgoals):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> abs_ish pats rhs\n 2. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "show \"abs_ish pats rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> abs_ish pats rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> abs_ish pats rhs\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  abs_ish pats rhs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow> abs_ish pats rhs", "thus ?thesis"], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. abs_ish pats rhs", "unfolding abs_ish_def"], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. pats \\<noteq> [] \\<or> is_abs rhs", "by (simp add: is_abs_def term_cases_def)"], ["proof (state)\nthis:\n  abs_ish pats rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abs_ish pats rhs\n\ngoal (1 subgoal):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "have \"welldefined rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> consts rhs |\\<subseteq>| all_consts\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> consts rhs |\\<subseteq>| all_consts\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "hence \\<open>(pats, rhs) |\\<in>| irs'\\<close>"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. (pats, rhs) |\\<in>| irs'", "using \\<open>(pats, rhs) |\\<in>| irs\\<close> \\<open>(name, irs') |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>| irs\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. (pats, rhs) |\\<in>| irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n  (pats, rhs) |\\<in>|\n  (if arity irs' = 0 then irs'\n   else map_prod id Pabs |`|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs')\n  (name, irs') |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. (pats, rhs) |\\<in>| irs'", "by (smt fBallE split_conv)"], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| irs'\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow> consts rhs |\\<subseteq>| all_consts\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "thus ?thesis"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using fbspec[OF inner \\<open>(name, irs') |\\<in>| rs\\<close>, simplified]"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| irs'\n  Rewriting_Nterm.arity_compatibles irs' \\<and>\n  is_fmap irs' \\<and>\n  patterns_compatibles irs' \\<and>\n  irs' \\<noteq> {||} \\<and>\n  fBall irs'\n   (\\<lambda>(pats, rhs).\n       linears pats \\<and>\n       abs_ish pats rhs \\<and>\n       closed_except rhs (freess pats) \\<and>\n       fdisjnt (freess pats) all_consts \\<and>\n       pre_strong_term_class.wellformed rhs \\<and>\n       \\<not> shadows_consts rhs \\<and> consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by force"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "hence irs': \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = transform_irules irs'\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "then"], ["proof (chain)\npicking this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "obtain cs where \"(pats, cs) |\\<in>| ?grp\" \"rhs = Pabs cs\""], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, rhs) |\\<in>| irs\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>(pats, cs) |\\<in>|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  irs';\n         rhs = Pabs cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  rhs = Pabs cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    consts rhs |\\<subseteq>| all_consts", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Pabs cs) |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion ((consts \\<circ> snd) |`| cs) |\\<subseteq>| all_consts", "apply (rule ffUnion_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall ((consts \\<circ> snd) |`| cs)\n     (\\<lambda>X. X |\\<subseteq>| all_consts)", "unfolding ball_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall cs (\\<lambda>x. (consts \\<circ> snd) x |\\<subseteq>| all_consts)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| cs \\<Longrightarrow>\n       (consts \\<circ> snd) x |\\<subseteq>| all_consts", "apply (rename_tac x, case_tac x, hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow>\n       (consts \\<circ> snd) (a, b) |\\<subseteq>| all_consts", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs \\<Longrightarrow> consts b |\\<subseteq>| all_consts", "subgoal premises prems for pat t"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "from prems"], ["proof (chain)\npicking this:\n  (pat, t) |\\<in>| cs", "obtain pats' where \"(pats', t) |\\<in>| irs'\""], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        (pats', t) |\\<in>| irs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (prove)\nusing this:\n  (pat, t) |\\<in>| cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        (pats', t) |\\<in>| irs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', t) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "hence \"welldefined t\""], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "using fbspec[OF inner \\<open>(name, irs') |\\<in>| rs\\<close>, simplified]"], ["proof (prove)\nusing this:\n  (pats', t) |\\<in>| irs'\n  Rewriting_Nterm.arity_compatibles irs' \\<and>\n  is_fmap irs' \\<and>\n  patterns_compatibles irs' \\<and>\n  irs' \\<noteq> {||} \\<and>\n  fBall irs'\n   (\\<lambda>(pats, rhs).\n       linears pats \\<and>\n       abs_ish pats rhs \\<and>\n       closed_except rhs (freess pats) \\<and>\n       fdisjnt (freess pats) all_consts \\<and>\n       pre_strong_term_class.wellformed rhs \\<and>\n       \\<not> shadows_consts rhs \\<and> consts rhs |\\<subseteq>| all_consts)\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by blast"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "thus ?thesis"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by simp"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| all_consts\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. \\<And>name irs pats rhs.\n       \\<lbrakk>(name, irs) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| irs\\<rbrakk>\n       \\<Longrightarrow> consts rhs |\\<subseteq>|\n                         pre_constants.all_consts C_info\n                          (fst |`| transform_irule_set rs)", "thus \"pre_constants.welldefined C_info (fst |`| transform_irule_set rs) rhs\""], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    pre_constants.all_consts C_info (fst |`| transform_irule_set rs)", "unfolding transform_irule_set_heads"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "."], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  pre_constants.all_consts C_info (fst |`| transform_irule_set rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Matching and rewriting\\<close>"], ["", "definition irewrite_step :: \"name \\<Rightarrow> term list \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> pterm option\" where\n\"irewrite_step name pats rhs t = map_option (subst rhs) (match (name $$ pats) t)\""], ["", "abbreviation irewrite_step' :: \"name \\<Rightarrow> term list \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_, _, _ \\<turnstile>\\<^sub>i/ _ \\<rightarrow>/ _\" [50,0,50] 50) where\n\"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> u \\<equiv> irewrite_step name pats rhs t = Some u\""], ["", "lemma irewrite_stepI:\n  assumes \"match (name $$ pats) t = Some env\" \"subst rhs env = u\"\n  shows \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> u", "using assms"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env\n  subst rhs env = u\n\ngoal (1 subgoal):\n 1. name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> u", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env\n  subst rhs env = u\n\ngoal (1 subgoal):\n 1. map_option (subst rhs) (match (name $$ pats) t) = Some u", "by simp"], ["", "inductive irewrite :: \"irule_set \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>i/ _ \\<longrightarrow>/ _\" [50,0,50] 50) for irs where\nstep: \"\\<lbrakk> (name, rs) |\\<in>| irs; (pats, rhs) |\\<in>| rs; name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t' \\<rbrakk> \\<Longrightarrow> irs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\" |\nbeta: \"\\<lbrakk> c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t' \\<rbrakk> \\<Longrightarrow> irs \\<turnstile>\\<^sub>i Pabs cs $\\<^sub>p t \\<longrightarrow> t'\" |\n\"fun\": \"irs \\<turnstile>\\<^sub>i t \\<longrightarrow> t' \\<Longrightarrow> irs \\<turnstile>\\<^sub>i t $\\<^sub>p u \\<longrightarrow> t' $\\<^sub>p u\" |\narg: \"irs \\<turnstile>\\<^sub>i u \\<longrightarrow> u' \\<Longrightarrow> irs \\<turnstile>\\<^sub>i t $\\<^sub>p u \\<longrightarrow> t $\\<^sub>p u'\""], ["", "global_interpretation irewrite: rewriting \"irewrite rs\" for rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rewriting (irewrite rs)", "by standard (auto intro: irewrite.intros simp: app_pterm_def)+"], ["", "abbreviation irewrite_rt :: \"irule_set \\<Rightarrow> pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_/ \\<turnstile>\\<^sub>i/ _ \\<longrightarrow>*/ _\" [50,0,50] 50) where\n\"irewrite_rt rs \\<equiv> (irewrite rs)\\<^sup>*\\<^sup>*\""], ["", "lemma (in irules) irewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> u\" \"closed t\"\n  shows \"closed u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow> u\n  closed t\n\ngoal (1 subgoal):\n 1. closed u", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "case (step name rs pats rhs t t')"], ["proof (state)\nthis:\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "then"], ["proof (chain)\npicking this:\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t", "obtain env where \"match (name $$ pats) t = Some env\" \"t' = subst rhs env\""], ["proof (prove)\nusing this:\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  map_option (subst rhs) (match (name $$ pats) t) = Some t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match (name $$ pats) t = Some env\n  t' = subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "hence \"closed_env env\""], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env\n  t' = subst rhs env\n\ngoal (1 subgoal):\n 1. closed_env env", "using step"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env\n  t' = subst rhs env\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. closed_env env", "by (auto intro: closed.match)"], ["proof (state)\nthis:\n  closed_env env\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst rhs env)", "apply (subst closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst rhs env) |\\<subseteq>| {||}", "apply (subst subst_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env env\n 2. frees rhs |-| fmdom env |\\<subseteq>| {||}", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| fmdom env |\\<subseteq>| {||}", "apply (subst match_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match ?p1 ?t1 = Some env\n 2. frees rhs |-| frees ?p1 |\\<subseteq>| {||}", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| frees (name $$ pats) |\\<subseteq>| {||}", "apply (subst frees_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| (frees (const name) |\\<union>| freess pats) |\\<subseteq>|\n    {||}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| freess pats", "apply (subst closed_except_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "using inner step"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  (name, rs) |\\<in>| rs\n  (pats, rhs) |\\<in>| rs\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats)", "by blast"], ["proof (state)\nthis:\n  closed t'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "case (beta c cs t t')"], ["proof (state)\nthis:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "then"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)", "obtain pat rhs where \"c = (pat, rhs)\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        c = (pat, rhs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (pat, rhs)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "with beta"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n  c = (pat, rhs)", "obtain env where \"match pat t = Some env\" \"t' = subst rhs env\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match pat t = Some env; t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match pat t = Some env\n  t' = subst rhs env\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "moreover"], ["proof (state)\nthis:\n  match pat t = Some env\n  t' = subst rhs env\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "have \"closed t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t", "using beta"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. closed t", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  frees (Pabs cs $\\<^sub>p t) |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| {||}", "by simp"], ["proof (state)\nthis:\n  closed t\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "ultimately"], ["proof (chain)\npicking this:\n  match pat t = Some env\n  t' = subst rhs env\n  closed t", "have \"closed_env env\""], ["proof (prove)\nusing this:\n  match pat t = Some env\n  t' = subst rhs env\n  closed t\n\ngoal (1 subgoal):\n 1. closed_env env", "using beta"], ["proof (prove)\nusing this:\n  match pat t = Some env\n  t' = subst rhs env\n  closed t\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n\ngoal (1 subgoal):\n 1. closed_env env", "by (auto intro: closed.match)"], ["proof (state)\nthis:\n  closed_env env\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'", "unfolding \\<open>t' = subst rhs env\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst rhs env)", "apply (subst closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst rhs env) |\\<subseteq>| {||}", "apply (subst subst_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env env\n 2. frees rhs |-| fmdom env |\\<subseteq>| {||}", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| fmdom env |\\<subseteq>| {||}", "apply (subst match_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match ?p1 ?t1 = Some env\n 2. frees rhs |-| frees ?p1 |\\<subseteq>| {||}", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| frees pat |\\<subseteq>| {||}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat", "apply (subst closed_except_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "using inner beta \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  c |\\<in>| cs\n  c \\<turnstile> t \\<rightarrow> t'\n  closed (Pabs cs $\\<^sub>p t)\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "by (auto simp: closed_except_simps)"], ["proof (state)\nthis:\n  closed t'\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow> closed t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t' $\\<^sub>p u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow> closed u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> closed (t $\\<^sub>p u')", "qed (auto simp: closed_except_def)"], ["", "corollary (in irules) irewrite_rt_closed:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\" \"closed t\"\n  shows \"closed u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n  closed t\n\ngoal (1 subgoal):\n 1. closed u", "by induction (auto intro: irewrite_closed)"], ["", "subsubsection \\<open>Correctness of translation\\<close>"], ["", "abbreviation irelated :: \"nterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_ \\<approx>\\<^sub>i _\" [0,50] 50) where\n\"n \\<approx>\\<^sub>i p \\<equiv> nterm_to_pterm n = p\""], ["", "global_interpretation irelated: term_struct_rel_strong irelated"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_struct_rel_strong irelated", "by standard\n   (auto simp: app_pterm_def app_nterm_def const_pterm_def const_nterm_def elim: nterm_to_pterm.elims)"], ["", "lemma irelated_vars: \"t \\<approx>\\<^sub>i u \\<Longrightarrow> frees t = frees u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>i u \\<Longrightarrow> frees t = frees u", "by auto"], ["", "lemma irelated_no_abs:\n  assumes \"t \\<approx>\\<^sub>i u\"\n  shows \"no_abs t \\<longleftrightarrow> no_abs u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs t = no_abs u", "using assms"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. no_abs t = no_abs u", "apply (induction arbitrary: t)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x t.\n       t \\<approx>\\<^sub>i Pconst x \\<Longrightarrow>\n       no_abs t = no_abs (Pconst x)\n 2. \\<And>x t.\n       t \\<approx>\\<^sub>i Pvar x \\<Longrightarrow>\n       no_abs t = no_abs (Pvar x)\n 3. \\<And>x t.\n       \\<lbrakk>\\<And>xa xaa t.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    t \\<approx>\\<^sub>i xaa\\<rbrakk>\n                   \\<Longrightarrow> no_abs t = no_abs xaa;\n        t \\<approx>\\<^sub>i Pabs x\\<rbrakk>\n       \\<Longrightarrow> no_abs t = no_abs (Pabs x)\n 4. \\<And>x1a x2a t.\n       \\<lbrakk>\\<And>t.\n                   t \\<approx>\\<^sub>i x1a \\<Longrightarrow>\n                   no_abs t = no_abs x1a;\n        \\<And>t.\n           t \\<approx>\\<^sub>i x2a \\<Longrightarrow> no_abs t = no_abs x2a;\n        t \\<approx>\\<^sub>i x1a $\\<^sub>p x2a\\<rbrakk>\n       \\<Longrightarrow> no_abs t = no_abs (x1a $\\<^sub>p x2a)", "apply (auto elim!: nterm_to_pterm.elims)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s. no_abs (Nconst s) \\<Longrightarrow> no_abs (Pconst s)\n 2. \\<And>s. no_abs (Pconst s) \\<Longrightarrow> no_abs (Nconst s)\n 3. \\<And>s. no_abs (Nvar s) \\<Longrightarrow> no_abs (Pvar s)\n 4. \\<And>s. no_abs (Pvar s) \\<Longrightarrow> no_abs (Nvar s)\n 5. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>t.\n                   t \\<approx>\\<^sub>i nterm_to_pterm\n  t\\<^sub>1 \\<Longrightarrow>\n                   no_abs t = no_abs (nterm_to_pterm t\\<^sub>1);\n        \\<And>t.\n           t \\<approx>\\<^sub>i nterm_to_pterm t\\<^sub>2 \\<Longrightarrow>\n           no_abs t = no_abs (nterm_to_pterm t\\<^sub>2);\n        no_abs (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> no_abs\n                          (nterm_to_pterm t\\<^sub>1 $\\<^sub>p\n                           nterm_to_pterm t\\<^sub>2)\n 6. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>t.\n                   t \\<approx>\\<^sub>i nterm_to_pterm\n  t\\<^sub>1 \\<Longrightarrow>\n                   no_abs t = no_abs (nterm_to_pterm t\\<^sub>1);\n        \\<And>t.\n           t \\<approx>\\<^sub>i nterm_to_pterm t\\<^sub>2 \\<Longrightarrow>\n           no_abs t = no_abs (nterm_to_pterm t\\<^sub>2);\n        no_abs\n         (nterm_to_pterm t\\<^sub>1 $\\<^sub>p\n          nterm_to_pterm t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> no_abs (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)", "apply (fold const_nterm_def const_pterm_def free_nterm_def free_pterm_def app_pterm_def app_nterm_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s. no_abs (const s) \\<Longrightarrow> no_abs (const s)\n 2. \\<And>s. no_abs (const s) \\<Longrightarrow> no_abs (const s)\n 3. \\<And>s. no_abs (free s) \\<Longrightarrow> no_abs (free s)\n 4. \\<And>s. no_abs (free s) \\<Longrightarrow> no_abs (free s)\n 5. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>t.\n                   t \\<approx>\\<^sub>i nterm_to_pterm\n  t\\<^sub>1 \\<Longrightarrow>\n                   no_abs t = no_abs (nterm_to_pterm t\\<^sub>1);\n        \\<And>t.\n           t \\<approx>\\<^sub>i nterm_to_pterm t\\<^sub>2 \\<Longrightarrow>\n           no_abs t = no_abs (nterm_to_pterm t\\<^sub>2);\n        no_abs (app t\\<^sub>1 t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> no_abs\n                          (app (nterm_to_pterm t\\<^sub>1)\n                            (nterm_to_pterm t\\<^sub>2))\n 6. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<And>t.\n                   t \\<approx>\\<^sub>i nterm_to_pterm\n  t\\<^sub>1 \\<Longrightarrow>\n                   no_abs t = no_abs (nterm_to_pterm t\\<^sub>1);\n        \\<And>t.\n           t \\<approx>\\<^sub>i nterm_to_pterm t\\<^sub>2 \\<Longrightarrow>\n           no_abs t = no_abs (nterm_to_pterm t\\<^sub>2);\n        no_abs\n         (app (nterm_to_pterm t\\<^sub>1)\n           (nterm_to_pterm t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> no_abs (app t\\<^sub>1 t\\<^sub>2)", "by auto"], ["", "lemma irelated_subst:\n  assumes \"t \\<approx>\\<^sub>i u\" \"irelated.P_env nenv penv\"\n  shows \"subst t nenv \\<approx>\\<^sub>i subst u penv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t nenv \\<approx>\\<^sub>i subst u penv", "using assms"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>i u\n  irelated.P_env nenv penv\n\ngoal (1 subgoal):\n 1. subst t nenv \\<approx>\\<^sub>i subst u penv", "proof (induction arbitrary: nenv penv u rule: nterm_to_pterm.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nvar s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nvar s) nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 4. \\<And>x t nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<Lambda>\\<^sub>n x. t \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (\\<Lambda>\\<^sub>n x. t)\n                          nenv \\<approx>\\<^sub>i subst u penv", "case (1 s)"], ["proof (state)\nthis:\n  Nvar s \\<approx>\\<^sub>i u\n  irelated.P_env nenv penv\n\ngoal (4 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nvar s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nvar s) nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 4. \\<And>x t nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<Lambda>\\<^sub>n x. t \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (\\<Lambda>\\<^sub>n x. t)\n                          nenv \\<approx>\\<^sub>i subst u penv", "then"], ["proof (chain)\npicking this:\n  Nvar s \\<approx>\\<^sub>i u\n  irelated.P_env nenv penv", "show ?case"], ["proof (prove)\nusing this:\n  Nvar s \\<approx>\\<^sub>i u\n  irelated.P_env nenv penv\n\ngoal (1 subgoal):\n 1. subst (Nvar s) nenv \\<approx>\\<^sub>i subst u penv", "by (auto elim!: fmrel_cases[where x = s])"], ["proof (state)\nthis:\n  subst (Nvar s) nenv \\<approx>\\<^sub>i subst u penv\n\ngoal (3 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 3. \\<And>x t nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<Lambda>\\<^sub>n x. t \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (\\<Lambda>\\<^sub>n x. t)\n                          nenv \\<approx>\\<^sub>i subst u penv", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 3. \\<And>x t nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<Lambda>\\<^sub>n x. t \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (\\<Lambda>\\<^sub>n x. t)\n                          nenv \\<approx>\\<^sub>i subst u penv", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>t_ \\<approx>\\<^sub>i ?u; irelated.P_env ?nenv ?penv\\<rbrakk>\n  \\<Longrightarrow> subst t_ ?nenv \\<approx>\\<^sub>i subst ?u ?penv\n  \\<Lambda>\\<^sub>n x_. t_ \\<approx>\\<^sub>i u\n  irelated.P_env nenv penv\n\ngoal (3 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 3. \\<And>x t nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<Lambda>\\<^sub>n x. t \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (\\<Lambda>\\<^sub>n x. t)\n                          nenv \\<approx>\\<^sub>i subst u penv", "from 4(2)[symmetric]"], ["proof (chain)\npicking this:\n  u = nterm_to_pterm (\\<Lambda>\\<^sub>n x_. t_)", "show ?case"], ["proof (prove)\nusing this:\n  u = nterm_to_pterm (\\<Lambda>\\<^sub>n x_. t_)\n\ngoal (1 subgoal):\n 1. subst (\\<Lambda>\\<^sub>n x_. t_) nenv \\<approx>\\<^sub>i subst u penv", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<Lambda>\\<^sub>p x_. nterm_to_pterm t_) \\<Longrightarrow>\n    subst t_\n     (fmdrop x_\n       nenv) \\<approx>\\<^sub>i subst (nterm_to_pterm t_) (fmdrop x_ penv)", "apply (rule 4)"], ["proof (prove)\ngoal (2 subgoals):\n 1. u = (\\<Lambda>\\<^sub>p x_. nterm_to_pterm t_) \\<Longrightarrow>\n    t_ \\<approx>\\<^sub>i nterm_to_pterm t_\n 2. u = (\\<Lambda>\\<^sub>p x_. nterm_to_pterm t_) \\<Longrightarrow>\n    irelated.P_env (fmdrop x_ nenv) (fmdrop x_ penv)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<Lambda>\\<^sub>p x_. nterm_to_pterm t_) \\<Longrightarrow>\n    irelated.P_env (fmdrop x_ nenv) (fmdrop x_ penv)", "using 4(3)"], ["proof (prove)\nusing this:\n  irelated.P_env nenv penv\n\ngoal (1 subgoal):\n 1. u = (\\<Lambda>\\<^sub>p x_. nterm_to_pterm t_) \\<Longrightarrow>\n    irelated.P_env (fmdrop x_ nenv) (fmdrop x_ penv)", "by (simp add: fmrel_drop)"], ["proof (state)\nthis:\n  subst (\\<Lambda>\\<^sub>n x_. t_) nenv \\<approx>\\<^sub>i subst u penv\n\ngoal (2 subgoals):\n 1. \\<And>s nenv penv u.\n       \\<lbrakk>Nconst s \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (Nconst s)\n                          nenv \\<approx>\\<^sub>i subst u penv\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 nenv penv u.\n       \\<lbrakk>\\<And>nenv penv u.\n                   \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>i u;\n                    irelated.P_env nenv penv\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\nnenv \\<approx>\\<^sub>i subst u penv;\n        \\<And>nenv penv u.\n           \\<lbrakk>t\\<^sub>2 \\<approx>\\<^sub>i u;\n            irelated.P_env nenv penv\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              nenv \\<approx>\\<^sub>i subst u penv;\n        t\\<^sub>1 $\\<^sub>n t\\<^sub>2 \\<approx>\\<^sub>i u;\n        irelated.P_env nenv penv\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>n t\\<^sub>2)\n                          nenv \\<approx>\\<^sub>i subst u penv", "qed auto"], ["", "lemma related_irewrite_step:\n  assumes \"name, pats, nterm_to_pterm rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\" \"t \\<approx>\\<^sub>i u\"\n  obtains t' where \"unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?rhs' = \"nterm_to_pterm rhs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?x = \"name $$ pats\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  name, pats, nterm_to_pterm rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>i u", "obtain env where \"match ?x u = Some env\" \"u' = subst ?rhs' env\""], ["proof (prove)\nusing this:\n  name, pats, nterm_to_pterm rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) u = Some env;\n         u' = subst (nterm_to_pterm rhs) env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  map_option (subst (nterm_to_pterm rhs)) (match (name $$ pats) u) = Some u'\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) u = Some env;\n         u' = subst (nterm_to_pterm rhs) env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  match (name $$ pats) u = Some env\n  u' = subst (nterm_to_pterm rhs) env\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  match (name $$ pats) u = Some env\n  u' = subst (nterm_to_pterm rhs) env", "obtain nenv where \"match ?x t = Some nenv\" \"irelated.P_env nenv env\""], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\n  u' = subst (nterm_to_pterm rhs) env\n\ngoal (1 subgoal):\n 1. (\\<And>nenv.\n        \\<lbrakk>match (name $$ pats) t = Some nenv;\n         irelated.P_env nenv env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\n  u' = subst (nterm_to_pterm rhs) env\n  name, pats, nterm_to_pterm rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>nenv.\n        \\<lbrakk>match (name $$ pats) t = Some nenv;\n         irelated.P_env nenv env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Option.is_none_def not_None_eq option.rel_distinct(1) option.sel rel_option_unfold irelated.match_rel)"], ["proof (state)\nthis:\n  match (name $$ pats) t = Some nenv\n  irelated.P_env nenv env\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n                 t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow> ?t'\n 2. ?t' \\<approx>\\<^sub>i u'", "show \"unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow> subst rhs nenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n    subst rhs nenv", "using \\<open>match ?x t = _\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some nenv\n\ngoal (1 subgoal):\n 1. unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow>\n    subst rhs nenv", "by auto"], ["proof (state)\nthis:\n  unsplit_rule (name, pats, rhs) \\<turnstile> t \\<rightarrow> subst rhs nenv\n\ngoal (1 subgoal):\n 1. subst rhs nenv \\<approx>\\<^sub>i u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst rhs nenv \\<approx>\\<^sub>i u'", "show \"subst rhs nenv \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs nenv \\<approx>\\<^sub>i u'", "unfolding \\<open>u' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs nenv \\<approx>\\<^sub>i subst (nterm_to_pterm rhs) env", "using \\<open>irelated.P_env nenv env\\<close>"], ["proof (prove)\nusing this:\n  irelated.P_env nenv env\n\ngoal (1 subgoal):\n 1. subst rhs nenv \\<approx>\\<^sub>i subst (nterm_to_pterm rhs) env", "by (auto intro: irelated_subst)"], ["proof (state)\nthis:\n  subst rhs nenv \\<approx>\\<^sub>i u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in nrules) compile_correct:\n  assumes \"compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\" \"t \\<approx>\\<^sub>i u\" \"closed t\"\n  obtains t' where \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1-3)"], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: t thesis rule: irewrite.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step name irs pats rhs u u')"], ["proof (state)\nthis:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i u\n  closed t", "obtain crs where \"irs = translate_crules crs\" \"(name, crs) |\\<in>| consts_of rs\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>crs.\n        \\<lbrakk>irs = translate_crules crs;\n         (name, crs) |\\<in>| consts_of rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_def"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| map_prod id translate_crules |`| consts_of rs\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>crs.\n        \\<lbrakk>irs = translate_crules crs;\n         (name, crs) |\\<in>| consts_of rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with step"], ["proof (chain)\npicking this:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i u\n  closed t\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs", "obtain rhs' where \"rhs = nterm_to_pterm rhs'\" \"(pats, rhs') |\\<in>| crs\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i u\n  closed t\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>rhs = nterm_to_pterm rhs';\n         (pats, rhs') |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding translate_crules_def"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| compile (consts_of rs)\n  (pats, rhs) |\\<in>| irs\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i u\n  closed t\n  irs = map_prod id nterm_to_pterm |`| crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>rhs = nterm_to_pterm rhs';\n         (pats, rhs') |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rhs = nterm_to_pterm rhs'\n  (pats, rhs') |\\<in>| crs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n  rhs = nterm_to_pterm rhs'\n  (pats, rhs') |\\<in>| crs", "obtain rule where \"split_rule rule = (name, (pats, rhs'))\" \"rule |\\<in>| rs\""], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n  rhs = nterm_to_pterm rhs'\n  (pats, rhs') |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>rule.\n        \\<lbrakk>split_rule rule = (name, pats, rhs');\n         rule |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consts_of_def"], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| fgroup_by split_rule rs\n  rhs = nterm_to_pterm rhs'\n  (pats, rhs') |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>rule.\n        \\<lbrakk>split_rule rule = (name, pats, rhs');\n         rule |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  split_rule rule = (name, pats, rhs')\n  rule |\\<in>| rs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"nrule rule\""], ["proof (prove)\nusing this:\n  split_rule rule = (name, pats, rhs')\n  rule |\\<in>| rs\n\ngoal (1 subgoal):\n 1. nrule rule", "using all_rules"], ["proof (prove)\nusing this:\n  split_rule rule = (name, pats, rhs')\n  rule |\\<in>| rs\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. nrule rule", "by blast"], ["proof (state)\nthis:\n  nrule rule\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t' where \"unsplit_rule (name, pats, rhs') \\<turnstile> t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs') \\<turnstile>\n                 t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\\<close> \\<open>t \\<approx>\\<^sub>i u\\<close>"], ["proof (prove)\nusing this:\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs') \\<turnstile>\n                 t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>rhs = nterm_to_pterm rhs'\\<close>"], ["proof (prove)\nusing this:\n  name, pats, nterm_to_pterm rhs' \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>unsplit_rule (name, pats, rhs') \\<turnstile>\n                 t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim related_irewrite_step)"], ["proof (state)\nthis:\n  unsplit_rule (name, pats, rhs') \\<turnstile> t \\<rightarrow> t'\n  t' \\<approx>\\<^sub>i u'\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"rule \\<turnstile> t \\<rightarrow> t'\""], ["proof (prove)\nusing this:\n  unsplit_rule (name, pats, rhs') \\<turnstile> t \\<rightarrow> t'\n  t' \\<approx>\\<^sub>i u'\n\ngoal (1 subgoal):\n 1. rule \\<turnstile> t \\<rightarrow> t'", "using \\<open>nrule rule\\<close> \\<open>split_rule rule = (name, (pats, rhs'))\\<close>"], ["proof (prove)\nusing this:\n  unsplit_rule (name, pats, rhs') \\<turnstile> t \\<rightarrow> t'\n  t' \\<approx>\\<^sub>i u'\n  nrule rule\n  split_rule rule = (name, pats, rhs')\n\ngoal (1 subgoal):\n 1. rule \\<turnstile> t \\<rightarrow> t'", "by (metis unsplit_split)"], ["proof (state)\nthis:\n  rule \\<turnstile> t \\<rightarrow> t'\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| compile (consts_of rs);\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3\n 2. ?t'3 \\<approx>\\<^sub>i u'", "show \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'", "apply (rule nrewrite.step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?r |\\<in>| rs\n 2. ?r \\<turnstile> t \\<rightarrow> t'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. rule \\<turnstile> t \\<rightarrow> t'", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>i u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>i u'", "show \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>i u'", "by fact"], ["proof (state)\nthis:\n  t' \\<approx>\\<^sub>i u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (beta c cs u u')"], ["proof (state)\nthis:\n  c |\\<in>| cs\n  c \\<turnstile> u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\n  closed t\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\n  c \\<turnstile> u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\n  closed t", "obtain pat rhs where \"c = (pat, rhs)\" \"(pat, rhs) |\\<in>| cs\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\n  c \\<turnstile> u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        \\<lbrakk>c = (pat, rhs); (pat, rhs) |\\<in>| cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (pat, rhs)\n  (pat, rhs) |\\<in>| cs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain v w where \"t = v $\\<^sub>n w\" \"v \\<approx>\\<^sub>i Pabs cs\" \"w \\<approx>\\<^sub>i u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        \\<lbrakk>t = v $\\<^sub>n w; v \\<approx>\\<^sub>i Pabs cs;\n         w \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        \\<lbrakk>t = v $\\<^sub>n w; v \\<approx>\\<^sub>i Pabs cs;\n         w \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: nterm_to_pterm.elims)"], ["proof (state)\nthis:\n  t = v $\\<^sub>n w\n  v \\<approx>\\<^sub>i Pabs cs\n  w \\<approx>\\<^sub>i u\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain x nrhs irhs where \"v = (\\<Lambda>\\<^sub>n x. nrhs)\" \"cs = {| (Free x, irhs) |}\" \"nrhs \\<approx>\\<^sub>i irhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x nrhs irhs.\n        \\<lbrakk>v = (\\<Lambda>\\<^sub>n x. nrhs); cs = {|(Free x, irhs)|};\n         nrhs \\<approx>\\<^sub>i irhs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v \\<approx>\\<^sub>i Pabs cs\\<close>"], ["proof (prove)\nusing this:\n  v \\<approx>\\<^sub>i Pabs cs\n\ngoal (1 subgoal):\n 1. (\\<And>x nrhs irhs.\n        \\<lbrakk>v = (\\<Lambda>\\<^sub>n x. nrhs); cs = {|(Free x, irhs)|};\n         nrhs \\<approx>\\<^sub>i irhs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: nterm_to_pterm.elims)"], ["proof (state)\nthis:\n  v = (\\<Lambda>\\<^sub>n x. nrhs)\n  cs = {|(Free x, irhs)|}\n  nrhs \\<approx>\\<^sub>i irhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"t = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w\" \"\\<Lambda>\\<^sub>n x. nrhs \\<approx>\\<^sub>i \\<Lambda>\\<^sub>p x. irhs\""], ["proof (prove)\nusing this:\n  v = (\\<Lambda>\\<^sub>n x. nrhs)\n  cs = {|(Free x, irhs)|}\n  nrhs \\<approx>\\<^sub>i irhs\n\ngoal (1 subgoal):\n 1. t = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w &&&\n    \\<Lambda>\\<^sub>n x. nrhs \\<approx>\\<^sub>i \\<Lambda>\\<^sub>p x. irhs", "unfolding \\<open>t = v $\\<^sub>n w\\<close>"], ["proof (prove)\nusing this:\n  v = (\\<Lambda>\\<^sub>n x. nrhs)\n  cs = {|(Free x, irhs)|}\n  nrhs \\<approx>\\<^sub>i irhs\n\ngoal (1 subgoal):\n 1. v $\\<^sub>n w = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w &&&\n    \\<Lambda>\\<^sub>n x. nrhs \\<approx>\\<^sub>i \\<Lambda>\\<^sub>p x. irhs", "using \\<open>v \\<approx>\\<^sub>i Pabs cs\\<close>"], ["proof (prove)\nusing this:\n  v = (\\<Lambda>\\<^sub>n x. nrhs)\n  cs = {|(Free x, irhs)|}\n  nrhs \\<approx>\\<^sub>i irhs\n  v \\<approx>\\<^sub>i Pabs cs\n\ngoal (1 subgoal):\n 1. v $\\<^sub>n w = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w &&&\n    \\<Lambda>\\<^sub>n x. nrhs \\<approx>\\<^sub>i \\<Lambda>\\<^sub>p x. irhs", "by auto"], ["proof (state)\nthis:\n  t = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w\n  \\<Lambda>\\<^sub>n x. nrhs \\<approx>\\<^sub>i \\<Lambda>\\<^sub>p x. irhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"pat = Free x\" \"rhs = irhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pat = Free x &&& rhs = irhs", "using \\<open>cs = {| (Free x, irhs) |}\\<close> \\<open>(pat, rhs) |\\<in>| cs\\<close>"], ["proof (prove)\nusing this:\n  cs = {|(Free x, irhs)|}\n  (pat, rhs) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. pat = Free x &&& rhs = irhs", "by auto"], ["proof (state)\nthis:\n  pat = Free x\n  rhs = irhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"(Free x, irhs) \\<turnstile> u \\<rightarrow> u'\""], ["proof (prove)\nusing this:\n  pat = Free x\n  rhs = irhs\n\ngoal (1 subgoal):\n 1. (Free x, irhs) \\<turnstile> u \\<rightarrow> u'", "using beta \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  pat = Free x\n  rhs = irhs\n  c |\\<in>| cs\n  c \\<turnstile> u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i Pabs cs $\\<^sub>p u\n  closed t\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. (Free x, irhs) \\<turnstile> u \\<rightarrow> u'", "by simp"], ["proof (state)\nthis:\n  (Free x, irhs) \\<turnstile> u \\<rightarrow> u'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"u' = subst irhs (fmap_of_list [(x, u)])\""], ["proof (prove)\nusing this:\n  (Free x, irhs) \\<turnstile> u \\<rightarrow> u'\n\ngoal (1 subgoal):\n 1. u' = subst irhs (fmap_of_list [(x, u)])", "by simp"], ["proof (state)\nthis:\n  u' = subst irhs (fmap_of_list [(x, u)])\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule beta.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3\n 2. ?t'3 \\<approx>\\<^sub>i u'", "show \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> subst nrhs (fmap_of_list [(x, w)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n    subst nrhs (fmap_of_list [(x, w)])", "unfolding \\<open>t = (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n\n    (\\<Lambda>\\<^sub>n x. nrhs) $\\<^sub>n w \\<longrightarrow>\n    subst nrhs (fmap_of_list [(x, w)])", "by (rule nrewrite.beta)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n  subst nrhs (fmap_of_list [(x, w)])\n\ngoal (1 subgoal):\n 1. subst nrhs (fmap_of_list [(x, w)]) \\<approx>\\<^sub>i u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst nrhs (fmap_of_list [(x, w)]) \\<approx>\\<^sub>i u'", "show \"subst nrhs (fmap_of_list [(x, w)]) \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst nrhs (fmap_of_list [(x, w)]) \\<approx>\\<^sub>i u'", "unfolding \\<open>u' = subst irhs _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst nrhs\n     (fmap_of_list\n       [(x, w)]) \\<approx>\\<^sub>i subst irhs (fmap_of_list [(x, u)])", "apply (rule irelated_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nrhs \\<approx>\\<^sub>i irhs\n 2. irelated.P_env (fmap_of_list [(x, w)]) (fmap_of_list [(x, u)])", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. irelated.P_env (fmap_of_list [(x, w)]) (fmap_of_list [(x, u)])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. irelated.P_env (fmupd x w fmempty) (fmupd x u fmempty)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. irelated.P_env fmempty fmempty\n 2. w \\<approx>\\<^sub>i u", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<approx>\\<^sub>i u", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst nrhs (fmap_of_list [(x, w)]) \\<approx>\\<^sub>i u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (\"fun\" v v' u)"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain w x where \"t = w $\\<^sub>n x\" \"w \\<approx>\\<^sub>i v\" \"x \\<approx>\\<^sub>i u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>n x; w \\<approx>\\<^sub>i v;\n         x \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<approx>\\<^sub>i v $\\<^sub>p u\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>n x; w \\<approx>\\<^sub>i v;\n         x \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: nterm_to_pterm.elims)"], ["proof (state)\nthis:\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \"fun\""], ["proof (chain)\npicking this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u", "obtain w' where \"rs \\<turnstile>\\<^sub>n w \\<longrightarrow> w'\" \"w' \\<approx>\\<^sub>i v'\""], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n w \\<longrightarrow> w';\n         w' \\<approx>\\<^sub>i v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i v; frees ?t3 |\\<subseteq>| {||}\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  frees t |\\<subseteq>| {||}\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n w \\<longrightarrow> w';\n         w' \\<approx>\\<^sub>i v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n w \\<longrightarrow> w'\n  w' \\<approx>\\<^sub>i v'\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow>\n                                t'a;\n                        t'a \\<approx>\\<^sub>i t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>i t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t'a;\n            t'a \\<approx>\\<^sub>i t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule fun.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3\n 2. ?t'3 \\<approx>\\<^sub>i v' $\\<^sub>p u", "show \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w' $\\<^sub>n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w' $\\<^sub>n x", "unfolding \\<open>t = w $\\<^sub>n x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n w $\\<^sub>n x \\<longrightarrow> w' $\\<^sub>n x", "by (rule nrewrite.fun) fact"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w' $\\<^sub>n x\n\ngoal (1 subgoal):\n 1. w' $\\<^sub>n x \\<approx>\\<^sub>i v' $\\<^sub>p u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w' $\\<^sub>n x \\<approx>\\<^sub>i v' $\\<^sub>p u", "show \"w' $\\<^sub>n x \\<approx>\\<^sub>i v' $\\<^sub>p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w' $\\<^sub>n x \\<approx>\\<^sub>i v' $\\<^sub>p u", "by auto fact+"], ["proof (state)\nthis:\n  w' $\\<^sub>n x \\<approx>\\<^sub>i v' $\\<^sub>p u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (arg u u' v)"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain w x where \"t = w $\\<^sub>n x\" \"w \\<approx>\\<^sub>i v\" \"x \\<approx>\\<^sub>i u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>n x; w \\<approx>\\<^sub>i v;\n         x \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open> t \\<approx>\\<^sub>i v $\\<^sub>p u\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>n x; w \\<approx>\\<^sub>i v;\n         x \\<approx>\\<^sub>i u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: nterm_to_pterm.elims)"], ["proof (state)\nthis:\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with arg"], ["proof (chain)\npicking this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u", "obtain x' where \"rs \\<turnstile>\\<^sub>n x \\<longrightarrow> x'\" \"x' \\<approx>\\<^sub>i u'\""], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n x \\<longrightarrow> x';\n         x' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow> t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; frees ?t3 |\\<subseteq>| {||}\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3;\n   ?t'3 \\<approx>\\<^sub>i v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i v $\\<^sub>p u\n  frees t |\\<subseteq>| {||}\n  t = w $\\<^sub>n x\n  w \\<approx>\\<^sub>i v\n  x \\<approx>\\<^sub>i u\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n x \\<longrightarrow> x';\n         x' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n x \\<longrightarrow> x'\n  x' \\<approx>\\<^sub>i u'\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>\n                                t';\n                        t' \\<approx>\\<^sub>i u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n ta \\<longrightarrow> t';\n            t' \\<approx>\\<^sub>i t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>i t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule arg.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> ?t'3\n 2. ?t'3 \\<approx>\\<^sub>i v $\\<^sub>p u'", "show \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w $\\<^sub>n x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w $\\<^sub>n x'", "unfolding \\<open>t = w $\\<^sub>n x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n w $\\<^sub>n x \\<longrightarrow> w $\\<^sub>n x'", "by (rule nrewrite.arg) fact"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> w $\\<^sub>n x'\n\ngoal (1 subgoal):\n 1. w $\\<^sub>n x' \\<approx>\\<^sub>i v $\\<^sub>p u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w $\\<^sub>n x' \\<approx>\\<^sub>i v $\\<^sub>p u'", "show \"w $\\<^sub>n x' \\<approx>\\<^sub>i v $\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w $\\<^sub>n x' \\<approx>\\<^sub>i v $\\<^sub>p u'", "by auto fact+"], ["proof (state)\nthis:\n  w $\\<^sub>n x' \\<approx>\\<^sub>i v $\\<^sub>p u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in nrules) compile_correct_rt:\n  assumes \"compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\" \"t \\<approx>\\<^sub>i u\" \"closed t\"\n  obtains t' where \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: thesis t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        compile (consts_of rs) \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>i y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>i z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "(* FIXME clone of transform_correct_rt, maybe locale? *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        compile (consts_of rs) \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>i y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>i z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step u' u'')"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        compile (consts_of rs) \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>i y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>i z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t' where \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step"], ["proof (prove)\nusing this:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>n ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>i u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>i u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>i u''\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>i u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>i u'\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        compile (consts_of rs) \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>i y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>i z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t'' where \"rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t''\" \"t'' \\<approx>\\<^sub>i u''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule compile_correct)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    compile (consts_of rs) \\<turnstile>\\<^sub>i ?u5 \\<longrightarrow> ?u'5\n 2. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?t5 \\<approx>\\<^sub>i ?u5\n 3. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed ?t5\n 4. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>n ?t5 \\<longrightarrow> t'a;\n        t'a \\<approx>\\<^sub>i ?u'5\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"compile (consts_of rs) \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\" \"t' \\<approx>\\<^sub>i u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i u' \\<longrightarrow> u'' &&&\n    t' \\<approx>\\<^sub>i u'", "by fact+"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\n  t' \\<approx>\\<^sub>i u'\n\ngoal (2 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed t'\n 2. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>n t' \\<longrightarrow> t'a;\n        t'a \\<approx>\\<^sub>i u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed t'\n 2. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>n t' \\<longrightarrow> t'a;\n        t'a \\<approx>\\<^sub>i u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t'", "using \\<open>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\\<close> \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\n  closed t\n\ngoal (1 subgoal):\n 1. closed t'", "by (rule nrewrite_rt_closed)"], ["proof (state)\nthis:\n  closed t'\n\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>i u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>n t' \\<longrightarrow> t'a;\n        t'a \\<approx>\\<^sub>i u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t''\n  t'' \\<approx>\\<^sub>i u''\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>compile (consts_of rs) \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        compile (consts_of rs) \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>i y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>i z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>i u''", "show \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t''", "using \\<open>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\\<close> \\<open>rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t''\\<close>"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t'\n  rs \\<turnstile>\\<^sub>n t' \\<longrightarrow>* t''\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t''", "by auto"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t''\n\ngoal (1 subgoal):\n 1. t'' \\<approx>\\<^sub>i u''", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>i u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>i u; closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["", "subsubsection \\<open>Completeness of translation\\<close>"], ["", "lemma (in nrules) compile_complete:\n  assumes \"rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\" \"closed t\"\n  shows \"compile (consts_of rs) \\<turnstile>\\<^sub>i nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "case (step r t t')"], ["proof (state)\nthis:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t", "obtain pat rhs' where \"r = (pat, rhs')\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs'.\n        r = (pat, rhs') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r = (pat, rhs')\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  r = (pat, rhs')", "have \"(pat, rhs') |\\<in>| rs\" \"(pat, rhs') \\<turnstile> t \\<rightarrow> t'\""], ["proof (prove)\nusing this:\n  r = (pat, rhs')\n\ngoal (1 subgoal):\n 1. (pat, rhs') |\\<in>| rs &&& (pat, rhs') \\<turnstile> t \\<rightarrow> t'", "using step"], ["proof (prove)\nusing this:\n  r = (pat, rhs')\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (pat, rhs') |\\<in>| rs &&& (pat, rhs') \\<turnstile> t \\<rightarrow> t'", "by blast+"], ["proof (state)\nthis:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'", "have \"nrule (pat, rhs')\""], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n\ngoal (1 subgoal):\n 1. nrule (pat, rhs')", "using all_rules"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  fBall rs nrule\n\ngoal (1 subgoal):\n 1. nrule (pat, rhs')", "by blast"], ["proof (state)\nthis:\n  nrule (pat, rhs')\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  nrule (pat, rhs')", "obtain name pats where \"(name, (pats, rhs')) = split_rule r\" \"pat = name $$ pats\""], ["proof (prove)\nusing this:\n  nrule (pat, rhs')\n\ngoal (1 subgoal):\n 1. (\\<And>name pats.\n        \\<lbrakk>(name, pats, rhs') = split_rule r;\n         pat = name $$ pats\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding split_rule_def \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  nrule (pat, rhs')\n\ngoal (1 subgoal):\n 1. (\\<And>name pats.\n        \\<lbrakk>(name, pats, rhs') =\n                 (case (pat, rhs') of\n                  (lhs, rhs) \\<Rightarrow>\n                    let (name, args) = strip_comb lhs\n                    in (const_name name, args, rhs));\n         pat = name $$ pats\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. nrule (pat, rhs') \\<Longrightarrow>\n    \\<exists>name pats.\n       (name, pats, rhs') =\n       (case (pat, rhs') of\n        (lhs, rhs) \\<Rightarrow>\n          let (name, args) = strip_comb lhs\n          in (const_name name, args, rhs)) \\<and>\n       pat = name $$ pats", "by (auto simp: split_beta)"], ["proof (state)\nthis:\n  (name, pats, rhs') = split_rule r\n  pat = name $$ pats\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "obtain crs where \"(name, crs) |\\<in>| consts_of rs\" \"(pats, rhs') |\\<in>| crs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>crs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs') |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step \\<open>_ = split_rule r\\<close> \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n  (name, pats, rhs') = split_rule r\n  r = (pat, rhs')\n\ngoal (1 subgoal):\n 1. (\\<And>crs.\n        \\<lbrakk>(name, crs) |\\<in>| consts_of rs;\n         (pats, rhs') |\\<in>| crs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis consts_of_def fgroup_by_complete fst_conv snd_conv)"], ["proof (state)\nthis:\n  (name, crs) |\\<in>| consts_of rs\n  (pats, rhs') |\\<in>| crs\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats, rhs') |\\<in>| crs", "obtain irs where \"irs = translate_crules crs\""], ["proof (prove)\nusing this:\n  (name, crs) |\\<in>| consts_of rs\n  (pats, rhs') |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        irs = translate_crules crs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  irs = translate_crules crs\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  irs = translate_crules crs", "have \"(name, irs) |\\<in>| compile (consts_of rs)\""], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n\ngoal (1 subgoal):\n 1. (name, irs) |\\<in>| compile (consts_of rs)", "unfolding compile_def"], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n\ngoal (1 subgoal):\n 1. (name, irs) |\\<in>| map_prod id translate_crules |`| consts_of rs", "using \\<open>(name, _) |\\<in>| _\\<close>"], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n  (name, crs) |\\<in>| consts_of rs\n\ngoal (1 subgoal):\n 1. (name, irs) |\\<in>| map_prod id translate_crules |`| consts_of rs", "by (metis fimageI id_def map_prod_simp)"], ["proof (state)\nthis:\n  (name, irs) |\\<in>| compile (consts_of rs)\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "obtain rhs where \"rhs = nterm_to_pterm rhs'\" \"(pats, rhs) |\\<in>| irs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs = nterm_to_pterm rhs'; (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>irs = _\\<close> \\<open>_ |\\<in>| crs\\<close>"], ["proof (prove)\nusing this:\n  irs = translate_crules crs\n  (pats, rhs') |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs = nterm_to_pterm rhs'; (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding translate_crules_def"], ["proof (prove)\nusing this:\n  irs = map_prod id nterm_to_pterm |`| crs\n  (pats, rhs') |\\<in>| crs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>rhs = nterm_to_pterm rhs'; (pats, rhs) |\\<in>| irs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis fimageI id_def map_prod_simp)"], ["proof (state)\nthis:\n  rhs = nterm_to_pterm rhs'\n  (pats, rhs) |\\<in>| irs\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "from step"], ["proof (chain)\npicking this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t", "obtain env' where \"match pat t = Some env'\" \"t' = subst rhs' env'\""], ["proof (prove)\nusing this:\n  r |\\<in>| rs\n  r \\<turnstile> t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match pat t = Some env'; t' = subst rhs' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>r = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match pat t = Some env'; t' = subst rhs' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rewrite_step.simps"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| rs\n  (pat, rhs') \\<turnstile> t \\<rightarrow> t'\n  closed t\n  rewrite_step (?t\\<^sub>1, ?t\\<^sub>2) ?u =\n  map_option (subst ?t\\<^sub>2) (match ?t\\<^sub>1 ?u)\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match pat t = Some env'; t' = subst rhs' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  match pat t = Some env'\n  t' = subst rhs' env'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  match pat t = Some env'\n  t' = subst rhs' env'", "obtain env where \"match pat (nterm_to_pterm t) = Some env\" \"irelated.P_env env' env\""], ["proof (prove)\nusing this:\n  match pat t = Some env'\n  t' = subst rhs' env'\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n         irelated.P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis irelated.match_rel option_rel_Some1)"], ["proof (state)\nthis:\n  match pat (nterm_to_pterm t) = Some env\n  irelated.P_env env' env\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "then"], ["proof (chain)\npicking this:\n  match pat (nterm_to_pterm t) = Some env\n  irelated.P_env env' env", "have \"subst rhs env = nterm_to_pterm t'\""], ["proof (prove)\nusing this:\n  match pat (nterm_to_pterm t) = Some env\n  irelated.P_env env' env\n\ngoal (1 subgoal):\n 1. subst rhs env = nterm_to_pterm t'", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\nusing this:\n  match pat (nterm_to_pterm t) = Some env\n  irelated.P_env env' env\n\ngoal (1 subgoal):\n 1. subst rhs env = nterm_to_pterm (subst rhs' env')", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> subst rhs env = nterm_to_pterm (subst rhs' env')", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> subst rhs' env' \\<approx>\\<^sub>i subst rhs env", "apply (rule irelated_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> rhs' \\<approx>\\<^sub>i rhs\n 2. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> irelated.P_env env' env", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> rhs' \\<approx>\\<^sub>i nterm_to_pterm rhs'\n 2. \\<lbrakk>match pat (nterm_to_pterm t) = Some env;\n     irelated.P_env env' env\\<rbrakk>\n    \\<Longrightarrow> irelated.P_env env' env", "by auto"], ["proof (state)\nthis:\n  subst rhs env = nterm_to_pterm t'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "have \"name, pats, rhs \\<turnstile>\\<^sub>i nterm_to_pterm t \\<rightarrow> nterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name, pats, rhs \\<turnstile>\\<^sub>i nterm_to_pterm t \\<rightarrow>\n    nterm_to_pterm t'", "apply (rule irewrite_stepI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match (name $$ pats) (nterm_to_pterm t) = Some ?env\n 2. subst rhs ?env = nterm_to_pterm t'", "using \\<open>match _ _ = Some env\\<close>"], ["proof (prove)\nusing this:\n  match pat (nterm_to_pterm t) = Some env\n\ngoal (2 subgoals):\n 1. match (name $$ pats) (nterm_to_pterm t) = Some ?env\n 2. subst rhs ?env = nterm_to_pterm t'", "unfolding \\<open>pat = _\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ pats) (nterm_to_pterm t) = Some env\n\ngoal (2 subgoals):\n 1. match (name $$ pats) (nterm_to_pterm t) = Some ?env\n 2. subst rhs ?env = nterm_to_pterm t'", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env = nterm_to_pterm t'", "by fact"], ["proof (state)\nthis:\n  name, pats, rhs \\<turnstile>\\<^sub>i nterm_to_pterm t \\<rightarrow>\n  nterm_to_pterm t'\n\ngoal (4 subgoals):\n 1. \\<And>r t u.\n       \\<lbrakk>r |\\<in>| rs; r \\<turnstile> t \\<rightarrow> u;\n        closed t\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm t \\<longrightarrow> nterm_to_pterm u\n 2. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'", "by rule fact+"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "case (beta x t t')"], ["proof (state)\nthis:\n  closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t')\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "obtain c where \"c = (Free x, nterm_to_pterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c = (Free x, nterm_to_pterm t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c = (Free x, nterm_to_pterm t)\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "from beta"], ["proof (chain)\npicking this:\n  closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t')", "have \"closed (nterm_to_pterm t')\""], ["proof (prove)\nusing this:\n  closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t')\n\ngoal (1 subgoal):\n 1. closed (nterm_to_pterm t')", "using closed_nterm_to_pterm[where t = t']"], ["proof (prove)\nusing this:\n  closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t')\n  closed_except (nterm_to_pterm t') (frees t')\n\ngoal (1 subgoal):\n 1. closed (nterm_to_pterm t')", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') |\\<subseteq>| {||}\n  frees (nterm_to_pterm t') |\\<subseteq>| frees t'\n\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm t') |\\<subseteq>| {||}", "by auto"], ["proof (state)\nthis:\n  closed (nterm_to_pterm t')\n\ngoal (3 subgoals):\n 1. \\<And>x t t'.\n       closed ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<Longrightarrow>\n       compile (consts_of rs) \\<turnstile>\\<^sub>i\n       nterm_to_pterm\n        ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n       nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n    nterm_to_pterm (subst t (fmap_of_list [(x, t')]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    (\\<Lambda>\\<^sub>p x. nterm_to_pterm t) $\\<^sub>p\n    nterm_to_pterm t' \\<longrightarrow>\n    nterm_to_pterm (subst t (fmupd x t' fmempty))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?c |\\<in>| {|(Free x, nterm_to_pterm t)|}\n 2. ?c \\<turnstile> nterm_to_pterm t' \\<rightarrow>\n    nterm_to_pterm (subst t (fmupd x t' fmempty))", "using \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  c = (Free x, nterm_to_pterm t)\n\ngoal (2 subgoals):\n 1. ?c |\\<in>| {|(Free x, nterm_to_pterm t)|}\n 2. ?c \\<turnstile> nterm_to_pterm t' \\<rightarrow>\n    nterm_to_pterm (subst t (fmupd x t' fmempty))", "by (fastforce intro: irelated_subst[THEN sym])+"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm ((\\<Lambda>\\<^sub>n x. t) $\\<^sub>n t') \\<longrightarrow>\n  nterm_to_pterm (subst t (fmap_of_list [(x, t')]))\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "case (\"fun\" t t' u)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n  closed t \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\n  closed (t $\\<^sub>n u)\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t' $\\<^sub>n u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n    nterm_to_pterm (t' $\\<^sub>n u)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t $\\<^sub>p nterm_to_pterm u \\<longrightarrow>\n    nterm_to_pterm t' $\\<^sub>p nterm_to_pterm u", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'", "apply (rule \"fun\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t", "using \"fun\""], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n  closed t \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\n  closed (t $\\<^sub>n u)\n\ngoal (1 subgoal):\n 1. closed t", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n t \\<longrightarrow> t'\n  frees t |\\<subseteq>| {||} \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm t \\<longrightarrow> nterm_to_pterm t'\n  frees (t $\\<^sub>n u) |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| {||}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n  nterm_to_pterm (t' $\\<^sub>n u)\n\ngoal (1 subgoal):\n 1. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "case (arg u u' t)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u'\n  closed (t $\\<^sub>n u)\n\ngoal (1 subgoal):\n 1. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        compile (consts_of rs) \\<turnstile>\\<^sub>i\n        nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u';\n        closed (t $\\<^sub>n u)\\<rbrakk>\n       \\<Longrightarrow> compile (consts_of rs) \\<turnstile>\\<^sub>i\n                         nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n                         nterm_to_pterm (t $\\<^sub>n u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n    nterm_to_pterm (t $\\<^sub>n u')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm t $\\<^sub>p nterm_to_pterm u \\<longrightarrow>\n    nterm_to_pterm t $\\<^sub>p nterm_to_pterm u'", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. compile (consts_of rs) \\<turnstile>\\<^sub>i\n    nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u'", "apply (rule arg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u", "using arg"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  closed u \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u'\n  closed (t $\\<^sub>n u)\n\ngoal (1 subgoal):\n 1. closed u", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>n u \\<longrightarrow> u'\n  frees u |\\<subseteq>| {||} \\<Longrightarrow>\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm u \\<longrightarrow> nterm_to_pterm u'\n  frees (t $\\<^sub>n u) |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. frees u |\\<subseteq>| {||}", "by simp"], ["proof (state)\nthis:\n  compile (consts_of rs) \\<turnstile>\\<^sub>i\n  nterm_to_pterm (t $\\<^sub>n u) \\<longrightarrow>\n  nterm_to_pterm (t $\\<^sub>n u')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness of transformation\\<close>"], ["", "abbreviation irules_deferred_matches :: \"pterm list \\<Rightarrow> irules \\<Rightarrow> (term \\<times> pterm) fset\" where\n\"irules_deferred_matches args \\<equiv> fselect\n  (\\<lambda>(pats, rhs). map_option (\\<lambda>env. (last pats, subst rhs env)) (matchs (butlast pats) args))\""], ["", "context irules begin"], ["", "inductive prelated :: \"pterm \\<Rightarrow> pterm \\<Rightarrow> bool\" (\"_ \\<approx>\\<^sub>p _\" [0,50] 50) where\nconst: \"Pconst x \\<approx>\\<^sub>p Pconst x\" |\nvar: \"Pvar x \\<approx>\\<^sub>p Pvar x\" |\napp: \"t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1 \\<Longrightarrow> t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2 \\<Longrightarrow> t\\<^sub>1 $\\<^sub>p t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>1 $\\<^sub>p u\\<^sub>2\" |\npat: \"rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2 \\<Longrightarrow> Pabs cs\\<^sub>1 \\<approx>\\<^sub>p Pabs cs\\<^sub>2\" |\n\"defer\":\n  \"(name, rsi) |\\<in>| rs \\<Longrightarrow> 0 < arity rsi \\<Longrightarrow>\n   rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi) cs \\<Longrightarrow>\n   list_all closed args \\<Longrightarrow>\n   name $$ args \\<approx>\\<^sub>p Pabs cs\""], ["", "inductive_cases prelated_absE[consumes 1, case_names pat \"defer\"]: \"t \\<approx>\\<^sub>p Pabs cs\""], ["", "lemma prelated_refl[intro!]: \"t \\<approx>\\<^sub>p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p t", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. Pconst x \\<approx>\\<^sub>p Pconst x\n 2. \\<And>x. Pvar x \\<approx>\\<^sub>p Pvar x\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> xaa \\<approx>\\<^sub>p xaa) \\<Longrightarrow>\n       Pabs x \\<approx>\\<^sub>p Pabs x\n 4. \\<And>t1 t2.\n       \\<lbrakk>t1 \\<approx>\\<^sub>p t1; t2 \\<approx>\\<^sub>p t2\\<rbrakk>\n       \\<Longrightarrow> t1 $\\<^sub>p t2 \\<approx>\\<^sub>p t1 $\\<^sub>p t2", "case Pabs"], ["proof (state)\nthis:\n  \\<lbrakk>?xa3 \\<in> fset x_; ?xaa3 \\<in> Basic_BNFs.snds ?xa3\\<rbrakk>\n  \\<Longrightarrow> ?xaa3 \\<approx>\\<^sub>p ?xaa3\n\ngoal (4 subgoals):\n 1. \\<And>x. Pconst x \\<approx>\\<^sub>p Pconst x\n 2. \\<And>x. Pvar x \\<approx>\\<^sub>p Pvar x\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> xaa \\<approx>\\<^sub>p xaa) \\<Longrightarrow>\n       Pabs x \\<approx>\\<^sub>p Pabs x\n 4. \\<And>t1 t2.\n       \\<lbrakk>t1 \\<approx>\\<^sub>p t1; t2 \\<approx>\\<^sub>p t2\\<rbrakk>\n       \\<Longrightarrow> t1 $\\<^sub>p t2 \\<approx>\\<^sub>p t1 $\\<^sub>p t2", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa3 \\<in> fset x_; ?xaa3 \\<in> Basic_BNFs.snds ?xa3\\<rbrakk>\n  \\<Longrightarrow> ?xaa3 \\<approx>\\<^sub>p ?xaa3\n\ngoal (1 subgoal):\n 1. Pabs x_ \\<approx>\\<^sub>p Pabs x_", "by (auto simp: snds.simps fmember.rep_eq intro!: prelated.pat rel_fset_refl_strong rel_prod.intros)"], ["proof (state)\nthis:\n  Pabs x_ \\<approx>\\<^sub>p Pabs x_\n\ngoal (3 subgoals):\n 1. \\<And>x. Pconst x \\<approx>\\<^sub>p Pconst x\n 2. \\<And>x. Pvar x \\<approx>\\<^sub>p Pvar x\n 3. \\<And>t1 t2.\n       \\<lbrakk>t1 \\<approx>\\<^sub>p t1; t2 \\<approx>\\<^sub>p t2\\<rbrakk>\n       \\<Longrightarrow> t1 $\\<^sub>p t2 \\<approx>\\<^sub>p t1 $\\<^sub>p t2", "qed (auto intro: prelated.intros)"], ["", "sublocale prelated: term_struct_rel prelated"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_struct_rel prelated", "by standard (auto simp: const_pterm_def app_pterm_def intro: prelated.intros elim: prelated.cases)"], ["", "lemma prelated_pvars:\n  assumes \"t \\<approx>\\<^sub>p u\"\n  shows \"frees t = frees u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t = frees u", "using assms"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. frees t = frees u", "proof (induction rule: prelated.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>cs\\<^sub>1 cs\\<^sub>2.\n       rel_fset\n        (rel_prod (=)\n          (\\<lambda>x1 x2.\n              x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n        cs\\<^sub>1 cs\\<^sub>2 \\<Longrightarrow>\n       frees (Pabs cs\\<^sub>1) = frees (Pabs cs\\<^sub>2)\n 5. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "case (pat cs\\<^sub>1 cs\\<^sub>2)"], ["proof (state)\nthis:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   cs\\<^sub>1 cs\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>cs\\<^sub>1 cs\\<^sub>2.\n       rel_fset\n        (rel_prod (=)\n          (\\<lambda>x1 x2.\n              x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n        cs\\<^sub>1 cs\\<^sub>2 \\<Longrightarrow>\n       frees (Pabs cs\\<^sub>1) = frees (Pabs cs\\<^sub>2)\n 5. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Pabs cs\\<^sub>1) = frees (Pabs cs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n      cs\\<^sub>1) =\n    ffUnion\n     (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n      cs\\<^sub>2)", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n    cs\\<^sub>1 =\n    ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n    cs\\<^sub>2", "apply (rule rel_fset_image_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_fset ?P5 cs\\<^sub>1 cs\\<^sub>2\n 2. \\<And>a b.\n       \\<lbrakk>a |\\<in>| cs\\<^sub>1; b |\\<in>| cs\\<^sub>2; ?P5 a b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n                          map_prod id frees)\n                          a =\n                         ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n                          map_prod id frees)\n                          b", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a |\\<in>| cs\\<^sub>1; b |\\<in>| cs\\<^sub>2;\n        rel_prod (=)\n         (\\<lambda>x1 x2.\n             x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2)\n         a b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n                          map_prod id frees)\n                          a =\n                         ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n                          map_prod id frees)\n                          b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  frees (Pabs cs\\<^sub>1) = frees (Pabs cs\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "case (\"defer\" name rsi args cs)"], ["proof (state)\nthis:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   (irules_deferred_matches args rsi) cs\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "{"], ["proof (state)\nthis:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   (irules_deferred_matches args rsi) cs\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "fix pat t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "assume \"(pat, t) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat, t) |\\<in>| cs\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "with \"defer\""], ["proof (chain)\npicking this:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   (irules_deferred_matches args rsi) cs\n  (pat, t) |\\<in>| cs", "obtain t'\n      where \"(pat, t') |\\<in>| irules_deferred_matches args rsi\" \"frees t = frees t'\""], ["proof (prove)\nusing this:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   (irules_deferred_matches args rsi) cs\n  (pat, t) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>(pat, t') |\\<in>| irules_deferred_matches args rsi;\n         frees t = frees t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_fsetE2)"], ["proof (state)\nthis:\n  (pat, t') |\\<in>| irules_deferred_matches args rsi\n  frees t = frees t'\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "then"], ["proof (chain)\npicking this:\n  (pat, t') |\\<in>| irules_deferred_matches args rsi\n  frees t = frees t'", "obtain pats rhs env\n      where \"pat = last pats\" \"(pats, rhs) |\\<in>| rsi\"\n        and \"matchs (butlast pats) args = Some env\" \"t' = subst rhs env\""], ["proof (prove)\nusing this:\n  (pat, t') |\\<in>| irules_deferred_matches args rsi\n  frees t = frees t'\n\ngoal (1 subgoal):\n 1. (\\<And>pats rhs env.\n        \\<lbrakk>pat = last pats; (pats, rhs) |\\<in>| rsi;\n         matchs (butlast pats) args = Some env; t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pat = last pats\n  (pats, rhs) |\\<in>| rsi\n  matchs (butlast pats) args = Some env\n  t' = subst rhs env\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"closed_except rhs (freess pats)\" \"linears pats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats) &&& linears pats", "using \\<open>(pats, rhs) |\\<in>| rsi\\<close> \\<open>(name, rsi) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats, rhs) |\\<in>| rsi\n  (name, rsi) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. closed_except rhs (freess pats) &&& linears pats", "by blast+"], ["proof (state)\nthis:\n  closed_except rhs (freess pats)\n  linears pats\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"arity_compatibles rsi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rsi", "using \"defer\" inner"], ["proof (prove)\nusing this:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2. x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n   (irules_deferred_matches args rsi) cs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rsi", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles rsi\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"length pats > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length pats", "by (subst arity_compatible_length) fact+"], ["proof (state)\nthis:\n  0 < length pats\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "hence \"pats = butlast pats @ [last pats]\""], ["proof (prove)\nusing this:\n  0 < length pats\n\ngoal (1 subgoal):\n 1. pats = butlast pats @ [last pats]", "by simp"], ["proof (state)\nthis:\n  pats = butlast pats @ [last pats]\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "note \\<open>frees t = frees t'\\<close>"], ["proof (state)\nthis:\n  frees t = frees t'\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  frees t = frees t'\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"frees t' = frees rhs - fmdom env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t' = frees rhs |-| fmdom env", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst rhs env) = frees rhs |-| fmdom env", "apply (rule subst_frees)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env", "apply (rule closed.matchs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs ?pats2 ?ts2 = Some env\n 2. list_all closed ?ts2", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  frees t' = frees rhs |-| fmdom env\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  frees t' = frees rhs |-| fmdom env\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"\\<dots> = frees rhs - freess (butlast pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| fmdom env = frees rhs |-| freess (butlast pats)", "using \\<open>matchs _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  matchs (butlast pats) args = Some env\n\ngoal (1 subgoal):\n 1. frees rhs |-| fmdom env = frees rhs |-| freess (butlast pats)", "by (metis matchs_dom)"], ["proof (state)\nthis:\n  frees rhs |-| fmdom env = frees rhs |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  frees rhs |-| fmdom env = frees rhs |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"\\<dots> |\\<subseteq>| freess pats - freess (butlast pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |-| freess (butlast pats) |\\<subseteq>|\n    freess pats |-| freess (butlast pats)", "using \\<open>closed_except _ _\\<close>"], ["proof (prove)\nusing this:\n  closed_except rhs (freess pats)\n\ngoal (1 subgoal):\n 1. frees rhs |-| freess (butlast pats) |\\<subseteq>|\n    freess pats |-| freess (butlast pats)", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  frees rhs |-| freess (butlast pats) |\\<subseteq>|\n  freess pats |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  frees rhs |-| freess (butlast pats) |\\<subseteq>|\n  freess pats |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"\\<dots> = frees (last pats) |-| freess (butlast pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess pats |-| freess (butlast pats) =\n    frees (last pats) |-| freess (butlast pats)", "by (subst \\<open>pats = _\\<close>) (simp add: funion_fminus)"], ["proof (state)\nthis:\n  freess pats |-| freess (butlast pats) =\n  frees (last pats) |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  freess pats |-| freess (butlast pats) =\n  frees (last pats) |-| freess (butlast pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"\\<dots> = frees (last pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (last pats) |-| freess (butlast pats) = frees (last pats)", "proof (rule fminus_triv)"], ["proof (state)\ngoal (1 subgoal):\n 1. frees (last pats) |\\<inter>| freess (butlast pats) = {||}", "have \"fdisjnt (freess (butlast pats)) (freess [last pats])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats)) (freess [last pats])", "using \\<open>linears pats\\<close> \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  linears pats\n  pats = butlast pats @ [last pats]\n\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats)) (freess [last pats])", "by (metis linears_appendD)"], ["proof (state)\nthis:\n  fdisjnt (freess (butlast pats)) (freess [last pats])\n\ngoal (1 subgoal):\n 1. frees (last pats) |\\<inter>| freess (butlast pats) = {||}", "thus \"frees (last pats) |\\<inter>| freess (butlast pats) = {||}\""], ["proof (prove)\nusing this:\n  fdisjnt (freess (butlast pats)) (freess [last pats])\n\ngoal (1 subgoal):\n 1. frees (last pats) |\\<inter>| freess (butlast pats) = {||}", "by (fastforce simp: fdisjnt_alt_def)"], ["proof (state)\nthis:\n  frees (last pats) |\\<inter>| freess (butlast pats) = {||}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frees (last pats) |-| freess (butlast pats) = frees (last pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "also"], ["proof (state)\nthis:\n  frees (last pats) |-| freess (butlast pats) = frees (last pats)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"\\<dots> = frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (last pats) = frees pat", "unfolding \\<open>pat = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (last pats) = frees (last pats)", ".."], ["proof (state)\nthis:\n  frees (last pats) = frees pat\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "finally"], ["proof (chain)\npicking this:\n  frees t |\\<subseteq>| frees pat", "have \"frees t |\\<subseteq>| frees pat\""], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| frees pat\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees pat", "."], ["proof (state)\nthis:\n  frees t |\\<subseteq>| frees pat\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "}"], ["proof (state)\nthis:\n  (?pat5, ?ta5) |\\<in>| cs \\<Longrightarrow>\n  frees ?ta5 |\\<subseteq>| frees ?pat5\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "hence \"closed (Pabs cs)\""], ["proof (prove)\nusing this:\n  (?pat5, ?ta5) |\\<in>| cs \\<Longrightarrow>\n  frees ?ta5 |\\<subseteq>| frees ?pat5\n\ngoal (1 subgoal):\n 1. closed (Pabs cs)", "unfolding closed_except_simps"], ["proof (prove)\nusing this:\n  (?pat5, ?ta5) |\\<in>| cs \\<Longrightarrow>\n  frees ?ta5 |\\<subseteq>| frees ?pat5\n\ngoal (1 subgoal):\n 1. fBall cs\n     (\\<lambda>(pat, t). closed_except t ({||} |\\<union>| frees pat))", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed (Pabs cs)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "moreover"], ["proof (state)\nthis:\n  closed (Pabs cs)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "have \"closed (name $$ args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (name $$ args)", "unfolding closed_list_comb"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed args", "by fact"], ["proof (state)\nthis:\n  closed (name $$ args)\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\n 4. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and> frees x1 = frees x2))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> frees (name $$ args) = frees (Pabs cs)", "ultimately"], ["proof (chain)\npicking this:\n  closed (Pabs cs)\n  closed (name $$ args)", "show ?case"], ["proof (prove)\nusing this:\n  closed (Pabs cs)\n  closed (name $$ args)\n\ngoal (1 subgoal):\n 1. frees (name $$ args) = frees (Pabs cs)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (Pabs cs) |\\<subseteq>| {||}\n  frees (name $$ args) |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. frees (name $$ args) = frees (Pabs cs)", "by simp"], ["proof (state)\nthis:\n  frees (name $$ args) = frees (Pabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x. frees (Pconst x) = frees (Pconst x)\n 2. \\<And>x. frees (Pvar x) = frees (Pvar x)\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        frees t\\<^sub>1 = frees u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        frees t\\<^sub>2 = frees u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> frees (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n                         frees (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)", "qed auto"], ["", "corollary prelated_closed: \"t \\<approx>\\<^sub>p u \\<Longrightarrow> closed t \\<longleftrightarrow> closed u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p u \\<Longrightarrow> closed t = closed u", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p u \\<Longrightarrow>\n    (frees t |\\<subseteq>| {||}) = (frees u |\\<subseteq>| {||})", "by (auto simp: prelated_pvars)"], ["", "lemma prelated_no_abs_right:\n  assumes \"t \\<approx>\\<^sub>p u\" \"no_abs u\"\n  shows \"t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = u", "using assms"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>p u\n  no_abs u\n\ngoal (1 subgoal):\n 1. t = u", "apply (induction rule: prelated.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. no_abs (Pconst x) \\<Longrightarrow> Pconst x = Pconst x\n 2. \\<And>x. no_abs (Pvar x) \\<Longrightarrow> Pvar x = Pvar x\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        no_abs u\\<^sub>1 \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        no_abs u\\<^sub>2 \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2;\n        no_abs (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> t\\<^sub>1 $\\<^sub>p t\\<^sub>2 =\n                         u\\<^sub>1 $\\<^sub>p u\\<^sub>2\n 4. \\<And>cs\\<^sub>1 cs\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (no_abs x2 \\<longrightarrow> x1 = x2)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        no_abs (Pabs cs\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> Pabs cs\\<^sub>1 = Pabs cs\\<^sub>2\n 5. \\<And>name rsi args cs.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (no_abs x2 \\<longrightarrow> x1 = x2)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args; no_abs (Pabs cs)\\<rbrakk>\n       \\<Longrightarrow> name $$ args = Pabs cs", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        no_abs u\\<^sub>1 \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        no_abs u\\<^sub>2 \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2;\n        no_abs (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        no_abs u\\<^sub>1 \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        no_abs u\\<^sub>2 \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2;\n        no_abs (u\\<^sub>1 $\\<^sub>p u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2", "apply (fold app_pterm_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        no_abs u\\<^sub>1 \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        no_abs u\\<^sub>2 \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2;\n        no_abs (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        no_abs u\\<^sub>1 \\<Longrightarrow> t\\<^sub>1 = u\\<^sub>1;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        no_abs u\\<^sub>2 \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2;\n        no_abs (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> t\\<^sub>2 = u\\<^sub>2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary env_prelated_refl[intro!]: \"prelated.P_env env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env env", "by (auto intro: fmap.rel_refl)"], ["", "text \\<open>\n  The following, more general statement does not hold:\n    @{prop \"t \\<approx>\\<^sub>p u \\<Longrightarrow> rel_option prelated.P_env (match x t) (match x u)\"}\n  If @{text t} and @{text u} are related because of the @{thm [source=true] prelated.defer} rule,\n  they have completely different shapes.\n  Establishing @{prop \"is_abs t \\<longleftrightarrow> is_abs u\"} as a precondition would rule out this case, but at\n  the same time be too restrictive.\n\n  Instead, we use @{thm prelated.related_match}.\n\\<close>"], ["", "lemma prelated_subst:\n  assumes \"t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\" \"prelated.P_env env\\<^sub>1 env\\<^sub>2\"\n  shows \"subst t\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p subst t\\<^sub>2 env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\\<^sub>1\n     env\\<^sub>1 \\<approx>\\<^sub>p subst t\\<^sub>2 env\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t\\<^sub>1\n     env\\<^sub>1 \\<approx>\\<^sub>p subst t\\<^sub>2 env\\<^sub>2", "proof (induction arbitrary: env\\<^sub>1 env\\<^sub>2 rule: prelated.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pvar x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 4. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 5. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "case (var x)"], ["proof (state)\nthis:\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pvar x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2\n 3. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 4. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 5. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "thus ?case"], ["proof (prove)\nusing this:\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2", "proof (cases rule: fmrel_cases[where x = x])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmlookup env\\<^sub>1 x = None;\n     fmlookup env\\<^sub>2 x = None\\<rbrakk>\n    \\<Longrightarrow> subst (Pvar x)\n                       env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                env\\<^sub>2\n 2. \\<And>a b.\n       \\<lbrakk>fmlookup env\\<^sub>1 x = Some a;\n        fmlookup env\\<^sub>2 x = Some b; a \\<approx>\\<^sub>p b\\<rbrakk>\n       \\<Longrightarrow> subst (Pvar x)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                   env\\<^sub>2", "case none"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>1 x = None\n  fmlookup env\\<^sub>2 x = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fmlookup env\\<^sub>1 x = None;\n     fmlookup env\\<^sub>2 x = None\\<rbrakk>\n    \\<Longrightarrow> subst (Pvar x)\n                       env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                env\\<^sub>2\n 2. \\<And>a b.\n       \\<lbrakk>fmlookup env\\<^sub>1 x = Some a;\n        fmlookup env\\<^sub>2 x = Some b; a \\<approx>\\<^sub>p b\\<rbrakk>\n       \\<Longrightarrow> subst (Pvar x)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                   env\\<^sub>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>1 x = None\n  fmlookup env\\<^sub>2 x = None\n\ngoal (1 subgoal):\n 1. subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2", "by (auto intro: prelated.var)"], ["proof (state)\nthis:\n  subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fmlookup env\\<^sub>1 x = Some a;\n        fmlookup env\\<^sub>2 x = Some b; a \\<approx>\\<^sub>p b\\<rbrakk>\n       \\<Longrightarrow> subst (Pvar x)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                   env\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fmlookup env\\<^sub>1 x = Some a;\n        fmlookup env\\<^sub>2 x = Some b; a \\<approx>\\<^sub>p b\\<rbrakk>\n       \\<Longrightarrow> subst (Pvar x)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                   env\\<^sub>2", "case (some t u)"], ["proof (state)\nthis:\n  fmlookup env\\<^sub>1 x = Some t\n  fmlookup env\\<^sub>2 x = Some u\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fmlookup env\\<^sub>1 x = Some a;\n        fmlookup env\\<^sub>2 x = Some b; a \\<approx>\\<^sub>p b\\<rbrakk>\n       \\<Longrightarrow> subst (Pvar x)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x)\n                   env\\<^sub>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmlookup env\\<^sub>1 x = Some t\n  fmlookup env\\<^sub>2 x = Some u\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst (Pvar x) env\\<^sub>1 \\<approx>\\<^sub>p subst (Pvar x) env\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 4. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 4. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "case (pat cs\\<^sub>1 cs\\<^sub>2)"], ["proof (state)\nthis:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   cs\\<^sub>1 cs\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 4. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "let ?drop = \"\\<lambda>env. \\<lambda>(pat::term). fmdrop_fset (frees pat) env\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 4. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "from pat"], ["proof (chain)\npicking this:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   cs\\<^sub>1 cs\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2", "have \"prelated.P_env (?drop env\\<^sub>1 pat) (?drop env\\<^sub>2 pat)\" for pat"], ["proof (prove)\nusing this:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   cs\\<^sub>1 cs\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. prelated.P_env (fmdrop_fset (frees pat) env\\<^sub>1)\n     (fmdrop_fset (frees pat) env\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  prelated.P_env (fmdrop_fset (frees ?pat4) env\\<^sub>1)\n   (fmdrop_fset (frees ?pat4) env\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>cs\\<^sub>1 cs\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>rel_fset\n                 (rel_prod (=)\n                   (\\<lambda>x1 x2.\n                       x1 \\<approx>\\<^sub>p x2 \\<and>\n                       (\\<forall>x xa.\n                           prelated.P_env x xa \\<longrightarrow>\n                           subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n                 cs\\<^sub>1 cs\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs\\<^sub>1)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (Pabs cs\\<^sub>2) env\\<^sub>2\n 4. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "with pat"], ["proof (chain)\npicking this:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   cs\\<^sub>1 cs\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n  prelated.P_env (fmdrop_fset (frees ?pat4) env\\<^sub>1)\n   (fmdrop_fset (frees ?pat4) env\\<^sub>2)", "show ?case"], ["proof (prove)\nusing this:\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   cs\\<^sub>1 cs\\<^sub>2\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n  prelated.P_env (fmdrop_fset (frees ?pat4) env\\<^sub>1)\n   (fmdrop_fset (frees ?pat4) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst (Pabs cs\\<^sub>1)\n     env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs\\<^sub>2) env\\<^sub>2", "by (auto intro!: prelated.pat rel_fset_image)"], ["proof (state)\nthis:\n  subst (Pabs cs\\<^sub>1)\n   env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs\\<^sub>2) env\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "case (\"defer\" name rsi args cs)"], ["proof (state)\nthis:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   (irules_deferred_matches args rsi) cs\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "have \"name $$ args \\<approx>\\<^sub>p Pabs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$ args \\<approx>\\<^sub>p Pabs cs", "apply (rule prelated.defer)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (name, ?rsi) |\\<in>| rs\n 2. 0 < arity ?rsi\n 3. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args ?rsi) cs\n 4. list_all closed args", "apply fact+"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi) cs\n 2. list_all closed args", "apply (rule fset.rel_mono_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_fset ?R7 (irules_deferred_matches args rsi) cs\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> fset (irules_deferred_matches args rsi);\n        yb \\<in> fset cs; ?R7 z yb\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=) prelated z yb\n 3. list_all closed args", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> fset (irules_deferred_matches args rsi);\n        yb \\<in> fset cs;\n        rel_prod (=)\n         (\\<lambda>x1 x2.\n             x1 \\<approx>\\<^sub>p x2 \\<and>\n             (\\<forall>x xa.\n                 prelated.P_env x xa \\<longrightarrow>\n                 subst x1 x \\<approx>\\<^sub>p subst x2 xa))\n         z yb\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=) prelated z yb\n 2. list_all closed args", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed args", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  name $$ args \\<approx>\\<^sub>p Pabs cs\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  name $$ args \\<approx>\\<^sub>p Pabs cs\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "have \"closed (name $$ args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (name $$ args)", "unfolding closed_list_comb"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed args", "by fact"], ["proof (state)\nthis:\n  closed (name $$ args)\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  name $$ args \\<approx>\\<^sub>p Pabs cs\n  closed (name $$ args)", "have \"closed (Pabs cs)\""], ["proof (prove)\nusing this:\n  name $$ args \\<approx>\\<^sub>p Pabs cs\n  closed (name $$ args)\n\ngoal (1 subgoal):\n 1. closed (Pabs cs)", "by (metis prelated_closed)"], ["proof (state)\nthis:\n  closed (Pabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "let ?drop = \"\\<lambda>env. \\<lambda>pat. fmdrop_fset (frees pat) env\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "let ?f = \"\\<lambda>env. (\\<lambda>(pat, rhs). (pat, subst rhs (?drop env pat)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "have \"name $$ args \\<approx>\\<^sub>p Pabs (?f env\\<^sub>2 |`| cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$\n    args \\<approx>\\<^sub>p Pabs\n                            ((\\<lambda>(pat, rhs).\n                                 (pat,\n                                  subst rhs\n                                   (fmdrop_fset (frees pat)\n                                     env\\<^sub>2))) |`|\n                             cs)", "proof (rule prelated.defer)"], ["proof (state)\ngoal (4 subgoals):\n 1. (name, ?rsi) |\\<in>| rs\n 2. 0 < arity ?rsi\n 3. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args ?rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)\n 4. list_all closed args", "show \"(name, rsi) |\\<in>| rs\" \"0 < arity rsi\" \"list_all closed args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rsi) |\\<in>| rs &&& 0 < arity rsi &&& list_all closed args", "using \"defer\""], ["proof (prove)\nusing this:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   (irules_deferred_matches args rsi) cs\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (name, rsi) |\\<in>| rs &&& 0 < arity rsi &&& list_all closed args", "by auto"], ["proof (state)\nthis:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "fix pat\\<^sub>1 rhs\\<^sub>1"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "fix pat\\<^sub>2 rhs\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "assume \"(pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\""], ["proof (state)\nthis:\n  (pat\\<^sub>2, rhs\\<^sub>2) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "assume \"pat\\<^sub>1 = pat\\<^sub>2\" \"rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\""], ["proof (state)\nthis:\n  pat\\<^sub>1 = pat\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "have \"rhs\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2 (fmdrop_fset (frees pat\\<^sub>2) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2\n                                   (fmdrop_fset (frees pat\\<^sub>2)\n                                     env\\<^sub>2)", "by (subst subst_closed_pabs) fact+"], ["proof (state)\nthis:\n  rhs\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2\n                                 (fmdrop_fset (frees pat\\<^sub>2)\n                                   env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?pat\\<^sub>27, ?rhs\\<^sub>27) |\\<in>| cs;\n   ?pat\\<^sub>17 = ?pat\\<^sub>27;\n   ?rhs\\<^sub>17 \\<approx>\\<^sub>p ?rhs\\<^sub>27\\<rbrakk>\n  \\<Longrightarrow> ?rhs\\<^sub>17 \\<approx>\\<^sub>p subst ?rhs\\<^sub>27\n               (fmdrop_fset (frees ?pat\\<^sub>27) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "hence \"rel_fset (rel_prod (=) prelated) (id |`| irules_deferred_matches args rsi) (?f env\\<^sub>2 |`| cs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat\\<^sub>27, ?rhs\\<^sub>27) |\\<in>| cs;\n   ?pat\\<^sub>17 = ?pat\\<^sub>27;\n   ?rhs\\<^sub>17 \\<approx>\\<^sub>p ?rhs\\<^sub>27\\<rbrakk>\n  \\<Longrightarrow> ?rhs\\<^sub>17 \\<approx>\\<^sub>p subst ?rhs\\<^sub>27\n               (fmdrop_fset (frees ?pat\\<^sub>27) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated)\n     (id |`| irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "by (force intro!: rel_fset_image[OF \\<open>rel_fset _ _ _\\<close>])"], ["proof (state)\nthis:\n  rel_fset (rel_prod (=) prelated) (id |`| irules_deferred_matches args rsi)\n   ((\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs)\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "thus \"rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi) (?f env\\<^sub>2 |`| cs)\""], ["proof (prove)\nusing this:\n  rel_fset (rel_prod (=) prelated) (id |`| irules_deferred_matches args rsi)\n   ((\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs)\n\ngoal (1 subgoal):\n 1. rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n      cs)", "by simp"], ["proof (state)\nthis:\n  rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n   ((\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  name $$\n  args \\<approx>\\<^sub>p Pabs\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n                           cs)\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  name $$\n  args \\<approx>\\<^sub>p Pabs\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n                           cs)\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "have \"map (\\<lambda>t. subst t env\\<^sub>1) args = args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>t. subst t env\\<^sub>1) args = args", "apply (rule map_idI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> subst x env\\<^sub>1 = x", "apply (rule subst_closed_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> closed x", "using \"defer\""], ["proof (prove)\nusing this:\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  list_all closed args\n  rel_fset\n   (rel_prod (=)\n     (\\<lambda>x1 x2.\n         x1 \\<approx>\\<^sub>p x2 \\<and>\n         (\\<forall>x xa.\n             prelated.P_env x xa \\<longrightarrow>\n             subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n   (irules_deferred_matches args rsi) cs\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set args \\<Longrightarrow> closed x", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  map (\\<lambda>t. subst t env\\<^sub>1) args = args\n\ngoal (3 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2\n 3. \\<And>name rsi args cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>(name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset\n         (rel_prod (=)\n           (\\<lambda>x1 x2.\n               x1 \\<approx>\\<^sub>p x2 \\<and>\n               (\\<forall>x xa.\n                   prelated.P_env x xa \\<longrightarrow>\n                   subst x1 x \\<approx>\\<^sub>p subst x2 xa)))\n         (irules_deferred_matches args rsi) cs;\n        list_all closed args;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (name $$ args)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs)\n                   env\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  name $$\n  args \\<approx>\\<^sub>p Pabs\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n                           cs)\n  map (\\<lambda>t. subst t env\\<^sub>1) args = args", "show ?case"], ["proof (prove)\nusing this:\n  name $$\n  args \\<approx>\\<^sub>p Pabs\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n                           cs)\n  map (\\<lambda>t. subst t env\\<^sub>1) args = args\n\ngoal (1 subgoal):\n 1. subst (name $$ args)\n     env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs) env\\<^sub>2", "by (simp add: subst_list_comb)"], ["proof (state)\nthis:\n  subst (name $$ args)\n   env\\<^sub>1 \\<approx>\\<^sub>p subst (Pabs cs) env\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x env\\<^sub>1 env\\<^sub>2.\n       prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n       subst (Pconst x)\n        env\\<^sub>1 \\<approx>\\<^sub>p subst (Pconst x) env\\<^sub>2\n 2. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>1\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>1 env\\<^sub>2;\n        t\\<^sub>2 \\<approx>\\<^sub>p u\\<^sub>2;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           prelated.P_env env\\<^sub>1 env\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2\n            env\\<^sub>1 \\<approx>\\<^sub>p subst u\\<^sub>2 env\\<^sub>2;\n        prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> subst (t\\<^sub>1 $\\<^sub>p t\\<^sub>2)\n                          env\\<^sub>1 \\<approx>\\<^sub>p subst\n                   (u\\<^sub>1 $\\<^sub>p u\\<^sub>2) env\\<^sub>2", "qed (auto intro: prelated.intros)"], ["", "lemma prelated_step:\n  assumes \"name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\" \"t \\<approx>\\<^sub>p u\"\n  obtains t' where \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?lhs = \"name $$ pats\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>p u", "obtain env where \"match ?lhs u = Some env\" \"u' = subst rhs env\""], ["proof (prove)\nusing this:\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) u = Some env;\n         u' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  map_option (subst rhs) (match (name $$ pats) u) = Some u'\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        \\<lbrakk>match (name $$ pats) u = Some env;\n         u' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  match (name $$ pats) u = Some env\n  u' = subst rhs env\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  match (name $$ pats) u = Some env\n  u' = subst rhs env", "obtain env' where \"match ?lhs t = Some env'\" \"prelated.P_env env' env\""], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\n  u' = subst rhs env\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match (name $$ pats) t = Some env';\n         prelated.P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\n  u' = subst rhs env\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match (name $$ pats) t = Some env';\n         prelated.P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: prelated.related_match)"], ["proof (state)\nthis:\n  match (name $$ pats) t = Some env'\n  prelated.P_env env' env\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"subst rhs env' \\<approx>\\<^sub>p subst rhs env\""], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env'\n  prelated.P_env env' env\n\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p subst rhs env", "using assms"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env'\n  prelated.P_env env' env\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  t \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p subst rhs env", "by (auto intro: prelated_subst)"], ["proof (state)\nthis:\n  subst rhs env' \\<approx>\\<^sub>p subst rhs env\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p u'", "show \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> subst rhs env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> subst rhs env'", "unfolding irewrite_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (subst rhs) (match (name $$ pats) t) = Some (subst rhs env')", "using \\<open>match ?lhs t = Some env'\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ pats) t = Some env'\n\ngoal (1 subgoal):\n 1. map_option (subst rhs) (match (name $$ pats) t) = Some (subst rhs env')", "by simp"], ["proof (state)\nthis:\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> subst rhs env'\n\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p u'", "show \"subst rhs env' \\<approx>\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p u'", "unfolding \\<open>u' = subst rhs env\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env' \\<approx>\\<^sub>p subst rhs env", "by fact"], ["proof (state)\nthis:\n  subst rhs env' \\<approx>\\<^sub>p u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "(* FIXME write using relators *)"], ["", "lemma prelated_beta: \\<comment> \\<open>same problem as @{thm [source=true] prelated.related_match}\\<close>\n  assumes \"(pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\" \"rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\" \"t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\"\n  obtains u\\<^sub>1 where \"(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow> u\\<^sub>1\" \"u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n                 u\\<^sub>1;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n                 u\\<^sub>1;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2", "obtain env\\<^sub>2 where \"match pat t\\<^sub>2 = Some env\\<^sub>2\" \"u\\<^sub>2 = subst rhs\\<^sub>2 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>2.\n        \\<lbrakk>match pat t\\<^sub>2 = Some env\\<^sub>2;\n         u\\<^sub>2 = subst rhs\\<^sub>2 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match pat t\\<^sub>2 = Some env\\<^sub>2\n  u\\<^sub>2 = subst rhs\\<^sub>2 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n                 u\\<^sub>1;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n  match pat t\\<^sub>2 = Some env\\<^sub>2\n  u\\<^sub>2 = subst rhs\\<^sub>2 env\\<^sub>2", "obtain env\\<^sub>1 where \"match pat t\\<^sub>1 = Some env\\<^sub>1\" \"prelated.P_env env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n  match pat t\\<^sub>2 = Some env\\<^sub>2\n  u\\<^sub>2 = subst rhs\\<^sub>2 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>match pat t\\<^sub>1 = Some env\\<^sub>1;\n         prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: prelated.related_match)"], ["proof (state)\nthis:\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n                 u\\<^sub>1;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  prelated.P_env env\\<^sub>1 env\\<^sub>2", "have \"subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  (pat, rhs\\<^sub>2) \\<turnstile> t\\<^sub>2 \\<rightarrow> u\\<^sub>2\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  t\\<^sub>1 \\<approx>\\<^sub>p t\\<^sub>2\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1\n     env\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2 env\\<^sub>2", "by (auto intro: prelated_subst)"], ["proof (state)\nthis:\n  subst rhs\\<^sub>1\n   env\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n                 u\\<^sub>1;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow> ?u\\<^sub>13\n 2. ?u\\<^sub>13 \\<approx>\\<^sub>p u\\<^sub>2", "show \"(pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow> subst rhs\\<^sub>1 env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1 env\\<^sub>1", "using \\<open>match pat t\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. (pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1 env\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  (pat, rhs\\<^sub>1) \\<turnstile> t\\<^sub>1 \\<rightarrow>\n  subst rhs\\<^sub>1 env\\<^sub>1\n\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2", "show \"subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2", "unfolding \\<open>u\\<^sub>2 = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1\n     env\\<^sub>1 \\<approx>\\<^sub>p subst rhs\\<^sub>2 env\\<^sub>2", "by fact"], ["proof (state)\nthis:\n  subst rhs\\<^sub>1 env\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem transform_correct:\n  assumes \"transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\" \"t \\<approx>\\<^sub>p u\" \"closed t\"\n  obtains t' where \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\" \\<comment> \\<open>zero or one step\\<close> and \"t' \\<approx>\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1-3)"], ["proof (prove)\nusing this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: t thesis rule: irewrite.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (beta c cs\\<^sub>2 u\\<^sub>2 x\\<^sub>2')"], ["proof (state)\nthis:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain v u\\<^sub>1 where \"t = v $\\<^sub>p u\\<^sub>1\" \"v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\" \"u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v u\\<^sub>1.\n        \\<lbrakk>t = v $\\<^sub>p u\\<^sub>1;\n         v \\<approx>\\<^sub>p Pabs cs\\<^sub>2;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v u\\<^sub>1.\n        \\<lbrakk>t = v $\\<^sub>p u\\<^sub>1;\n         v \\<approx>\\<^sub>p Pabs cs\\<^sub>2;\n         u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  t = v $\\<^sub>p u\\<^sub>1\n  v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with beta"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  t = v $\\<^sub>p u\\<^sub>1\n  v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2", "have \"closed u\\<^sub>1\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  t = v $\\<^sub>p u\\<^sub>1\n  v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n\ngoal (1 subgoal):\n 1. closed u\\<^sub>1", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  closed u\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain pat rhs\\<^sub>2 where \"c = (pat, rhs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs\\<^sub>2.\n        c = (pat, rhs\\<^sub>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (pat, rhs\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c cs t t' ta thesis.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p Pabs cs $\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  v \\<approx>\\<^sub>p Pabs cs\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  v \\<approx>\\<^sub>p Pabs cs\\<^sub>2\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases rule: prelated_absE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs\\<^sub>1.\n       \\<lbrakk>v = Pabs cs\\<^sub>1;\n        rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (pat cs\\<^sub>1)"], ["proof (state)\nthis:\n  v = Pabs cs\\<^sub>1\n  rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>cs\\<^sub>1.\n       \\<lbrakk>v = Pabs cs\\<^sub>1;\n        rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "with beta \\<open>c = _\\<close>"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)\n  v = Pabs cs\\<^sub>1\n  rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2", "obtain rhs\\<^sub>1 where \"(pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1\" \"rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)\n  v = Pabs cs\\<^sub>1\n  rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1.\n        \\<lbrakk>(pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1;\n         rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_fsetE2)"], ["proof (state)\nthis:\n  (pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>cs\\<^sub>1.\n       \\<lbrakk>v = Pabs cs\\<^sub>1;\n        rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "with beta"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  (pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2", "obtain x\\<^sub>1' where \"(pat, rhs\\<^sub>1) \\<turnstile> u\\<^sub>1 \\<rightarrow> x\\<^sub>1'\" \"x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  (pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>1'.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> u\\<^sub>1 \\<rightarrow>\n                 x\\<^sub>1';\n         x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<close> assms \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  (pat, rhs\\<^sub>1) |\\<in>| cs\\<^sub>1\n  rhs\\<^sub>1 \\<approx>\\<^sub>p rhs\\<^sub>2\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  t \\<approx>\\<^sub>p u\n  closed t\n  c = (pat, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>1'.\n        \\<lbrakk>(pat, rhs\\<^sub>1) \\<turnstile> u\\<^sub>1 \\<rightarrow>\n                 x\\<^sub>1';\n         x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: prelated_beta simp del: rewrite_step.simps)"], ["proof (state)\nthis:\n  (pat, rhs\\<^sub>1) \\<turnstile> u\\<^sub>1 \\<rightarrow> x\\<^sub>1'\n  x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\n\ngoal (2 subgoals):\n 1. \\<And>cs\\<^sub>1.\n       \\<lbrakk>v = Pabs cs\\<^sub>1;\n        rel_fset (rel_prod (=) prelated) cs\\<^sub>1 cs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule beta.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'", "show \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* x\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* x\\<^sub>1'", "unfolding \\<open>t = _\\<close> \\<open>v = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i\n    Pabs cs\\<^sub>1 $\\<^sub>p u\\<^sub>1 \\<longrightarrow>* x\\<^sub>1'", "by (intro r_into_rtranclp irewrite.beta) fact+"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* x\\<^sub>1'\n\ngoal (1 subgoal):\n 1. x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'", "show \"x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'", "by fact"], ["proof (state)\nthis:\n  x\\<^sub>1' \\<approx>\\<^sub>p x\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (\"defer\" name rsi args)"], ["proof (state)\nthis:\n  v = name $$ args\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n   cs\\<^sub>2\n  list_all closed args\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "with beta \\<open>c = _\\<close>"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)\n  v = name $$ args\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n   cs\\<^sub>2\n  list_all closed args", "obtain rhs\\<^sub>1' where \"(pat, rhs\\<^sub>1') |\\<in>| irules_deferred_matches args rsi\" \"rhs\\<^sub>1' \\<approx>\\<^sub>p rhs\\<^sub>2\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)\n  v = name $$ args\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n   cs\\<^sub>2\n  list_all closed args\n\ngoal (1 subgoal):\n 1. (\\<And>rhs\\<^sub>1'.\n        \\<lbrakk>(pat, rhs\\<^sub>1') |\\<in>|\n                 irules_deferred_matches args rsi;\n         rhs\\<^sub>1' \\<approx>\\<^sub>p rhs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_fsetE2)"], ["proof (state)\nthis:\n  (pat, rhs\\<^sub>1') |\\<in>| irules_deferred_matches args rsi\n  rhs\\<^sub>1' \\<approx>\\<^sub>p rhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (pat, rhs\\<^sub>1') |\\<in>| irules_deferred_matches args rsi\n  rhs\\<^sub>1' \\<approx>\\<^sub>p rhs\\<^sub>2", "obtain env\\<^sub>a rhs\\<^sub>1 pats\n        where \"matchs (butlast pats) args = Some env\\<^sub>a\" \"pat = last pats\" \"rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a\"\n          and \"(pats, rhs\\<^sub>1) |\\<in>| rsi\""], ["proof (prove)\nusing this:\n  (pat, rhs\\<^sub>1') |\\<in>| irules_deferred_matches args rsi\n  rhs\\<^sub>1' \\<approx>\\<^sub>p rhs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>pats env\\<^sub>a rhs\\<^sub>1.\n        \\<lbrakk>matchs (butlast pats) args = Some env\\<^sub>a;\n         pat = last pats; rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a;\n         (pats, rhs\\<^sub>1) |\\<in>| rsi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  matchs (butlast pats) args = Some env\\<^sub>a\n  pat = last pats\n  rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a\n  (pats, rhs\\<^sub>1) |\\<in>| rsi\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"linears pats\""], ["proof (prove)\nusing this:\n  matchs (butlast pats) args = Some env\\<^sub>a\n  pat = last pats\n  rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a\n  (pats, rhs\\<^sub>1) |\\<in>| rsi\n\ngoal (1 subgoal):\n 1. linears pats", "using \\<open>(name, rsi) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  matchs (butlast pats) args = Some env\\<^sub>a\n  pat = last pats\n  rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a\n  (pats, rhs\\<^sub>1) |\\<in>| rsi\n  (name, rsi) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats", "unfolding irules_def"], ["proof (prove)\nusing this:\n  matchs (butlast pats) args = Some env\\<^sub>a\n  pat = last pats\n  rhs\\<^sub>1' = subst rhs\\<^sub>1 env\\<^sub>a\n  (pats, rhs\\<^sub>1) |\\<in>| rsi\n  (name, rsi) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats", "by blast"], ["proof (state)\nthis:\n  linears pats\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"arity_compatibles rsi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rsi", "using \"defer\" inner"], ["proof (prove)\nusing this:\n  v = name $$ args\n  (name, rsi) |\\<in>| rs\n  0 < arity rsi\n  rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n   cs\\<^sub>2\n  list_all closed args\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rsi", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles rsi\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length pats > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length pats", "by (subst arity_compatible_length) fact+"], ["proof (state)\nthis:\n  0 < length pats\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"pats = butlast pats @ [pat]\""], ["proof (prove)\nusing this:\n  0 < length pats\n\ngoal (1 subgoal):\n 1. pats = butlast pats @ [pat]", "unfolding \\<open>pat = _\\<close>"], ["proof (prove)\nusing this:\n  0 < length pats\n\ngoal (1 subgoal):\n 1. pats = butlast pats @ [last pats]", "by simp"], ["proof (state)\nthis:\n  pats = butlast pats @ [pat]\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "from beta \\<open>c = _\\<close>"], ["proof (chain)\npicking this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)", "obtain env\\<^sub>b where \"match pat u\\<^sub>2 = Some env\\<^sub>b\" \"x\\<^sub>2' = subst rhs\\<^sub>2 env\\<^sub>b\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs\\<^sub>2\n  c \\<turnstile> u\\<^sub>2 \\<rightarrow> x\\<^sub>2'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p Pabs cs\\<^sub>2 $\\<^sub>p u\\<^sub>2\n  closed t\n  c = (pat, rhs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>b.\n        \\<lbrakk>match pat u\\<^sub>2 = Some env\\<^sub>b;\n         x\\<^sub>2' = subst rhs\\<^sub>2 env\\<^sub>b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  match pat u\\<^sub>2 = Some env\\<^sub>b\n  x\\<^sub>2' = subst rhs\\<^sub>2 env\\<^sub>b\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n  match pat u\\<^sub>2 = Some env\\<^sub>b\n  x\\<^sub>2' = subst rhs\\<^sub>2 env\\<^sub>b", "obtain env\\<^sub>b' where \"match pat u\\<^sub>1 = Some env\\<^sub>b'\" \"prelated.P_env env\\<^sub>b' env\\<^sub>b\""], ["proof (prove)\nusing this:\n  u\\<^sub>1 \\<approx>\\<^sub>p u\\<^sub>2\n  match pat u\\<^sub>2 = Some env\\<^sub>b\n  x\\<^sub>2' = subst rhs\\<^sub>2 env\\<^sub>b\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>b'.\n        \\<lbrakk>match pat u\\<^sub>1 = Some env\\<^sub>b';\n         prelated.P_env env\\<^sub>b' env\\<^sub>b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prelated.related_match)"], ["proof (state)\nthis:\n  match pat u\\<^sub>1 = Some env\\<^sub>b'\n  prelated.P_env env\\<^sub>b' env\\<^sub>b\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"closed_env env\\<^sub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env\\<^sub>a", "by (rule closed.matchs) fact+"], ["proof (state)\nthis:\n  closed_env env\\<^sub>a\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"closed_env env\\<^sub>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env\\<^sub>b'", "apply (rule closed.matchs[where pats = \"[pat]\" and ts = \"[u\\<^sub>1]\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs [pat] [u\\<^sub>1] = Some env\\<^sub>b'\n 2. list_all closed [u\\<^sub>1]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat u\\<^sub>1 = Some env\\<^sub>b'\n 2. list_all closed [u\\<^sub>1]", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed [u\\<^sub>1]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u\\<^sub>1", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_env env\\<^sub>b'\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmdom env\\<^sub>a = freess (butlast pats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>a = freess (butlast pats)", "by (rule matchs_dom) fact"], ["proof (state)\nthis:\n  fmdom env\\<^sub>a = freess (butlast pats)\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  fmdom env\\<^sub>a = freess (butlast pats)\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmdom env\\<^sub>b' = frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>b' = frees pat", "by (rule match_dom) fact"], ["proof (state)\nthis:\n  fmdom env\\<^sub>b' = frees pat\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  fmdom env\\<^sub>b' = frees pat\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fdisjnt (freess (butlast pats)) (frees pat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats)) (frees pat)", "using \\<open>pats = _\\<close> \\<open>linears pats\\<close>"], ["proof (prove)\nusing this:\n  pats = butlast pats @ [pat]\n  linears pats\n\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats)) (frees pat)", "by (metis freess_single linears_appendD(3))"], ["proof (state)\nthis:\n  fdisjnt (freess (butlast pats)) (frees pat)\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  fmdom env\\<^sub>a = freess (butlast pats)\n  fmdom env\\<^sub>b' = frees pat\n  fdisjnt (freess (butlast pats)) (frees pat)", "have \"fdisjnt (fmdom env\\<^sub>a) (fmdom env\\<^sub>b')\""], ["proof (prove)\nusing this:\n  fmdom env\\<^sub>a = freess (butlast pats)\n  fmdom env\\<^sub>b' = frees pat\n  fdisjnt (freess (butlast pats)) (frees pat)\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>a) (fmdom env\\<^sub>b')", "by simp"], ["proof (state)\nthis:\n  fdisjnt (fmdom env\\<^sub>a) (fmdom env\\<^sub>b')\n\ngoal (1 subgoal):\n 1. \\<And>name rsi args.\n       \\<lbrakk>v = name $$ args; (name, rsi) |\\<in>| rs; 0 < arity rsi;\n        rel_fset (rel_prod (=) prelated) (irules_deferred_matches args rsi)\n         cs\\<^sub>2;\n        list_all closed args\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule beta.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'", "have \"rs \\<turnstile>\\<^sub>i name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow> subst rhs\\<^sub>1' env\\<^sub>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow>\n    subst rhs\\<^sub>1' env\\<^sub>b'", "proof (rule irewrite.step)"], ["proof (state)\ngoal (3 subgoals):\n 1. (?name, ?rs) |\\<in>| rs\n 2. (?pats, ?rhs) |\\<in>| ?rs\n 3. ?name, ?pats, ?rhs \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1' env\\<^sub>b'", "show \"(name, rsi) |\\<in>| rs\" \"(pats, rhs\\<^sub>1) |\\<in>| rsi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rsi) |\\<in>| rs &&& (pats, rhs\\<^sub>1) |\\<in>| rsi", "by fact+"], ["proof (state)\nthis:\n  (name, rsi) |\\<in>| rs\n  (pats, rhs\\<^sub>1) |\\<in>| rsi\n\ngoal (1 subgoal):\n 1. name, pats, rhs\\<^sub>1 \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1' env\\<^sub>b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. name, pats, rhs\\<^sub>1 \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1' env\\<^sub>b'", "show \"name, pats, rhs\\<^sub>1 \\<turnstile>\\<^sub>i name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow> subst rhs\\<^sub>1' env\\<^sub>b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name, pats, rhs\\<^sub>1 \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow>\n    subst rhs\\<^sub>1' env\\<^sub>b'", "apply (rule irewrite_stepI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match (name $$ pats) (name $$ args $\\<^sub>p u\\<^sub>1) = Some ?env\n 2. subst rhs\\<^sub>1 ?env = subst rhs\\<^sub>1' env\\<^sub>b'", "apply (fold app_pterm_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match (name $$ pats) (app (name $$ args) u\\<^sub>1) = Some ?env\n 2. subst rhs\\<^sub>1 ?env = subst rhs\\<^sub>1' env\\<^sub>b'", "apply (subst list_comb_snoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. match (name $$ pats) (name $$ (args @ [u\\<^sub>1])) = Some ?env\n 2. subst rhs\\<^sub>1 ?env = subst rhs\\<^sub>1' env\\<^sub>b'", "apply (subst matchs_match_list_comb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs pats (args @ [u\\<^sub>1]) = Some ?env\n 2. subst rhs\\<^sub>1 ?env = subst rhs\\<^sub>1' env\\<^sub>b'", "apply (subst \\<open>pats = _\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs (butlast pats @ [pat]) (args @ [u\\<^sub>1]) = Some ?env\n 2. subst rhs\\<^sub>1 ?env = subst rhs\\<^sub>1' env\\<^sub>b'", "apply (rule matchs_appI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. matchs (butlast pats) args = Some ?env\\<^sub>112\n 2. matchs [pat] [u\\<^sub>1] = Some ?env\\<^sub>212\n 3. subst rhs\\<^sub>1 (?env\\<^sub>112 ++\\<^sub>f ?env\\<^sub>212) =\n    subst rhs\\<^sub>1' env\\<^sub>b'", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs [pat] [u\\<^sub>1] = Some ?env\\<^sub>212\n 2. subst rhs\\<^sub>1 (env\\<^sub>a ++\\<^sub>f ?env\\<^sub>212) =\n    subst rhs\\<^sub>1' env\\<^sub>b'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. match pat u\\<^sub>1 = Some ?env\\<^sub>212\n 2. subst rhs\\<^sub>1 (env\\<^sub>a ++\\<^sub>f ?env\\<^sub>212) =\n    subst rhs\\<^sub>1' env\\<^sub>b'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1 (env\\<^sub>a ++\\<^sub>f env\\<^sub>b') =\n    subst rhs\\<^sub>1' env\\<^sub>b'", "unfolding \\<open>rhs\\<^sub>1' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1 (env\\<^sub>a ++\\<^sub>f env\\<^sub>b') =\n    subst (subst rhs\\<^sub>1 env\\<^sub>a) env\\<^sub>b'", "apply (rule subst_indep')"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env env\\<^sub>a\n 2. fdisjnt (fmdom env\\<^sub>a) (fmdom env\\<^sub>b')", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  name, pats, rhs\\<^sub>1 \\<turnstile>\\<^sub>i\n  name $$ args $\\<^sub>p u\\<^sub>1 \\<rightarrow>\n  subst rhs\\<^sub>1' env\\<^sub>b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow>\n  subst rhs\\<^sub>1' env\\<^sub>b'\n\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p x\\<^sub>2'", "thus \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* subst rhs\\<^sub>1' env\\<^sub>b'\""], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow>\n  subst rhs\\<^sub>1' env\\<^sub>b'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n    subst rhs\\<^sub>1' env\\<^sub>b'", "unfolding \\<open>t = _\\<close> \\<open>v = _\\<close>"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow>\n  subst rhs\\<^sub>1' env\\<^sub>b'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i\n    name $$ args $\\<^sub>p u\\<^sub>1 \\<longrightarrow>*\n    subst rhs\\<^sub>1' env\\<^sub>b'", "by (rule r_into_rtranclp)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n  subst rhs\\<^sub>1' env\\<^sub>b'\n\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1' env\\<^sub>b' \\<approx>\\<^sub>p x\\<^sub>2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1' env\\<^sub>b' \\<approx>\\<^sub>p x\\<^sub>2'", "show \"subst rhs\\<^sub>1' env\\<^sub>b' \\<approx>\\<^sub>p x\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1' env\\<^sub>b' \\<approx>\\<^sub>p x\\<^sub>2'", "unfolding \\<open>x\\<^sub>2' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\\<^sub>1'\n     env\\<^sub>b' \\<approx>\\<^sub>p subst rhs\\<^sub>2 env\\<^sub>b", "by (rule prelated_subst) fact+"], ["proof (state)\nthis:\n  subst rhs\\<^sub>1' env\\<^sub>b' \\<approx>\\<^sub>p x\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step name rs\\<^sub>2 pats rhs u u')"], ["proof (state)\nthis:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (3 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t", "obtain rs\\<^sub>1 where \"rs\\<^sub>2 = transform_irules rs\\<^sub>1\" \"(name, rs\\<^sub>1) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>rs\\<^sub>1.\n        \\<lbrakk>rs\\<^sub>2 = transform_irules rs\\<^sub>1;\n         (name, rs\\<^sub>1) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| map_prod id transform_irules |`| rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>rs\\<^sub>1.\n        \\<lbrakk>rs\\<^sub>2 = transform_irules rs\\<^sub>1;\n         (name, rs\\<^sub>1) |\\<in>| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rs\\<^sub>2 = transform_irules rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n\ngoal (3 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"arity_compatibles rs\\<^sub>1\""], ["proof (prove)\nusing this:\n  rs\\<^sub>2 = transform_irules rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rs\\<^sub>1", "using inner"], ["proof (prove)\nusing this:\n  rs\\<^sub>2 = transform_irules rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles rs\\<^sub>1", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles rs\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>name rsa pats rhs t t' ta thesis.\n       \\<lbrakk>(name, rsa) |\\<in>| transform_irule_set rs;\n        (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"arity rs\\<^sub>1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity rs\\<^sub>1 = 0 \\<Longrightarrow> thesis\n 2. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  arity rs\\<^sub>1 = 0\n\ngoal (2 subgoals):\n 1. arity rs\\<^sub>1 = 0 \\<Longrightarrow> thesis\n 2. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "hence \"rs\\<^sub>2 = rs\\<^sub>1\""], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 = 0\n\ngoal (1 subgoal):\n 1. rs\\<^sub>2 = rs\\<^sub>1", "unfolding \\<open>rs\\<^sub>2 = _\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 = 0\n\ngoal (1 subgoal):\n 1. (if arity rs\\<^sub>1 = 0 then rs\\<^sub>1\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           rs\\<^sub>1) =\n    rs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  rs\\<^sub>2 = rs\\<^sub>1\n\ngoal (2 subgoals):\n 1. arity rs\\<^sub>1 = 0 \\<Longrightarrow> thesis\n 2. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "with step"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t\n  rs\\<^sub>2 = rs\\<^sub>1", "have \"(pats, rhs) |\\<in>| rs\\<^sub>1\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t\n  rs\\<^sub>2 = rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. (pats, rhs) |\\<in>| rs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  (pats, rhs) |\\<in>| rs\\<^sub>1\n\ngoal (2 subgoals):\n 1. arity rs\\<^sub>1 = 0 \\<Longrightarrow> thesis\n 2. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "from step"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t", "obtain t' where \"name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\" \"t' \\<approx>\\<^sub>p u'\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: prelated_step)"], ["proof (state)\nthis:\n  name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  t' \\<approx>\\<^sub>p u'\n\ngoal (2 subgoals):\n 1. arity rs\\<^sub>1 = 0 \\<Longrightarrow> thesis\n 2. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p u'", "show \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "by (intro conjI exI r_into_rtranclp irewrite.step) fact+"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>p u'", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "let ?f = \"\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "let ?grp = \"fgroup_by ?f rs\\<^sub>1\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  arity rs\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "hence \"rs\\<^sub>2 = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rs\\<^sub>2 =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs\\<^sub>1", "unfolding \\<open>rs\\<^sub>2 = _\\<close> transform_irules_def"], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity rs\\<^sub>1 = 0 then rs\\<^sub>1\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           rs\\<^sub>1) =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n     rs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  rs\\<^sub>2 =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "with step"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t\n  rs\\<^sub>2 =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1", "obtain cs where \"rhs = Pabs cs\" \"(pats, cs) |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n  rs\\<^sub>2 =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>rhs = Pabs cs;\n         (pats, cs) |\\<in>|\n         fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n          rs\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rhs = Pabs cs\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "from step"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t", "obtain env\\<^sub>2 where \"match (name $$ pats) u = Some env\\<^sub>2\" \"u' = subst rhs env\\<^sub>2\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>2.\n        \\<lbrakk>match (name $$ pats) u = Some env\\<^sub>2;\n         u' = subst rhs env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding irewrite_step_def"], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  map_option (subst rhs) (match (name $$ pats) u) = Some u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>2.\n        \\<lbrakk>match (name $$ pats) u = Some env\\<^sub>2;\n         u' = subst rhs env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match (name $$ pats) u = Some env\\<^sub>2\n  u' = subst rhs env\\<^sub>2\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  match (name $$ pats) u = Some env\\<^sub>2\n  u' = subst rhs env\\<^sub>2", "obtain args\\<^sub>2 where \"u = name $$ args\\<^sub>2\" \"matchs pats args\\<^sub>2 = Some env\\<^sub>2\""], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\\<^sub>2\n  u' = subst rhs env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>args\\<^sub>2.\n        \\<lbrakk>u = name $$ args\\<^sub>2;\n         matchs pats args\\<^sub>2 = Some env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: match_list_combE)"], ["proof (state)\nthis:\n  u = name $$ args\\<^sub>2\n  matchs pats args\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "with step"], ["proof (chain)\npicking this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  closed t\n  u = name $$ args\\<^sub>2\n  matchs pats args\\<^sub>2 = Some env\\<^sub>2", "obtain args\\<^sub>1 where \"t = name $$ args\\<^sub>1\" \"list_all2 prelated args\\<^sub>1 args\\<^sub>2\""], ["proof (prove)\nusing this:\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  (pats, rhs) |\\<in>| rs\\<^sub>2\n  name, pats, rhs \\<turnstile>\\<^sub>i u \\<rightarrow> u'\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  closed t\n  u = name $$ args\\<^sub>2\n  matchs pats args\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>args\\<^sub>1.\n        \\<lbrakk>t = name $$ args\\<^sub>1;\n         list_all2 prelated args\\<^sub>1 args\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: prelated.list_combE)"], ["proof (state)\nthis:\n  t = name $$ args\\<^sub>1\n  list_all2 prelated args\\<^sub>1 args\\<^sub>2\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  t = name $$ args\\<^sub>1\n  list_all2 prelated args\\<^sub>1 args\\<^sub>2", "obtain env\\<^sub>1 where \"matchs pats args\\<^sub>1 = Some env\\<^sub>1\" \"prelated.P_env env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  t = name $$ args\\<^sub>1\n  list_all2 prelated args\\<^sub>1 args\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs pats args\\<^sub>1 = Some env\\<^sub>1;\n         prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>matchs pats args\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  t = name $$ args\\<^sub>1\n  list_all2 prelated args\\<^sub>1 args\\<^sub>2\n  matchs pats args\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs pats args\\<^sub>1 = Some env\\<^sub>1;\n         prelated.P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prelated.related_matchs)"], ["proof (state)\nthis:\n  matchs pats args\\<^sub>1 = Some env\\<^sub>1\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "hence \"fmdom env\\<^sub>1 = freess pats\""], ["proof (prove)\nusing this:\n  matchs pats args\\<^sub>1 = Some env\\<^sub>1\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>1 = freess pats", "by (auto simp: matchs_dom)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>1 = freess pats\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "obtain cs' where \"u' = Pabs cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs'. u' = Pabs cs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>u' = _\\<close> \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        subst (Pabs cs) env\\<^sub>2 = Pabs cs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u' = Pabs cs'\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "hence \"cs' = (\\<lambda>(pat, rhs). (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2 ))) |`| cs\""], ["proof (prove)\nusing this:\n  u' = Pabs cs'\n\ngoal (1 subgoal):\n 1. cs' =\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs", "using \\<open>u' = subst rhs env\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  u' = Pabs cs'\n  u' = subst rhs env\\<^sub>2\n\ngoal (1 subgoal):\n 1. cs' =\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\nusing this:\n  u' = Pabs cs'\n  u' = subst (Pabs cs) env\\<^sub>2\n\ngoal (1 subgoal):\n 1. cs' =\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs", "by simp"], ["proof (state)\nthis:\n  cs' =\n  (\\<lambda>(pat, rhs).\n      (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n  cs\n\ngoal (1 subgoal):\n 1. arity rs\\<^sub>1 \\<noteq> 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p u'", "show \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t", "by (rule rtranclp.rtrancl_refl)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t\n\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p u'", "show \"t \\<approx>\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p u'", "unfolding \\<open>u' = Pabs cs'\\<close> \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$ args\\<^sub>1 \\<approx>\\<^sub>p Pabs cs'", "proof (intro prelated.defer rel_fsetI; safe?)"], ["proof (state)\ngoal (5 subgoals):\n 1. (name, ?rsi1) |\\<in>| rs\n 2. 0 < arity ?rsi1\n 3. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 ?rsi1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 4. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 ?rsi1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))\n 5. list_all closed args\\<^sub>1", "show \"(name, rs\\<^sub>1) |\\<in>| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, rs\\<^sub>1) |\\<in>| rs", "by fact"], ["proof (state)\nthis:\n  (name, rs\\<^sub>1) |\\<in>| rs\n\ngoal (4 subgoals):\n 1. 0 < arity rs\\<^sub>1\n 2. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 3. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))\n 4. list_all closed args\\<^sub>1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < arity rs\\<^sub>1\n 2. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 3. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))\n 4. list_all closed args\\<^sub>1", "show \"0 < arity rs\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < arity rs\\<^sub>1", "using False"], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < arity rs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  0 < arity rs\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))\n 3. list_all closed args\\<^sub>1", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))\n 3. list_all closed args\\<^sub>1", "show \"list_all closed args\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all closed args\\<^sub>1", "using \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  closed t\n\ngoal (1 subgoal):\n 1. list_all closed args\\<^sub>1", "unfolding \\<open>t = _\\<close> closed_list_comb"], ["proof (prove)\nusing this:\n  list_all closed args\\<^sub>1\n\ngoal (1 subgoal):\n 1. list_all closed args\\<^sub>1", "."], ["proof (state)\nthis:\n  list_all closed args\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "fix pat rhs'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "assume \"(pat, rhs') |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1\""], ["proof (state)\nthis:\n  (pat, rhs') |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "then"], ["proof (chain)\npicking this:\n  (pat, rhs') |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "obtain pats' rhs env\n                where \"(pats', rhs) |\\<in>| rs\\<^sub>1\"\n                  and \"matchs (butlast pats') args\\<^sub>1 = Some env\" \"pat = last pats'\" \"rhs' = subst rhs env\""], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>pats' rhs env.\n        \\<lbrakk>(pats', rhs) |\\<in>| rs\\<^sub>1;\n         matchs (butlast pats') args\\<^sub>1 = Some env; pat = last pats';\n         rhs' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  matchs (butlast pats') args\\<^sub>1 = Some env\n  pat = last pats'\n  rhs' = subst rhs env\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "with False"], ["proof (chain)\npicking this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  matchs (butlast pats') args\\<^sub>1 = Some env\n  pat = last pats'\n  rhs' = subst rhs env", "have \"pats' \\<noteq> []\""], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  matchs (butlast pats') args\\<^sub>1 = Some env\n  pat = last pats'\n  rhs' = subst rhs env\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "using \\<open>arity_compatibles rs\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  matchs (butlast pats') args\\<^sub>1 = Some env\n  pat = last pats'\n  rhs' = subst rhs env\n  Rewriting_Nterm.arity_compatibles rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. pats' \\<noteq> []", "by (metis list.size(3) arity_compatible_length)"], ["proof (state)\nthis:\n  pats' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "hence \"butlast pats' @ [last pats'] = pats'\""], ["proof (prove)\nusing this:\n  pats' \\<noteq> []\n\ngoal (1 subgoal):\n 1. butlast pats' @ [last pats'] = pats'", "by simp"], ["proof (state)\nthis:\n  butlast pats' @ [last pats'] = pats'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "from \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (chain)\npicking this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1", "obtain pats\\<^sub>e rhs\\<^sub>e\n                where \"(pats\\<^sub>e, rhs\\<^sub>e) |\\<in>| rs\\<^sub>1\" \"pats = butlast pats\\<^sub>e\""], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>pats\\<^sub>e rhs\\<^sub>e.\n        \\<lbrakk>(pats\\<^sub>e, rhs\\<^sub>e) |\\<in>| rs\\<^sub>1;\n         pats = butlast pats\\<^sub>e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: fgroup_byE2)"], ["proof (state)\nthis:\n  (pats\\<^sub>e, rhs\\<^sub>e) |\\<in>| rs\\<^sub>1\n  pats = butlast pats\\<^sub>e\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "have \"patterns_compatible (butlast pats') pats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatible (butlast pats') pats", "unfolding \\<open>pats = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatible (butlast pats') (butlast pats\\<^sub>e)", "apply (rule rev_accum_rel_butlast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatible pats' pats\\<^sub>e", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>(pats\\<^sub>e, rhs\\<^sub>e) |\\<in>| rs\\<^sub>1\\<close> \\<open>(name, rs\\<^sub>1) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  (pats\\<^sub>e, rhs\\<^sub>e) |\\<in>| rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. patterns_compatible pats' pats\\<^sub>e", "by (blast dest: fpairwiseD)"], ["proof (state)\nthis:\n  patterns_compatible (butlast pats') pats\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "interpret irules': irules C_info \"transform_irule_set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (transform_irule_set rs)", "by (rule rules_transform)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "have \"butlast pats' = pats\" \"env = env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast pats' = pats &&& env = env\\<^sub>1", "apply (rule matchs_compatible_eq)"], ["proof (prove)\ngoal (6 subgoals):\n 1. patterns_compatible (butlast pats') pats\n 2. linears (butlast pats')\n 3. linears pats\n 4. matchs (butlast pats') ?us = Some ?env\\<^sub>1\n 5. matchs pats ?us = Some ?env\\<^sub>2\n 6. env = env\\<^sub>1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns_compatible (butlast pats') pats", "by fact"], ["proof (prove)\ngoal (5 subgoals):\n 1. linears (butlast pats')\n 2. linears pats\n 3. matchs (butlast pats') ?us = Some ?env\\<^sub>1\n 4. matchs pats ?us = Some ?env\\<^sub>2\n 5. env = env\\<^sub>1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linears (butlast pats')", "apply (rule linears_butlastI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats'", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>(name, rs\\<^sub>1) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats'", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. linears pats\n 2. matchs (butlast pats') ?us = Some ?env\\<^sub>1\n 3. matchs pats ?us = Some ?env\\<^sub>2\n 4. env = env\\<^sub>1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats", "using \\<open>(pats, _) |\\<in>| rs\\<^sub>2\\<close> \\<open>(name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\\<close>"], ["proof (prove)\nusing this:\n  (pats, rhs__) |\\<in>| rs\\<^sub>2\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n\ngoal (1 subgoal):\n 1. linears pats", "using irules'.inner"], ["proof (prove)\nusing this:\n  (pats, rhs__) |\\<in>| rs\\<^sub>2\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  fBall (transform_irule_set rs)\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) irules'.all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> irules'.shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| irules'.all_consts))\n\ngoal (1 subgoal):\n 1. linears pats", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. matchs (butlast pats') ?us = Some ?env\\<^sub>1\n 2. matchs pats ?us = Some ?env\\<^sub>2\n 3. env = env\\<^sub>1", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. env = env\\<^sub>1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. env = env\\<^sub>1", "apply (rule matchs_compatible_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. patterns_compatible ?ts\\<^sub>1 ?ts\\<^sub>2\n 2. linears ?ts\\<^sub>1\n 3. linears ?ts\\<^sub>2\n 4. matchs ?ts\\<^sub>1 ?us = Some env\n 5. matchs ?ts\\<^sub>2 ?us = Some env\\<^sub>1", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. linears (butlast pats')\n 2. linears pats\n 3. matchs (butlast pats') ?us = Some env\n 4. matchs pats ?us = Some env\\<^sub>1", "apply (rule linears_butlastI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. linears pats'\n 2. linears pats\n 3. matchs (butlast pats') ?us = Some env\n 4. matchs pats ?us = Some env\\<^sub>1", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>(name, rs\\<^sub>1) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (4 subgoals):\n 1. linears pats'\n 2. linears pats\n 3. matchs (butlast pats') ?us = Some env\n 4. matchs pats ?us = Some env\\<^sub>1", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. linears pats\n 2. matchs (butlast pats') ?us = Some env\n 3. matchs pats ?us = Some env\\<^sub>1", "using \\<open>(pats, _) |\\<in>| rs\\<^sub>2\\<close> \\<open>(name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\\<close>"], ["proof (prove)\nusing this:\n  (pats, rhs__) |\\<in>| rs\\<^sub>2\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n\ngoal (3 subgoals):\n 1. linears pats\n 2. matchs (butlast pats') ?us = Some env\n 3. matchs pats ?us = Some env\\<^sub>1", "using irules'.inner"], ["proof (prove)\nusing this:\n  (pats, rhs__) |\\<in>| rs\\<^sub>2\n  (name, rs\\<^sub>2) |\\<in>| transform_irule_set rs\n  fBall (transform_irule_set rs)\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) irules'.all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> irules'.shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| irules'.all_consts))\n\ngoal (3 subgoals):\n 1. linears pats\n 2. matchs (butlast pats') ?us = Some env\n 3. matchs pats ?us = Some env\\<^sub>1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. matchs (butlast pats') ?us = Some env\n 2. matchs pats ?us = Some env\\<^sub>1", "by fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  butlast pats' = pats\n  env = env\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "let ?rhs_subst = \"\\<lambda>env. subst rhs (fmdrop_fset (frees pat) env)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "have \"fmdom env\\<^sub>2 = freess pats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = freess pats", "using \\<open>match (_ $$ _) _ = Some env\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ pats) u = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>2 = freess pats", "by (simp add: match_dom)"], ["proof (state)\nthis:\n  fmdom env\\<^sub>2 = freess pats\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>|\n       irules_deferred_matches args\\<^sub>1 rs\\<^sub>1 \\<Longrightarrow>\n       fBex cs' (rel_prod (=) prelated (a, b))\n 2. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "show \"fBex cs' (rel_prod (=) prelated (pat, rhs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex cs' (rel_prod (=) prelated (pat, rhs'))", "unfolding \\<open>rhs' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex cs' (rel_prod (=) prelated (pat, subst rhs env))", "proof (rule fBexI, rule rel_prod.intros)"], ["proof (state)\ngoal (3 subgoals):\n 1. pat = ?b3\n 2. subst rhs env \\<approx>\\<^sub>p ?d3\n 3. (?b3, ?d3) |\\<in>| cs'", "have \"fdisjnt (freess (butlast pats')) (frees (last pats'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats')) (frees (last pats'))", "apply (subst freess_single[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess (butlast pats')) (freess [last pats'])", "apply (rule linears_appendD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. linears (butlast pats' @ [last pats'])", "apply (subst \\<open>butlast pats' @ [last pats'] = pats'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats'", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>(name, rs\\<^sub>1) |\\<in>| rs\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats'", "by blast"], ["proof (state)\nthis:\n  fdisjnt (freess (butlast pats')) (frees (last pats'))\n\ngoal (3 subgoals):\n 1. pat = ?b3\n 2. subst rhs env \\<approx>\\<^sub>p ?d3\n 3. (?b3, ?d3) |\\<in>| cs'", "show \"subst rhs env \\<approx>\\<^sub>p ?rhs_subst env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\n     env \\<approx>\\<^sub>p subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)", "apply (rule prelated_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rhs \\<approx>\\<^sub>p rhs\n 2. prelated.P_env env (fmdrop_fset (frees pat) env\\<^sub>2)", "apply (rule prelated_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env (fmdrop_fset (frees pat) env\\<^sub>2)", "unfolding fmfilter_alt_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env\n     (fmfilter (\\<lambda>a. a |\\<notin>| frees pat) env\\<^sub>2)", "apply (subst fmfilter_true)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       fmlookup env\\<^sub>2 x = Some y \\<Longrightarrow>\n       x |\\<notin>| frees pat\n 2. prelated.P_env env env\\<^sub>2", "subgoal premises prems for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<notin>| frees pat", "using fmdomI[OF prems]"], ["proof (prove)\nusing this:\n  x |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees pat", "unfolding \\<open>pat = _\\<close> \\<open>fmdom env\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  x |\\<in>| freess pats\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees (last pats')", "apply (subst (asm) \\<open>butlast pats' = pats\\<close>[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<in>| freess (butlast pats') \\<Longrightarrow>\n    x |\\<notin>| frees (last pats')", "using \\<open>fdisjnt (freess (butlast pats')) (frees (last pats'))\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt (freess (butlast pats')) (frees (last pats'))\n\ngoal (1 subgoal):\n 1. x |\\<in>| freess (butlast pats') \\<Longrightarrow>\n    x |\\<notin>| frees (last pats')", "by (auto simp: fdisjnt_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env env\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env env\\<^sub>2", "unfolding \\<open>env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. prelated.P_env env\\<^sub>1 env\\<^sub>2", "by fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst rhs\n   env \\<approx>\\<^sub>p subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\n\ngoal (2 subgoals):\n 1. pat = ?b3\n 2. (?b3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>| cs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. pat = ?b3\n 2. (?b3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>| cs'", "have \"(pat, rhs) |\\<in>| cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| cs", "unfolding \\<open>pat = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (last pats', rhs) |\\<in>| cs", "apply (rule fgroup_byD[where a = \"(x, y)\" for x y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (?b, cs) |\\<in>| fgroup_by ?f ?as\n 2. ?f (?x7, ?y7) = (?b, last pats', rhs)\n 3. (?x7, ?y7) |\\<in>| ?as", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case (?x7, ?y7) of\n     (pats, rhs) \\<Rightarrow> (butlast pats, last pats, rhs)) =\n    (pats, last pats', rhs)\n 2. (?x7, ?y7) |\\<in>| rs\\<^sub>1", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. butlast ?x7 = pats \\<and> last ?x7 = last pats' \\<and> ?y7 = rhs\n 2. (?x7, ?y7) |\\<in>| rs\\<^sub>1", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. butlast ?x7 = pats\n 2. last ?x7 = last pats'\n 3. ?y7 = rhs\n 4. (?x7, ?y7) |\\<in>| rs\\<^sub>1", "apply fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. last pats' = last pats'\n 2. ?y7 = rhs\n 3. (pats', ?y7) |\\<in>| rs\\<^sub>1", "apply (rule refl)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pats', rhs) |\\<in>| rs\\<^sub>1", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (pat, rhs) |\\<in>| cs\n\ngoal (2 subgoals):\n 1. pat = ?b3\n 2. (?b3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>| cs'", "thus \"(pat, ?rhs_subst env\\<^sub>2) |\\<in>| cs'\""], ["proof (prove)\nusing this:\n  (pat, rhs) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>| cs'", "unfolding \\<open>cs' = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>|\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n    cs", "by force"], ["proof (state)\nthis:\n  (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)) |\\<in>| cs'\n\ngoal (1 subgoal):\n 1. pat = pat", "qed simp"], ["proof (state)\nthis:\n  fBex cs' (rel_prod (=) prelated (pat, rhs'))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "fix pat rhs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "assume \"(pat, rhs') |\\<in>| cs'\""], ["proof (state)\nthis:\n  (pat, rhs') |\\<in>| cs'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "then"], ["proof (chain)\npicking this:\n  (pat, rhs') |\\<in>| cs'", "obtain rhs\n                where \"(pat, rhs) |\\<in>| cs\"\n                  and \"rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2 )\""], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>| cs'\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>(pat, rhs) |\\<in>| cs;\n         rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>cs' = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs') |\\<in>|\n  (\\<lambda>(pat, rhs).\n      (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n  cs\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        \\<lbrakk>(pat, rhs) |\\<in>| cs;\n         rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pat, rhs) |\\<in>| cs\n  rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "with \\<open>(pats, cs) |\\<in>| ?grp\\<close>"], ["proof (chain)\npicking this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n  (pat, rhs) |\\<in>| cs\n  rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)", "obtain pats'\n                where \"(pats', rhs) |\\<in>| rs\\<^sub>1\" \"pats = butlast pats'\" \"pat = last pats'\""], ["proof (prove)\nusing this:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n   rs\\<^sub>1\n  (pat, rhs) |\\<in>| cs\n  rhs' = subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>pats'.\n        \\<lbrakk>(pats', rhs) |\\<in>| rs\\<^sub>1; pats = butlast pats';\n         pat = last pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  pats = butlast pats'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "with False"], ["proof (chain)\npicking this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  pats = butlast pats'\n  pat = last pats'", "have \"length pats' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  pats = butlast pats'\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. length pats' \\<noteq> 0", "using \\<open>arity_compatibles _\\<close>"], ["proof (prove)\nusing this:\n  arity rs\\<^sub>1 \\<noteq> 0\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  pats = butlast pats'\n  pat = last pats'\n  Rewriting_Nterm.arity_compatibles rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. length pats' \\<noteq> 0", "by (metis arity_compatible_length)"], ["proof (state)\nthis:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "hence \"pats' = pats @ [pat]\""], ["proof (prove)\nusing this:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' = pats @ [pat]", "unfolding \\<open>pats = _\\<close> \\<open>pat = _\\<close>"], ["proof (prove)\nusing this:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' = butlast pats' @ [last pats']", "by auto"], ["proof (state)\nthis:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "moreover"], ["proof (state)\nthis:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "have \"linears pats'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears pats'", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>(name, rs\\<^sub>1) |\\<in>| _\\<close> inner"], ["proof (prove)\nusing this:\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  (name, rs\\<^sub>1) |\\<in>| rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. linears pats'", "by blast"], ["proof (state)\nthis:\n  linears pats'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "ultimately"], ["proof (chain)\npicking this:\n  pats' = pats @ [pat]\n  linears pats'", "have \"fdisjnt (fmdom env\\<^sub>1) (frees pat)\""], ["proof (prove)\nusing this:\n  pats' = pats @ [pat]\n  linears pats'\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>1) (frees pat)", "unfolding \\<open>fmdom env\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  pats' = pats @ [pat]\n  linears pats'\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) (frees pat)", "by (auto dest: linears_appendD)"], ["proof (state)\nthis:\n  fdisjnt (fmdom env\\<^sub>1) (frees pat)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "let ?rhs_subst = \"\\<lambda>env. subst rhs (fmdrop_fset (frees pat) env)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| cs' \\<Longrightarrow>\n       fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n        (\\<lambda>x. rel_prod (=) prelated x (a, b))", "show \"fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1) (\\<lambda>e. rel_prod (=) prelated e (pat, rhs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n     (\\<lambda>e. rel_prod (=) prelated e (pat, rhs'))", "unfolding \\<open>rhs' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n     (\\<lambda>e.\n         rel_prod (=) prelated e\n          (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)))", "proof (rule fBexI, rule rel_prod.intros)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a3 = pat\n 2. ?c3 \\<approx>\\<^sub>p subst rhs (fmdrop_fset (frees pat) env\\<^sub>2)\n 3. (?a3, ?c3) |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "show \"?rhs_subst env\\<^sub>1 \\<approx>\\<^sub>p ?rhs_subst env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs\n     (fmdrop_fset (frees pat)\n       env\\<^sub>1) \\<approx>\\<^sub>p subst rhs\n (fmdrop_fset (frees pat) env\\<^sub>2)", "using \\<open>prelated.P_env env\\<^sub>1 env\\<^sub>2\\<close> inner"], ["proof (prove)\nusing this:\n  prelated.P_env env\\<^sub>1 env\\<^sub>2\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. subst rhs\n     (fmdrop_fset (frees pat)\n       env\\<^sub>1) \\<approx>\\<^sub>p subst rhs\n (fmdrop_fset (frees pat) env\\<^sub>2)", "by (auto intro: prelated_subst)"], ["proof (state)\nthis:\n  subst rhs\n   (fmdrop_fset (frees pat)\n     env\\<^sub>1) \\<approx>\\<^sub>p subst rhs\n                                     (fmdrop_fset (frees pat) env\\<^sub>2)\n\ngoal (2 subgoals):\n 1. ?a3 = pat\n 2. (?a3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a3 = pat\n 2. (?a3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "have \"matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1", "using \\<open>matchs pats args\\<^sub>1 = _\\<close> \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  matchs pats args\\<^sub>1 = Some env\\<^sub>1\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?a3 = pat\n 2. (?a3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?a3 = pat\n 2. (?a3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "have \"subst rhs env\\<^sub>1 = ?rhs_subst env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env\\<^sub>1 = subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)", "apply (rule arg_cong[where f = \"subst rhs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. env\\<^sub>1 = fmdrop_fset (frees pat) env\\<^sub>1", "unfolding fmfilter_alt_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. env\\<^sub>1 = fmfilter (\\<lambda>a. a |\\<notin>| frees pat) env\\<^sub>1", "apply (rule fmfilter_true[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup env\\<^sub>1 x = Some y \\<Longrightarrow>\n       x |\\<notin>| frees pat", "using \\<open>fdisjnt (fmdom env\\<^sub>1) _\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt (fmdom env\\<^sub>1) (frees pat)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fmlookup env\\<^sub>1 x = Some y \\<Longrightarrow>\n       x |\\<notin>| frees pat", "by (auto simp: fdisjnt_alt_def intro: fmdomI)"], ["proof (state)\nthis:\n  subst rhs env\\<^sub>1 = subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)\n\ngoal (2 subgoals):\n 1. ?a3 = pat\n 2. (?a3, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\n  subst rhs env\\<^sub>1 = subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)", "show \"(pat, ?rhs_subst env\\<^sub>1) |\\<in>| irules_deferred_matches args\\<^sub>1 rs\\<^sub>1\""], ["proof (prove)\nusing this:\n  matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\n  subst rhs env\\<^sub>1 = subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "using \\<open>(pats', rhs) |\\<in>| rs\\<^sub>1\\<close> \\<open>pat = last pats'\\<close>"], ["proof (prove)\nusing this:\n  matchs (butlast pats') args\\<^sub>1 = Some env\\<^sub>1\n  subst rhs env\\<^sub>1 = subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)\n  (pats', rhs) |\\<in>| rs\\<^sub>1\n  pat = last pats'\n\ngoal (1 subgoal):\n 1. (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n    irules_deferred_matches args\\<^sub>1 rs\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>1)) |\\<in>|\n  irules_deferred_matches args\\<^sub>1 rs\\<^sub>1\n\ngoal (1 subgoal):\n 1. pat = pat", "qed simp"], ["proof (state)\nthis:\n  fBex (irules_deferred_matches args\\<^sub>1 rs\\<^sub>1)\n   (\\<lambda>e. rel_prod (=) prelated e (pat, rhs'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<approx>\\<^sub>p u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (\"fun\" v v' u)"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain w x where \"t = w $\\<^sub>p x\" \"w \\<approx>\\<^sub>p v\" \"x \\<approx>\\<^sub>p u\" \"closed w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>p x; w \\<approx>\\<^sub>p v;\n         x \\<approx>\\<^sub>p u; closed w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<approx>\\<^sub>p v $\\<^sub>p u\\<close> \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>p x; w \\<approx>\\<^sub>p v;\n         x \\<approx>\\<^sub>p u; closed w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed w\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \"fun\""], ["proof (chain)\npicking this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed w", "obtain w' where \"rs \\<turnstile>\\<^sub>i w \\<longrightarrow>* w'\" \"w' \\<approx>\\<^sub>p v'\""], ["proof (prove)\nusing this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i v \\<longrightarrow> v'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p v'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p v; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v' $\\<^sub>p u\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed w\n\ngoal (1 subgoal):\n 1. (\\<And>w'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i w \\<longrightarrow>* w';\n         w' \\<approx>\\<^sub>p v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i w \\<longrightarrow>* w'\n  w' \\<approx>\\<^sub>p v'\n\ngoal (2 subgoals):\n 1. \\<And>t t' u ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                t \\<longrightarrow> t';\n        \\<And>ta thesis.\n           \\<lbrakk>\\<And>t'a.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i\n                                ta \\<longrightarrow>* t'a;\n                        t'a \\<approx>\\<^sub>p t'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            ta \\<approx>\\<^sub>p t; closed ta\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'a.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t'a;\n            t'a \\<approx>\\<^sub>p t' $\\<^sub>p u\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule fun.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p v' $\\<^sub>p u", "show \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w' $\\<^sub>p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w' $\\<^sub>p x", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i w $\\<^sub>p x \\<longrightarrow>* w' $\\<^sub>p x", "by (intro irewrite.rt_comb[unfolded app_pterm_def] rtranclp.rtrancl_refl) fact"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w' $\\<^sub>p x\n\ngoal (1 subgoal):\n 1. w' $\\<^sub>p x \\<approx>\\<^sub>p v' $\\<^sub>p u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w' $\\<^sub>p x \\<approx>\\<^sub>p v' $\\<^sub>p u", "show \"w' $\\<^sub>p x \\<approx>\\<^sub>p v' $\\<^sub>p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w' $\\<^sub>p x \\<approx>\\<^sub>p v' $\\<^sub>p u", "by (rule prelated.app) fact+"], ["proof (state)\nthis:\n  w' $\\<^sub>p x \\<approx>\\<^sub>p v' $\\<^sub>p u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (arg u u' v)"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain w x where \"t = w $\\<^sub>p x\" \"w \\<approx>\\<^sub>p v\" \"x \\<approx>\\<^sub>p u\" \"closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>p x; w \\<approx>\\<^sub>p v;\n         x \\<approx>\\<^sub>p u; closed x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<approx>\\<^sub>p v $\\<^sub>p u\\<close> \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>w x.\n        \\<lbrakk>t = w $\\<^sub>p x; w \\<approx>\\<^sub>p v;\n         x \\<approx>\\<^sub>p u; closed x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed x\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "with arg"], ["proof (chain)\npicking this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed x", "obtain x' where \"rs \\<turnstile>\\<^sub>i x \\<longrightarrow>* x'\" \"x' \\<approx>\\<^sub>p u'\""], ["proof (prove)\nusing this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u'\n  \\<lbrakk>\\<And>t'.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t3 \\<longrightarrow>* t';\n               t' \\<approx>\\<^sub>p u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis3;\n   ?t3 \\<approx>\\<^sub>p u; closed ?t3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3;\n   ?t'3 \\<approx>\\<^sub>p v $\\<^sub>p u'\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p v $\\<^sub>p u\n  closed t\n  t = w $\\<^sub>p x\n  w \\<approx>\\<^sub>p v\n  x \\<approx>\\<^sub>p u\n  closed x\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i x \\<longrightarrow>* x';\n         x' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i x \\<longrightarrow>* x'\n  x' \\<approx>\\<^sub>p u'\n\ngoal (1 subgoal):\n 1. \\<And>u u' t ta thesis.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow> u';\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>t'.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t';\n                        t' \\<approx>\\<^sub>p u'\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t'.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i ta \\<longrightarrow>* t';\n            t' \\<approx>\\<^sub>p t $\\<^sub>p u'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ta \\<approx>\\<^sub>p t $\\<^sub>p u; closed ta\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule arg.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t'3\n 2. ?t'3 \\<approx>\\<^sub>p v $\\<^sub>p u'", "show \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w $\\<^sub>p x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w $\\<^sub>p x'", "unfolding \\<open>t = w $\\<^sub>p x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i w $\\<^sub>p x \\<longrightarrow>* w $\\<^sub>p x'", "by (intro irewrite.rt_comb[unfolded app_pterm_def] rtranclp.rtrancl_refl) fact"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* w $\\<^sub>p x'\n\ngoal (1 subgoal):\n 1. w $\\<^sub>p x' \\<approx>\\<^sub>p v $\\<^sub>p u'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w $\\<^sub>p x' \\<approx>\\<^sub>p v $\\<^sub>p u'", "show \"w $\\<^sub>p x' \\<approx>\\<^sub>p v $\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w $\\<^sub>p x' \\<approx>\\<^sub>p v $\\<^sub>p u'", "by (rule prelated.app) fact+"], ["proof (state)\nthis:\n  w $\\<^sub>p x' \\<approx>\\<^sub>p v $\\<^sub>p u'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Completeness of transformation\\<close>"], ["", "lemma (in irules) transform_completeness:\n  assumes \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\" \"closed t\"\n  shows \"transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t \\<longrightarrow>* t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow>* t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t $\\<^sub>p u'", "case (step name irs' pats' rhs' t t')"], ["proof (state)\nthis:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t \\<longrightarrow>* t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow>* t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t $\\<^sub>p u'", "then"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t", "obtain irs where \"irs = transform_irules irs'\" \"(name, irs) |\\<in>| transform_irule_set rs\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>irs = transform_irules irs';\n         (name, irs) |\\<in>| transform_irule_set rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding transform_irule_set_def"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>irs.\n        \\<lbrakk>irs = transform_irules irs';\n         (name, irs) |\\<in>| map_prod id transform_irules |`| rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis fimageI id_apply map_prod_simp)"], ["proof (state)\nthis:\n  irs = transform_irules irs'\n  (name, irs) |\\<in>| transform_irule_set rs\n\ngoal (4 subgoals):\n 1. \\<And>name rsa pats rhs t t'.\n       \\<lbrakk>(name, rsa) |\\<in>| rs; (pats, rhs) |\\<in>| rsa;\n        name, pats, rhs \\<turnstile>\\<^sub>i t \\<rightarrow> t';\n        closed t\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t \\<longrightarrow>* t'\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow>* t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t' $\\<^sub>p u\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t $\\<^sub>p u'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "proof (cases \"arity irs' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "case True"], ["proof (state)\nthis:\n  arity irs' = 0\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "hence \"irs = irs'\""], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. irs = irs'", "unfolding \\<open>irs = _\\<close>"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. transform_irules irs' = irs'", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' = 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    irs'", "by simp"], ["proof (state)\nthis:\n  irs = irs'\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "with step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  irs = irs'", "have \"(pats', rhs') |\\<in>| irs\" \"name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  irs = irs'\n\ngoal (1 subgoal):\n 1. (pats', rhs') |\\<in>| irs &&&\n    name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'", "by blast+"], ["proof (state)\nthis:\n  (pats', rhs') |\\<in>| irs\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "apply (rule r_into_rtranclp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t'", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. (?name2, ?rs2) |\\<in>| transform_irule_set rs\n 2. (?pats2, ?rhs2) |\\<in>| ?rs2\n 3. ?name2, ?pats2, ?rhs2 \\<turnstile>\\<^sub>i t \\<rightarrow> t'", "by fact+"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n\ngoal (2 subgoals):\n 1. arity irs' = 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n 2. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "by fact"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "let ?f = \"\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "let ?grp = \"fgroup_by ?f irs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "note closed_except_def [simp add]"], ["proof (state)\nthis:\n  closed_except ?t ?S = (frees ?t |\\<subseteq>| ?S)\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "case False"], ["proof (state)\nthis:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  arity irs' \\<noteq> 0", "have \"irs = map_prod id Pabs |`| ?grp\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irs =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding \\<open>irs = _\\<close>"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. transform_irules irs' =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs') =\n    map_prod id Pabs |`|\n    fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "by simp"], ["proof (state)\nthis:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "with False"], ["proof (chain)\npicking this:\n  arity irs' \\<noteq> 0\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "have \"irs = transform_irules irs'\""], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. irs = transform_irules irs'", "unfolding transform_irules_def"], ["proof (prove)\nusing this:\n  arity irs' \\<noteq> 0\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. irs =\n    (if arity irs' = 0 then irs'\n     else map_prod id Pabs |`|\n          fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n           irs')", "by simp"], ["proof (state)\nthis:\n  irs = transform_irules irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "obtain pat pats where \"pat = last pats'\" \"pats = butlast pats'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat pats.\n        \\<lbrakk>pat = last pats'; pats = butlast pats'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pat = last pats'\n  pats = butlast pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "from step False"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  arity irs' \\<noteq> 0", "have \"length pats' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  arity irs' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length pats' \\<noteq> 0", "using arity_compatible_length inner"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  arity irs' \\<noteq> 0\n  \\<lbrakk>Rewriting_Nterm.arity_compatibles ?rs;\n   (?pats, ?rhs) |\\<in>| ?rs\\<rbrakk>\n  \\<Longrightarrow> length ?pats = arity ?rs\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. length pats' \\<noteq> 0", "by (smt fBallE prod.simps(2))"], ["proof (state)\nthis:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  length pats' \\<noteq> 0", "have \"pats' = pats @ [pat]\""], ["proof (prove)\nusing this:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' = pats @ [pat]", "unfolding \\<open>pat = _\\<close> \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  length pats' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pats' = butlast pats' @ [last pats']", "by simp"], ["proof (state)\nthis:\n  pats' = pats @ [pat]\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "from step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t", "have \"linears pats'\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. linears pats'", "using inner fBallE"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n  \\<lbrakk>fBall ?A ?P; ?P ?x \\<Longrightarrow> ?Q;\n   ?x |\\<notin>| ?A \\<Longrightarrow> ?Q\\<rbrakk>\n  \\<Longrightarrow> ?Q\n\ngoal (1 subgoal):\n 1. linears pats'", "by (metis (mono_tags, lifting) old.prod.case)"], ["proof (state)\nthis:\n  linears pats'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  linears pats'", "have \"fdisjnt (freess pats) (frees pat)\""], ["proof (prove)\nusing this:\n  linears pats'\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) (frees pat)", "unfolding \\<open>pats' = _\\<close>"], ["proof (prove)\nusing this:\n  linears (pats @ [pat])\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) (frees pat)", "using linears_appendD(3) freess_single"], ["proof (prove)\nusing this:\n  linears (pats @ [pat])\n  linears (?xs @ ?ys) \\<Longrightarrow> fdisjnt (freess ?xs) (freess ?ys)\n  freess [?x] = frees ?x\n\ngoal (1 subgoal):\n 1. fdisjnt (freess pats) (frees pat)", "by force"], ["proof (state)\nthis:\n  fdisjnt (freess pats) (frees pat)\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "from step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t", "obtain cs where \"(pats, cs) |\\<in>| ?grp\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (pats, cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        (butlast pats', cs) |\\<in>|\n        fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n         irs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) fgroup_by_complete fst_conv prod.simps(2))"], ["proof (state)\nthis:\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "with step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'", "have \"(pat, rhs') |\\<in>| cs\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (pat, rhs') |\\<in>| cs", "unfolding \\<open>pat = _\\<close> \\<open>pats = _\\<close>"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  (butlast pats', cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (last pats', rhs') |\\<in>| cs", "by (meson fgroup_byD old.prod.case)"], ["proof (state)\nthis:\n  (pat, rhs') |\\<in>| cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"(pats, Pabs cs) |\\<in>| irs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pats, Pabs cs) |\\<in>| irs", "using \\<open>irs = map_prod id Pabs |`| ?grp\\<close> \\<open>(pats, cs) |\\<in>| _\\<close>"], ["proof (prove)\nusing this:\n  irs =\n  map_prod id Pabs |`|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n  (pats, cs) |\\<in>|\n  fgroup_by (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs)) irs'\n\ngoal (1 subgoal):\n 1. (pats, Pabs cs) |\\<in>| irs", "by (metis (no_types, lifting) eq_snd_iff fst_conv fst_map_prod id_def rev_fimage_eqI snd_map_prod)"], ["proof (state)\nthis:\n  (pats, Pabs cs) |\\<in>| irs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "from step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t", "obtain env' where \"match (name $$ pats') t = Some env'\" \"subst rhs' env' = t'\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match (name $$ pats') t = Some env';\n         subst rhs' env' = t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using irewrite_step_def"], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  irewrite_step ?name ?pats ?rhs ?t =\n  map_option (subst ?rhs) (match (?name $$ ?pats) ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match (name $$ pats') t = Some env';\n         subst rhs' env' = t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match (name $$ pats') t = Some env'\n  subst rhs' env' = t'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"name $$ pats' = (name $$ pats) $ pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$ pats' = name $$ pats $ pat", "unfolding \\<open>pats' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$ (pats @ [pat]) = name $$ pats $ pat", "by (simp add: app_term_def)"], ["proof (state)\nthis:\n  name $$ pats' = name $$ pats $ pat\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  name $$ pats' = name $$ pats $ pat", "obtain t\\<^sub>0 t\\<^sub>1 env\\<^sub>0 env\\<^sub>1 where \"t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1\" \"match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\" \"match pat t\\<^sub>1 = Some env\\<^sub>1\" \"env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\""], ["proof (prove)\nusing this:\n  name $$ pats' = name $$ pats $ pat\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0 t\\<^sub>1 env\\<^sub>0 env\\<^sub>1.\n        \\<lbrakk>t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1;\n         match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0;\n         match pat t\\<^sub>1 = Some env\\<^sub>1;\n         env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using match_appE_split[OF \\<open>match (name $$ pats') _ = _\\<close>[unfolded \\<open>name $$ pats' = _\\<close>], unfolded app_pterm_def]"], ["proof (prove)\nusing this:\n  name $$ pats' = name $$ pats $ pat\n  (\\<And>u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n      \\<lbrakk>t = u\\<^sub>1 $\\<^sub>p u\\<^sub>2;\n       match (name $$ pats) u\\<^sub>1 = Some env\\<^sub>1;\n       match pat u\\<^sub>2 = Some env\\<^sub>2;\n       env' = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0 t\\<^sub>1 env\\<^sub>0 env\\<^sub>1.\n        \\<lbrakk>t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1;\n         match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0;\n         match pat t\\<^sub>1 = Some env\\<^sub>1;\n         env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "with step"], ["proof (chain)\npicking this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1", "have \"closed t\\<^sub>0\" \"closed t\\<^sub>1\""], ["proof (prove)\nusing this:\n  (name, irs') |\\<in>| rs\n  (pats', rhs') |\\<in>| irs'\n  name, pats', rhs' \\<turnstile>\\<^sub>i t \\<rightarrow> t'\n  closed t\n  t = t\\<^sub>0 $\\<^sub>p t\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  env' = env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\n\ngoal (1 subgoal):\n 1. closed t\\<^sub>0 &&& closed t\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  closed t\\<^sub>0\n  closed t\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  closed t\\<^sub>0\n  closed t\\<^sub>1", "have \"closed_env env\\<^sub>0\" \"closed_env env\\<^sub>1\""], ["proof (prove)\nusing this:\n  closed t\\<^sub>0\n  closed t\\<^sub>1\n\ngoal (1 subgoal):\n 1. closed_env env\\<^sub>0 &&& closed_env env\\<^sub>1", "using match_vars[OF \\<open>match _ t\\<^sub>0 = _\\<close>] match_vars[OF \\<open>match _ t\\<^sub>1 = _\\<close>]"], ["proof (prove)\nusing this:\n  closed t\\<^sub>0\n  closed t\\<^sub>1\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t\\<^sub>0) env\\<^sub>0\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t\\<^sub>1) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. closed_env env\\<^sub>0 &&& closed_env env\\<^sub>1", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees t\\<^sub>0 |\\<subseteq>| {||}\n  frees t\\<^sub>1 |\\<subseteq>| {||}\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t\\<^sub>0) env\\<^sub>0\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t\\<^sub>1) env\\<^sub>1\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_ t. frees t |\\<subseteq>| {||}) env\\<^sub>0 &&&\n    fmpred (\\<lambda>_ t. frees t |\\<subseteq>| {||}) env\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  closed_env env\\<^sub>0\n  closed_env env\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "obtain t\\<^sub>0' where \"subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0'.\n        subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0'", "obtain cs' where \"t\\<^sub>0' = Pabs cs'\" \"cs' = ((\\<lambda>(pat, rhs). (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`| cs)\""], ["proof (prove)\nusing this:\n  subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0'\n\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        \\<lbrakk>t\\<^sub>0' = Pabs cs';\n         cs' =\n         (\\<lambda>(pat, rhs).\n             (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`|\n         cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subst_pterm.simps(3)"], ["proof (prove)\nusing this:\n  subst (Pabs cs) env\\<^sub>0 = t\\<^sub>0'\n  subst (Pabs ?cs) ?env =\n  Pabs\n   ((\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) ?env))) |`|\n    ?cs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        \\<lbrakk>t\\<^sub>0' = Pabs cs';\n         cs' =\n         (\\<lambda>(pat, rhs).\n             (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`|\n         cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t\\<^sub>0' = Pabs cs'\n  cs' =\n  (\\<lambda>(pat, rhs).\n      (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`|\n  cs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "obtain rhs where \"subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) =\n        rhs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "then"], ["proof (chain)\npicking this:\n  subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs", "have \"(pat, rhs) |\\<in>| cs'\""], ["proof (prove)\nusing this:\n  subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs\n\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| cs'", "unfolding \\<open>cs' = _\\<close>"], ["proof (prove)\nusing this:\n  subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs\n\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>|\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`|\n    cs", "using \\<open>_ |\\<in>| cs\\<close>"], ["proof (prove)\nusing this:\n  subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0) = rhs\n  (pat, rhs') |\\<in>| cs\n\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>|\n    (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env\\<^sub>0))) |`|\n    cs", "by (metis (mono_tags, lifting) old.prod.case rev_fimage_eqI)"], ["proof (state)\nthis:\n  (pat, rhs) |\\<in>| cs'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"env\\<^sub>0 ++\\<^sub>f env\\<^sub>1 = (fmdrop_fset (frees pat) env\\<^sub>0) ++\\<^sub>f env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. env\\<^sub>0 ++\\<^sub>f env\\<^sub>1 =\n    fmdrop_fset (frees pat) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1", "apply (subst fmadd_drop_left_dom[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdrop_fset (fmdom env\\<^sub>1) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1 =\n    fmdrop_fset (frees pat) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1", "using \\<open>match pat _ = _\\<close> match_dom"], ["proof (prove)\nusing this:\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  match ?p ?t = Some ?env \\<Longrightarrow> fmdom ?env = frees ?p\n\ngoal (1 subgoal):\n 1. fmdrop_fset (fmdom env\\<^sub>1) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1 =\n    fmdrop_fset (frees pat) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1", "by metis"], ["proof (state)\nthis:\n  env\\<^sub>0 ++\\<^sub>f env\\<^sub>1 =\n  fmdrop_fset (frees pat) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)", "using match_dom"], ["proof (prove)\nusing this:\n  match ?p ?t = Some ?env \\<Longrightarrow> fmdom ?env = frees ?p\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)", "using \\<open>match pat _ = _\\<close> \\<open>match (name $$ pats) _ = _\\<close>"], ["proof (prove)\nusing this:\n  match ?p ?t = Some ?env \\<Longrightarrow> fmdom ?env = frees ?p\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)", "using \\<open>fdisjnt _ _\\<close>"], ["proof (prove)\nusing this:\n  match ?p ?t = Some ?env \\<Longrightarrow> fmdom ?env = frees ?p\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n  fdisjnt (freess pats) (frees pat)\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  match ?p ?t = Some ?env \\<Longrightarrow> fmdom ?env = frees ?p\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  match (name $$ pats) t\\<^sub>0 = Some env\\<^sub>0\n  freess pats |\\<inter>| frees pat = {||}\n\ngoal (1 subgoal):\n 1. fmdom env\\<^sub>0 |\\<inter>| fmdom env\\<^sub>1 = {||}", "by (metis matchs_dom match_list_combE)"], ["proof (state)\nthis:\n  fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "have \"subst rhs env\\<^sub>1 = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs env\\<^sub>1 = t'", "unfolding \\<open>_ = rhs\\<close>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    t'", "unfolding \\<open>_ = t'\\<close>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst rhs' env'", "unfolding \\<open>env' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst rhs' (env\\<^sub>0 ++\\<^sub>f env\\<^sub>1)", "unfolding \\<open>env\\<^sub>0 ++\\<^sub>f _ = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0 ++\\<^sub>f env\\<^sub>1)", "apply (subst subst_indep')"], ["proof (prove)\ngoal (3 subgoals):\n 1. closed_env (fmdrop_fset (frees pat) env\\<^sub>0)\n 2. fdisjnt (fmdom (fmdrop_fset (frees pat) env\\<^sub>0))\n     (fmdom env\\<^sub>1)\n 3. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1", "using \\<open>closed_env env\\<^sub>0\\<close>"], ["proof (prove)\nusing this:\n  closed_env env\\<^sub>0\n\ngoal (3 subgoals):\n 1. closed_env (fmdrop_fset (frees pat) env\\<^sub>0)\n 2. fdisjnt (fmdom (fmdrop_fset (frees pat) env\\<^sub>0))\n     (fmdom env\\<^sub>1)\n 3. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. fdisjnt (fmdom (fmdrop_fset (frees pat) env\\<^sub>0))\n     (fmdom env\\<^sub>1)\n 2. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1", "using \\<open>fdisjnt (fmdom _) _\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt (fmdom env\\<^sub>0) (fmdom env\\<^sub>1)\n\ngoal (2 subgoals):\n 1. fdisjnt (fmdom (fmdrop_fset (frees pat) env\\<^sub>0))\n     (fmdom env\\<^sub>1)\n 2. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  fmdom env\\<^sub>0 |\\<inter>| fmdom env\\<^sub>1 = {||}\n\ngoal (2 subgoals):\n 1. fmdom (fmdrop_fset (frees pat) env\\<^sub>0) |\\<inter>|\n    fmdom env\\<^sub>1 =\n    {||}\n 2. subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1 =\n    subst (subst rhs' (fmdrop_fset (frees pat) env\\<^sub>0)) env\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  subst rhs env\\<^sub>1 = t'\n\ngoal (1 subgoal):\n 1. arity irs' \\<noteq> 0 \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i\n    t\\<^sub>0 $\\<^sub>p t\\<^sub>1 \\<longrightarrow>* t'", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i\n    t\\<^sub>0 $\\<^sub>p t\\<^sub>1 \\<longrightarrow>* ?b\n 2. transform_irule_set rs \\<turnstile>\\<^sub>i ?b \\<longrightarrow> t'", "apply (rule r_into_rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i\n    t\\<^sub>0 $\\<^sub>p t\\<^sub>1 \\<longrightarrow> ?b\n 2. transform_irule_set rs \\<turnstile>\\<^sub>i ?b \\<longrightarrow> t'", "apply (rule irewrite.intros(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t\\<^sub>0 \\<longrightarrow>\n    ?t'5\n 2. transform_irule_set rs \\<turnstile>\\<^sub>i\n    ?t'5 $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. (?name7, ?rs7) |\\<in>| transform_irule_set rs\n 2. (?pats7, ?rhs7) |\\<in>| ?rs7\n 3. ?name7, ?pats7, ?rhs7 \\<turnstile>\\<^sub>i t\\<^sub>0 \\<rightarrow> ?t'5\n 4. transform_irule_set rs \\<turnstile>\\<^sub>i\n    ?t'5 $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "apply fact+"], ["proof (prove)\ngoal (2 subgoals):\n 1. name, pats, Pabs cs \\<turnstile>\\<^sub>i t\\<^sub>0 \\<rightarrow> ?t'5\n 2. transform_irule_set rs \\<turnstile>\\<^sub>i\n    ?t'5 $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "apply (rule irewrite_stepI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. match (name $$ pats) t\\<^sub>0 = Some ?env13\n 2. subst (Pabs cs) ?env13 = ?t'5\n 3. transform_irule_set rs \\<turnstile>\\<^sub>i\n    ?t'5 $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i\n    t\\<^sub>0' $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "unfolding \\<open>t\\<^sub>0' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i\n    Pabs cs' $\\<^sub>p t\\<^sub>1 \\<longrightarrow> t'", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?c18 |\\<in>| cs'\n 2. ?c18 \\<turnstile> t\\<^sub>1 \\<rightarrow> t'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<turnstile> t\\<^sub>1 \\<rightarrow> t'", "using \\<open>match pat t\\<^sub>1 = _\\<close> \\<open>subst rhs _ = _\\<close>"], ["proof (prove)\nusing this:\n  match pat t\\<^sub>1 = Some env\\<^sub>1\n  subst rhs env\\<^sub>1 = t'\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<turnstile> t\\<^sub>1 \\<rightarrow> t'", "by force"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         Pabs cs $\\<^sub>p t \\<longrightarrow>* t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow> t';\n        closed t \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t' $\\<^sub>p u\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>i u \\<longrightarrow> u';\n        closed u \\<Longrightarrow>\n        transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u';\n        closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> transform_irule_set rs \\<turnstile>\\<^sub>i\n                         t $\\<^sub>p u \\<longrightarrow>* t $\\<^sub>p u'", "qed (auto intro: irewrite.rt_comb[unfolded app_pterm_def] intro!: irewrite.intros simp: closed_except_def)"], ["", "subsubsection \\<open>Computability\\<close>"], ["", "export_code\n  compile transform_irules\n  checking Scala SML"], ["", "end"]]}