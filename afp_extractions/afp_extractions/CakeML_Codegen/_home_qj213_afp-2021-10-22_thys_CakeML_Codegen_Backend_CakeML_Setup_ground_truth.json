{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Backend/CakeML_Setup.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma fmlookup_ns[simp]: \"fmlookup (fmap_of_ns ns) k = cupcake_nsLookup ns (as_string k)\"", "lemma fmap_of_nsBind[simp]: \"fmap_of_ns (nsBind (as_string k) v0 ns) = fmupd k v0 (fmap_of_ns ns)\"", "lemma fmap_of_nsAppend[simp]: \"fmap_of_ns (nsAppend ns1 ns2) = fmap_of_ns ns2 ++\\<^sub>f fmap_of_ns ns1\"", "lemma fmap_of_alist_to_ns[simp]: \"fmap_of_ns (alist_to_ns xs) = fmap_of_list (map (map_prod Name id) xs)\"", "lemma fmap_of_nsEmpty[simp]: \"fmap_of_ns nsEmpty = fmempty\"", "lemma build_rec_env_fmap0:\n  \"fmap_of_ns (foldr (\\<lambda>(f, x, e). nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f)) funs env) =\n    fmap_of_ns env ++\\<^sub>f fmap_of_list (map (\\<lambda>(f, _). (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f)) funs)\"", "lemma build_rec_env_fmap:\n  \"fmap_of_ns (build_rec_env funs env\\<^sub>\\<Lambda> env) = fmap_of_ns env ++\\<^sub>f cake_mk_rec_env funs env\\<^sub>\\<Lambda>\"", "lemma as_static_cenv_cakeml_static_env: \"cakeml_static_env as_static_cenv\"", "lemma empty_state_with_types_alt_def:\n  \"empty_state_with_types = empty_state \\<lparr> defined_types := cake_all_types \\<rparr>\"", "lemma state_types_update:\n  \"update_defined_types (\\<lambda>_. cake_all_types \\<union> defined_types empty_state) empty_state =\n    empty_state_with_types\"", "lemma env_types_update: \"build_tdefs [] as_cake_type_def = as_static_cenv\"", "lemmas evaluate_type =\n  evaluate_dec.dtype1[\n    where new_tdecs = cake_all_types and s = empty_state and mn = \"[]\" and tds = as_cake_type_def,\n    unfolded state_types_update env_types_update,\n    folded empty_sem_env_def]", "lemma type_defs_to_new_tdecs:\n  \"type_defs_to_new_tdecs [] as_cake_type_def =\n    set (map (\\<lambda>name. TypeId (Short (as_string name))) (sorted_list_of_fset (fmdom C_info)))\"", "lemma cakeml_convoluted1: \"foldr (\\<lambda>(n, ts). (#) n) ys xs = map fst ys @ xs\"", "lemma cakeml_convoluted2: \"foldr (\\<lambda>x y. f x @ y) xs ys = concat (map f xs) @ ys\"", "lemma check_dup_ctors_alt_def: \"check_dup_ctors tds \\<longleftrightarrow> distinct (tds \\<bind> (\\<lambda>(_, _, cons). map fst cons))\"", "lemma evaluate_dec_prelude:\n  \"evaluate_dec t [] env empty_state cake_dt_prelude (empty_state_with_types, Rval empty_sem_env)\""], "translations": [["", "lemma fmlookup_ns[simp]: \"fmlookup (fmap_of_ns ns) k = cupcake_nsLookup ns (as_string k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup (fmap_of_ns ns) k = cupcake_nsLookup ns (as_string k)", "by (cases ns) (simp add: fmlookup_of_list map_prod_def name.map_of_rekey option.map_ident)"], ["", "lemma fmap_of_nsBind[simp]: \"fmap_of_ns (nsBind (as_string k) v0 ns) = fmupd k v0 (fmap_of_ns ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (nsBind (as_string k) v0 ns) = fmupd k v0 (fmap_of_ns ns)", "by (cases ns) auto"], ["", "lemma fmap_of_nsAppend[simp]: \"fmap_of_ns (nsAppend ns1 ns2) = fmap_of_ns ns2 ++\\<^sub>f fmap_of_ns ns1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (nsAppend ns1 ns2) = fmap_of_ns ns2 ++\\<^sub>f fmap_of_ns ns1", "by (cases ns1; cases ns2) simp"], ["", "lemma fmap_of_alist_to_ns[simp]: \"fmap_of_ns (alist_to_ns xs) = fmap_of_list (map (map_prod Name id) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (alist_to_ns xs) = fmap_of_list (map (map_prod Name id) xs)", "unfolding alist_to_ns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (Bind xs []) = fmap_of_list (map (map_prod Name id) xs)", "by simp"], ["", "lemma fmap_of_nsEmpty[simp]: \"fmap_of_ns nsEmpty = fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns nsEmpty = fmempty", "unfolding nsEmpty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (Bind [] []) = fmempty", "by simp"], ["", "context begin"], ["", "private"], ["", "lemma build_rec_env_fmap0:\n  \"fmap_of_ns (foldr (\\<lambda>(f, x, e). nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f)) funs env) =\n    fmap_of_ns env ++\\<^sub>f fmap_of_list (map (\\<lambda>(f, _). (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f)) funs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns\n     (foldr\n       (\\<lambda>(f, x, e).\n           nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n       funs env) =\n    fmap_of_ns env ++\\<^sub>f\n    fmap_of_list\n     (map (\\<lambda>(f, uu_).\n              (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n       funs)", "apply (induction funs arbitrary: env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>env.\n       fmap_of_ns\n        (foldr\n          (\\<lambda>(f, x, e).\n              nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n          [] env) =\n       fmap_of_ns env ++\\<^sub>f\n       fmap_of_list\n        (map (\\<lambda>(f, uu_).\n                 (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n          [])\n 2. \\<And>a funs env.\n       (\\<And>env.\n           fmap_of_ns\n            (foldr\n              (\\<lambda>(f, x, e).\n                  nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n              funs env) =\n           fmap_of_ns env ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>(f, uu_).\n                     (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n              funs)) \\<Longrightarrow>\n       fmap_of_ns\n        (foldr\n          (\\<lambda>(f, x, e).\n              nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n          (a # funs) env) =\n       fmap_of_ns env ++\\<^sub>f\n       fmap_of_list\n        (map (\\<lambda>(f, uu_).\n                 (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n          (a # funs))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a funs env.\n       (\\<And>env.\n           fmap_of_ns\n            (foldr\n              (\\<lambda>(f, x, e).\n                  nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n              funs env) =\n           fmap_of_ns env ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>(f, uu_).\n                     (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n              funs)) \\<Longrightarrow>\n       fmap_of_ns\n        (nsBind a (Recclosure env\\<^sub>\\<Lambda> funs' a)\n          (foldr\n            (\\<lambda>(f, x, e).\n                nsBind f (Recclosure env\\<^sub>\\<Lambda> funs' f))\n            funs env)) =\n       fmupd (Name a) (Recclosure env\\<^sub>\\<Lambda> funs' a)\n        (fmap_of_ns env ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>(f, uu_).\n                   (Name f, Recclosure env\\<^sub>\\<Lambda> funs' f))\n            funs))", "by (metis (no_types, lifting) fmap_of_nsBind name.sel)"], ["", "definition cake_mk_rec_env where\n\"cake_mk_rec_env funs env = fmap_of_list (map (\\<lambda>(f, _). (Name f, Recclosure env funs f)) funs)\""], ["", "lemma build_rec_env_fmap:\n  \"fmap_of_ns (build_rec_env funs env\\<^sub>\\<Lambda> env) = fmap_of_ns env ++\\<^sub>f cake_mk_rec_env funs env\\<^sub>\\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns (build_rec_env funs env\\<^sub>\\<Lambda> env) =\n    fmap_of_ns env ++\\<^sub>f cake_mk_rec_env funs env\\<^sub>\\<Lambda>", "unfolding build_rec_env_def cake_mk_rec_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_ns\n     (foldr\n       (\\<lambda>(f, x, e).\n           nsBind f (Recclosure env\\<^sub>\\<Lambda> funs f))\n       funs env) =\n    fmap_of_ns env ++\\<^sub>f\n    fmap_of_list\n     (map (\\<lambda>(f, uu_).\n              (Name f, Recclosure env\\<^sub>\\<Lambda> funs f))\n       funs)", "by (rule build_rec_env_fmap0)"], ["", "end"], ["", "section \\<open>Constructors according to CakeML\\<close>"], ["", "definition cake_tctor :: \"string \\<Rightarrow> tctor\" where\n\"cake_tctor name = (if name = ''fun'' then Ast.TC_fn else Ast.TC_name (Short name))\""], ["", "primrec typ_to_t :: \"typ \\<Rightarrow> Ast.t\" where\n\"typ_to_t (TVar name) = Ast.Tvar (as_string name)\" |\n\"typ_to_t (TApp name args) = Ast.Tapp (map typ_to_t args) (cake_tctor (as_string name))\""], ["", "context constructors begin"], ["", "definition as_static_cenv :: c_ns where\n\"as_static_cenv = Bind (rev (map (map_prod id (map_prod id (TypeId \\<circ> Short))) flat_C_info)) []\""], ["", "lemma as_static_cenv_cakeml_static_env: \"cakeml_static_env as_static_cenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cakeml_static_env as_static_cenv", "unfolding cakeml_static_env_def as_static_cenv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_c_ns\n     (Bind\n       (rev (map (map_prod id (map_prod id (TypeId \\<circ> Short)))\n              flat_C_info))\n       [])", "by (auto simp: list.pred_map split: prod.splits)"], ["", "sublocale cake_static_env?: cakeml_static_env as_static_cenv"], ["proof (prove)\ngoal (1 subgoal):\n 1. cakeml_static_env as_static_cenv", "by (rule as_static_cenv_cakeml_static_env)"], ["", "definition as_cake_type_def :: Ast.type_def where\n\"as_cake_type_def =\n  map (\\<lambda>(name, dt_def). (map as_string (tparams dt_def), as_string name,\n      map (\\<lambda>(C, params). (as_string C, map typ_to_t params))\n        (sorted_list_of_fmap (constructors dt_def))))\n    (sorted_list_of_fmap C_info)\""], ["", "definition cake_dt_prelude :: Ast.dec where\n\"cake_dt_prelude = Ast.Dtype empty_locs as_cake_type_def\""], ["", "definition cake_all_types :: \"tid_or_exn set\" where\n\"cake_all_types = (TypeId \\<circ> Short \\<circ> as_string) ` fset all_tdefs\""], ["", "definition empty_state_with_types :: \"unit SemanticPrimitives.state\" where\n\"empty_state_with_types =\n  \\<lparr> clock = 0, refs = [], ffi = empty_ffi_state, defined_types = cake_all_types, defined_mods = {} \\<rparr>\""], ["", "lemma empty_state_with_types_alt_def:\n  \"empty_state_with_types = empty_state \\<lparr> defined_types := cake_all_types \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_state_with_types =\n    update_defined_types (\\<lambda>_. cake_all_types) empty_state", "unfolding empty_state_with_types_def empty_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. make_state 0 [] empty_ffi_state cake_all_types {} =\n    update_defined_types (\\<lambda>_. cake_all_types)\n     (make_state 0 [] empty_ffi_state {} {})", "(* FIXME update_f (make_t ) lemma missing *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. make_state 0 [] empty_ffi_state cake_all_types {} =\n    update_defined_types (\\<lambda>_. cake_all_types)\n     (make_state 0 [] empty_ffi_state {} {})", "by (auto simp: datatype_record_update)"], ["", "end"], ["", "subsection \\<open>Running the generated type declarations through the semantics\\<close>"], ["", "context constants begin"], ["", "context begin"], ["", "(* FIXME slightly different shape than empty_state_with_types_alt_def *)\nprivate"], ["", "lemma state_types_update:\n  \"update_defined_types (\\<lambda>_. cake_all_types \\<union> defined_types empty_state) empty_state =\n    empty_state_with_types\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_defined_types\n     (\\<lambda>_. cake_all_types \\<union> defined_types empty_state)\n     empty_state =\n    empty_state_with_types", "unfolding empty_state_with_types_def empty_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_defined_types\n     (\\<lambda>_.\n         cake_all_types \\<union>\n         defined_types (make_state 0 [] empty_ffi_state {} {}))\n     (make_state 0 [] empty_ffi_state {} {}) =\n    make_state 0 [] empty_ffi_state cake_all_types {}", "(* FIXME update_f (make_t ) lemma missing *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. update_defined_types\n     (\\<lambda>_.\n         cake_all_types \\<union>\n         defined_types (make_state 0 [] empty_ffi_state {} {}))\n     (make_state 0 [] empty_ffi_state {} {}) =\n    make_state 0 [] empty_ffi_state cake_all_types {}", "by (simp add: datatype_record_update)"], ["", "private"], ["", "lemma env_types_update: \"build_tdefs [] as_cake_type_def = as_static_cenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_tdefs [] as_cake_type_def = as_static_cenv", "unfolding as_cake_type_def_def as_static_cenv_def build_tdefs_def alist_to_ns_def flat_C_info_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bind\n     (rev (concat\n            (map (\\<lambda>(tvs, tn, y).\n                     map (\\<lambda>(conN, ts).\n                             (conN, length ts, TypeId (mk_id [] tn)))\n                      y)\n              (map (\\<lambda>(name, dt_def).\n                       (map as_string (tparams dt_def), as_string name,\n                        map (\\<lambda>(C, params).\n                                (as_string C, map typ_to_t params))\n                         (sorted_list_of_fmap (constructors dt_def))))\n                (sorted_list_of_fmap C_info)))))\n     [] =\n    Bind\n     (rev (map (map_prod id (map_prod id (TypeId \\<circ> Short)))\n            (sorted_list_of_fmap C_info \\<bind>\n             (\\<lambda>(tname, Cs).\n                 sorted_list_of_fmap (constructors Cs) \\<bind>\n                 (\\<lambda>(C, params).\n                     [(as_string C, length params, as_string tname)])))))\n     []", "apply (auto simp: List.bind_def map_concat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map ((\\<lambda>(tvs, tn, y).\n               map (\\<lambda>(conN, ts).\n                       (conN, length ts, TypeId (Short tn)))\n                y) \\<circ>\n           (\\<lambda>(name, dt_def).\n               (map as_string (tparams dt_def), as_string name,\n                map (\\<lambda>(C, params).\n                        (as_string C, map typ_to_t params))\n                 (sorted_list_of_fmap (constructors dt_def)))))\n       (sorted_list_of_fmap C_info)) =\n    concat\n     (map (map (map_prod id (map_prod id (TypeId \\<circ> Short))) \\<circ>\n           (\\<lambda>(tname, Cs).\n               concat\n                (map (\\<lambda>(C, params).\n                         [(as_string C, length params, as_string tname)])\n                  (sorted_list_of_fmap (constructors Cs)))))\n       (sorted_list_of_fmap C_info))", "apply (rule arg_cong[where f = concat])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>(tvs, tn, y).\n             map (\\<lambda>(conN, ts). (conN, length ts, TypeId (Short tn)))\n              y) \\<circ>\n         (\\<lambda>(name, dt_def).\n             (map as_string (tparams dt_def), as_string name,\n              map (\\<lambda>(C, params). (as_string C, map typ_to_t params))\n               (sorted_list_of_fmap (constructors dt_def)))))\n     (sorted_list_of_fmap C_info) =\n    map (map (map_prod id (map_prod id (TypeId \\<circ> Short))) \\<circ>\n         (\\<lambda>(tname, Cs).\n             concat\n              (map (\\<lambda>(C, params).\n                       [(as_string C, length params, as_string tname)])\n                (sorted_list_of_fmap (constructors Cs)))))\n     (sorted_list_of_fmap C_info)", "by (auto simp: map_concat comp_def split_beta)"], ["", "private"], ["", "lemmas evaluate_type =\n  evaluate_dec.dtype1[\n    where new_tdecs = cake_all_types and s = empty_state and mn = \"[]\" and tds = as_cake_type_def,\n    unfolded state_types_update env_types_update,\n    folded empty_sem_env_def]"], ["", "private"], ["", "lemma type_defs_to_new_tdecs:\n  \"type_defs_to_new_tdecs [] as_cake_type_def =\n    set (map (\\<lambda>name. TypeId (Short (as_string name))) (sorted_list_of_fset (fmdom C_info)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_defs_to_new_tdecs [] as_cake_type_def =\n    set (map (\\<lambda>name. TypeId (Short (as_string name)))\n          (sorted_list_of_fset (fmdom C_info)))", "unfolding cake_all_types_def type_defs_to_new_tdecs_def as_cake_type_def_def all_tdefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(tvs, tn, ctors). TypeId (mk_id [] tn))\n          (map (\\<lambda>(name, dt_def).\n                   (map as_string (tparams dt_def), as_string name,\n                    map (\\<lambda>(C, params).\n                            (as_string C, map typ_to_t params))\n                     (sorted_list_of_fmap (constructors dt_def))))\n            (sorted_list_of_fmap C_info))) =\n    set (map (\\<lambda>name. TypeId (Short (as_string name)))\n          (sorted_list_of_fset (fmdom C_info)))", "by (simp add: case_prod_twice sorted_list_of_fmap_def)"], ["", "private"], ["", "lemma cakeml_convoluted1: \"foldr (\\<lambda>(n, ts). (#) n) ys xs = map fst ys @ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(n, ts). (#) n) ys xs = map fst ys @ xs", "(* thanks Scott *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(n, ts). (#) n) ys xs = map fst ys @ xs", "by (induction ys arbitrary: xs) auto"], ["", "private"], ["", "lemma cakeml_convoluted2: \"foldr (\\<lambda>x y. f x @ y) xs ys = concat (map f xs) @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (@) (f x)) xs ys = concat (map f xs) @ ys", "(* thanks again *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (@) (f x)) xs ys = concat (map f xs) @ ys", "by (induction xs arbitrary: ys) auto"], ["", "private"], ["", "lemma check_dup_ctors_alt_def: \"check_dup_ctors tds \\<longleftrightarrow> distinct (tds \\<bind> (\\<lambda>(_, _, cons). map fst cons))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_dup_ctors tds =\n    distinct (tds \\<bind> (\\<lambda>(uu_, uu_, cons). map fst cons))", "unfolding check_dup_ctors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct\n     (HOL.Let []\n       (foldr\n         (\\<lambda>(tvs, tn, y).\n             foldr (\\<lambda>(n, ts) x2. if True then n # x2 else x2) y)\n         tds)) =\n    distinct (tds \\<bind> (\\<lambda>(uu_, uu_, cons). map fst cons))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (foldr (\\<lambda>(tvs, tn, y). foldr (\\<lambda>(n, ts). (#) n) y) tds\n       []) =\n    distinct (tds \\<bind> (\\<lambda>(uu_, uu_, cons). map fst cons))", "apply (rule arg_cong[where f = distinct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(tvs, tn, y). foldr (\\<lambda>(n, ts). (#) n) y) tds\n     [] =\n    tds \\<bind> (\\<lambda>(uu_, uu_, cons). map fst cons)", "apply (subst foldr_cong[OF refl refl, where g = \"\\<lambda>x a. map fst (snd (snd x)) @ a\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x.\n       x \\<in> set tds \\<Longrightarrow>\n       (case x of\n        (tvs, tn, xa) \\<Rightarrow> foldr (\\<lambda>(n, ts). (#) n) xa)\n        a =\n       map fst (snd (snd x)) @ a\n 2. foldr (\\<lambda>x. (@) (map fst (snd (snd x)))) tds [] =\n    tds \\<bind> (\\<lambda>(_, uu_, y). map fst y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set tds \\<Longrightarrow>\n    (case x_ of\n     (tvs, tn, xa) \\<Rightarrow> foldr (\\<lambda>(n, ts). (#) n) xa)\n     a_ =\n    map fst (snd (snd x_)) @ a_", "apply (subst split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set tds \\<Longrightarrow>\n    (case snd x_ of (tn, x) \\<Rightarrow> foldr (\\<lambda>(n, ts). (#) n) x)\n     a_ =\n    map fst (snd (snd x_)) @ a_", "apply (subst split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set tds \\<Longrightarrow>\n    foldr (\\<lambda>(n, ts). (#) n) (snd (snd x_)) a_ =\n    map fst (snd (snd x_)) @ a_", "by (rule cakeml_convoluted1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (@) (map fst (snd (snd x)))) tds [] =\n    tds \\<bind> (\\<lambda>(_, uu_, y). map fst y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (@) (map fst (snd (snd x)))) tds [] =\n    tds \\<bind> (\\<lambda>(_, uu_, y). map fst y)", "apply (subst cakeml_convoluted2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. map fst (snd (snd x))) tds) @ [] =\n    tds \\<bind> (\\<lambda>(_, uu_, y). map fst y)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. map fst (snd (snd x))) tds) =\n    tds \\<bind> (\\<lambda>(_, uu_, y). map fst y)", "unfolding List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. map fst (snd (snd x))) tds) =\n    concat (map (\\<lambda>(_, uu_, y). map fst y) tds)", "apply (rule arg_cong[where f = concat])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. map fst (snd (snd x))) tds =\n    map (\\<lambda>(_, uu_, y). map fst y) tds", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evaluate_dec_prelude:\n  \"evaluate_dec t [] env empty_state cake_dt_prelude (empty_state_with_types, Rval empty_sem_env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec t [] env empty_state cake_dt_prelude\n     (empty_state_with_types, Rval empty_sem_env)", "unfolding cake_dt_prelude_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec t [] env empty_state (Dtype empty_locs as_cake_type_def)\n     (empty_state_with_types, Rval empty_sem_env)", "proof (rule evaluate_type, intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. check_dup_ctors as_cake_type_def\n 2. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n 3. disjnt cake_all_types (defined_types empty_state)\n 4. allDistinct\n     (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n       as_cake_type_def)", "show \"check_dup_ctors as_cake_type_def\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_dup_ctors as_cake_type_def", "using distinct_ctr'"], ["proof (prove)\nusing this:\n  distinct (map as_string all_constructors)\n\ngoal (1 subgoal):\n 1. check_dup_ctors as_cake_type_def", "unfolding check_dup_ctors_alt_def List.bind_def as_cake_type_def_def all_constructors_def"], ["proof (prove)\nusing this:\n  distinct\n   (map as_string\n     (concat\n       (map (\\<lambda>(uu_, Cs).\n                map fst (sorted_list_of_fmap (constructors Cs)))\n         (sorted_list_of_fmap C_info))))\n\ngoal (1 subgoal):\n 1. distinct\n     (concat\n       (map (\\<lambda>(_, uu_, y). map fst y)\n         (map (\\<lambda>(name, dt_def).\n                  (map as_string (tparams dt_def), as_string name,\n                   map (\\<lambda>(C, params).\n                           (as_string C, map typ_to_t params))\n                    (sorted_list_of_fmap (constructors dt_def))))\n           (sorted_list_of_fmap C_info))))", "by (auto simp: comp_def split_beta map_concat)"], ["proof (state)\nthis:\n  check_dup_ctors as_cake_type_def\n\ngoal (3 subgoals):\n 1. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n 2. disjnt cake_all_types (defined_types empty_state)\n 3. allDistinct\n     (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n       as_cake_type_def)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n 2. disjnt cake_all_types (defined_types empty_state)\n 3. allDistinct\n     (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n       as_cake_type_def)", "show \"allDistinct (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn) as_cake_type_def)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct\n     (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n       as_cake_type_def)", "unfolding all_distinct_alt_def as_cake_type_def_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n       (map (\\<lambda>(name, dt_def).\n                (map as_string (tparams dt_def), as_string name,\n                 map (\\<lambda>(C, params).\n                         (as_string C, map typ_to_t params))\n                  (sorted_list_of_fmap (constructors dt_def))))\n         (sorted_list_of_fmap C_info)))", "apply (auto simp: comp_def case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x.\n              case x of (name, dt_def) \\<Rightarrow> as_string name)\n       (sorted_list_of_fmap C_info))", "apply (rule name_as_string.fst_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (sorted_list_of_fmap C_info))", "unfolding sorted_list_of_fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>k. (k, option.the (fmlookup C_info k)))\n         (sorted_list_of_fset (fmdom C_info))))", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  allDistinct\n   (map (\\<lambda>x. case x of (tvs, tn, ctors) \\<Rightarrow> tn)\n     as_cake_type_def)\n\ngoal (2 subgoals):\n 1. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n 2. disjnt cake_all_types (defined_types empty_state)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n 2. disjnt cake_all_types (defined_types empty_state)", "show \"cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def", "unfolding cake_all_types_def type_defs_to_new_tdecs all_tdefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (TypeId \\<circ> Short \\<circ> as_string) ` fset (fmdom C_info) =\n    set (map (\\<lambda>name. TypeId (Short (as_string name)))\n          (sorted_list_of_fset (fmdom C_info)))", "by simp"], ["proof (state)\nthis:\n  cake_all_types = type_defs_to_new_tdecs [] as_cake_type_def\n\ngoal (1 subgoal):\n 1. disjnt cake_all_types (defined_types empty_state)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. disjnt cake_all_types (defined_types empty_state)", "show \"disjnt cake_all_types (defined_types empty_state)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt cake_all_types (defined_types empty_state)", "unfolding empty_state_def disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cake_all_types \\<inter>\n    defined_types (make_state 0 [] empty_ffi_state {} {}) =\n    {}", "by simp"], ["proof (state)\nthis:\n  disjnt cake_all_types (defined_types empty_state)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "text \\<open>Computability\\<close>"], ["", "declare constructors.as_static_cenv_def[code]"], ["", "declare constructors.as_cake_type_def_def[code]"], ["", "declare constructors.cake_dt_prelude_def[code]"], ["", "export_code constructors.as_static_cenv constructors.cake_dt_prelude\n  checking Scala"], ["", "end"]]}