{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/CupCakeML/CupCake_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma cupcake_nsLookup_eq[simp]: \"nsLookup ns (Short n) = cupcake_nsLookup ns n\"", "lemma cupcake_match_resultE:\n  assumes \"cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\"\n  obtains init rest\n    where \"pes = init @ (p, e) # rest\"\n      and \"distinct (pat_bindings p [])\"\n      and \"list_all (\\<lambda>(p, e). cupcake_pmatch cenv p v0 [] = No_match \\<and> distinct (pat_bindings p [])) init\"\n      and \"cupcake_pmatch cenv p v0 [] = Match env'\"", "lemma cupcake_pmatch_eq:\n  \"is_cupcake_pat pat \\<Longrightarrow> pmatch_single envC s pat v0 env = cupcake_pmatch envC pat v0 env\"", "lemma cupcake_match_result_eq:\n  \"cupcake_clauses pes \\<Longrightarrow>\n    match_result env s v pes err_v =\n      map_result (\\<lambda>(e, _, env'). (e, env')) id (cupcake_match_result (c env) v pes err_v)\"", "lemma cupcake_nsBind_preserve:\n  \"is_cupcake_ns ns \\<Longrightarrow> is_cupcake_value v0 \\<Longrightarrow> is_cupcake_ns (nsBind k v0 ns)\"", "lemma cupcake_build_rec_preserve:\n  assumes \"is_cupcake_all_env cl_env\" \"is_cupcake_ns env\" \"list_all (\\<lambda>(_, _, e). is_cupcake_exp e) fs\"\n  shows \"is_cupcake_ns (build_rec_env fs cl_env env)\"", "lemma cupcake_v_update_preserve:\n  assumes \"is_cupcake_all_env env\" \"is_cupcake_ns (f (sem_env.v env))\"\n  shows \"is_cupcake_all_env (sem_env.update_v f env)\"", "lemma cupcake_nsAppend_preserve: \"is_cupcake_ns ns1 \\<Longrightarrow> is_cupcake_ns ns2 \\<Longrightarrow> is_cupcake_ns (nsAppend ns1 ns2)\"", "lemma cupcake_alist_to_ns_preserve: \"list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow> is_cupcake_ns (alist_to_ns env)\"", "lemma cupcake_opapp_preserve:\n  assumes \"do_opapp vs = Some (env, e)\" \"list_all is_cupcake_value vs\"\n  shows \"is_cupcake_all_env env\" \"is_cupcake_exp e\"", "lemma cup_pmatch_list_length_neq:\n  \"length vs \\<noteq> length ps \\<Longrightarrow> Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs m = Match_type_error\"", "lemma cup_pmatch_list_nomatch:\n  \"length vs = length ps \\<Longrightarrow>  Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs No_match = No_match\"", "lemma cup_pmatch_list_typerr:\n  \"length vs = length ps \\<Longrightarrow> Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs Match_type_error = Match_type_error\"", "lemma cupcake_pmatch_list_preserve:\n  assumes \" \\<And>p v env. p \\<in> set ps \\<and> v \\<in> set vs \\<longrightarrow> list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv p v env)\" \"list_all (is_cupcake_value \\<circ> snd) env\"\n  shows \"if_match (list_all (\\<lambda>a. is_cupcake_value (snd a))) (Matching.fold2\n            (\\<lambda>p v m. case m of\n               Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n            | m \\<Rightarrow> m)\n            Match_type_error ps vs (Match env))\"", "lemma cupcake_pmatch_preserve0:\n  \"is_cupcake_pat pat \\<Longrightarrow>\n    is_cupcake_value v0 \\<Longrightarrow>\n     list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n      cupcake_c_ns envC \\<Longrightarrow>\n       if_match (list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch envC pat v0 env)\"", "lemma cupcake_pmatch_preserve:\n  \"is_cupcake_pat pat \\<Longrightarrow>\n    is_cupcake_value v0 \\<Longrightarrow>\n     list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n      cupcake_c_ns envC \\<Longrightarrow>\n       cupcake_pmatch envC pat v0 env = Match env' \\<Longrightarrow>\n        list_all (is_cupcake_value \\<circ> snd) env'\"", "lemma cupcake_match_result_preserve:\n  \"cupcake_c_ns envC \\<Longrightarrow>\n    cupcake_clauses pes \\<Longrightarrow>\n      is_cupcake_value v \\<Longrightarrow>\n        if_rval (\\<lambda>(e, p, env'). is_cupcake_pat p \\<and> is_cupcake_exp e \\<and> list_all (is_cupcake_value \\<circ> snd) env')\n          (cupcake_match_result envC v pes err_v)\"", "lemma static_cenv_lookup:\n  assumes \"cupcake_nsLookup static_cenv i = Some (len, b)\"\n  obtains name where \"b = TypeId (Short name)\"", "lemma cupcake_build_conv_preserve:\n  fixes v\n  assumes \"list_all is_cupcake_value vs\" \"build_conv static_cenv (Some (Short i)) vs = Some v\"\n  shows \"is_cupcake_value v\"", "lemma cupcake_nsLookup_preserve:\n  assumes \"is_cupcake_ns ns\" \"nsLookup ns n = Some v0\"\n  shows \"is_cupcake_value v0\"", "lemma list_all2_shortcircuit_induct[consumes 1, case_names nil cons_val cons_err]:\n  assumes \"list_all2_shortcircuit P xs ys\"\n  assumes \"R [] []\"\n  assumes \"\\<And>x xs y ys. P x (Rval y) \\<Longrightarrow> list_all2_shortcircuit P xs ys \\<Longrightarrow> R xs ys \\<Longrightarrow> R (x # xs) (Rval y # ys)\"\n  assumes \"\\<And>x xs y ys. P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\"\n  shows \"R xs ys\"", "lemma list_all2_shortcircuit_mono[mono]:\n  assumes \"R \\<le> Q\"\n  shows \"list_all2_shortcircuit R \\<le> list_all2_shortcircuit Q\"", "lemma list_all2_shortcircuit_weaken: \"list_all2_shortcircuit P xs ys \\<Longrightarrow> (\\<And>xs ys. P xs ys \\<Longrightarrow> Q xs ys) \\<Longrightarrow> list_all2_shortcircuit Q xs ys\"", "lemma list_all2_shortcircuit_rval[simp]:\n  \"list_all2_shortcircuit P xs (map Rval ys) \\<longleftrightarrow> list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma cupcake_list_preserve0:\n  \"list_all2_shortcircuit\n     (\\<lambda>e r. cupcake_evaluate_single env e r \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> if_rval is_cupcake_value r)) es rs \\<Longrightarrow>\n  is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es \\<Longrightarrow> sequence_result rs = Rval vs \\<Longrightarrow> list_all is_cupcake_value vs\"", "lemma cupcake_single_preserve0:\n  \"cupcake_evaluate_single env e res \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> if_rval is_cupcake_value res\"", "lemma cupcake_single_preserve:\n  \"cupcake_evaluate_single env e (Rval res) \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> is_cupcake_value res\"", "lemma cupcake_list_preserve:\n  \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<Longrightarrow>\n  is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es \\<Longrightarrow> sequence_result rs = Rval vs \\<Longrightarrow> list_all is_cupcake_value vs\"", "lemma cupcake_list_correct_rval:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\" \"sequence_result rs = Rval vs\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',Rval vs)\"", "lemma cupcake_list_correct_rerr:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\" \"sequence_result rs = Rerr err\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',Rerr err)\"", "lemma cupcake_list_correct0:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',sequence_result rs)\"", "lemma cupcake_single_correct:\n  assumes \"cupcake_evaluate_single env e res\" \"is_cupcake_all_env env\" \"is_cupcake_exp e\"\n  shows \"\\<exists>s'. Big_Step_Unclocked_Single.evaluate env s e (s',res)\"", "lemma cupcake_list_correct:\n  assumes \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',sequence_result rs)\"", "lemma cupcake_list_complete0:\n  \"evaluate_list\n     (\\<lambda>s e r. evaluate env s e r \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> cupcake_evaluate_single env e (snd r))) s1 es res \\<Longrightarrow>\n    is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es  \\<Longrightarrow>  \\<exists>rs. list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<and> sequence_result rs = (snd res)\"", "lemma cupcake_single_complete0:\n\"evaluate env s e res \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> cupcake_evaluate_single env e (snd res)\"", "lemma cupcake_single_complete:\n  \"evaluate env s e (s', res) \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> cupcake_evaluate_single env e res\"", "lemma cupcake_list_complete:\n  \"evaluate_list (evaluate env) s1 es res \\<Longrightarrow>\n    is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es  \\<Longrightarrow>  \\<exists>rs. list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<and> sequence_result rs = (snd res)\"", "lemma cupcake_list_state_preserve0:\n  assumes \"evaluate_list (\\<lambda>s e res. Big_Step_Unclocked_Single.evaluate env s e res \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> s = fst res)) s es res\"\n          \"list_all is_cupcake_exp es\" \"is_cupcake_all_env env\"\n        shows \"s = (fst res)\"", "lemma cupcake_state_preserve:\n  assumes \"Big_Step_Unclocked_Single.evaluate env s e res\" \"is_cupcake_all_env env\" \"is_cupcake_exp e\"\n  shows \"s = (fst res)\""], "translations": [["", "lemma cupcake_nsLookup_eq[simp]: \"nsLookup ns (Short n) = cupcake_nsLookup ns n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nsLookup ns (Short n) = cupcake_nsLookup ns n", "by (cases ns) auto"], ["", "fun cupcake_pmatch :: \"((string),(string),(nat*tid_or_exn))namespace \\<Rightarrow> pat \\<Rightarrow> v \\<Rightarrow>(string*v)list \\<Rightarrow>((string*v)list)match_result \" where\n\"cupcake_pmatch cenv (Pvar x) v0 env = Match ((x, v0)# env)\" |\n\"cupcake_pmatch cenv (Pcon (Some (Short n)) ps) (Conv (Some (n', t')) vs) env =\n  (case cupcake_nsLookup cenv n of\n      Some (l, t)=>\n        if same_tid t t' \\<and> (List.length ps = l) then\n          if same_ctor (n, t) (n',t') then\n            Matching.fold2 (\\<lambda>p v m. case m of\n               Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n            | m \\<Rightarrow> m) Match_type_error ps vs (Match env)\n          else\n            No_match\n        else\n          Match_type_error\n    | _ => Match_type_error)\" |\n\"cupcake_pmatch cenv _ _ _ = Match_type_error\""], ["", "fun cupcake_match_result :: \"_ \\<Rightarrow> v \\<Rightarrow>(pat*exp)list \\<Rightarrow> v \\<Rightarrow> (exp \\<times> pat \\<times> (char list \\<times> v) list, v)result\" where\n\"cupcake_match_result _ _ [] err_v = Rerr (Rraise err_v)\" |\n\"cupcake_match_result cenv v0 ((p, e) # pes) err_v =\n  (if distinct (pat_bindings p []) then\n    (case cupcake_pmatch cenv p v0 [] of\n      Match env' \\<Rightarrow> Rval (e, p, env') |\n      No_match \\<Rightarrow> cupcake_match_result cenv v0 pes err_v |\n      Match_type_error \\<Rightarrow> Rerr (Rabort Rtype_error))\n   else\n      Rerr (Rabort Rtype_error))\""], ["", "lemma cupcake_match_resultE:\n  assumes \"cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\"\n  obtains init rest\n    where \"pes = init @ (p, e) # rest\"\n      and \"distinct (pat_bindings p [])\"\n      and \"list_all (\\<lambda>(p, e). cupcake_pmatch cenv p v0 [] = No_match \\<and> distinct (pat_bindings p [])) init\"\n      and \"cupcake_pmatch cenv p v0 [] = Match env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>init rest.\n        \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n         list_all\n          (\\<lambda>(p, e).\n              cupcake_pmatch cenv p v0 [] = No_match \\<and>\n              distinct (pat_bindings p []))\n          init;\n         cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\n\ngoal (1 subgoal):\n 1. (\\<And>init rest.\n        \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n         list_all\n          (\\<lambda>(p, e).\n              cupcake_pmatch cenv p v0 [] = No_match \\<and>\n              distinct (pat_bindings p []))\n          init;\n         cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction pes)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>init rest.\n                \\<lbrakk>[] = init @ (p, e) # rest;\n                 distinct (pat_bindings p []);\n                 list_all\n                  (\\<lambda>(p, e).\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                  init;\n                 cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cupcake_match_result cenv v0 [] err_v = Rval (e, p, env')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a pes.\n       \\<lbrakk>\\<lbrakk>\\<And>init rest.\n                            \\<lbrakk>pes = init @ (p, e) # rest;\n                             distinct (pat_bindings p []);\n                             list_all\n                              (\\<lambda>(p, e).\n                                  cupcake_pmatch cenv p v0 [] =\n                                  No_match \\<and>\n                                  distinct (pat_bindings p []))\n                              init;\n                             cupcake_pmatch cenv p v0 [] =\n                             Match env'\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 cupcake_match_result cenv v0 pes err_v =\n                 Rval (e, p, env')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>init rest.\n           \\<lbrakk>a # pes = init @ (p, e) # rest;\n            distinct (pat_bindings p []);\n            list_all\n             (\\<lambda>(p, e).\n                 cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                 distinct (pat_bindings p []))\n             init;\n            cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        cupcake_match_result cenv v0 (a # pes) err_v =\n        Rval (e, p, env')\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons pe pes)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>init rest.\n                \\<lbrakk>[] = init @ (p, e) # rest;\n                 distinct (pat_bindings p []);\n                 list_all\n                  (\\<lambda>(p, e).\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                  init;\n                 cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cupcake_match_result cenv v0 [] err_v = Rval (e, p, env')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a pes.\n       \\<lbrakk>\\<lbrakk>\\<And>init rest.\n                            \\<lbrakk>pes = init @ (p, e) # rest;\n                             distinct (pat_bindings p []);\n                             list_all\n                              (\\<lambda>(p, e).\n                                  cupcake_pmatch cenv p v0 [] =\n                                  No_match \\<and>\n                                  distinct (pat_bindings p []))\n                              init;\n                             cupcake_pmatch cenv p v0 [] =\n                             Match env'\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 cupcake_match_result cenv v0 pes err_v =\n                 Rval (e, p, env')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>init rest.\n           \\<lbrakk>a # pes = init @ (p, e) # rest;\n            distinct (pat_bindings p []);\n            list_all\n             (\\<lambda>(p, e).\n                 cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                 distinct (pat_bindings p []))\n             init;\n            cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        cupcake_match_result cenv v0 (a # pes) err_v =\n        Rval (e, p, env')\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain p0 e0 where \"pe = (p0, e0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p0 e0. pe = (p0, e0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  pe = (p0, e0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>init rest.\n                \\<lbrakk>[] = init @ (p, e) # rest;\n                 distinct (pat_bindings p []);\n                 list_all\n                  (\\<lambda>(p, e).\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                  init;\n                 cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cupcake_match_result cenv v0 [] err_v = Rval (e, p, env')\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a pes.\n       \\<lbrakk>\\<lbrakk>\\<And>init rest.\n                            \\<lbrakk>pes = init @ (p, e) # rest;\n                             distinct (pat_bindings p []);\n                             list_all\n                              (\\<lambda>(p, e).\n                                  cupcake_pmatch cenv p v0 [] =\n                                  No_match \\<and>\n                                  distinct (pat_bindings p []))\n                              init;\n                             cupcake_pmatch cenv p v0 [] =\n                             Match env'\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 cupcake_match_result cenv v0 pes err_v =\n                 Rval (e, p, env')\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>init rest.\n           \\<lbrakk>a # pes = init @ (p, e) # rest;\n            distinct (pat_bindings p []);\n            list_all\n             (\\<lambda>(p, e).\n                 cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                 distinct (pat_bindings p []))\n             init;\n            cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        cupcake_match_result cenv v0 (a # pes) err_v =\n        Rval (e, p, env')\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"distinct (pat_bindings p0 [])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (pat_bindings p0 []) \\<Longrightarrow> thesis\n 2. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  distinct (pat_bindings p0 [])\n\ngoal (2 subgoals):\n 1. distinct (pat_bindings p0 []) \\<Longrightarrow> thesis\n 2. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"cupcake_pmatch cenv p0 v0 []\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>distinct (pat_bindings p0 []);\n        cupcake_pmatch cenv p0 v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "case No_match"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p0 v0 [] = No_match\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = No_match\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>distinct (pat_bindings p0 []);\n        cupcake_pmatch cenv p0 v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule Cons)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "fix init rest"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "assume \"pes = init @ (p, e) # rest\""], ["proof (state)\nthis:\n  pes = init @ (p, e) # rest\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "assume \"list_all (\\<lambda>(p, e). cupcake_pmatch cenv p v0 [] = No_match \\<and> distinct (pat_bindings p [])) init\""], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   init\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "assume \"distinct (pat_bindings p [])\""], ["proof (state)\nthis:\n  distinct (pat_bindings p [])\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "assume \"cupcake_pmatch cenv p v0 [] = Match env'\""], ["proof (state)\nthis:\n  cupcake_pmatch cenv p v0 [] = Match env'\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "moreover"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p v0 [] = Match env'\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "have \"pe # pes = ((p0, e0) # init) @ (p, e) # rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pe # pes = ((p0, e0) # init) @ (p, e) # rest", "unfolding \\<open>pes = _\\<close> \\<open>pe = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p0, e0) # init @ (p, e) # rest = ((p0, e0) # init) @ (p, e) # rest", "by simp"], ["proof (state)\nthis:\n  pe # pes = ((p0, e0) # init) @ (p, e) # rest\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "moreover"], ["proof (state)\nthis:\n  pe # pes = ((p0, e0) # init) @ (p, e) # rest\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "have \"list_all (\\<lambda>(p, e). cupcake_pmatch cenv p v0 [] = No_match \\<and> distinct (pat_bindings p [])) ((p0, e0) # init)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     ((p0, e0) # init)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. cupcake_pmatch cenv p0 v0 [] = No_match\n 2. distinct (pat_bindings p0 [])\n 3. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     init", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_pmatch cenv p0 v0 [] = No_match", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (pat_bindings p0 [])\n 2. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     init", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (pat_bindings p0 [])", "using True"], ["proof (prove)\nusing this:\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. distinct (pat_bindings p0 [])", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     init", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     init", "using \\<open>list_all _ _\\<close>"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   init\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(p, e).\n         cupcake_pmatch cenv p v0 [] = No_match \\<and>\n         distinct (pat_bindings p []))\n     init", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   ((p0, e0) # init)\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "moreover"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   ((p0, e0) # init)\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "have \"distinct (pat_bindings p [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (pat_bindings p [])", "by fact"], ["proof (state)\nthis:\n  distinct (pat_bindings p [])\n\ngoal (2 subgoals):\n 1. \\<And>init rest.\n       \\<lbrakk>pes = init @ (p, e) # rest; distinct (pat_bindings p []);\n        list_all\n         (\\<lambda>a.\n             case a of\n             (p, e) \\<Rightarrow>\n               cupcake_pmatch cenv p v0 [] = No_match \\<and>\n               distinct (pat_bindings p []))\n         init;\n        cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "ultimately"], ["proof (chain)\npicking this:\n  cupcake_pmatch cenv p v0 [] = Match env'\n  pe # pes = ((p0, e0) # init) @ (p, e) # rest\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   ((p0, e0) # init)\n  distinct (pat_bindings p [])", "show thesis"], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v0 [] = Match env'\n  pe # pes = ((p0, e0) # init) @ (p, e) # rest\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   ((p0, e0) # init)\n  distinct (pat_bindings p [])\n\ngoal (1 subgoal):\n 1. thesis", "using Cons"], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v0 [] = Match env'\n  pe # pes = ((p0, e0) # init) @ (p, e) # rest\n  list_all\n   (\\<lambda>(p, e).\n       cupcake_pmatch cenv p v0 [] = No_match \\<and>\n       distinct (pat_bindings p []))\n   ((p0, e0) # init)\n  distinct (pat_bindings p [])\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "show \"cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "using Cons No_match True"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = No_match\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "unfolding \\<open>pe = _\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(p0, e0) # pes = ?init @ (p, e) # ?rest;\n   distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 ((p0, e0) # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = No_match\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')", "by auto"], ["proof (state)\nthis:\n  cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>distinct (pat_bindings p0 []);\n        cupcake_pmatch cenv p0 v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>distinct (pat_bindings p0 []);\n        cupcake_pmatch cenv p0 v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Match"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p0 v0 [] = Match x3_\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>distinct (pat_bindings p0 []);\n        cupcake_pmatch cenv p0 v0 [] = Match x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match x3_", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match x3_\n\ngoal (1 subgoal):\n 1. thesis", "using True"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match x3_\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. thesis", "unfolding \\<open>pe = _\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(p0, e0) # pes = ?init @ (p, e) # ?rest;\n   distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 ((p0, e0) # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match x3_\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis", "case Match_type_error"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p0 v0 [] = Match_type_error\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (pat_bindings p0 []);\n     cupcake_pmatch cenv p0 v0 [] = Match_type_error\\<rbrakk>\n    \\<Longrightarrow> thesis", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match_type_error", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match_type_error\n\ngoal (1 subgoal):\n 1. thesis", "using True"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match_type_error\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. thesis", "unfolding \\<open>pe = _\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(p0, e0) # pes = ?init @ (p, e) # ?rest;\n   distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 ((p0, e0) # pes) err_v = Rval (e, p, env')\n  cupcake_pmatch cenv p0 v0 [] = Match_type_error\n  distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. thesis", "by force"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "hence False"], ["proof (prove)\nusing this:\n  \\<not> distinct (pat_bindings p0 [])\n\ngoal (1 subgoal):\n 1. False", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> distinct (pat_bindings p0 [])\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>pe # pes = ?init @ (p, e) # ?rest; distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 (pe # pes) err_v = Rval (e, p, env')\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>pe = _\\<close>"], ["proof (prove)\nusing this:\n  \\<not> distinct (pat_bindings p0 [])\n  \\<lbrakk>\\<And>init rest.\n              \\<lbrakk>pes = init @ (p, e) # rest;\n               distinct (pat_bindings p []);\n               list_all\n                (\\<lambda>a.\n                    case a of\n                    (p, e) \\<Rightarrow>\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                init;\n               cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(p0, e0) # pes = ?init @ (p, e) # ?rest;\n   distinct (pat_bindings p []);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (p, e) \\<Rightarrow>\n          cupcake_pmatch cenv p v0 [] = No_match \\<and>\n          distinct (pat_bindings p []))\n    ?init;\n   cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  cupcake_match_result cenv v0 ((p0, e0) # pes) err_v = Rval (e, p, env')\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pat_bindings p0 []) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>init rest.\n                \\<lbrakk>[] = init @ (p, e) # rest;\n                 distinct (pat_bindings p []);\n                 list_all\n                  (\\<lambda>(p, e).\n                      cupcake_pmatch cenv p v0 [] = No_match \\<and>\n                      distinct (pat_bindings p []))\n                  init;\n                 cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cupcake_match_result cenv v0 [] err_v = Rval (e, p, env')\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed simp"], ["", "lemma cupcake_pmatch_eq:\n  \"is_cupcake_pat pat \\<Longrightarrow> pmatch_single envC s pat v0 env = cupcake_pmatch envC pat v0 env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_pat pat \\<Longrightarrow>\n    pmatch_single envC s pat v0 env = cupcake_pmatch envC pat v0 env", "proof (induct rule: pmatch_single.induct)"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>envC s v' env.\n       is_cupcake_pat Pany \\<Longrightarrow>\n       pmatch_single envC s Pany v' env = cupcake_pmatch envC Pany v' env\n 2. \\<And>envC s x v' env.\n       is_cupcake_pat (Pvar x) \\<Longrightarrow>\n       pmatch_single envC s (Pvar x) v' env =\n       cupcake_pmatch envC (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       is_cupcake_pat (Plit l) \\<Longrightarrow>\n       pmatch_single envC s (Plit l) (Litv l') env =\n       cupcake_pmatch envC (Plit l) (Litv l') env\n 4. \\<And>envC s n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>nsLookup envC n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (id_to_n n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3;\n                    is_cupcake_pat xa\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s xa ya x3 =\n                                     cupcake_pmatch envC xa ya x3;\n        is_cupcake_pat (Pcon (Some n) ps)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pcon (Some n) ps)\n                          (Conv (Some (n', t')) vs) env =\n                         cupcake_pmatch envC (Pcon (Some n) ps)\n                          (Conv (Some (n', t')) vs) env\n 5. \\<And>envC s ps vs env.\n       \\<lbrakk>\\<And>init x y x3.\n                   \\<lbrakk>length ps = length vs; x \\<in> set ps;\n                    y \\<in> set vs; init = Match x3;\n                    is_cupcake_pat x\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s x y x3 =\n                                     cupcake_pmatch envC x y x3;\n        is_cupcake_pat (Pcon None ps)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pcon None ps) (Conv None vs)\n                          env =\n                         cupcake_pmatch envC (Pcon None ps) (Conv None vs)\n                          env\n 6. \\<And>envC s p lnum env.\n       \\<lbrakk>\\<And>x2 x1.\n                   \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1;\n                    is_cupcake_pat p\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s p x1 env =\n                                     cupcake_pmatch envC p x1 env;\n        is_cupcake_pat (Pref p)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pref p) (Loc lnum) env =\n                         cupcake_pmatch envC (Pref p) (Loc lnum) env\n 7. \\<And>envC s p t1 v2 env.\n       \\<lbrakk>is_cupcake_pat p \\<Longrightarrow>\n                pmatch_single envC s p v2 env =\n                cupcake_pmatch envC p v2 env;\n        is_cupcake_pat (Ptannot p t1)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Ptannot p t1) v2 env =\n                         cupcake_pmatch envC (Ptannot p t1) v2 env\n 8. \\<And>envC uu_ v va vb env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env =\n       cupcake_pmatch envC (Plit v) (Conv va vb) env\n 9. \\<And>envC uu_ v va vb vc env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env =\n       cupcake_pmatch envC (Plit v) (Closure va vb vc) env\n 10. \\<And>envC uu_ v va vb vc env.\n        is_cupcake_pat (Plit v) \\<Longrightarrow>\n        pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env =\n        cupcake_pmatch envC (Plit v) (Recclosure va vb vc) env\nA total of 29 subgoals...", "case 4"], ["proof (state)\nthis:\n  \\<lbrakk>nsLookup envC_ n_ = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t'_ \\<and> length ps_ = ?x;\n   same_ctor (id_to_n n_, ?y) (n'_, t'_); ?xa \\<in> set ps_;\n   ?ya \\<in> set vs_; ?init = Match ?x3.0; is_cupcake_pat ?xa\\<rbrakk>\n  \\<Longrightarrow> pmatch_single envC_ s_ ?xa ?ya ?x3.0 =\n                    cupcake_pmatch envC_ ?xa ?ya ?x3.0\n  is_cupcake_pat (Pcon (Some n_) ps_)\n\ngoal (29 subgoals):\n 1. \\<And>envC s v' env.\n       is_cupcake_pat Pany \\<Longrightarrow>\n       pmatch_single envC s Pany v' env = cupcake_pmatch envC Pany v' env\n 2. \\<And>envC s x v' env.\n       is_cupcake_pat (Pvar x) \\<Longrightarrow>\n       pmatch_single envC s (Pvar x) v' env =\n       cupcake_pmatch envC (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       is_cupcake_pat (Plit l) \\<Longrightarrow>\n       pmatch_single envC s (Plit l) (Litv l') env =\n       cupcake_pmatch envC (Plit l) (Litv l') env\n 4. \\<And>envC s n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>nsLookup envC n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (id_to_n n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3;\n                    is_cupcake_pat xa\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s xa ya x3 =\n                                     cupcake_pmatch envC xa ya x3;\n        is_cupcake_pat (Pcon (Some n) ps)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pcon (Some n) ps)\n                          (Conv (Some (n', t')) vs) env =\n                         cupcake_pmatch envC (Pcon (Some n) ps)\n                          (Conv (Some (n', t')) vs) env\n 5. \\<And>envC s ps vs env.\n       \\<lbrakk>\\<And>init x y x3.\n                   \\<lbrakk>length ps = length vs; x \\<in> set ps;\n                    y \\<in> set vs; init = Match x3;\n                    is_cupcake_pat x\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s x y x3 =\n                                     cupcake_pmatch envC x y x3;\n        is_cupcake_pat (Pcon None ps)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pcon None ps) (Conv None vs)\n                          env =\n                         cupcake_pmatch envC (Pcon None ps) (Conv None vs)\n                          env\n 6. \\<And>envC s p lnum env.\n       \\<lbrakk>\\<And>x2 x1.\n                   \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1;\n                    is_cupcake_pat p\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s p x1 env =\n                                     cupcake_pmatch envC p x1 env;\n        is_cupcake_pat (Pref p)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pref p) (Loc lnum) env =\n                         cupcake_pmatch envC (Pref p) (Loc lnum) env\n 7. \\<And>envC s p t1 v2 env.\n       \\<lbrakk>is_cupcake_pat p \\<Longrightarrow>\n                pmatch_single envC s p v2 env =\n                cupcake_pmatch envC p v2 env;\n        is_cupcake_pat (Ptannot p t1)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Ptannot p t1) v2 env =\n                         cupcake_pmatch envC (Ptannot p t1) v2 env\n 8. \\<And>envC uu_ v va vb env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env =\n       cupcake_pmatch envC (Plit v) (Conv va vb) env\n 9. \\<And>envC uu_ v va vb vc env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env =\n       cupcake_pmatch envC (Plit v) (Closure va vb vc) env\n 10. \\<And>envC uu_ v va vb vc env.\n        is_cupcake_pat (Plit v) \\<Longrightarrow>\n        pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env =\n        cupcake_pmatch envC (Plit v) (Recclosure va vb vc) env\nA total of 29 subgoals...", "from is_cupcake_pat.elims(2)[OF 4(2)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>uu_. Pcon (Some n_) ps_ = Pvar uu_ \\<Longrightarrow> ?P;\n   \\<And>uv_ xs.\n      \\<lbrakk>Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs;\n       list_all is_cupcake_pat xs\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>uu_. Pcon (Some n_) ps_ = Pvar uu_ \\<Longrightarrow> ?P;\n   \\<And>uv_ xs.\n      \\<lbrakk>Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs;\n       list_all is_cupcake_pat xs\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. pmatch_single envC_ s_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_ =\n    cupcake_pmatch envC_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       Pcon (Some n_) ps_ = Pvar uu_ \\<Longrightarrow>\n       pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_ =\n       cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_\n 2. \\<And>uv_ xs.\n       \\<lbrakk>Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs;\n        list_all is_cupcake_pat xs\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n                          (Conv (Some (n'_, t'_)) vs_) env_ =\n                         cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n                          (Conv (Some (n'_, t'_)) vs_) env_", "case 2"], ["proof (state)\nthis:\n  Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs_\n  list_all is_cupcake_pat xs_\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       Pcon (Some n_) ps_ = Pvar uu_ \\<Longrightarrow>\n       pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_ =\n       cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_\n 2. \\<And>uv_ xs.\n       \\<lbrakk>Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs;\n        list_all is_cupcake_pat xs\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n                          (Conv (Some (n'_, t'_)) vs_) env_ =\n                         cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n                          (Conv (Some (n'_, t'_)) vs_) env_", "then"], ["proof (chain)\npicking this:\n  Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs_\n  list_all is_cupcake_pat xs_", "show ?thesis"], ["proof (prove)\nusing this:\n  Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs_\n  list_all is_cupcake_pat xs_\n\ngoal (1 subgoal):\n 1. pmatch_single envC_ s_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_ =\n    cupcake_pmatch envC_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_", "using 4(1)"], ["proof (prove)\nusing this:\n  Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs_\n  list_all is_cupcake_pat xs_\n  \\<lbrakk>nsLookup envC_ n_ = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t'_ \\<and> length ps_ = ?x;\n   same_ctor (id_to_n n_, ?y) (n'_, t'_); ?xa \\<in> set ps_;\n   ?ya \\<in> set vs_; ?init = Match ?x3.0; is_cupcake_pat ?xa\\<rbrakk>\n  \\<Longrightarrow> pmatch_single envC_ s_ ?xa ?ya ?x3.0 =\n                    cupcake_pmatch envC_ ?xa ?ya ?x3.0\n\ngoal (1 subgoal):\n 1. pmatch_single envC_ s_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_ =\n    cupcake_pmatch envC_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n     env_", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pcon (Some n_) ps_ = Pcon (Some (Short uv_)) xs_;\n     list_all is_cupcake_pat xs_;\n     \\<And>x2 x y xa ya init x3.\n        \\<lbrakk>nsLookup envC_ n_ = Some x2; (x, y) = x2;\n         same_tid y t'_ \\<and> length ps_ = x;\n         same_ctor (id_to_n n_, y) (n'_, t'_); xa \\<in> set ps_;\n         ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n        \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                          cupcake_pmatch envC_ xa ya x3\\<rbrakk>\n    \\<Longrightarrow> pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n                       (Conv (Some (n'_, t'_)) vs_) env_ =\n                      cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n                       (Conv (Some (n'_, t'_)) vs_) env_", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n_ = Short uv_ \\<and> ps_ = xs_; list_all is_cupcake_pat xs_;\n     \\<And>x2 y xa ya init x3.\n        \\<lbrakk>cupcake_nsLookup envC_ uv_ = Some x2; (length xs_, y) = x2;\n         same_tid y t'_; same_ctor (uv_, y) (n'_, t'_); xa \\<in> set xs_;\n         ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n        \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                          cupcake_pmatch envC_ xa ya x3\\<rbrakk>\n    \\<Longrightarrow> (case cupcake_nsLookup envC_ uv_ of\n                       None \\<Rightarrow> Match_type_error\n                       | Some (l, t1) \\<Rightarrow>\n                           if same_tid t1 t'_ \\<and> length xs_ = l\n                           then if same_ctor (id_to_n (Short uv_), t1)\n                                    (n'_, t'_)\n                                then Matching.fold2\n(\\<lambda>p v.\n    case_match_result No_match Match_type_error\n     (pmatch_single envC_ s_ p v))\nMatch_type_error xs_ vs_ (Match env_)\n                                else No_match\n                           else Match_type_error) =\n                      (case cupcake_nsLookup envC_ uv_ of\n                       None \\<Rightarrow> Match_type_error\n                       | Some (l, t) \\<Rightarrow>\n                           if same_tid t t'_ \\<and> length xs_ = l\n                           then if same_ctor (uv_, t) (n'_, t'_)\n                                then Matching.fold2\n(\\<lambda>p v.\n    case_match_result No_match Match_type_error (cupcake_pmatch envC_ p v))\nMatch_type_error xs_ vs_ (Match env_)\n                                else No_match\n                           else Match_type_error)", "apply (auto split: option.splits match_result.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_;\n        cupcake_nsLookup envC_ uv_ = Some (length xs_, b)\\<rbrakk>\n       \\<Longrightarrow> Matching.fold2\n                          (\\<lambda>p v.\n                              case_match_result No_match Match_type_error\n                               (pmatch_single envC_ s_ p v))\n                          Match_type_error xs_ vs_ (Match env_) =\n                         Matching.fold2\n                          (\\<lambda>p v.\n                              case_match_result No_match Match_type_error\n                               (cupcake_pmatch envC_ p v))\n                          Match_type_error xs_ vs_ (Match env_)", "apply (rule Matching.fold2_cong)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_;\n        cupcake_nsLookup envC_ uv_ = Some (length xs_, b)\\<rbrakk>\n       \\<Longrightarrow> Match env_ = Match env_\n 2. \\<And>b.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_;\n        cupcake_nsLookup envC_ uv_ = Some (length xs_, b)\\<rbrakk>\n       \\<Longrightarrow> Match_type_error = Match_type_error\n 3. \\<And>b.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_;\n        cupcake_nsLookup envC_ uv_ = Some (length xs_, b)\\<rbrakk>\n       \\<Longrightarrow> xs_ = xs_\n 4. \\<And>b.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_;\n        cupcake_nsLookup envC_ uv_ = Some (length xs_, b)\\<rbrakk>\n       \\<Longrightarrow> vs_ = vs_\n 5. \\<And>b init x y.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_; cupcake_nsLookup envC_ uv_ = Some (length xs_, b);\n        x \\<in> set xs_; y \\<in> set vs_\\<rbrakk>\n       \\<Longrightarrow> (case init of No_match \\<Rightarrow> No_match\n                          | Match_type_error \\<Rightarrow> Match_type_error\n                          | Match xa \\<Rightarrow>\n                              pmatch_single envC_ s_ x y xa) =\n                         (case init of No_match \\<Rightarrow> No_match\n                          | Match_type_error \\<Rightarrow> Match_type_error\n                          | Match xa \\<Rightarrow>\n                              cupcake_pmatch envC_ x y xa)", "apply (auto simp: fun_eq_iff split: match_result.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x y x3.\n       \\<lbrakk>list_all is_cupcake_pat xs_;\n        \\<And>a y xa ya init x3.\n           \\<lbrakk>length xs_ = a; y = b; xa \\<in> set xs_;\n            ya \\<in> set vs_; init = Match x3; is_cupcake_pat xa\\<rbrakk>\n           \\<Longrightarrow> pmatch_single envC_ s_ xa ya x3 =\n                             cupcake_pmatch envC_ xa ya x3;\n        n_ = Short uv_; ps_ = xs_; same_ctor (uv_, b) (n'_, t'_);\n        same_tid b t'_; cupcake_nsLookup envC_ uv_ = Some (length xs_, b);\n        x \\<in> set xs_; y \\<in> set vs_\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC_ s_ x y x3 =\n                         cupcake_pmatch envC_ x y x3", "apply (metis in_set_conv_decomp_last list.pred_inject(2) list_all_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pmatch_single envC_ s_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n   env_ =\n  cupcake_pmatch envC_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n   env_\n\ngoal (1 subgoal):\n 1. \\<And>uu_.\n       Pcon (Some n_) ps_ = Pvar uu_ \\<Longrightarrow>\n       pmatch_single envC_ s_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_ =\n       cupcake_pmatch envC_ (Pcon (Some n_) ps_)\n        (Conv (Some (n'_, t'_)) vs_) env_", "qed simp"], ["proof (state)\nthis:\n  pmatch_single envC_ s_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n   env_ =\n  cupcake_pmatch envC_ (Pcon (Some n_) ps_) (Conv (Some (n'_, t'_)) vs_)\n   env_\n\ngoal (28 subgoals):\n 1. \\<And>envC s v' env.\n       is_cupcake_pat Pany \\<Longrightarrow>\n       pmatch_single envC s Pany v' env = cupcake_pmatch envC Pany v' env\n 2. \\<And>envC s x v' env.\n       is_cupcake_pat (Pvar x) \\<Longrightarrow>\n       pmatch_single envC s (Pvar x) v' env =\n       cupcake_pmatch envC (Pvar x) v' env\n 3. \\<And>envC s l l' env.\n       is_cupcake_pat (Plit l) \\<Longrightarrow>\n       pmatch_single envC s (Plit l) (Litv l') env =\n       cupcake_pmatch envC (Plit l) (Litv l') env\n 4. \\<And>envC s ps vs env.\n       \\<lbrakk>\\<And>init x y x3.\n                   \\<lbrakk>length ps = length vs; x \\<in> set ps;\n                    y \\<in> set vs; init = Match x3;\n                    is_cupcake_pat x\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s x y x3 =\n                                     cupcake_pmatch envC x y x3;\n        is_cupcake_pat (Pcon None ps)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pcon None ps) (Conv None vs)\n                          env =\n                         cupcake_pmatch envC (Pcon None ps) (Conv None vs)\n                          env\n 5. \\<And>envC s p lnum env.\n       \\<lbrakk>\\<And>x2 x1.\n                   \\<lbrakk>store_lookup lnum s = Some x2; x2 = Refv x1;\n                    is_cupcake_pat p\\<rbrakk>\n                   \\<Longrightarrow> pmatch_single envC s p x1 env =\n                                     cupcake_pmatch envC p x1 env;\n        is_cupcake_pat (Pref p)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Pref p) (Loc lnum) env =\n                         cupcake_pmatch envC (Pref p) (Loc lnum) env\n 6. \\<And>envC s p t1 v2 env.\n       \\<lbrakk>is_cupcake_pat p \\<Longrightarrow>\n                pmatch_single envC s p v2 env =\n                cupcake_pmatch envC p v2 env;\n        is_cupcake_pat (Ptannot p t1)\\<rbrakk>\n       \\<Longrightarrow> pmatch_single envC s (Ptannot p t1) v2 env =\n                         cupcake_pmatch envC (Ptannot p t1) v2 env\n 7. \\<And>envC uu_ v va vb env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Conv va vb) env =\n       cupcake_pmatch envC (Plit v) (Conv va vb) env\n 8. \\<And>envC uu_ v va vb vc env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Closure va vb vc) env =\n       cupcake_pmatch envC (Plit v) (Closure va vb vc) env\n 9. \\<And>envC uu_ v va vb vc env.\n       is_cupcake_pat (Plit v) \\<Longrightarrow>\n       pmatch_single envC uu_ (Plit v) (Recclosure va vb vc) env =\n       cupcake_pmatch envC (Plit v) (Recclosure va vb vc) env\n 10. \\<And>envC uu_ v va env.\n        is_cupcake_pat (Plit v) \\<Longrightarrow>\n        pmatch_single envC uu_ (Plit v) (Loc va) env =\n        cupcake_pmatch envC (Plit v) (Loc va) env\nA total of 28 subgoals...", "qed auto"], ["", "lemma cupcake_match_result_eq:\n  \"cupcake_clauses pes \\<Longrightarrow>\n    match_result env s v pes err_v =\n      map_result (\\<lambda>(e, _, env'). (e, env')) id (cupcake_match_result (c env) v pes err_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_clauses pes \\<Longrightarrow>\n    match_result env s v pes err_v =\n    map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n     (cupcake_match_result (c env) v pes err_v)", "by (induction pes) (auto split: match_result.splits simp: cupcake_pmatch_eq pmatch_single_equiv)"], ["", "context cakeml_static_env begin"], ["", "lemma cupcake_nsBind_preserve:\n  \"is_cupcake_ns ns \\<Longrightarrow> is_cupcake_value v0 \\<Longrightarrow> is_cupcake_ns (nsBind k v0 ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_cupcake_ns ns; is_cupcake_value v0\\<rbrakk>\n    \\<Longrightarrow> is_cupcake_ns (nsBind k v0 ns)", "by (cases ns) (auto elim: is_cupcake_ns.elims)"], ["", "lemma cupcake_build_rec_preserve:\n  assumes \"is_cupcake_all_env cl_env\" \"is_cupcake_ns env\" \"list_all (\\<lambda>(_, _, e). is_cupcake_exp e) fs\"\n  shows \"is_cupcake_ns (build_rec_env fs cl_env env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (build_rec_env fs cl_env env)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cupcake_ns (build_rec_env fs cl_env env)", "have \"is_cupcake_ns (foldr (\\<lambda>(f, _) env'. nsBind f (Recclosure cl_env fs0 f) env') fs env)\"\n    if \"list_all (\\<lambda>(_, _, e). is_cupcake_exp e) fs0\"\n    for fs0"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns\n     (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) fs env)", "using \\<open>is_cupcake_ns env\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_ns env\n\ngoal (1 subgoal):\n 1. is_cupcake_ns\n     (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) fs env)", "proof (induction fs arbitrary: env)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env.\n       is_cupcake_ns env \\<Longrightarrow>\n       is_cupcake_ns\n        (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) []\n          env)\n 2. \\<And>a fs env.\n       \\<lbrakk>\\<And>env.\n                   is_cupcake_ns env \\<Longrightarrow>\n                   is_cupcake_ns\n                    (foldr\n                      (\\<lambda>(f, uu_).\n                          nsBind f (Recclosure cl_env fs0 f))\n                      fs env);\n        is_cupcake_ns env\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_ns\n                          (foldr\n                            (\\<lambda>(f, uu_).\n                                nsBind f (Recclosure cl_env fs0 f))\n                            (a # fs) env)", "case (Cons f fs)"], ["proof (state)\nthis:\n  is_cupcake_ns ?env \\<Longrightarrow>\n  is_cupcake_ns\n   (foldr\n     (\\<lambda>a.\n         case a of\n         (f, uu_) \\<Rightarrow> nsBind f (Recclosure cl_env fs0 f))\n     fs ?env)\n  is_cupcake_ns env\n\ngoal (2 subgoals):\n 1. \\<And>env.\n       is_cupcake_ns env \\<Longrightarrow>\n       is_cupcake_ns\n        (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) []\n          env)\n 2. \\<And>a fs env.\n       \\<lbrakk>\\<And>env.\n                   is_cupcake_ns env \\<Longrightarrow>\n                   is_cupcake_ns\n                    (foldr\n                      (\\<lambda>(f, uu_).\n                          nsBind f (Recclosure cl_env fs0 f))\n                      fs env);\n        is_cupcake_ns env\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_ns\n                          (foldr\n                            (\\<lambda>(f, uu_).\n                                nsBind f (Recclosure cl_env fs0 f))\n                            (a # fs) env)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns\n     (foldr\n       (\\<lambda>a.\n           case a of\n           (f, uu_) \\<Rightarrow> nsBind f (Recclosure cl_env fs0 f))\n       (f # fs) env)", "apply (cases f, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_ns\n        (nsBind a (Recclosure cl_env fs0 a)\n          (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) fs\n            env))", "apply (rule cupcake_nsBind_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_ns\n        (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) fs\n          env)\n 2. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_value (Recclosure cl_env fs0 a)", "apply (rule Cons.IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c. f = (a, b, c) \\<Longrightarrow> is_cupcake_ns env\n 2. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_value (Recclosure cl_env fs0 a)", "apply (rule Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_value (Recclosure cl_env fs0 a)", "using that assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e) fs0\n  is_cupcake_all_env cl_env\n  is_cupcake_ns env\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e) fs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       f = (a, b, c) \\<Longrightarrow>\n       is_cupcake_value (Recclosure cl_env fs0 a)", "by auto"], ["proof (state)\nthis:\n  is_cupcake_ns\n   (foldr\n     (\\<lambda>a.\n         case a of\n         (f, uu_) \\<Rightarrow> nsBind f (Recclosure cl_env fs0 f))\n     (f # fs) env)\n\ngoal (1 subgoal):\n 1. \\<And>env.\n       is_cupcake_ns env \\<Longrightarrow>\n       is_cupcake_ns\n        (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env fs0 f)) []\n          env)", "qed auto"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n   ?fs0.0 \\<Longrightarrow>\n  is_cupcake_ns\n   (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env ?fs0.0 f)) fs env)\n\ngoal (1 subgoal):\n 1. is_cupcake_ns (build_rec_env fs cl_env env)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n   ?fs0.0 \\<Longrightarrow>\n  is_cupcake_ns\n   (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env ?fs0.0 f)) fs env)\n\ngoal (1 subgoal):\n 1. is_cupcake_ns (build_rec_env fs cl_env env)", "unfolding build_rec_env_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n   ?fs0.0 \\<Longrightarrow>\n  is_cupcake_ns\n   (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env ?fs0.0 f)) fs env)\n\ngoal (1 subgoal):\n 1. is_cupcake_ns\n     (foldr (\\<lambda>(f, x, e). nsBind f (Recclosure cl_env fs f)) fs env)", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n   ?fs0.0 \\<Longrightarrow>\n  is_cupcake_ns\n   (foldr (\\<lambda>(f, uu_). nsBind f (Recclosure cl_env ?fs0.0 f)) fs env)\n  is_cupcake_all_env cl_env\n  is_cupcake_ns env\n  list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e) fs\n\ngoal (1 subgoal):\n 1. is_cupcake_ns\n     (foldr (\\<lambda>(f, x, e). nsBind f (Recclosure cl_env fs f)) fs env)", "by (simp add: cond_case_prod_eta)"], ["proof (state)\nthis:\n  is_cupcake_ns (build_rec_env fs cl_env env)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cupcake_v_update_preserve:\n  assumes \"is_cupcake_all_env env\" \"is_cupcake_ns (f (sem_env.v env))\"\n  shows \"is_cupcake_all_env (sem_env.update_v f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env (update_v f env)", "using assms"], ["proof (prove)\nusing this:\n  is_cupcake_all_env env\n  is_cupcake_ns (f (sem_env.v env))\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env (update_v f env)", "by (metis is_cupcake_all_env.simps(1) is_cupcake_all_envE is_cupcake_nsE sem_env.collapse sem_env.record_simps(1) sem_env.record_simps(2) sem_env.sel(2))"], ["", "lemma cupcake_nsAppend_preserve: \"is_cupcake_ns ns1 \\<Longrightarrow> is_cupcake_ns ns2 \\<Longrightarrow> is_cupcake_ns (nsAppend ns1 ns2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_cupcake_ns ns1; is_cupcake_ns ns2\\<rbrakk>\n    \\<Longrightarrow> is_cupcake_ns (nsAppend ns1 ns2)", "by (auto elim!: is_cupcake_ns.elims)"], ["", "lemma cupcake_alist_to_ns_preserve: \"list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow> is_cupcake_ns (alist_to_ns env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n    is_cupcake_ns (alist_to_ns env)", "unfolding alist_to_ns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n    is_cupcake_ns (Bind env [])", "by simp"], ["", "lemma cupcake_opapp_preserve:\n  assumes \"do_opapp vs = Some (env, e)\" \"list_all is_cupcake_value vs\"\n  shows \"is_cupcake_all_env env\" \"is_cupcake_exp e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env &&& is_cupcake_exp e", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_exp e", "obtain cl v0 where \"vs = [cl, v0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cl v0. vs = [cl, v0] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  do_opapp vs = Some (env, e)\n  list_all is_cupcake_value vs\n\ngoal (1 subgoal):\n 1. (\\<And>cl v0. vs = [cl, v0] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases vs rule: do_opapp.cases) auto"], ["proof (state)\nthis:\n  vs = [cl, v0]\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_exp e", "with assms"], ["proof (chain)\npicking this:\n  do_opapp vs = Some (env, e)\n  list_all is_cupcake_value vs\n  vs = [cl, v0]", "have \"is_cupcake_value cl\" \"is_cupcake_value v0\""], ["proof (prove)\nusing this:\n  do_opapp vs = Some (env, e)\n  list_all is_cupcake_value vs\n  vs = [cl, v0]\n\ngoal (1 subgoal):\n 1. is_cupcake_value cl &&& is_cupcake_value v0", "by auto"], ["proof (state)\nthis:\n  is_cupcake_value cl\n  is_cupcake_value v0\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_exp e", "have \"is_cupcake_all_env env \\<and> is_cupcake_exp e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "using \\<open>do_opapp vs = _\\<close>"], ["proof (prove)\nusing this:\n  do_opapp vs = Some (env, e)\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "proof (cases rule: do_opapp_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>enva n v0.\n       \\<lbrakk>vs = [Closure enva n e, v0];\n        env =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v enva)) enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e\n 2. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "case (closure env' n arg)"], ["proof (state)\nthis:\n  vs = [Closure env' n e, arg]\n  env = update_v (\\<lambda>_. nsBind n arg (sem_env.v env')) env'\n\ngoal (2 subgoals):\n 1. \\<And>enva n v0.\n       \\<lbrakk>vs = [Closure enva n e, v0];\n        env =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v enva)) enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e\n 2. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "then"], ["proof (chain)\npicking this:\n  vs = [Closure env' n e, arg]\n  env = update_v (\\<lambda>_. nsBind n arg (sem_env.v env')) env'", "show ?thesis"], ["proof (prove)\nusing this:\n  vs = [Closure env' n e, arg]\n  env = update_v (\\<lambda>_. nsBind n arg (sem_env.v env')) env'\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "using \\<open>is_cupcake_value cl\\<close> \\<open>is_cupcake_value v0\\<close> \\<open>vs = [cl, v0]\\<close>"], ["proof (prove)\nusing this:\n  vs = [Closure env' n e, arg]\n  env = update_v (\\<lambda>_. nsBind n arg (sem_env.v env')) env'\n  is_cupcake_value cl\n  is_cupcake_value v0\n  vs = [cl, v0]\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "by (auto intro: cupcake_v_update_preserve cupcake_nsBind_preserve dest:is_cupcake_all_envD(1))"], ["proof (state)\nthis:\n  is_cupcake_all_env env \\<and> is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "case (recclosure env' funs name n)"], ["proof (state)\nthis:\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "hence \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env'", "using \\<open>is_cupcake_value cl\\<close> \\<open>vs = [cl, v0]\\<close>"], ["proof (prove)\nusing this:\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n  is_cupcake_value cl\n  vs = [cl, v0]\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env'", "by simp"], ["proof (state)\nthis:\n  is_cupcake_all_env env'\n\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "have \"(name, n, e) \\<in> set funs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, n, e) \\<in> set funs", "using recclosure"], ["proof (prove)\nusing this:\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. (name, n, e) \\<in> set funs", "by (auto dest: map_of_SomeD)"], ["proof (state)\nthis:\n  (name, n, e) \\<in> set funs\n\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "hence \"is_cupcake_exp e\""], ["proof (prove)\nusing this:\n  (name, n, e) \\<in> set funs\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e", "using \\<open>is_cupcake_value cl\\<close> \\<open>vs = [cl, v0]\\<close> recclosure"], ["proof (prove)\nusing this:\n  (name, n, e) \\<in> set funs\n  is_cupcake_value cl\n  vs = [cl, v0]\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. \\<And>enva funs name n v0.\n       \\<lbrakk>vs = [Recclosure enva funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, e);\n        env =\n        update_v\n         (\\<lambda>_.\n             nsBind n v0 (build_rec_env funs enva (sem_env.v enva)))\n         enva\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_all_env env \\<and> is_cupcake_exp e", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "using \\<open>is_cupcake_all_env env'\\<close> \\<open>is_cupcake_value cl\\<close> \\<open>is_cupcake_value v0\\<close> \\<open>vs = [cl, v0]\\<close> recclosure"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  is_cupcake_value cl\n  is_cupcake_value v0\n  vs = [cl, v0]\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  env =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env \\<and> is_cupcake_exp e", "unfolding \\<open>env = _\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  is_cupcake_value cl\n  is_cupcake_value v0\n  vs = [cl, v0]\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env' =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v\n       (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n       env') \\<and>\n    is_cupcake_exp e", "using cupcake_build_rec_preserve cupcake_nsBind_preserve cupcake_v_update_preserve is_cupcake_all_envD(1)"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  is_cupcake_value cl\n  is_cupcake_value v0\n  vs = [cl, v0]\n  vs = [Recclosure env' funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, e)\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env' =\n  update_v\n   (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n   env'\n  \\<lbrakk>is_cupcake_all_env ?cl_env; is_cupcake_ns ?env;\n   list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e) ?fs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_ns (build_rec_env ?fs ?cl_env ?env)\n  \\<lbrakk>is_cupcake_ns ?ns; is_cupcake_value ?v0.0\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_ns (nsBind ?k ?v0.0 ?ns)\n  \\<lbrakk>is_cupcake_all_env ?env;\n   is_cupcake_ns (?f (sem_env.v ?env))\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_all_env (update_v ?f ?env)\n  is_cupcake_all_env ?env \\<Longrightarrow> is_cupcake_ns (sem_env.v ?env)\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v\n       (\\<lambda>_. nsBind n v0_ (build_rec_env funs env' (sem_env.v env')))\n       env') \\<and>\n    is_cupcake_exp e", "by auto"], ["proof (state)\nthis:\n  is_cupcake_all_env env \\<and> is_cupcake_exp e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_cupcake_all_env env \\<and> is_cupcake_exp e\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_exp e", "thus \"is_cupcake_all_env env\" \"is_cupcake_exp e\""], ["proof (prove)\nusing this:\n  is_cupcake_all_env env \\<and> is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env &&& is_cupcake_exp e", "by simp+"], ["proof (state)\nthis:\n  is_cupcake_all_env env\n  is_cupcake_exp e\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "lemma cup_pmatch_list_length_neq:\n  \"length vs \\<noteq> length ps \\<Longrightarrow> Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs m = Match_type_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs \\<noteq> length ps \\<Longrightarrow>\n    Matching.fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> cupcake_pmatch cenv p v env)\n     Match_type_error ps vs m =\n    Match_type_error", "by (induction ps vs arbitrary:m rule:List.list_induct2') auto"], ["", "lemma cup_pmatch_list_nomatch:\n  \"length vs = length ps \\<Longrightarrow>  Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs No_match = No_match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs = length ps \\<Longrightarrow>\n    Matching.fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> cupcake_pmatch cenv p v env)\n     Match_type_error ps vs No_match =\n    No_match", "by (induction ps vs  rule:List.list_induct2') auto"], ["", "lemma cup_pmatch_list_typerr:\n  \"length vs = length ps \\<Longrightarrow> Matching.fold2(\\<lambda>p v m. case m of\n       Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n        | m \\<Rightarrow> m) Match_type_error ps vs Match_type_error = Match_type_error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs = length ps \\<Longrightarrow>\n    Matching.fold2\n     (\\<lambda>p v m.\n         case m of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match env \\<Rightarrow> cupcake_pmatch cenv p v env)\n     Match_type_error ps vs Match_type_error =\n    Match_type_error", "by (induction ps vs  rule:List.list_induct2') auto"], ["", "private"], ["", "lemma cupcake_pmatch_list_preserve:\n  assumes \" \\<And>p v env. p \\<in> set ps \\<and> v \\<in> set vs \\<longrightarrow> list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv p v env)\" \"list_all (is_cupcake_value \\<circ> snd) env\"\n  shows \"if_match (list_all (\\<lambda>a. is_cupcake_value (snd a))) (Matching.fold2\n            (\\<lambda>p v m. case m of\n               Match env \\<Rightarrow> cupcake_pmatch cenv p v env\n            | m \\<Rightarrow> m)\n            Match_type_error ps vs (Match env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v m.\n           case m of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match env \\<Rightarrow> cupcake_pmatch cenv p v env)\n       Match_type_error ps vs (Match env))", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> set ps \\<and> ?v \\<in> set vs \\<longrightarrow>\n  list_all (is_cupcake_value \\<circ> snd) ?env \\<longrightarrow>\n  if_match (list_all (is_cupcake_value \\<circ> snd))\n   (cupcake_pmatch cenv ?p ?v ?env)\n  list_all (is_cupcake_value \\<circ> snd) env\n\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v m.\n           case m of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match env \\<Rightarrow> cupcake_pmatch cenv p v env)\n       Match_type_error ps vs (Match env))", "proof (induction ps vs arbitrary: env rule:list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and> v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] [] (Match env))\n 2. \\<And>x xs env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set (x # xs) \\<and>\n                   v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error (x # xs) [] (Match env))\n 3. \\<And>y ys env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and>\n                   v \\<in> set (y # ys) \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] (y # ys) (Match env))\n 4. \\<And>x xs y ys env.\n       \\<lbrakk>\\<And>env.\n                   \\<lbrakk>\\<And>p v env.\n                               p \\<in> set xs \\<and>\n                               v \\<in> set ys \\<longrightarrow>\n                               list_all (is_cupcake_value \\<circ> snd)\n                                env \\<longrightarrow>\n                               if_match\n                                (list_all (is_cupcake_value \\<circ> snd))\n                                (cupcake_pmatch cenv p v env);\n                    list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (\\<lambda>a. is_cupcake_value (snd a)))\n(Matching.fold2\n  (\\<lambda>p v.\n      case_match_result No_match Match_type_error (cupcake_pmatch cenv p v))\n  Match_type_error xs ys (Match env));\n        \\<And>p v env.\n           p \\<in> set (x # xs) \\<and>\n           v \\<in> set (y # ys) \\<longrightarrow>\n           list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow>\n           if_match (list_all (is_cupcake_value \\<circ> snd))\n            (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error (x # xs) (y # ys) (Match env))", "case (4 p ps v vs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p v env.\n              p \\<in> set ps \\<and> v \\<in> set vs \\<longrightarrow>\n              list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow>\n              if_match (list_all (is_cupcake_value \\<circ> snd))\n               (cupcake_pmatch cenv p v env);\n   list_all (is_cupcake_value \\<circ> snd) ?env\\<rbrakk>\n  \\<Longrightarrow> if_match\n                     (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                     (Matching.fold2\n                       (\\<lambda>p v a.\n                           case a of No_match \\<Rightarrow> No_match\n                           | Match_type_error \\<Rightarrow> Match_type_error\n                           | Match a \\<Rightarrow>\n                               cupcake_pmatch cenv p v a)\n                       Match_type_error ps vs (Match ?env))\n  ?p \\<in> set (p # ps) \\<and> ?v \\<in> set (v # vs) \\<longrightarrow>\n  list_all (is_cupcake_value \\<circ> snd) ?env \\<longrightarrow>\n  if_match (list_all (is_cupcake_value \\<circ> snd))\n   (cupcake_pmatch cenv ?p ?v ?env)\n  list_all (is_cupcake_value \\<circ> snd) env\n\ngoal (4 subgoals):\n 1. \\<And>env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and> v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] [] (Match env))\n 2. \\<And>x xs env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set (x # xs) \\<and>\n                   v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error (x # xs) [] (Match env))\n 3. \\<And>y ys env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and>\n                   v \\<in> set (y # ys) \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] (y # ys) (Match env))\n 4. \\<And>x xs y ys env.\n       \\<lbrakk>\\<And>env.\n                   \\<lbrakk>\\<And>p v env.\n                               p \\<in> set xs \\<and>\n                               v \\<in> set ys \\<longrightarrow>\n                               list_all (is_cupcake_value \\<circ> snd)\n                                env \\<longrightarrow>\n                               if_match\n                                (list_all (is_cupcake_value \\<circ> snd))\n                                (cupcake_pmatch cenv p v env);\n                    list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (\\<lambda>a. is_cupcake_value (snd a)))\n(Matching.fold2\n  (\\<lambda>p v.\n      case_match_result No_match Match_type_error (cupcake_pmatch cenv p v))\n  Match_type_error xs ys (Match env));\n        \\<And>p v env.\n           p \\<in> set (x # xs) \\<and>\n           v \\<in> set (y # ys) \\<longrightarrow>\n           list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow>\n           if_match (list_all (is_cupcake_value \\<circ> snd))\n            (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error (x # xs) (y # ys) (Match env))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))", "proof (cases \"cupcake_pmatch cenv p v env\")"], ["proof (state)\ngoal (3 subgoals):\n 1. cupcake_pmatch cenv p v env = No_match \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 2. cupcake_pmatch cenv p v env = Match_type_error \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 3. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "case No_match"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p v env = No_match\n\ngoal (3 subgoals):\n 1. cupcake_pmatch cenv p v env = No_match \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 2. cupcake_pmatch cenv p v env = Match_type_error \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 3. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "then"], ["proof (chain)\npicking this:\n  cupcake_pmatch cenv p v env = No_match", "show ?thesis"], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v env = No_match\n\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))", "by (cases \"length ps = length vs\") (auto simp:cup_pmatch_list_nomatch cup_pmatch_list_length_neq)"], ["proof (state)\nthis:\n  if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n   (Matching.fold2\n     (\\<lambda>p v a.\n         case a of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n     Match_type_error (p # ps) (v # vs) (Match env))\n\ngoal (2 subgoals):\n 1. cupcake_pmatch cenv p v env = Match_type_error \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 2. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cupcake_pmatch cenv p v env = Match_type_error \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 2. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "case Match_type_error"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p v env = Match_type_error\n\ngoal (2 subgoals):\n 1. cupcake_pmatch cenv p v env = Match_type_error \\<Longrightarrow>\n    if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))\n 2. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "then"], ["proof (chain)\npicking this:\n  cupcake_pmatch cenv p v env = Match_type_error", "show ?thesis"], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v env = Match_type_error\n\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))", "by (cases \"length ps = length vs\") (auto simp:cup_pmatch_list_typerr cup_pmatch_list_length_neq)"], ["proof (state)\nthis:\n  if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n   (Matching.fold2\n     (\\<lambda>p v a.\n         case a of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n     Match_type_error (p # ps) (v # vs) (Match env))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "case (Match env')"], ["proof (state)\nthis:\n  cupcake_pmatch cenv p v env = Match env'\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "then"], ["proof (chain)\npicking this:\n  cupcake_pmatch cenv p v env = Match env'", "have env': \"list_all (is_cupcake_value \\<circ> snd) env'\""], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v env = Match env'\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env'", "using 4"], ["proof (prove)\nusing this:\n  cupcake_pmatch cenv p v env = Match env'\n  \\<lbrakk>\\<And>p v env.\n              p \\<in> set ps \\<and> v \\<in> set vs \\<longrightarrow>\n              list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow>\n              if_match (list_all (is_cupcake_value \\<circ> snd))\n               (cupcake_pmatch cenv p v env);\n   list_all (is_cupcake_value \\<circ> snd) ?env\\<rbrakk>\n  \\<Longrightarrow> if_match\n                     (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                     (Matching.fold2\n                       (\\<lambda>p v a.\n                           case a of No_match \\<Rightarrow> No_match\n                           | Match_type_error \\<Rightarrow> Match_type_error\n                           | Match a \\<Rightarrow>\n                               cupcake_pmatch cenv p v a)\n                       Match_type_error ps vs (Match ?env))\n  ?p \\<in> set (p # ps) \\<and> ?v \\<in> set (v # vs) \\<longrightarrow>\n  list_all (is_cupcake_value \\<circ> snd) ?env \\<longrightarrow>\n  if_match (list_all (is_cupcake_value \\<circ> snd))\n   (cupcake_pmatch cenv ?p ?v ?env)\n  list_all (is_cupcake_value \\<circ> snd) env\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env'", "by fastforce"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       cupcake_pmatch cenv p v env = Match x3 \\<Longrightarrow>\n       if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n        (Matching.fold2\n          (\\<lambda>p v a.\n              case a of No_match \\<Rightarrow> No_match\n              | Match_type_error \\<Rightarrow> Match_type_error\n              | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n          Match_type_error (p # ps) (v # vs) (Match env))", "then"], ["proof (chain)\npicking this:\n  list_all (is_cupcake_value \\<circ> snd) env'", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (1 subgoal):\n 1. if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n     (Matching.fold2\n       (\\<lambda>p v a.\n           case a of No_match \\<Rightarrow> No_match\n           | Match_type_error \\<Rightarrow> Match_type_error\n           | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n       Match_type_error (p # ps) (v # vs) (Match env))", "apply (cases \"length ps = length vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) env';\n     length ps = length vs\\<rbrakk>\n    \\<Longrightarrow> if_match\n                       (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                       (Matching.fold2\n                         (\\<lambda>p v a.\n                             case a of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match a \\<Rightarrow>\n                                 cupcake_pmatch cenv p v a)\n                         Match_type_error (p # ps) (v # vs) (Match env))\n 2. \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) env';\n     length ps \\<noteq> length vs\\<rbrakk>\n    \\<Longrightarrow> if_match\n                       (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                       (Matching.fold2\n                         (\\<lambda>p v a.\n                             case a of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match a \\<Rightarrow>\n                                 cupcake_pmatch cenv p v a)\n                         Match_type_error (p # ps) (v # vs) (Match env))", "using 4 Match"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p v env.\n              p \\<in> set ps \\<and> v \\<in> set vs \\<longrightarrow>\n              list_all (is_cupcake_value \\<circ> snd) env \\<longrightarrow>\n              if_match (list_all (is_cupcake_value \\<circ> snd))\n               (cupcake_pmatch cenv p v env);\n   list_all (is_cupcake_value \\<circ> snd) ?env\\<rbrakk>\n  \\<Longrightarrow> if_match\n                     (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                     (Matching.fold2\n                       (\\<lambda>p v a.\n                           case a of No_match \\<Rightarrow> No_match\n                           | Match_type_error \\<Rightarrow> Match_type_error\n                           | Match a \\<Rightarrow>\n                               cupcake_pmatch cenv p v a)\n                       Match_type_error ps vs (Match ?env))\n  ?p \\<in> set (p # ps) \\<and> ?v \\<in> set (v # vs) \\<longrightarrow>\n  list_all (is_cupcake_value \\<circ> snd) ?env \\<longrightarrow>\n  if_match (list_all (is_cupcake_value \\<circ> snd))\n   (cupcake_pmatch cenv ?p ?v ?env)\n  list_all (is_cupcake_value \\<circ> snd) env\n  cupcake_pmatch cenv p v env = Match env'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) env';\n     length ps = length vs\\<rbrakk>\n    \\<Longrightarrow> if_match\n                       (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                       (Matching.fold2\n                         (\\<lambda>p v a.\n                             case a of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match a \\<Rightarrow>\n                                 cupcake_pmatch cenv p v a)\n                         Match_type_error (p # ps) (v # vs) (Match env))\n 2. \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) env';\n     length ps \\<noteq> length vs\\<rbrakk>\n    \\<Longrightarrow> if_match\n                       (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                       (Matching.fold2\n                         (\\<lambda>p v a.\n                             case a of No_match \\<Rightarrow> No_match\n                             | Match_type_error \\<Rightarrow>\n                                 Match_type_error\n                             | Match a \\<Rightarrow>\n                                 cupcake_pmatch cenv p v a)\n                         Match_type_error (p # ps) (v # vs) (Match env))", "by fastforce+"], ["proof (state)\nthis:\n  if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n   (Matching.fold2\n     (\\<lambda>p v a.\n         case a of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n     Match_type_error (p # ps) (v # vs) (Match env))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_match (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n   (Matching.fold2\n     (\\<lambda>p v a.\n         case a of No_match \\<Rightarrow> No_match\n         | Match_type_error \\<Rightarrow> Match_type_error\n         | Match a \\<Rightarrow> cupcake_pmatch cenv p v a)\n     Match_type_error (p # ps) (v # vs) (Match env))\n\ngoal (3 subgoals):\n 1. \\<And>env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and> v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] [] (Match env))\n 2. \\<And>x xs env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set (x # xs) \\<and>\n                   v \\<in> set [] \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error (x # xs) [] (Match env))\n 3. \\<And>y ys env.\n       \\<lbrakk>\\<And>p v env.\n                   p \\<in> set [] \\<and>\n                   v \\<in> set (y # ys) \\<longrightarrow>\n                   list_all (is_cupcake_value \\<circ> snd)\n                    env \\<longrightarrow>\n                   if_match (list_all (is_cupcake_value \\<circ> snd))\n                    (cupcake_pmatch cenv p v env);\n        list_all (is_cupcake_value \\<circ> snd) env\\<rbrakk>\n       \\<Longrightarrow> if_match\n                          (list_all (\\<lambda>a. is_cupcake_value (snd a)))\n                          (Matching.fold2\n                            (\\<lambda>p v.\n                                case_match_result No_match Match_type_error\n                                 (cupcake_pmatch cenv p v))\n                            Match_type_error [] (y # ys) (Match env))", "qed (auto simp: comp_def)"], ["", "private"], ["", "lemma cupcake_pmatch_preserve0:\n  \"is_cupcake_pat pat \\<Longrightarrow>\n    is_cupcake_value v0 \\<Longrightarrow>\n     list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n      cupcake_c_ns envC \\<Longrightarrow>\n       if_match (list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch envC pat v0 env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_cupcake_pat pat; is_cupcake_value v0;\n     list_all (is_cupcake_value \\<circ> snd) env; cupcake_c_ns envC\\<rbrakk>\n    \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                       (cupcake_pmatch envC pat v0 env)", "proof (induction rule: cupcake_pmatch.induct)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>cenv x v0 env.\n       \\<lbrakk>is_cupcake_pat (Pvar x); is_cupcake_value v0;\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pvar x) v0 env)\n 2. \\<And>cenv n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>cupcake_nsLookup cenv n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3; is_cupcake_pat xa;\n                    is_cupcake_value ya;\n                    list_all (is_cupcake_value \\<circ> snd) x3;\n                    cupcake_c_ns cenv\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv xa ya x3);\n        is_cupcake_pat (Pcon (Some (Short n)) ps);\n        is_cupcake_value (Conv (Some (n', t')) vs);\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Short n)) ps)\n                            (Conv (Some (n', t')) vs) env)\n 3. \\<And>cenv uv_ uw_.\n       \\<lbrakk>is_cupcake_pat Pany; is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv Pany uv_ uw_)\n 4. \\<And>cenv v uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Plit v); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Plit v) uv_ uw_)\n 5. \\<And>cenv va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon None va); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon None va) uv_ uw_)\n 6. \\<And>cenv vc vd va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon (Some (Long vc vd)) va);\n        is_cupcake_value uv_; list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Long vc vd)) va)\n                            uv_ uw_)\n 7. \\<And>cenv v va vb uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Litv vb);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Litv vb) uw_)\n 8. \\<And>cenv v va vc uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Conv None vc);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Conv None vc)\n                            uw_)\n 9. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Closure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Closure vb vc vd) uw_)\n 10. \\<And>cenv v va vb vc vd uw_.\n        \\<lbrakk>is_cupcake_pat (Pcon v va);\n         is_cupcake_value (Recclosure vb vc vd);\n         list_all (is_cupcake_value \\<circ> snd) uw_;\n         cupcake_c_ns cenv\\<rbrakk>\n        \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                           (cupcake_pmatch cenv (Pcon v va)\n                             (Recclosure vb vc vd) uw_)\nA total of 14 subgoals...", "case (2 cenv n ps n' t' vs env)"], ["proof (state)\nthis:\n  \\<lbrakk>cupcake_nsLookup cenv n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (n, ?y) (n', t');\n   ?xa \\<in> set ps; ?ya \\<in> set vs; ?init = Match ?x3.0;\n   is_cupcake_pat ?xa; is_cupcake_value ?ya;\n   list_all (is_cupcake_value \\<circ> snd) ?x3.0; cupcake_c_ns cenv\\<rbrakk>\n  \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                     (cupcake_pmatch cenv ?xa ?ya ?x3.0)\n  is_cupcake_pat (Pcon (Some (Short n)) ps)\n  is_cupcake_value (Conv (Some (n', t')) vs)\n  list_all (is_cupcake_value \\<circ> snd) env\n  cupcake_c_ns cenv\n\ngoal (14 subgoals):\n 1. \\<And>cenv x v0 env.\n       \\<lbrakk>is_cupcake_pat (Pvar x); is_cupcake_value v0;\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pvar x) v0 env)\n 2. \\<And>cenv n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>cupcake_nsLookup cenv n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3; is_cupcake_pat xa;\n                    is_cupcake_value ya;\n                    list_all (is_cupcake_value \\<circ> snd) x3;\n                    cupcake_c_ns cenv\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv xa ya x3);\n        is_cupcake_pat (Pcon (Some (Short n)) ps);\n        is_cupcake_value (Conv (Some (n', t')) vs);\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Short n)) ps)\n                            (Conv (Some (n', t')) vs) env)\n 3. \\<And>cenv uv_ uw_.\n       \\<lbrakk>is_cupcake_pat Pany; is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv Pany uv_ uw_)\n 4. \\<And>cenv v uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Plit v); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Plit v) uv_ uw_)\n 5. \\<And>cenv va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon None va); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon None va) uv_ uw_)\n 6. \\<And>cenv vc vd va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon (Some (Long vc vd)) va);\n        is_cupcake_value uv_; list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Long vc vd)) va)\n                            uv_ uw_)\n 7. \\<And>cenv v va vb uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Litv vb);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Litv vb) uw_)\n 8. \\<And>cenv v va vc uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Conv None vc);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Conv None vc)\n                            uw_)\n 9. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Closure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Closure vb vc vd) uw_)\n 10. \\<And>cenv v va vb vc vd uw_.\n        \\<lbrakk>is_cupcake_pat (Pcon v va);\n         is_cupcake_value (Recclosure vb vc vd);\n         list_all (is_cupcake_value \\<circ> snd) uw_;\n         cupcake_c_ns cenv\\<rbrakk>\n        \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                           (cupcake_pmatch cenv (Pcon v va)\n                             (Recclosure vb vc vd) uw_)\nA total of 14 subgoals...", "have p:\"p \\<in> set ps \\<Longrightarrow> is_cupcake_pat p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps \\<Longrightarrow> is_cupcake_pat p", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>cupcake_nsLookup cenv n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (n, ?y) (n', t');\n   ?xa \\<in> set ps; ?ya \\<in> set vs; ?init = Match ?x3.0;\n   is_cupcake_pat ?xa; is_cupcake_value ?ya;\n   list_all (is_cupcake_value \\<circ> snd) ?x3.0; cupcake_c_ns cenv\\<rbrakk>\n  \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                     (cupcake_pmatch cenv ?xa ?ya ?x3.0)\n  is_cupcake_pat (Pcon (Some (Short n)) ps)\n  is_cupcake_value (Conv (Some (n', t')) vs)\n  list_all (is_cupcake_value \\<circ> snd) env\n  cupcake_c_ns cenv\n\ngoal (1 subgoal):\n 1. p \\<in> set ps \\<Longrightarrow> is_cupcake_pat p", "by (metis Ball_set is_cupcake_pat.simps(2))"], ["proof (state)\nthis:\n  ?p \\<in> set ps \\<Longrightarrow> is_cupcake_pat ?p\n\ngoal (14 subgoals):\n 1. \\<And>cenv x v0 env.\n       \\<lbrakk>is_cupcake_pat (Pvar x); is_cupcake_value v0;\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pvar x) v0 env)\n 2. \\<And>cenv n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>cupcake_nsLookup cenv n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3; is_cupcake_pat xa;\n                    is_cupcake_value ya;\n                    list_all (is_cupcake_value \\<circ> snd) x3;\n                    cupcake_c_ns cenv\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv xa ya x3);\n        is_cupcake_pat (Pcon (Some (Short n)) ps);\n        is_cupcake_value (Conv (Some (n', t')) vs);\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Short n)) ps)\n                            (Conv (Some (n', t')) vs) env)\n 3. \\<And>cenv uv_ uw_.\n       \\<lbrakk>is_cupcake_pat Pany; is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv Pany uv_ uw_)\n 4. \\<And>cenv v uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Plit v); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Plit v) uv_ uw_)\n 5. \\<And>cenv va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon None va); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon None va) uv_ uw_)\n 6. \\<And>cenv vc vd va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon (Some (Long vc vd)) va);\n        is_cupcake_value uv_; list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Long vc vd)) va)\n                            uv_ uw_)\n 7. \\<And>cenv v va vb uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Litv vb);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Litv vb) uw_)\n 8. \\<And>cenv v va vc uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Conv None vc);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Conv None vc)\n                            uw_)\n 9. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Closure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Closure vb vc vd) uw_)\n 10. \\<And>cenv v va vb vc vd uw_.\n        \\<lbrakk>is_cupcake_pat (Pcon v va);\n         is_cupcake_value (Recclosure vb vc vd);\n         list_all (is_cupcake_value \\<circ> snd) uw_;\n         cupcake_c_ns cenv\\<rbrakk>\n        \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                           (cupcake_pmatch cenv (Pcon v va)\n                             (Recclosure vb vc vd) uw_)\nA total of 14 subgoals...", "have v:\"v \\<in> set vs \\<Longrightarrow> is_cupcake_value v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow> is_cupcake_value v", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>cupcake_nsLookup cenv n = Some ?x2.0; (?x, ?y) = ?x2.0;\n   same_tid ?y t' \\<and> length ps = ?x; same_ctor (n, ?y) (n', t');\n   ?xa \\<in> set ps; ?ya \\<in> set vs; ?init = Match ?x3.0;\n   is_cupcake_pat ?xa; is_cupcake_value ?ya;\n   list_all (is_cupcake_value \\<circ> snd) ?x3.0; cupcake_c_ns cenv\\<rbrakk>\n  \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                     (cupcake_pmatch cenv ?xa ?ya ?x3.0)\n  is_cupcake_pat (Pcon (Some (Short n)) ps)\n  is_cupcake_value (Conv (Some (n', t')) vs)\n  list_all (is_cupcake_value \\<circ> snd) env\n  cupcake_c_ns cenv\n\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow> is_cupcake_value v", "by (metis Ball_set is_cupcake_value.elims(2) v.distinct(11) v.distinct(13) v.inject(2))"], ["proof (state)\nthis:\n  ?v \\<in> set vs \\<Longrightarrow> is_cupcake_value ?v\n\ngoal (14 subgoals):\n 1. \\<And>cenv x v0 env.\n       \\<lbrakk>is_cupcake_pat (Pvar x); is_cupcake_value v0;\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pvar x) v0 env)\n 2. \\<And>cenv n ps n' t' vs env.\n       \\<lbrakk>\\<And>x2 x y init xa ya x3.\n                   \\<lbrakk>cupcake_nsLookup cenv n = Some x2; (x, y) = x2;\n                    same_tid y t' \\<and> length ps = x;\n                    same_ctor (n, y) (n', t'); xa \\<in> set ps;\n                    ya \\<in> set vs; init = Match x3; is_cupcake_pat xa;\n                    is_cupcake_value ya;\n                    list_all (is_cupcake_value \\<circ> snd) x3;\n                    cupcake_c_ns cenv\\<rbrakk>\n                   \\<Longrightarrow> if_match\n(list_all (is_cupcake_value \\<circ> snd)) (cupcake_pmatch cenv xa ya x3);\n        is_cupcake_pat (Pcon (Some (Short n)) ps);\n        is_cupcake_value (Conv (Some (n', t')) vs);\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Short n)) ps)\n                            (Conv (Some (n', t')) vs) env)\n 3. \\<And>cenv uv_ uw_.\n       \\<lbrakk>is_cupcake_pat Pany; is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv Pany uv_ uw_)\n 4. \\<And>cenv v uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Plit v); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Plit v) uv_ uw_)\n 5. \\<And>cenv va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon None va); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon None va) uv_ uw_)\n 6. \\<And>cenv vc vd va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon (Some (Long vc vd)) va);\n        is_cupcake_value uv_; list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Long vc vd)) va)\n                            uv_ uw_)\n 7. \\<And>cenv v va vb uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Litv vb);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Litv vb) uw_)\n 8. \\<And>cenv v va vc uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Conv None vc);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Conv None vc)\n                            uw_)\n 9. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Closure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Closure vb vc vd) uw_)\n 10. \\<And>cenv v va vb vc vd uw_.\n        \\<lbrakk>is_cupcake_pat (Pcon v va);\n         is_cupcake_value (Recclosure vb vc vd);\n         list_all (is_cupcake_value \\<circ> snd) uw_;\n         cupcake_c_ns cenv\\<rbrakk>\n        \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                           (cupcake_pmatch cenv (Pcon v va)\n                             (Recclosure vb vc vd) uw_)\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_match (list_all (is_cupcake_value \\<circ> snd))\n     (cupcake_pmatch cenv (Pcon (Some (Short n)) ps)\n       (Conv (Some (n', t')) vs) env)", "by (auto intro!: cupcake_pmatch_list_preserve split:if_splits option.splits) (metis 2 p v)+"], ["proof (state)\nthis:\n  if_match (list_all (is_cupcake_value \\<circ> snd))\n   (cupcake_pmatch cenv (Pcon (Some (Short n)) ps) (Conv (Some (n', t')) vs)\n     env)\n\ngoal (13 subgoals):\n 1. \\<And>cenv x v0 env.\n       \\<lbrakk>is_cupcake_pat (Pvar x); is_cupcake_value v0;\n        list_all (is_cupcake_value \\<circ> snd) env;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pvar x) v0 env)\n 2. \\<And>cenv uv_ uw_.\n       \\<lbrakk>is_cupcake_pat Pany; is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv Pany uv_ uw_)\n 3. \\<And>cenv v uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Plit v); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Plit v) uv_ uw_)\n 4. \\<And>cenv va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon None va); is_cupcake_value uv_;\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon None va) uv_ uw_)\n 5. \\<And>cenv vc vd va uv_ uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon (Some (Long vc vd)) va);\n        is_cupcake_value uv_; list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon (Some (Long vc vd)) va)\n                            uv_ uw_)\n 6. \\<And>cenv v va vb uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Litv vb);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Litv vb) uw_)\n 7. \\<And>cenv v va vc uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Conv None vc);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va) (Conv None vc)\n                            uw_)\n 8. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Closure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Closure vb vc vd) uw_)\n 9. \\<And>cenv v va vb vc vd uw_.\n       \\<lbrakk>is_cupcake_pat (Pcon v va);\n        is_cupcake_value (Recclosure vb vc vd);\n        list_all (is_cupcake_value \\<circ> snd) uw_;\n        cupcake_c_ns cenv\\<rbrakk>\n       \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                          (cupcake_pmatch cenv (Pcon v va)\n                            (Recclosure vb vc vd) uw_)\n 10. \\<And>cenv v va vb uw_.\n        \\<lbrakk>is_cupcake_pat (Pcon v va); is_cupcake_value (Loc vb);\n         list_all (is_cupcake_value \\<circ> snd) uw_;\n         cupcake_c_ns cenv\\<rbrakk>\n        \\<Longrightarrow> if_match (list_all (is_cupcake_value \\<circ> snd))\n                           (cupcake_pmatch cenv (Pcon v va) (Loc vb) uw_)\nA total of 13 subgoals...", "qed (auto split: option.splits if_splits elim: is_cupcake_pat.elims is_cupcake_value.elims)"], ["", "lemma cupcake_pmatch_preserve:\n  \"is_cupcake_pat pat \\<Longrightarrow>\n    is_cupcake_value v0 \\<Longrightarrow>\n     list_all (is_cupcake_value \\<circ> snd) env \\<Longrightarrow>\n      cupcake_c_ns envC \\<Longrightarrow>\n       cupcake_pmatch envC pat v0 env = Match env' \\<Longrightarrow>\n        list_all (is_cupcake_value \\<circ> snd) env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_cupcake_pat pat; is_cupcake_value v0;\n     list_all (is_cupcake_value \\<circ> snd) env; cupcake_c_ns envC;\n     cupcake_pmatch envC pat v0 env = Match env'\\<rbrakk>\n    \\<Longrightarrow> list_all (is_cupcake_value \\<circ> snd) env'", "by (metis if_match.simps(1) cupcake_pmatch_preserve0)+"], ["", "end"], ["", "lemma cupcake_match_result_preserve:\n  \"cupcake_c_ns envC \\<Longrightarrow>\n    cupcake_clauses pes \\<Longrightarrow>\n      is_cupcake_value v \\<Longrightarrow>\n        if_rval (\\<lambda>(e, p, env'). is_cupcake_pat p \\<and> is_cupcake_exp e \\<and> list_all (is_cupcake_value \\<circ> snd) env')\n          (cupcake_match_result envC v pes err_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cupcake_c_ns envC; cupcake_clauses pes;\n     is_cupcake_value v\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>(e, p, env').\n                           is_cupcake_pat p \\<and>\n                           is_cupcake_exp e \\<and>\n                           list_all (is_cupcake_value \\<circ> snd) env')\n                       (cupcake_match_result envC v pes err_v)", "apply (induction pes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>cupcake_c_ns envC; cupcake_clauses [];\n     is_cupcake_value v\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>(e, p, env').\n                           is_cupcake_pat p \\<and>\n                           is_cupcake_exp e \\<and>\n                           list_all (is_cupcake_value \\<circ> snd) env')\n                       (cupcake_match_result envC v [] err_v)\n 2. \\<And>a pes.\n       \\<lbrakk>\\<lbrakk>cupcake_c_ns envC; cupcake_clauses pes;\n                 is_cupcake_value v\\<rbrakk>\n                \\<Longrightarrow> if_rval\n                                   (\\<lambda>(e, p, env').\n is_cupcake_pat p \\<and>\n is_cupcake_exp e \\<and> list_all (is_cupcake_value \\<circ> snd) env')\n                                   (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; cupcake_clauses (a # pes);\n        is_cupcake_value v\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>(e, p, env').\n                              is_cupcake_pat p \\<and>\n                              is_cupcake_exp e \\<and>\n                              list_all (is_cupcake_value \\<circ> snd) env')\n                          (cupcake_match_result envC v (a # pes) err_v)", "apply (auto split: match_result.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> list_all (is_cupcake_value \\<circ> snd) x3", "apply (rule cupcake_pmatch_preserve)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_pat (?pat16 a b pes x3)\n 2. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> is_cupcake_value (?v0.16 a b pes x3)\n 3. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> list_all (is_cupcake_value \\<circ> snd)\n                          (?env16 a b pes x3)\n 4. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> cupcake_c_ns (?envC16 a b pes x3)\n 5. \\<And>a b pes x3.\n       \\<lbrakk>if_rval\n                 (\\<lambda>(e, p, env').\n                     is_cupcake_pat p \\<and>\n                     is_cupcake_exp e \\<and>\n                     list_all (is_cupcake_value \\<circ> snd) env')\n                 (cupcake_match_result envC v pes err_v);\n        cupcake_c_ns envC; is_cupcake_value v; cupcake_clauses pes;\n        is_cupcake_pat a; is_cupcake_exp b;\n        cupcake_pmatch envC a v [] = Match x3;\n        distinct (pat_bindings a [])\\<rbrakk>\n       \\<Longrightarrow> cupcake_pmatch (?envC16 a b pes x3)\n                          (?pat16 a b pes x3) (?v0.16 a b pes x3)\n                          (?env16 a b pes x3) =\n                         Match x3", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma static_cenv_lookup:\n  assumes \"cupcake_nsLookup static_cenv i = Some (len, b)\"\n  obtains name where \"b = TypeId (Short name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>name.\n        b = TypeId (Short name) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms static_cenv"], ["proof (prove)\nusing this:\n  cupcake_nsLookup static_cenv i = Some (len, b)\n  cupcake_c_ns static_cenv\n\ngoal (1 subgoal):\n 1. (\\<And>name.\n        b = TypeId (Short name) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases static_cenv; cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a.\n       \\<lbrakk>\\<And>name.\n                   b = TypeId (Short name) \\<Longrightarrow> thesis;\n        cupcake_nsLookup static_cenv i = Some (len, b);\n        cupcake_c_ns static_cenv; static_cenv = Bind x1 x2;\n        cupcake_nsLookup static_cenv i = Some (len, b);\n        cupcake_c_ns static_cenv; b = TypeId x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x1 x2 x2a.\n       \\<lbrakk>\\<And>name.\n                   b = TypeId (Short name) \\<Longrightarrow> thesis;\n        cupcake_nsLookup static_cenv i = Some (len, b);\n        cupcake_c_ns static_cenv; static_cenv = Bind x1 x2;\n        cupcake_nsLookup static_cenv i = Some (len, b);\n        cupcake_c_ns static_cenv; b = TypeExn x2a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto simp: list_all_iff split: prod.splits tid_or_exn.splits id0.splits dest!: map_of_SomeD elim!: ballE allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>static_cenv = Bind x1 []; b = TypeId x1a;\n        \\<And>name. x1a = Short name \\<Longrightarrow> thesis;\n        (i, len, TypeId x1a) \\<in> set x1;\n        (?x1.68 x1 x1a, ?a69 x1 x1a, TypeExn (?x2.73 x1 x1a))\n        \\<notin> set x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "using static_cenv"], ["proof (prove)\nusing this:\n  cupcake_c_ns static_cenv\n\ngoal (1 subgoal):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>static_cenv = Bind x1 []; b = TypeId x1a;\n        \\<And>name. x1a = Short name \\<Longrightarrow> thesis;\n        (i, len, TypeId x1a) \\<in> set x1;\n        (?x1.68 x1 x1a, ?a69 x1 x1a, TypeExn (?x2.73 x1 x1a))\n        \\<notin> set x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto simp: list_all_iff split: prod.splits tid_or_exn.splits id0.splits dest!: map_of_SomeD elim!: ballE allE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cupcake_build_conv_preserve:\n  fixes v\n  assumes \"list_all is_cupcake_value vs\" \"build_conv static_cenv (Some (Short i)) vs = Some v\"\n  shows \"is_cupcake_value v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value v", "using assms"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value vs\n  build_conv static_cenv (Some (Short i)) vs = Some v\n\ngoal (1 subgoal):\n 1. is_cupcake_value v", "by (auto simp: build_conv.simps split: option.splits elim: static_cenv_lookup)"], ["", "lemma cupcake_nsLookup_preserve:\n  assumes \"is_cupcake_ns ns\" \"nsLookup ns n = Some v0\"\n  shows \"is_cupcake_value v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "obtain vs where \"list_all (is_cupcake_value \\<circ> snd) vs\" \"ns = Bind vs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) vs;\n         ns = Bind vs []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_cupcake_ns ns\n  nsLookup ns n = Some v0\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>list_all (is_cupcake_value \\<circ> snd) vs;\n         ns = Bind vs []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_cupcake_ns.elims)"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) vs\n  ns = Bind vs []\n\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1. n = Short x1 \\<Longrightarrow> is_cupcake_value v0\n 2. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "case (Short id)"], ["proof (state)\nthis:\n  n = Short id\n\ngoal (2 subgoals):\n 1. \\<And>x1. n = Short x1 \\<Longrightarrow> is_cupcake_value v0\n 2. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "hence \"(id, v0) \\<in> set vs\""], ["proof (prove)\nusing this:\n  n = Short id\n\ngoal (1 subgoal):\n 1. (id, v0) \\<in> set vs", "using assms"], ["proof (prove)\nusing this:\n  n = Short id\n  is_cupcake_ns ns\n  nsLookup ns n = Some v0\n\ngoal (1 subgoal):\n 1. (id, v0) \\<in> set vs", "unfolding \\<open>ns = _\\<close>"], ["proof (prove)\nusing this:\n  n = Short id\n  is_cupcake_ns (Bind vs [])\n  nsLookup (Bind vs []) n = Some v0\n\ngoal (1 subgoal):\n 1. (id, v0) \\<in> set vs", "by (auto dest: map_of_SomeD)"], ["proof (state)\nthis:\n  (id, v0) \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<And>x1. n = Short x1 \\<Longrightarrow> is_cupcake_value v0\n 2. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (id, v0) \\<in> set vs\n\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "using \\<open>list_all (is_cupcake_value \\<circ> snd) vs\\<close>"], ["proof (prove)\nusing this:\n  (id, v0) \\<in> set vs\n  list_all (is_cupcake_value \\<circ> snd) vs\n\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  is_cupcake_value v0\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "case Long"], ["proof (state)\nthis:\n  n = Long x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "hence \"nsLookup ns n = None\""], ["proof (prove)\nusing this:\n  n = Long x21_ x22_\n\ngoal (1 subgoal):\n 1. nsLookup ns n = None", "unfolding \\<open>ns = _\\<close>"], ["proof (prove)\nusing this:\n  n = Long x21_ x22_\n\ngoal (1 subgoal):\n 1. nsLookup (Bind vs []) n = None", "by simp"], ["proof (state)\nthis:\n  nsLookup ns n = None\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22. n = Long x21 x22 \\<Longrightarrow> is_cupcake_value v0", "thus ?thesis"], ["proof (prove)\nusing this:\n  nsLookup ns n = None\n\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "using assms"], ["proof (prove)\nusing this:\n  nsLookup ns n = None\n  is_cupcake_ns ns\n  nsLookup ns n = Some v0\n\ngoal (1 subgoal):\n 1. is_cupcake_value v0", "by auto"], ["proof (state)\nthis:\n  is_cupcake_value v0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_cupcake_value v0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary match_all_preserve:\n  assumes \"cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\" \"cupcake_c_ns cenv\"\n  assumes \"is_cupcake_value v0\" \"cupcake_clauses pes\"\n  shows \"list_all (is_cupcake_value \\<circ> snd) env'\" \"is_cupcake_exp e\" \"is_cupcake_pat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&&\n    is_cupcake_exp e &&& is_cupcake_pat p", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_exp e\n 3. is_cupcake_pat p", "from assms"], ["proof (chain)\npicking this:\n  cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\n  cupcake_c_ns cenv\n  is_cupcake_value v0\n  cupcake_clauses pes", "obtain init rest\n    where \"pes = init @ (p, e) # rest\" and \"cupcake_pmatch cenv p v0 [] = Match env'\""], ["proof (prove)\nusing this:\n  cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\n  cupcake_c_ns cenv\n  is_cupcake_value v0\n  cupcake_clauses pes\n\ngoal (1 subgoal):\n 1. (\\<And>init rest.\n        \\<lbrakk>pes = init @ (p, e) # rest;\n         cupcake_pmatch cenv p v0 [] = Match env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim cupcake_match_resultE)"], ["proof (state)\nthis:\n  pes = init @ (p, e) # rest\n  cupcake_pmatch cenv p v0 [] = Match env'\n\ngoal (3 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_exp e\n 3. is_cupcake_pat p", "hence \"(p, e) \\<in> set pes\""], ["proof (prove)\nusing this:\n  pes = init @ (p, e) # rest\n  cupcake_pmatch cenv p v0 [] = Match env'\n\ngoal (1 subgoal):\n 1. (p, e) \\<in> set pes", "by simp"], ["proof (state)\nthis:\n  (p, e) \\<in> set pes\n\ngoal (3 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_exp e\n 3. is_cupcake_pat p", "thus \"is_cupcake_exp e\" \"is_cupcake_pat p\""], ["proof (prove)\nusing this:\n  (p, e) \\<in> set pes\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_pat p", "using assms"], ["proof (prove)\nusing this:\n  (p, e) \\<in> set pes\n  cupcake_match_result cenv v0 pes err_v = Rval (e, p, env')\n  cupcake_c_ns cenv\n  is_cupcake_value v0\n  cupcake_clauses pes\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_pat p", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  is_cupcake_pat p\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env'", "show \"list_all (is_cupcake_value \\<circ> snd) env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env'", "by (rule cupcake_pmatch_preserve[where env = \"[]\"]) (fact | simp)+"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun list_all2_shortcircuit where\n\"list_all2_shortcircuit P (x # xs) (y # ys) \\<longleftrightarrow> (case y of Rval _ \\<Rightarrow> P x y \\<and> list_all2_shortcircuit P xs ys | Rerr _ \\<Rightarrow> P x y)\" |\n\"list_all2_shortcircuit P [] [] \\<longleftrightarrow> True\" |\n\"list_all2_shortcircuit P _ _ \\<longleftrightarrow> False\""], ["", "lemma list_all2_shortcircuit_induct[consumes 1, case_names nil cons_val cons_err]:\n  assumes \"list_all2_shortcircuit P xs ys\"\n  assumes \"R [] []\"\n  assumes \"\\<And>x xs y ys. P x (Rval y) \\<Longrightarrow> list_all2_shortcircuit P xs ys \\<Longrightarrow> R xs ys \\<Longrightarrow> R (x # xs) (Rval y # ys)\"\n  assumes \"\\<And>x xs y ys. P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\"\n  shows \"R xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R xs ys", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit P xs ys\n  R [] []\n  \\<lbrakk>P ?x (Rval ?y); list_all2_shortcircuit P ?xs ?ys;\n   R ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> R (?x # ?xs) (Rval ?y # ?ys)\n  P ?x (Rerr ?y) \\<Longrightarrow> R (?x # ?xs) (Rerr ?y # ?ys)\n\ngoal (1 subgoal):\n 1. R xs ys", "proof (induction P xs ys rule: list_all2_shortcircuit.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>P x xs y ys.\n       \\<lbrakk>\\<And>x1.\n                   \\<lbrakk>y = Rval x1; list_all2_shortcircuit P xs ys;\n                    R [] [];\n                    \\<And>x y xs ys.\n                       \\<lbrakk>P x (Rval y);\n                        list_all2_shortcircuit P xs ys; R xs ys\\<rbrakk>\n                       \\<Longrightarrow> R (x # xs) (Rval y # ys);\n                    \\<And>x y xs ys.\n                       P x (Rerr y) \\<Longrightarrow>\n                       R (x # xs) (Rerr y # ys)\\<rbrakk>\n                   \\<Longrightarrow> R xs ys;\n        list_all2_shortcircuit P (x # xs) (y # ys); R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R (x # xs) (y # ys)\n 2. \\<And>P.\n       \\<lbrakk>list_all2_shortcircuit P [] []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] []\n 3. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P [] (v # va); R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] (v # va)\n 4. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P (v # va) []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R (v # va) []", "case (1 P x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>y = Rval ?x1.0; list_all2_shortcircuit P xs ys; R [] [];\n   \\<And>x y xs ys.\n      \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n       R xs ys\\<rbrakk>\n      \\<Longrightarrow> R (x # xs) (Rval y # ys);\n   \\<And>x y xs ys.\n      P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n  \\<Longrightarrow> R xs ys\n  list_all2_shortcircuit P (x # xs) (y # ys)\n  R [] []\n  \\<lbrakk>P ?x (Rval ?y); list_all2_shortcircuit P ?xs ?ys;\n   R ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> R (?x # ?xs) (Rval ?y # ?ys)\n  P ?x (Rerr ?y) \\<Longrightarrow> R (?x # ?xs) (Rerr ?y # ?ys)\n\ngoal (4 subgoals):\n 1. \\<And>P x xs y ys.\n       \\<lbrakk>\\<And>x1.\n                   \\<lbrakk>y = Rval x1; list_all2_shortcircuit P xs ys;\n                    R [] [];\n                    \\<And>x y xs ys.\n                       \\<lbrakk>P x (Rval y);\n                        list_all2_shortcircuit P xs ys; R xs ys\\<rbrakk>\n                       \\<Longrightarrow> R (x # xs) (Rval y # ys);\n                    \\<And>x y xs ys.\n                       P x (Rerr y) \\<Longrightarrow>\n                       R (x # xs) (Rerr y # ys)\\<rbrakk>\n                   \\<Longrightarrow> R xs ys;\n        list_all2_shortcircuit P (x # xs) (y # ys); R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R (x # xs) (y # ys)\n 2. \\<And>P.\n       \\<lbrakk>list_all2_shortcircuit P [] []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] []\n 3. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P [] (v # va); R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] (v # va)\n 4. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P (v # va) []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R (v # va) []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y = Rval ?x1.0; list_all2_shortcircuit P xs ys; R [] [];\n   \\<And>x y xs ys.\n      \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n       R xs ys\\<rbrakk>\n      \\<Longrightarrow> R (x # xs) (Rval y # ys);\n   \\<And>x y xs ys.\n      P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n  \\<Longrightarrow> R xs ys\n  list_all2_shortcircuit P (x # xs) (y # ys)\n  R [] []\n  \\<lbrakk>P ?x (Rval ?y); list_all2_shortcircuit P ?xs ?ys;\n   R ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> R (?x # ?xs) (Rval ?y # ?ys)\n  P ?x (Rerr ?y) \\<Longrightarrow> R (?x # ?xs) (Rerr ?y # ?ys)\n\ngoal (1 subgoal):\n 1. R (x # xs) (y # ys)", "by (cases y) auto"], ["proof (state)\nthis:\n  R (x # xs) (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>list_all2_shortcircuit P [] []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] []\n 2. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P [] (v # va); R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R [] (v # va)\n 3. \\<And>P v va.\n       \\<lbrakk>list_all2_shortcircuit P (v # va) []; R [] [];\n        \\<And>x y xs ys.\n           \\<lbrakk>P x (Rval y); list_all2_shortcircuit P xs ys;\n            R xs ys\\<rbrakk>\n           \\<Longrightarrow> R (x # xs) (Rval y # ys);\n        \\<And>x y xs ys.\n           P x (Rerr y) \\<Longrightarrow> R (x # xs) (Rerr y # ys)\\<rbrakk>\n       \\<Longrightarrow> R (v # va) []", "qed auto"], ["", "lemma list_all2_shortcircuit_mono[mono]:\n  assumes \"R \\<le> Q\"\n  shows \"list_all2_shortcircuit R \\<le> list_all2_shortcircuit Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2_shortcircuit R \\<le> list_all2_shortcircuit Q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2_shortcircuit R x y \\<Longrightarrow>\n       list_all2_shortcircuit Q x y", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2_shortcircuit R x y \\<Longrightarrow>\n       list_all2_shortcircuit Q x y", "assume \"list_all2_shortcircuit R xs ys\""], ["proof (state)\nthis:\n  list_all2_shortcircuit R xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_all2_shortcircuit R x y \\<Longrightarrow>\n       list_all2_shortcircuit Q x y", "thus \"list_all2_shortcircuit Q xs ys\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit R xs ys\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit Q xs ys", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit R xs ys\n  R \\<le> Q\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit Q xs ys", "by (induction xs ys rule: list_all2_shortcircuit_induct) auto"], ["proof (state)\nthis:\n  list_all2_shortcircuit Q xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_all2_shortcircuit_weaken: \"list_all2_shortcircuit P xs ys \\<Longrightarrow> (\\<And>xs ys. P xs ys \\<Longrightarrow> Q xs ys) \\<Longrightarrow> list_all2_shortcircuit Q xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2_shortcircuit P xs ys;\n     \\<And>xs ys. P xs ys \\<Longrightarrow> Q xs ys\\<rbrakk>\n    \\<Longrightarrow> list_all2_shortcircuit Q xs ys", "by (metis list_all2_shortcircuit_mono predicate2I rev_predicate2D)"], ["", "lemma list_all2_shortcircuit_rval[simp]:\n  \"list_all2_shortcircuit P xs (map Rval ys) \\<longleftrightarrow> list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2_shortcircuit P xs (map Rval ys) =\n    list_all2 (\\<lambda>x y. P x (Rval y)) xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all2_shortcircuit P xs (map Rval ys) \\<Longrightarrow>\n    list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\n 2. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys \\<Longrightarrow>\n    list_all2_shortcircuit P xs (map Rval ys)", "assume ?lhs"], ["proof (state)\nthis:\n  list_all2_shortcircuit P xs (map Rval ys)\n\ngoal (2 subgoals):\n 1. list_all2_shortcircuit P xs (map Rval ys) \\<Longrightarrow>\n    list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\n 2. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys \\<Longrightarrow>\n    list_all2_shortcircuit P xs (map Rval ys)", "thus ?rhs"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit P xs (map Rval ys)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys", "by (induction \"map Rval ys::('b, 'c) result list\" arbitrary: ys rule: list_all2_shortcircuit_induct) auto"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys \\<Longrightarrow>\n    list_all2_shortcircuit P xs (map Rval ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys \\<Longrightarrow>\n    list_all2_shortcircuit P xs (map Rval ys)", "assume ?rhs"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. P x (Rval y)) xs ys \\<Longrightarrow>\n    list_all2_shortcircuit P xs (map Rval ys)", "thus ?lhs"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. P x (Rval y)) xs ys\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit P xs (map Rval ys)", "by (induction rule: list_all2_induct) auto"], ["proof (state)\nthis:\n  list_all2_shortcircuit P xs (map Rval ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive cupcake_evaluate_single :: \"all_env \\<Rightarrow> exp \\<Rightarrow> (v, v) result \\<Rightarrow> bool\" where\ncon1:\n  \"do_con_check (c env) cn (length es) \\<Longrightarrow>\n   list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs \\<Longrightarrow>\n   sequence_result rs = Rval vs \\<Longrightarrow>\n   build_conv (c env) cn (rev vs) = Some v0 \\<Longrightarrow>\n   cupcake_evaluate_single env (Con cn es) (Rval v0)\" |\ncon2:\n  \"\\<not> do_con_check (c env) cn (List.length es) \\<Longrightarrow>\n   cupcake_evaluate_single env (Con cn es) (Rerr (Rabort Rtype_error))\" |\ncon3:\n  \"do_con_check (c env) cn (List.length es) \\<Longrightarrow>\n   list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs \\<Longrightarrow>\n   sequence_result rs = Rerr err \\<Longrightarrow>\n   cupcake_evaluate_single env (Con cn es) (Rerr err)\" |\nvar1:\n  \"nsLookup (sem_env.v env) n = Some v0 \\<Longrightarrow> cupcake_evaluate_single env (Var n) (Rval v0)\" |\nvar2:\n  \"nsLookup (sem_env.v env) n = None \\<Longrightarrow> cupcake_evaluate_single env (Var n) (Rerr (Rabort Rtype_error))\" |\nfn:\n  \"cupcake_evaluate_single env (Fun n e) (Rval (Closure env n e))\" |\napp1:\n  \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs \\<Longrightarrow>\n   sequence_result rs = Rval vs \\<Longrightarrow>\n   do_opapp (rev vs) = Some (env', e) \\<Longrightarrow>\n   cupcake_evaluate_single env' e bv \\<Longrightarrow>\n   cupcake_evaluate_single env (App Opapp es) bv\" |\napp3:\n  \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs \\<Longrightarrow>\n   sequence_result rs = Rval vs \\<Longrightarrow>\n   do_opapp (rev vs) = None \\<Longrightarrow>\n   cupcake_evaluate_single env (App Opapp es) (Rerr (Rabort Rtype_error))\" |\napp6:\n  \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs \\<Longrightarrow>\n   sequence_result rs = Rerr err \\<Longrightarrow>\n   cupcake_evaluate_single env (App op0 es) (Rerr err)\" |\nmat1:\n  \"cupcake_evaluate_single env e (Rval v0) \\<Longrightarrow>\n   cupcake_match_result (c env) v0 pes Bindv = Rval (e', _, env') \\<Longrightarrow>\n   cupcake_evaluate_single (env (| sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) |)) e' bv \\<Longrightarrow>\n   cupcake_evaluate_single env (Mat e pes) bv\" |\nmat1error:\n  \"cupcake_evaluate_single env e (Rval v0) \\<Longrightarrow>\n   cupcake_match_result (c env) v0 pes Bindv = Rerr err \\<Longrightarrow>\n   cupcake_evaluate_single env (Mat e pes) (Rerr err)\" |\nmat2:\n  \"cupcake_evaluate_single env e (Rerr err) \\<Longrightarrow>\n   cupcake_evaluate_single env (Mat e pes) (Rerr err)\""], ["", "context cakeml_static_env begin"], ["", "context begin"], ["", "private"], ["", "lemma cupcake_list_preserve0:\n  \"list_all2_shortcircuit\n     (\\<lambda>e r. cupcake_evaluate_single env e r \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> if_rval is_cupcake_value r)) es rs \\<Longrightarrow>\n  is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es \\<Longrightarrow> sequence_result rs = Rval vs \\<Longrightarrow> list_all is_cupcake_value vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2_shortcircuit\n              (\\<lambda>e r.\n                  cupcake_evaluate_single env e r \\<and>\n                  (is_cupcake_all_env env \\<longrightarrow>\n                   is_cupcake_exp e \\<longrightarrow>\n                   if_rval is_cupcake_value r))\n              es rs;\n     is_cupcake_all_env env; list_all is_cupcake_exp es;\n     sequence_result rs = Rval vs\\<rbrakk>\n    \\<Longrightarrow> list_all is_cupcake_value vs", "proof (induction es rs arbitrary: vs rule:list_all2_shortcircuit_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs\n 2. \\<And>x xs y ys vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 if_rval is_cupcake_value (Rval y));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              if_rval is_cupcake_value r))\n         xs ys;\n        \\<And>vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> list_all is_cupcake_value vs;\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs\n 3. \\<And>x xs y ys vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 if_rval is_cupcake_value (Rerr y));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs", "case (cons_val _ _ _ rs)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env x_ (Rval y_) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp x_ \\<longrightarrow> if_rval is_cupcake_value (Rval y_))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow> if_rval is_cupcake_value r))\n   xs_ rs\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs_;\n   sequence_result rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (x_ # xs_)\n  sequence_result (Rval y_ # rs) = Rval vs\n\ngoal (3 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs\n 2. \\<And>x xs y ys vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 if_rval is_cupcake_value (Rval y));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              if_rval is_cupcake_value r))\n         xs ys;\n        \\<And>vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> list_all is_cupcake_value vs;\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs\n 3. \\<And>x xs y ys vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 if_rval is_cupcake_value (Rerr y));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs", "thus ?case"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env x_ (Rval y_) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp x_ \\<longrightarrow> if_rval is_cupcake_value (Rval y_))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow> if_rval is_cupcake_value r))\n   xs_ rs\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs_;\n   sequence_result rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (x_ # xs_)\n  sequence_result (Rval y_ # rs) = Rval vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value vs", "by (cases \"sequence_result rs\") auto"], ["proof (state)\nthis:\n  list_all is_cupcake_value vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs\n 2. \\<And>x xs y ys vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 if_rval is_cupcake_value (Rerr y));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> list_all is_cupcake_value vs", "qed auto"], ["", "private"], ["", "lemma cupcake_single_preserve0:\n  \"cupcake_evaluate_single env e res \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> if_rval is_cupcake_value res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cupcake_evaluate_single env e res; is_cupcake_all_env env;\n     is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> if_rval is_cupcake_value res", "proof (induction rule:cupcake_evaluate_single.induct)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 2. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 4. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 5. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 8. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<lbrakk>is_cupcake_all_env\n                   (update_v\n                     (\\<lambda>_.\n                         nsAppend (alist_to_ns env') (sem_env.v env))\n                     env);\n          is_cupcake_exp e'\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value bv;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv\nA total of 12 subgoals...", "case (con1 env cn es rs vs v0)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 2. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 4. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 5. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 8. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<lbrakk>is_cupcake_all_env\n                   (update_v\n                     (\\<lambda>_.\n                         nsAppend (alist_to_ns env') (sem_env.v env))\n                     env);\n          is_cupcake_exp e'\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value bv;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)", "obtain tid where cn: \"cn = Some (Short tid)\" and \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. (\\<And>tid.\n        \\<lbrakk>cn = Some (Short tid);\n         list_all is_cupcake_exp (rev es)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  cn = Some (Short tid)\n  list_all is_cupcake_exp (rev es)\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 2. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 4. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 5. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 8. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<lbrakk>is_cupcake_all_env\n                   (update_v\n                     (\\<lambda>_.\n                         nsAppend (alist_to_ns env') (sem_env.v env))\n                     env);\n          is_cupcake_exp e'\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value bv;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv\nA total of 12 subgoals...", "hence \"list_all is_cupcake_value (rev vs)\" and \"c env = static_cenv\""], ["proof (prove)\nusing this:\n  cn = Some (Short tid)\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs) &&& c env = static_cenv", "using cupcake_list_preserve0 con1"], ["proof (prove)\nusing this:\n  cn = Some (Short tid)\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 if_rval is_cupcake_value r))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs) &&& c env = static_cenv", "by (fastforce elim:is_cupcake_all_envE)+"], ["proof (state)\nthis:\n  list_all is_cupcake_value (rev vs)\n  c env = static_cenv\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 2. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 4. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 5. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 8. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<lbrakk>is_cupcake_all_env\n                   (update_v\n                     (\\<lambda>_.\n                         nsAppend (alist_to_ns env') (sem_env.v env))\n                     env);\n          is_cupcake_exp e'\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value bv;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_value (rev vs)\n  c env = static_cenv", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n  c env = static_cenv\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value (Rval v0)", "using cupcake_build_conv_preserve con1 cn"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n  c env = static_cenv\n  \\<lbrakk>list_all is_cupcake_value ?vs;\n   build_conv static_cenv (Some (Short ?i)) ?vs = Some ?v\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_value ?v\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n  cn = Some (Short tid)\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value (Rval v0)", "by fastforce"], ["proof (state)\nthis:\n  if_rval is_cupcake_value (Rval v0)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "case (app1 env es rs vs env' e bv)"], ["proof (state)\nthis:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by fastforce"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "hence \"list_all is_cupcake_value (rev vs)\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs)", "using app1 cupcake_list_preserve0"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 if_rval is_cupcake_value r))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs)", "by force"], ["proof (state)\nthis:\n  list_all is_cupcake_value (rev vs)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "hence \"is_cupcake_exp e\" and \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "using app1 cupcake_opapp_preserve"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_all_env ?env\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp ?e\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "by blast+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (11 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 7. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 10. \\<And>env e v0 pes err.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value bv", "using app1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow> if_rval is_cupcake_value x2))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value bv", "by blast"], ["proof (state)\nthis:\n  if_rval is_cupcake_value bv\n\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "case (mat1 env e v0 pes e' uu env' bv)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "hence \"cupcake_c_ns (c env)\" \"cupcake_clauses pes\" \"is_cupcake_value v0\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. cupcake_c_ns (c env) &&& cupcake_clauses pes &&& is_cupcake_value v0", "by (auto dest: is_cupcake_all_envD)"], ["proof (state)\nthis:\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "hence \"list_all (is_cupcake_value \\<circ> snd) env'\" and e': \"is_cupcake_exp e'\""], ["proof (prove)\nusing this:\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "using cupcake_match_result_preserve[where envC = \"c env\" and v = v0 and pes = pes and err_v = Bindv, unfolded mat1, simplified]"], ["proof (prove)\nusing this:\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n  \\<lbrakk>cupcake_c_ns (c env); cupcake_clauses pes;\n   is_cupcake_value v0\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_pat uu \\<and>\n                    is_cupcake_exp e' \\<and>\n                    list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "by auto"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "have \"is_cupcake_all_env (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)", "apply (rule cupcake_v_update_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply (rule cupcake_nsAppend_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns (alist_to_ns env')\n 2. is_cupcake_ns (sem_env.v env)", "apply (rule cupcake_alist_to_ns_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_ns (sem_env.v env)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (sem_env.v env)", "apply (rule is_cupcake_all_envD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value bv;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value bv\n 9. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 10. \\<And>env e err pes.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n         \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "then"], ["proof (chain)\npicking this:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value bv", "using mat1 e'"], ["proof (prove)\nusing this:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> if_rval is_cupcake_value bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n  is_cupcake_exp e'\n\ngoal (1 subgoal):\n 1. if_rval is_cupcake_value bv", "by blast"], ["proof (state)\nthis:\n  if_rval is_cupcake_value bv\n\ngoal (9 subgoals):\n 1. \\<And>env cn es.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              if_rval is_cupcake_value x2))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 3. \\<And>env n v0.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval v0)\n 4. \\<And>env n.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rval (Closure env n e))\n 6. \\<And>env es rs vs.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      if_rval is_cupcake_value x2))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 8. \\<And>env e v0 pes err.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)\n 9. \\<And>env e err pes.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> if_rval is_cupcake_value (Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> if_rval is_cupcake_value (Rerr err)", "qed (auto intro: cupcake_nsLookup_preserve dest: is_cupcake_all_envD)"], ["", "lemma cupcake_single_preserve:\n  \"cupcake_evaluate_single env e (Rval res) \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> is_cupcake_value res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cupcake_evaluate_single env e (Rval res);\n     is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> is_cupcake_value res", "by (fastforce dest:cupcake_single_preserve0)"], ["", "lemma cupcake_list_preserve:\n  \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<Longrightarrow>\n  is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es \\<Longrightarrow> sequence_result rs = Rval vs \\<Longrightarrow> list_all is_cupcake_value vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env) es rs;\n     is_cupcake_all_env env; list_all is_cupcake_exp es;\n     sequence_result rs = Rval vs\\<rbrakk>\n    \\<Longrightarrow> list_all is_cupcake_value vs", "by (induction es rs arbitrary:vs rule:list_all2_shortcircuit_induct) (fastforce dest:cupcake_single_preserve)+"], ["", "private"], ["", "lemma cupcake_list_correct_rval:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\" \"sequence_result rs = Rval vs\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',Rval vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es (s', Rval vs)", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es rs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp es\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es (s', Rval vs)", "proof (induction es rs arbitrary: s vs rule:list_all2_shortcircuit_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "case (cons_val e es y ys)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "have e: \"is_cupcake_exp e\" \"list_all is_cupcake_exp es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& list_all is_cupcake_exp es", "using cons_val"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& list_all is_cupcake_exp es", "by fastforce+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es", "obtain vs' where ys: \"sequence_result ys = Rval vs'\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        sequence_result ys = Rval vs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cons_val"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        sequence_result ys = Rval vs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  sequence_result ys = Rval vs'\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "hence vs: \"Rval vs = Rval (y # vs')\""], ["proof (prove)\nusing this:\n  sequence_result ys = Rval vs'\n\ngoal (1 subgoal):\n 1. Rval vs = Rval (y # vs')", "using cons_val"], ["proof (prove)\nusing this:\n  sequence_result ys = Rval vs'\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (1 subgoal):\n 1. Rval vs = Rval (y # vs')", "by fastforce"], ["proof (state)\nthis:\n  Rval vs = Rval (y # vs')\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "from e"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es", "obtain s' where \"evaluate env s e (s', Rval y)\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cons_val"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "from e ys"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rval vs'", "obtain s'' where \"evaluate_list (evaluate env) s' es (s'', Rval vs')\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rval vs'\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        Big_Step_Unclocked_Single.evaluate_list\n         (Big_Step_Unclocked_Single.evaluate env) s' es\n         (s'', Rval vs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cons_val"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rval vs'\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rval ?vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        Big_Step_Unclocked_Single.evaluate_list\n         (Big_Step_Unclocked_Single.evaluate env) s' es\n         (s'', Rval vs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate_list\n   (Big_Step_Unclocked_Single.evaluate env) s' es (s'', Rval vs')\n\ngoal (3 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s vs.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rval vs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)\n 3. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s (e # es) (s', Rval vs)", "unfolding vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s (e # es)\n        (s', Rval (y # vs'))", "by (rule; rule evaluate_list.cons1) fact+"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate_list\n      (Big_Step_Unclocked_Single.evaluate env) s (e # es) (s', Rval vs)\n\ngoal (2 subgoals):\n 1. \\<And>s vs.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rval vs)\n 2. \\<And>x xs y ys s vs.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rval vs)", "qed (auto intro:evaluate_list.intros)"], ["", "private"], ["", "lemma cupcake_list_correct_rerr:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\" \"sequence_result rs = Rerr err\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',Rerr err)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es (s', Rerr err)", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es rs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp es\n  sequence_result rs = Rerr err\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es (s', Rerr err)", "proof (induction es rs arbitrary: s err rule:list_all2_shortcircuit_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s err.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rerr err\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)\n 3. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "case (cons_val e es y ys)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rerr ?err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rerr err\n\ngoal (3 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s err.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rerr err\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)\n 3. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rerr ?err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rerr err", "have \"is_cupcake_exp e\" \"list_all is_cupcake_exp es\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rerr ?err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rerr err\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& list_all is_cupcake_exp es", "by fastforce+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n\ngoal (3 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s err.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rerr err\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)\n 3. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "moreover"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n\ngoal (3 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s err.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rerr err\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)\n 3. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "have err: \"sequence_result ys = Rerr err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_result ys = Rerr err", "using cons_val"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rerr ?err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rerr err\n\ngoal (1 subgoal):\n 1. sequence_result ys = Rerr err", "by (cases \"sequence_result ys\") (auto simp: error_result.map_id)"], ["proof (state)\nthis:\n  sequence_result ys = Rerr err\n\ngoal (3 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rval y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rval y)));\n        list_all2_shortcircuit\n         (\\<lambda>e r.\n             cupcake_evaluate_single env e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              (\\<forall>s.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n         xs ys;\n        \\<And>s err.\n           \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp xs;\n            sequence_result ys = Rerr err\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate_list\n                                 (Big_Step_Unclocked_Single.evaluate env) s\n                                 xs (s', Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rval y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)\n 3. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rerr err", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rerr err\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s (e # es) (s', Rerr err)", "using cons3 cons_val"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  list_all is_cupcake_exp es\n  sequence_result ys = Rerr err\n  \\<lbrakk>?P ?s1.0 ?e (?s2.0, Rval ?v);\n   Big_Step_Unclocked_Single.evaluate_list ?P ?s2.0 ?es\n    (?s3.0, Rerr ?err)\\<rbrakk>\n  \\<Longrightarrow> Big_Step_Unclocked_Single.evaluate_list ?P ?s1.0\n                     (?e # ?es) (?s3.0, Rerr ?err)\n  cupcake_evaluate_single env e (Rval y) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   (\\<forall>s.\n       \\<exists>s'.\n          Big_Step_Unclocked_Single.evaluate env s e (s', Rval y)))\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es ys\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es;\n   sequence_result ys = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate env) ?s es\n                        (s', Rerr ?err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n  sequence_result (Rval y # ys) = Rerr err\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s (e # es) (s', Rerr err)", "by fast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate_list\n      (Big_Step_Unclocked_Single.evaluate env) s (e # es) (s', Rerr err)\n\ngoal (2 subgoals):\n 1. \\<And>s err.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp [];\n        sequence_result [] = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s []\n                             (s', Rerr err)\n 2. \\<And>x xs y ys s err.\n       \\<lbrakk>cupcake_evaluate_single env x (Rerr y) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp x \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate env s x\n                         (s', Rerr y)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (x # xs);\n        sequence_result (Rerr y # ys) = Rerr err\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate_list\n                             (Big_Step_Unclocked_Single.evaluate env) s\n                             (x # xs) (s', Rerr err)", "qed (auto intro:evaluate_list.intros)"], ["", "private"], ["", "lemma cupcake_list_correct0:\n  assumes \"list_all2_shortcircuit\n     (\\<lambda>e r.\n         cupcake_evaluate_single env e r \\<and>\n         (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> (\\<forall>(s::'a state). \\<exists>s'. evaluate env s e (s', r))))\n     es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',sequence_result rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es\n        (s', sequence_result rs)", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>e r.\n       cupcake_evaluate_single env e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        (\\<forall>s.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env s e (s', r))))\n   es rs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es\n        (s', sequence_result rs)", "by (cases \"sequence_result rs\") (fastforce intro: cupcake_list_correct_rval cupcake_list_correct_rerr)+"], ["", "lemma cupcake_single_correct:\n  assumes \"cupcake_evaluate_single env e res\" \"is_cupcake_all_env env\" \"is_cupcake_exp e\"\n  shows \"\\<exists>s'. Big_Step_Unclocked_Single.evaluate env s e (s',res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. Big_Step_Unclocked_Single.evaluate env s e (s', res)", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e res\n  is_cupcake_all_env env\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. \\<exists>s'. Big_Step_Unclocked_Single.evaluate env s e (s', res)", "proof (induction arbitrary:s rule:cupcake_evaluate_single.induct)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rval v0)\n 2. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 4. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 5. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 8. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             is_cupcake_exp e'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e' (s', bv);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', bv)\nA total of 12 subgoals...", "case (con1 env cn es rs vs v0)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rval v0)\n 2. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 4. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 5. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 8. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             is_cupcake_exp e'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e' (s', bv);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', bv)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)", "have \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (c env) cn (rev vs) = Some v0; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rval v0)\n 2. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 4. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 5. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 8. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             is_cupcake_exp e'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate\n                                  (update_v\n                                    (\\<lambda>_.\n  nsAppend (alist_to_ns env') (sem_env.v env))\n                                    env)\n                                  s e' (s', bv);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', bv)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rval v0)", "using cupcake_list_correct_rval evaluate.con1 con1"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate ?env s e\n                         (s', r))))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate ?env) ?s ?es\n                        (s', Rval ?vs)\n  \\<lbrakk>do_con_check (c ?env) ?cn (length ?es);\n   build_conv (c ?env) ?cn (rev ?vs) = Some ?v;\n   Big_Step_Unclocked_Single.evaluate_list\n    (Big_Step_Unclocked_Single.evaluate ?env) ?s1.0 (rev ?es)\n    (?s2.0, Rval ?vs)\\<rbrakk>\n  \\<Longrightarrow> Big_Step_Unclocked_Single.evaluate ?env ?s1.0\n                     (Con ?cn ?es) (?s2.0, Rval ?v)\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rval vs\n  build_conv (c env) cn (rev vs) = Some v0\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rval v0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rval v0)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 3. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 4. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 5. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 7. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 10. \\<And>env e v0 pes err s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 3. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 4. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 5. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 7. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 10. \\<And>env e v0 pes err s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)\nA total of 11 subgoals...", "case (con3 env cn es rs err)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 3. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 4. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 5. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 7. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 10. \\<And>env e v0 pes err s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)", "have \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err s.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x1 \\<longrightarrow>\n              (\\<forall>x.\n                  \\<exists>s'.\n                     Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr err)\n 3. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 4. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 5. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 7. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 10. \\<And>env e v0 pes err s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rval v0);\n         cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rerr err)", "using cupcake_list_correct_rerr con3 evaluate.con3"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate ?env s e\n                         (s', r))))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate ?env) ?s ?es\n                        (s', Rerr ?err)\n  do_con_check (c env) cn (length es)\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n  \\<lbrakk>do_con_check (c ?env) ?cn (length ?es);\n   Big_Step_Unclocked_Single.evaluate_list\n    (Big_Step_Unclocked_Single.evaluate ?env) ?s1.0 (rev ?es)\n    (?s2.0, Rerr ?err)\\<rbrakk>\n  \\<Longrightarrow> Big_Step_Unclocked_Single.evaluate ?env ?s1.0\n                     (Con ?cn ?es) (?s2.0, Rerr ?err)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rerr err)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (Con cn es) (s', Rerr err)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "case (app1 env es rs vs env' e bv)"], ["proof (state)\nthis:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env' ?s e (s', bv)\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "hence es: \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env' ?s e (s', bv)\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by fastforce"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "hence \"list_all is_cupcake_value (rev vs)\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs)", "using app1 cupcake_list_preserve list_all2_shortcircuit_weaken"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env' ?s e (s', bv)\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single ?env) ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  \\<lbrakk>list_all2_shortcircuit ?P ?xs ?ys;\n   \\<And>xs ys. ?P xs ys \\<Longrightarrow> ?Q xs ys\\<rbrakk>\n  \\<Longrightarrow> list_all2_shortcircuit ?Q ?xs ?ys\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev vs)", "by (metis (no_types, lifting) list_all_rev)"], ["proof (state)\nthis:\n  list_all is_cupcake_value (rev vs)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "hence \"is_cupcake_exp e\" and \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "using app1 cupcake_opapp_preserve"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev vs)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env' ?s e (s', bv)\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_all_env ?env\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp ?e\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "by blast+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (10 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env' s e\n                                 (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', bv)\n 6. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 9. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 10. \\<And>env e err pes s.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>s.\n            \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n            \\<Longrightarrow> \\<exists>s'.\n                                 Big_Step_Unclocked_Single.evaluate env s e\n                                  (s', Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env s\n                              (Mat e pes) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App Opapp es) (s', bv)", "using cupcake_list_correct_rval es app1 evaluate.app1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate ?env s e\n                         (s', r))))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate ?env) ?s ?es\n                        (s', Rval ?vs)\n  list_all is_cupcake_exp (rev es)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env' ?s e (s', bv)\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = Some (env', e)\n  cupcake_evaluate_single env' e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n            (Big_Step_Unclocked_Single.evaluate ?env) ?s1.0 (rev ?es)\n            (?s2.0, Rval ?vs);\n   do_opapp (rev ?vs) = Some (?env', ?e);\n   Big_Step_Unclocked_Single.evaluate ?env' ?s2.0 ?e ?bv\\<rbrakk>\n  \\<Longrightarrow> Big_Step_Unclocked_Single.evaluate ?env ?s1.0\n                     (App Opapp ?es) ?bv\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App Opapp es) (s', bv)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (App Opapp es) (s', bv)\n\ngoal (9 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 8. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 9. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 8. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 9. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "case (app3 env es rs vs)"], ["proof (state)\nthis:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (9 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 8. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 9. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by simp"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (9 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs vs s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env; is_cupcake_exp (App Opapp es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App Opapp es) (s', Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 8. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 9. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App Opapp es)\n        (s', Rerr (Rabort Rtype_error))", "using cupcake_list_correct_rval evaluate.app3 app3"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate ?env s e\n                         (s', r))))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate ?env) ?s ?es\n                        (s', Rval ?vs)\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n            (Big_Step_Unclocked_Single.evaluate ?env) ?s1.0 (rev ?es)\n            (?s2.0, Rval ?vs);\n   do_opapp (rev ?vs) = None\\<rbrakk>\n  \\<Longrightarrow> Big_Step_Unclocked_Single.evaluate ?env ?s1.0\n                     (App Opapp ?es) (?s2.0, Rerr (Rabort Rtype_error))\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rval vs\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App Opapp es)\n        (s', Rerr (Rabort Rtype_error))", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (App Opapp es)\n      (s', Rerr (Rabort Rtype_error))\n\ngoal (8 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 7. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 8. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 7. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 8. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "case (app6 env es rs err op0)"], ["proof (state)\nthis:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rerr err\n  is_cupcake_all_env env\n  is_cupcake_exp (App op0 es)\n\ngoal (8 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 7. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 8. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rerr err\n  is_cupcake_all_env env\n  is_cupcake_exp (App op0 es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by simp"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (8 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env es rs err op0 s.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      is_cupcake_exp x1 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<exists>s'.\n                             Big_Step_Unclocked_Single.evaluate env x x1\n                              (s', x2))))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (App op0 es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (App op0 es) (s', Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 7. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 8. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App op0 es) (s', Rerr err)", "using cupcake_list_correct_rerr app6 evaluate.app6"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit\n            (\\<lambda>e r.\n                cupcake_evaluate_single ?env e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 (\\<forall>s.\n                     \\<exists>s'.\n                        Big_Step_Unclocked_Single.evaluate ?env s e\n                         (s', r))))\n            ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rerr ?err\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate_list\n                        (Big_Step_Unclocked_Single.evaluate ?env) ?s ?es\n                        (s', Rerr ?err)\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x1 \\<longrightarrow>\n        (\\<forall>x.\n            \\<exists>s'.\n               Big_Step_Unclocked_Single.evaluate env x x1 (s', x2))))\n   (rev es) rs\n  sequence_result rs = Rerr err\n  is_cupcake_all_env env\n  is_cupcake_exp (App op0 es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (Big_Step_Unclocked_Single.evaluate ?env) ?s1.0 (rev ?es)\n   (?s2.0, Rerr ?err) \\<Longrightarrow>\n  Big_Step_Unclocked_Single.evaluate ?env ?s1.0 (App ?op0.0 ?es)\n   (?s2.0, Rerr ?err)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (App op0 es) (s', Rerr err)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (App op0 es) (s', Rerr err)\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "case (mat1 env e v0 pes e' uu env' bv)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        ?s e' (s', bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence e: \"is_cupcake_exp e\" and \"cupcake_c_ns (c env)\" and pes: \"cupcake_clauses pes\" and \"is_cupcake_value v0\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        ?s e' (s', bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (is_cupcake_exp e &&& cupcake_c_ns (c env)) &&&\n    cupcake_clauses pes &&& is_cupcake_value v0", "by (fastforce dest: is_cupcake_all_envD cupcake_single_preserve)+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"list_all (is_cupcake_value \\<circ> snd) env'\" and e': \"is_cupcake_exp e'\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "using cupcake_match_result_preserve[where envC = \"c env\" and v = v0 and pes = pes and err_v = Bindv, unfolded mat1, simplified]"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v0\n  \\<lbrakk>cupcake_c_ns (c env); cupcake_clauses pes;\n   is_cupcake_value v0\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_pat uu \\<and>\n                    is_cupcake_exp e' \\<and>\n                    list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "by blast+"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "have env': \"is_cupcake_all_env (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)", "apply (rule cupcake_v_update_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply (rule cupcake_nsAppend_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns (alist_to_ns env')\n 2. is_cupcake_ns (sem_env.v env)", "apply (rule cupcake_alist_to_ns_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_ns (sem_env.v env)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (sem_env.v env)", "apply (rule is_cupcake_all_envD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "from e"], ["proof (chain)\npicking this:\n  is_cupcake_exp e", "obtain s' where \"evaluate env s e (s', Rval v0)\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval v0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mat1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        ?s e' (s', bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval v0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "have \"match_result env s' v0 pes Bindv = Rval (e', env')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_result env s' v0 pes Bindv = Rval (e', env')", "using mat1 cupcake_match_result_eq[OF pes, where env = env and v = v0 and err_v = Bindv and s = s']"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        ?s e' (s', bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n  match_result env s' v0 pes Bindv =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v0 pes Bindv)\n\ngoal (1 subgoal):\n 1. match_result env s' v0 pes Bindv = Rval (e', env')", "by fastforce"], ["proof (state)\nthis:\n  match_result env s' v0 pes Bindv = Rval (e', env')\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "from e' env'"], ["proof (chain)\npicking this:\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)", "obtain s'' where \"evaluate (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env) s' e' (s'', bv)\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s' e' (s'', bv) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mat1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate\n                        (update_v\n                          (\\<lambda>_.\n                              nsAppend (alist_to_ns env') (sem_env.v env))\n                          env)\n                        ?s e' (s', bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s' e' (s'', bv) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s' e' (s'', bv)\n\ngoal (7 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes e' uu_ env' bv s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            is_cupcake_exp e'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate\n                                 (update_v\n                                   (\\<lambda>_.\n nsAppend (alist_to_ns env') (sem_env.v env))\n                                   env)\n                                 s e' (s', bv);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', bv)\n 6. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 7. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Mat e pes) (s', bv)", "by rule+ fact+"], ["proof (state)\nthis:\n  \\<exists>s'. Big_Step_Unclocked_Single.evaluate env s (Mat e pes) (s', bv)\n\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "case (mat1error env e v0 pes err)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"is_cupcake_exp e\" and pes: \"cupcake_clauses pes\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& cupcake_clauses pes", "by (auto dest: is_cupcake_all_envD)"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_clauses pes\n\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  cupcake_clauses pes", "obtain s' where \"Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_clauses pes\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval v0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mat1error"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_clauses pes\n  cupcake_evaluate_single env e (Rval v0)\n  cupcake_match_result (c env) v0 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env ?s e\n                        (s', Rval v0)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        Big_Step_Unclocked_Single.evaluate env s e\n         (s', Rval v0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\n\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"match_result env s' v0 pes Bindv = Rerr err\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\n\ngoal (1 subgoal):\n 1. match_result env s' v0 pes Bindv = Rerr err", "using cupcake_match_result_eq[OF pes, where env = env and s = s' and v = v0 and err_v = Bindv]"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\n  match_result env s' v0 pes Bindv =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v0 pes Bindv)\n\ngoal (1 subgoal):\n 1. match_result env s' v0 pes Bindv = Rerr err", "unfolding mat1error"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s e (s', Rval v0)\n  match_result env s' v0 pes Bindv =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id (Rerr err)\n\ngoal (1 subgoal):\n 1. match_result env s' v0 pes Bindv = Rerr err", "by (simp add: error_result.map_id)"], ["proof (state)\nthis:\n  match_result env s' v0 pes Bindv = Rerr err\n\ngoal (6 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e v0 pes err s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rval v0);\n        cupcake_match_result (c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)\n 6. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env s (Mat e pes) (s', Rerr err)", "by (rule; rule evaluate.mat1b) fact+"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env s (Mat e pes) (s', Rerr err)\n\ngoal (5 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "case (mat2 _ e)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env_ e (Rerr err_)\n  \\<lbrakk>is_cupcake_all_env env_; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env_ ?s e\n                        (s', Rerr err_)\n  is_cupcake_all_env env_\n  is_cupcake_exp (Mat e pes_)\n\ngoal (5 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "hence \"is_cupcake_exp e\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env_ e (Rerr err_)\n  \\<lbrakk>is_cupcake_all_env env_; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env_ ?s e\n                        (s', Rerr err_)\n  is_cupcake_all_env env_\n  is_cupcake_exp (Mat e pes_)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e", "by simp"], ["proof (state)\nthis:\n  is_cupcake_exp e\n\ngoal (5 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))\n 5. \\<And>env e err pes s.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>s.\n           \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n           \\<Longrightarrow> \\<exists>s'.\n                                Big_Step_Unclocked_Single.evaluate env s e\n                                 (s', Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Mat e pes)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Mat e pes) (s', Rerr err)", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env_ s (Mat e pes_)\n        (s', Rerr err_)", "using mat2 evaluate.mat2"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_evaluate_single env_ e (Rerr err_)\n  \\<lbrakk>is_cupcake_all_env env_; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate env_ ?s e\n                        (s', Rerr err_)\n  is_cupcake_all_env env_\n  is_cupcake_exp (Mat e pes_)\n  Big_Step_Unclocked_Single.evaluate ?env ?s ?e\n   (?s', Rerr ?err) \\<Longrightarrow>\n  Big_Step_Unclocked_Single.evaluate ?env ?s (Mat ?e ?pes) (?s', Rerr ?err)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate env_ s (Mat e pes_)\n        (s', Rerr err_)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s'.\n     Big_Step_Unclocked_Single.evaluate env_ s (Mat e pes_) (s', Rerr err_)\n\ngoal (4 subgoals):\n 1. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Con cn es) (s', Rerr (Rabort Rtype_error))\n 2. \\<And>env n v0 s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rval v0)\n 3. \\<And>env n s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s (Var n)\n                             (s', Rerr (Rabort Rtype_error))\n 4. \\<And>env n e s.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Fun n e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            Big_Step_Unclocked_Single.evaluate env s\n                             (Fun n e) (s', Rval (Closure env n e))", "qed (blast intro:evaluate.intros)+"], ["", "lemma cupcake_list_correct:\n  assumes \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs\" \"is_cupcake_all_env env\" \"list_all is_cupcake_exp es\"\n  shows \" \\<exists>s'. evaluate_list (evaluate env) (s::'a state) es (s',sequence_result rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es\n        (s', sequence_result rs)", "using assms"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  is_cupcake_all_env env\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       Big_Step_Unclocked_Single.evaluate_list\n        (Big_Step_Unclocked_Single.evaluate env) s es\n        (s', sequence_result rs)", "by (fastforce intro:cupcake_list_correct0 list_all2_shortcircuit_weaken cupcake_single_correct)+"], ["", "private"], ["", "lemma cupcake_list_complete0:\n  \"evaluate_list\n     (\\<lambda>s e r. evaluate env s e r \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> cupcake_evaluate_single env e (snd r))) s1 es res \\<Longrightarrow>\n    is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es  \\<Longrightarrow>  \\<exists>rs. list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<and> sequence_result rs = (snd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n              (\\<lambda>s e r.\n                  Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n                  (is_cupcake_all_env env \\<longrightarrow>\n                   is_cupcake_exp e \\<longrightarrow>\n                   cupcake_evaluate_single env e (snd r)))\n              s1 es res;\n     is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs.\n                         list_all2_shortcircuit\n                          (cupcake_evaluate_single env) es rs \\<and>\n                         sequence_result rs = snd res", "proof (induction rule:evaluate_list.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) [] rs \\<and>\n                            sequence_result rs = snd (s, Rval [])\n 2. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 3. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 4. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "case empty"], ["proof (state)\nthis:\n  is_cupcake_all_env env\n  list_all is_cupcake_exp []\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) [] rs \\<and>\n                            sequence_result rs = snd (s, Rval [])\n 2. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 3. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 4. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "have \"list_all2_shortcircuit (cupcake_evaluate_single env) [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2_shortcircuit (cupcake_evaluate_single env) [] []", "by fastforce"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) [] []\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) [] rs \\<and>\n                            sequence_result rs = snd (s, Rval [])\n 2. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 3. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 4. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "then"], ["proof (chain)\npicking this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) [] []", "show ?case"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) [] []\n\ngoal (1 subgoal):\n 1. \\<exists>rs.\n       list_all2_shortcircuit (cupcake_evaluate_single env) [] rs \\<and>\n       sequence_result rs = snd (s_, Rval [])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs.\n     list_all2_shortcircuit (cupcake_evaluate_single env) [] rs \\<and>\n     sequence_result rs = snd (s_, Rval [])\n\ngoal (3 subgoals):\n 1. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 2. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 3. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 2. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 3. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "case (cons1 s1 e s2 v es s3 vs)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rval vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (3 subgoals):\n 1. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 2. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 3. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "then"], ["proof (chain)\npicking this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rval vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)", "obtain rs where \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs\"\n    and \"sequence_result rs = Rval vs\"\n    and \"list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) (Rval v # rs)\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rval vs)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env) es rs;\n         sequence_result rs = Rval vs;\n         list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n          (Rval v # rs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce+"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rval vs\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n\ngoal (3 subgoals):\n 1. \\<And>s1 e s2 v es s3 vs.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rval vs);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rval vs);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rval (v # vs))\n 2. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 3. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "then"], ["proof (chain)\npicking this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rval vs\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)", "show ?case"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rval vs\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n\ngoal (1 subgoal):\n 1. \\<exists>rs.\n       list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n        rs \\<and>\n       sequence_result rs = snd (s3, Rval (v # vs))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs.\n     list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) rs \\<and>\n     sequence_result rs = snd (s3, Rval (v # vs))\n\ngoal (2 subgoals):\n 1. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 2. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 2. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "case (cons2 s1 e s2 err es)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rerr err)))\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (2 subgoals):\n 1. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 2. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "hence \"list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) [Rerr err]\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rerr err)))\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) [Rerr err]", "by simp"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) [Rerr err]\n\ngoal (2 subgoals):\n 1. \\<And>s1 e s2 err es.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr err) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rerr err)));\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s2, Rerr err)\n 2. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "then"], ["proof (chain)\npicking this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) [Rerr err]", "show ?case"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) [Rerr err]\n\ngoal (1 subgoal):\n 1. \\<exists>rs.\n       list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n        rs \\<and>\n       sequence_result rs = snd (s2, Rerr err)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs.\n     list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) rs \\<and>\n     sequence_result rs = snd (s2, Rerr err)\n\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "case (cons3 s1 e s2 v es s3 err)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rerr err)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rerr err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "then"], ["proof (chain)\npicking this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rerr err)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rerr err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)", "obtain rs where \"list_all2_shortcircuit (cupcake_evaluate_single env) es rs\"\n    and err:\"sequence_result rs = Rerr err\"\n    and \"list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) (Rval v # rs)\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   is_cupcake_exp e \\<longrightarrow>\n   cupcake_evaluate_single env e (snd (s2, Rval v)))\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e r.\n       Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow>\n        cupcake_evaluate_single env e (snd r)))\n   s2 es (s3, Rerr err)\n  \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single env)\n                        es rs \\<and>\n                       sequence_result rs = snd (s3, Rerr err)\n  is_cupcake_all_env env\n  list_all is_cupcake_exp (e # es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env) es rs;\n         sequence_result rs = Rerr err;\n         list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n          (Rval v # rs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "moreover"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "have \"sequence_result (Rval v # rs) = Rerr err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_result (Rval v # rs) = Rerr err", "by (auto simp: error_result.map_id err)"], ["proof (state)\nthis:\n  sequence_result (Rval v # rs) = Rerr err\n\ngoal (1 subgoal):\n 1. \\<And>s1 e s2 v es s3 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rval v) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single env e (snd (s2, Rval v)));\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>s e r.\n             Big_Step_Unclocked_Single.evaluate env s e r \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp e \\<longrightarrow>\n              cupcake_evaluate_single env e (snd r)))\n         s2 es (s3, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rs.\n                             list_all2_shortcircuit\n                              (cupcake_evaluate_single env) es rs \\<and>\n                             sequence_result rs = snd (s3, Rerr err);\n        is_cupcake_all_env env; list_all is_cupcake_exp (e # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            list_all2_shortcircuit\n                             (cupcake_evaluate_single env) (e # es)\n                             rs \\<and>\n                            sequence_result rs = snd (s3, Rerr err)", "ultimately"], ["proof (chain)\npicking this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n  sequence_result (Rval v # rs) = Rerr err", "show ?case"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) es rs\n  sequence_result rs = Rerr err\n  list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n   (Rval v # rs)\n  sequence_result (Rval v # rs) = Rerr err\n\ngoal (1 subgoal):\n 1. \\<exists>rs.\n       list_all2_shortcircuit (cupcake_evaluate_single env) (e # es)\n        rs \\<and>\n       sequence_result rs = snd (s3, Rerr err)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>rs.\n     list_all2_shortcircuit (cupcake_evaluate_single env) (e # es) rs \\<and>\n     sequence_result rs = snd (s3, Rerr err)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma cupcake_single_complete0:\n\"evaluate env s e res \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> cupcake_evaluate_single env e (snd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s e res;\n     is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> cupcake_evaluate_single env e (snd res)", "proof (induction rule:evaluate.induct)"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rval v))\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow>\n               cupcake_evaluate_single env x2 (snd x3)))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                           (snd (s2, Rerr err))\nA total of 34 subgoals...", "case (con1 env cn es vs v s1 s2)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rval v))\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow>\n               cupcake_evaluate_single env x2 (snd x3)))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                           (snd (s2, Rerr err))\nA total of 34 subgoals...", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rval v))\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow>\n               cupcake_evaluate_single env x2 (snd x3)))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                           (snd (s2, Rerr err))\nA total of 34 subgoals...", "hence \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) (map Rval vs)\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit (cupcake_evaluate_single env) (rev es)\n     (map Rval vs)", "using cupcake_list_complete0 con1"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n            (\\<lambda>s e r.\n                Big_Step_Unclocked_Single.evaluate ?env s e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single ?env e (snd r)))\n            ?s1.0 ?es ?res;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single ?env)\n                        ?es rs \\<and>\n                       sequence_result rs = snd ?res\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all2_shortcircuit (cupcake_evaluate_single env) (rev es)\n     (map Rval vs)", "by fastforce"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es)\n   (map Rval vs)\n\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rval v))\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow>\n               cupcake_evaluate_single env x2 (snd x3)))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                           (snd (s2, Rerr err))\nA total of 34 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (Con cn es) (snd (s2, Rval v))", "by (simp|rule|fact)+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (Con cn es) (snd (s2, Rval v))\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rerr err))\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rval va))\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rerr err))\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rval va))\nA total of 33 subgoals...", "case (con3 env cn es s1 s2 err)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rerr err))\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rval va))\nA total of 33 subgoals...", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rerr err))\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rval va))\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "obtain rs where \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\" \"sequence_result rs = Rerr err\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rerr err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using con3"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rerr err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest:cupcake_list_complete0)"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rerr err\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow>\n              cupcake_evaluate_single env x2 (snd x3)))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s2, Rerr err))\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rval va))\nA total of 33 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (Con cn es) (snd (s2, Rerr err))", "by (simp;rule cupcake_evaluate_single.con3) fact+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (Con cn es) (snd (s2, Rerr err))\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "case (app1 env s1 es s2 vs env' e bv)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)", "obtain rs where rs: \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\" \"sequence_result rs = Rval vs\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rval vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest:cupcake_list_complete0)"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by fastforce"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "hence \"list_all is_cupcake_value vs\" \"list_all is_cupcake_value (rev vs)\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value vs &&& list_all is_cupcake_value (rev vs)", "using cupcake_list_preserve app1 rs"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single ?env) ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value vs &&& list_all is_cupcake_value (rev vs)", "by fastforce+"], ["proof (state)\nthis:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "hence \"is_cupcake_exp e\" \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "using app1 cupcake_opapp_preserve"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_all_env ?env\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp ?e\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "by fastforce+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "hence \"cupcake_evaluate_single env' e (snd bv)\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env' e (snd bv)", "using app1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env' e (snd bv)\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env' e (snd bv)", "by fastforce"], ["proof (state)\nthis:\n  cupcake_evaluate_single env' e (snd bv)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 32 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (App Opapp es) (snd bv)", "by rule fact+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (App Opapp es) (snd bv)\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 31 subgoals...", "case (app3 env s1 es s2 vs)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 31 subgoals...", "hence \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by simp"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 31 subgoals...", "obtain rs where \" list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\" \"sequence_result rs = Rval vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rval vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using app3 cupcake_list_complete0"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rval vs)\n  do_opapp (rev vs) = None\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n            (\\<lambda>s e r.\n                Big_Step_Unclocked_Single.evaluate ?env s e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single ?env e (snd r)))\n            ?s1.0 ?es ?res;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single ?env)\n                        ?es rs \\<and>\n                       sequence_result rs = snd ?res\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rval vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 31 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (App Opapp es)\n     (snd (s2, Rerr (Rabort Rtype_error)))", "by (simp|rule|fact)+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (App Opapp es)\n   (snd (s2, Rerr (Rabort Rtype_error)))\n\ngoal (30 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 30 subgoals...", "case (app6 env s1 es s2 err op0)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (App op0 es)\n\ngoal (30 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 30 subgoals...", "obtain rs where \" list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\" \"sequence_result rs = Rerr err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rerr err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cupcake_list_complete0 app6"], ["proof (prove)\nusing this:\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n            (\\<lambda>s e r.\n                Big_Step_Unclocked_Single.evaluate ?env s e r \\<and>\n                (is_cupcake_all_env ?env \\<longrightarrow>\n                 is_cupcake_exp e \\<longrightarrow>\n                 cupcake_evaluate_single ?env e (snd r)))\n            ?s1.0 ?es ?res;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs.\n                       list_all2_shortcircuit (cupcake_evaluate_single ?env)\n                        ?es rs \\<and>\n                       sequence_result rs = snd ?res\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow>\n        cupcake_evaluate_single env x2 (snd x3)))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (App op0 es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rerr err\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rerr err\n\ngoal (30 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 30 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (App op0 es) (snd (s2, Rerr err))", "by (simp|rule|fact)+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (App op0 es) (snd (s2, Rerr err))\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "case (mat1 env s1 e s2 v1 pes e' env' bv)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     e' (snd bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "hence \"is_cupcake_exp e\" and \"cupcake_c_ns (c env)\" and pes:\"cupcake_clauses pes\" and \"is_cupcake_value v1\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     e' (snd bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (is_cupcake_exp e &&& cupcake_c_ns (c env)) &&&\n    cupcake_clauses pes &&& is_cupcake_value v1", "by (fastforce dest: is_cupcake_all_envD cupcake_single_preserve)+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "obtain uu where \"cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uu.\n        cupcake_match_result (c env) v1 pes Bindv =\n        Rval (e', uu, env') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cupcake_match_result_eq[OF pes,where env = env and s= s2 and v = v1 and err_v = Bindv, unfolded mat1]"], ["proof (prove)\nusing this:\n  Rval (e', env') =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. (\\<And>uu.\n        cupcake_match_result (c env) v1 pes Bindv =\n        Rval (e', uu, env') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"cupcake_match_result (c env) v1 pes Bindv\") auto"], ["proof (state)\nthis:\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')", "have \"list_all (is_cupcake_value \\<circ> snd) env'\" \"is_cupcake_exp e'\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "using cupcake_match_result_preserve[where envC = \"c env\" and v = v1 and pes = pes and err_v = Bindv]"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n  \\<lbrakk>cupcake_c_ns (c env); cupcake_clauses pes;\n   is_cupcake_value v1\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>(e, p, env').\n                         is_cupcake_pat p \\<and>\n                         is_cupcake_exp e \\<and>\n                         list_all (is_cupcake_value \\<circ> snd) env')\n                     (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "by fastforce+"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "moreover"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "have \"is_cupcake_all_env (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)", "apply (rule cupcake_v_update_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply (rule cupcake_nsAppend_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns (alist_to_ns env')\n 2. is_cupcake_ns (sem_env.v env)", "apply (rule cupcake_alist_to_ns_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_ns (sem_env.v env)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (sem_env.v env)", "apply (rule is_cupcake_all_envD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)", "have \"cupcake_evaluate_single env e (Rval v1)\"\n    and \"cupcake_evaluate_single (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env) e' (snd bv)\""], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env e (Rval v1) &&&\n    cupcake_evaluate_single\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)\n     e' (snd bv)", "using mat1"], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env)\n                     e' (snd bv)\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env e (Rval v1) &&&\n    cupcake_evaluate_single\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)\n     e' (snd bv)", "by fastforce+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval v1)\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   e' (snd bv)\n\ngoal (29 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 29 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (Mat e pes) (snd bv)", "by (rule cupcake_evaluate_single.mat1) fact+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (Mat e pes) (snd bv)\n\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "case (mat1b env s1 e s2 v1 pes err)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "hence \"is_cupcake_exp e\" and pes: \"cupcake_clauses pes\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& cupcake_clauses pes", "by (auto dest: is_cupcake_all_envD)"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_clauses pes\n\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "have \"cupcake_evaluate_single env e (Rval v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env e (Rval v1)", "using mat1b"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rerr err\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v1))\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env e (Rval v1)", "by fastforce"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval v1)\n\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "have \"cupcake_match_result (c env) v1 pes Bindv = Rerr err\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_match_result (c env) v1 pes Bindv = Rerr err", "using cupcake_match_result_eq[OF pes, where env = env and s = s2 and v = v1 and err_v = Bindv]"], ["proof (prove)\nusing this:\n  match_result env s2 v1 pes Bindv =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. cupcake_match_result (c env) v1 pes Bindv = Rerr err", "unfolding mat1b"], ["proof (prove)\nusing this:\n  Rerr err =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. cupcake_match_result (c env) v1 pes Bindv = Rerr err", "by (cases \"(cupcake_match_result (c env) v1 pes Bindv)\") (auto simp:error_result.map_id)"], ["proof (state)\nthis:\n  cupcake_match_result (c env) v1 pes Bindv = Rerr err\n\ngoal (28 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 28 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env (Mat e pes) (snd (s2, Rerr err))", "by (simp; rule cupcake_evaluate_single.mat1error) fact+"], ["proof (state)\nthis:\n  cupcake_evaluate_single env (Mat e pes) (snd (s2, Rerr err))\n\ngoal (27 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Lit l)\n                          (snd (s, Rval (Litv l)))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr (Rraise v)))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr err));\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Raise e)\n                          (snd (s2, Rerr err))\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e (snd (s2, Rval v));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rval v))\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise va)));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single\n                           (update_v\n                             (\\<lambda>_.\n                                 nsAppend (alist_to_ns env')\n                                  (sem_env.v env))\n                             env)\n                           e' (snd bv);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes) (snd bv)\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rraise v)));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr err))\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env e\n                           (snd (s2, Rerr (Rabort a)));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Handle e pes)\n                          (snd (s2, Rerr (Rabort a)))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Con cn es)\n                          (snd (s, Rerr (Rabort Rtype_error)))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                          (snd (s, Rval va))\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> cupcake_evaluate_single env (Var n)\n                           (snd (s, Rerr (Rabort Rtype_error)))\nA total of 27 subgoals...", "qed (fastforce intro: cupcake_evaluate_single.intros)+"], ["", "lemma cupcake_single_complete:\n  \"evaluate env s e (s', res) \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> cupcake_evaluate_single env e res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s e (s', res);\n     is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> cupcake_evaluate_single env e res", "by (fastforce dest:cupcake_single_complete0)"], ["", "lemma cupcake_list_complete:\n  \"evaluate_list (evaluate env) s1 es res \\<Longrightarrow>\n    is_cupcake_all_env env \\<Longrightarrow> list_all is_cupcake_exp es  \\<Longrightarrow>  \\<exists>rs. list_all2_shortcircuit (cupcake_evaluate_single env) es rs \\<and> sequence_result rs = (snd res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate_list\n              (Big_Step_Unclocked_Single.evaluate env) s1 es res;\n     is_cupcake_all_env env; list_all is_cupcake_exp es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs.\n                         list_all2_shortcircuit\n                          (cupcake_evaluate_single env) es rs \\<and>\n                         sequence_result rs = snd res", "by (fastforce intro:cupcake_list_complete0 cupcake_single_complete evaluate_list_mono_strong)"], ["", "private"], ["", "lemma cupcake_list_state_preserve0:\n  assumes \"evaluate_list (\\<lambda>s e res. Big_Step_Unclocked_Single.evaluate env s e res \\<and> (is_cupcake_all_env env \\<longrightarrow> is_cupcake_exp e \\<longrightarrow> s = fst res)) s es res\"\n          \"list_all is_cupcake_exp es\" \"is_cupcake_all_env env\"\n        shows \"s = (fst res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = fst res", "using assms"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>s e res.\n       Big_Step_Unclocked_Single.evaluate env s e res \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp e \\<longrightarrow> s = fst res))\n   s es res\n  list_all is_cupcake_exp es\n  is_cupcake_all_env env\n\ngoal (1 subgoal):\n 1. s = fst res", "by (induction rule:evaluate_list.induct) auto"], ["", "lemma cupcake_state_preserve:\n  assumes \"Big_Step_Unclocked_Single.evaluate env s e res\" \"is_cupcake_all_env env\" \"is_cupcake_exp e\"\n  shows \"s = (fst res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = fst res", "using assms"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s e res\n  is_cupcake_all_env env\n  is_cupcake_exp e\n\ngoal (1 subgoal):\n 1. s = fst res", "proof (induction arbitrary: rule: evaluate.induct)"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err)\nA total of 34 subgoals...", "case (con1 env cn es vs v s1 s2)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err)\nA total of 34 subgoals...", "hence \"list_all is_cupcake_exp es\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp es", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp es\n\ngoal (34 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es vs v s1 s2.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        build_conv (c env) cn (rev vs) = Some v;\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rval vs);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 9. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 10. \\<And>env cn es s1 s2 err.\n        \\<lbrakk>do_con_check (c env) cn (length es);\n         Big_Step_Unclocked_Single.evaluate_list\n          (\\<lambda>x1 x2 x3.\n              Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n              (is_cupcake_all_env env \\<longrightarrow>\n               is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n          s1 (rev es) (s2, Rerr err);\n         is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err)\nA total of 34 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp es", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. s1 = fst (s2, Rval v)", "using con1"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp es\n  do_con_check (c env) cn (length es)\n  build_conv (c env) cn (rev vs) = Some v\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. s1 = fst (s2, Rval v)", "by (fastforce dest:cupcake_list_state_preserve0)"], ["proof (state)\nthis:\n  s1 = fst (s2, Rval v)\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rval va)\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rval va)\nA total of 33 subgoals...", "case (con3 env cn es s1 s2 err)"], ["proof (state)\nthis:\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rval va)\nA total of 33 subgoals...", "hence \"list_all is_cupcake_exp es\""], ["proof (prove)\nusing this:\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp es", "by (cases rule: is_cupcake_exp.cases[where x = \"Con cn es\"]) auto"], ["proof (state)\nthis:\n  list_all is_cupcake_exp es\n\ngoal (33 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env cn es s1 s2 err.\n       \\<lbrakk>do_con_check (c env) cn (length es);\n        Big_Step_Unclocked_Single.evaluate_list\n         (\\<lambda>x1 x2 x3.\n             Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n         s1 (rev es) (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 10. \\<And>env n va s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n         is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rval va)\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp es", "show ?case"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp es\n\ngoal (1 subgoal):\n 1. s1 = fst (s2, Rerr err)", "using con3"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp es\n  do_con_check (c env) cn (length es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rerr err)\n  is_cupcake_all_env env\n  is_cupcake_exp (Con cn es)\n\ngoal (1 subgoal):\n 1. s1 = fst (s2, Rerr err)", "by (fastforce dest:cupcake_list_state_preserve0)"], ["proof (state)\nthis:\n  s1 = fst (s2, Rerr err)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "case (app1 env s1 es s2 vs env' e bv)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "have \"list_all is_cupcake_exp (rev es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "using app1"], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_exp (rev es)", "by fastforce"], ["proof (state)\nthis:\n  list_all is_cupcake_exp (rev es)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  list_all is_cupcake_exp (rev es)", "obtain rs where rs: \"list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\" \"sequence_result rs = Rval vs\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rval vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using app1"], ["proof (prove)\nusing this:\n  list_all is_cupcake_exp (rev es)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single env)\n                  (rev es) rs;\n         sequence_result rs = Rval vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest:evaluate_list_mono_strong[THEN cupcake_list_complete])"], ["proof (state)\nthis:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "hence \"list_all is_cupcake_value vs\" \"list_all is_cupcake_value (rev vs)\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value vs &&& list_all is_cupcake_value (rev vs)", "using cupcake_list_preserve app1 rs"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n  \\<lbrakk>list_all2_shortcircuit (cupcake_evaluate_single ?env) ?es ?rs;\n   is_cupcake_all_env ?env; list_all is_cupcake_exp ?es;\n   sequence_result ?rs = Rval ?vs\\<rbrakk>\n  \\<Longrightarrow> list_all is_cupcake_value ?vs\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  list_all2_shortcircuit (cupcake_evaluate_single env) (rev es) rs\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value vs &&& list_all is_cupcake_value (rev vs)", "by fastforce+"], ["proof (state)\nthis:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "hence \"is_cupcake_exp e\" \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "using app1 cupcake_opapp_preserve"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value vs\n  list_all is_cupcake_value (rev vs)\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_all_env ?env\n  \\<lbrakk>do_opapp ?vs = Some (?env, ?e);\n   list_all is_cupcake_value ?vs\\<rbrakk>\n  \\<Longrightarrow> is_cupcake_exp ?e\n\ngoal (1 subgoal):\n 1. is_cupcake_exp e &&& is_cupcake_all_env env'", "by fastforce+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (32 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'", "show ?case"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n\ngoal (1 subgoal):\n 1. s1 = fst bv", "using app1"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  is_cupcake_all_env env'\n  Big_Step_Unclocked_Single.evaluate_list\n   (\\<lambda>x1 x2 x3.\n       Big_Step_Unclocked_Single.evaluate env x1 x2 x3 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        is_cupcake_exp x2 \\<longrightarrow> x1 = fst x3))\n   s1 (rev es) (s2, Rval vs)\n  \\<lbrakk>is_cupcake_all_env env'; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  do_opapp (rev vs) = Some (env', e)\n  Big_Step_Unclocked_Single.evaluate env' s2 e bv\n  is_cupcake_all_env env\n  is_cupcake_exp (App Opapp es)\n\ngoal (1 subgoal):\n 1. s1 = fst bv", "by (fastforce dest:cupcake_list_state_preserve0)"], ["proof (state)\nthis:\n  s1 = fst bv\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "case (mat1 env s1 e s2 v1 pes e' env' bv)"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s1 = fst (s2, Rval v1)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "hence \"is_cupcake_exp e\" and \"cupcake_c_ns (c env)\" and pes:\"cupcake_clauses pes\" and \"is_cupcake_value v1\""], ["proof (prove)\nusing this:\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s1 = fst (s2, Rval v1)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. (is_cupcake_exp e &&& cupcake_c_ns (c env)) &&&\n    cupcake_clauses pes &&& is_cupcake_value v1", "by (fastforce dest: is_cupcake_all_envD cupcake_single_complete cupcake_single_preserve)+"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "moreover"], ["proof (state)\nthis:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "obtain uu where \"cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>uu.\n        cupcake_match_result (c env) v1 pes Bindv =\n        Rval (e', uu, env') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cupcake_match_result_eq[OF pes,where env = env and s= s2 and v = v1 and err_v = Bindv, unfolded mat1]"], ["proof (prove)\nusing this:\n  Rval (e', env') =\n  map_result (\\<lambda>(e, uu_, env'). (e, env')) id\n   (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. (\\<And>uu.\n        cupcake_match_result (c env) v1 pes Bindv =\n        Rval (e', uu, env') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"cupcake_match_result (c env) v1 pes Bindv\") auto"], ["proof (state)\nthis:\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')", "have \"list_all (is_cupcake_value \\<circ> snd) env'\" \"is_cupcake_exp e'\""], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "using cupcake_match_result_preserve[where envC = \"c env\" and v = v1 and pes = pes and err_v = Bindv]"], ["proof (prove)\nusing this:\n  is_cupcake_exp e\n  cupcake_c_ns (c env)\n  cupcake_clauses pes\n  is_cupcake_value v1\n  cupcake_match_result (c env) v1 pes Bindv = Rval (e', uu, env')\n  \\<lbrakk>cupcake_c_ns (c env); cupcake_clauses pes;\n   is_cupcake_value v1\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>(e, p, env').\n                         is_cupcake_pat p \\<and>\n                         is_cupcake_exp e \\<and>\n                         list_all (is_cupcake_value \\<circ> snd) env')\n                     (cupcake_match_result (c env) v1 pes Bindv)\n\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env' &&& is_cupcake_exp e'", "by fastforce+"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "moreover"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "have \"is_cupcake_all_env (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)", "apply (rule cupcake_v_update_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "apply (rule cupcake_nsAppend_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns (alist_to_ns env')\n 2. is_cupcake_ns (sem_env.v env)", "apply (rule cupcake_alist_to_ns_preserve)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (is_cupcake_value \\<circ> snd) env'\n 2. is_cupcake_ns (sem_env.v env)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (sem_env.v env)", "apply (rule is_cupcake_all_envD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env env", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (31 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 31 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)", "show ?case"], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (1 subgoal):\n 1. s1 = fst bv", "using mat1"], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n  is_cupcake_exp e'\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n  Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v1)\n  match_result env s2 v1 pes Bindv = Rval (e', env')\n  Big_Step_Unclocked_Single.evaluate\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   s2 e' bv\n  \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n  \\<Longrightarrow> s1 = fst (s2, Rval v1)\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   is_cupcake_exp e'\\<rbrakk>\n  \\<Longrightarrow> s2 = fst bv\n  is_cupcake_all_env env\n  is_cupcake_exp (Mat e pes)\n\ngoal (1 subgoal):\n 1. s1 = fst bv", "by fastforce"], ["proof (state)\nthis:\n  s1 = fst bv\n\ngoal (30 subgoals):\n 1. \\<And>env s l.\n       \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp (Lit l)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval (Litv l))\n 2. \\<And>env s1 e s2 v.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v))\n 3. \\<And>env s1 e s2 err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rerr err);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr err);\n        is_cupcake_all_env env; is_cupcake_exp (Raise e)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 4. \\<And>env s1 e s2 v pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e (s2, Rval v);\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rval v);\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rval v)\n 5. \\<And>env s1 e s2 va pes e' env' bv.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise va));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise va));\n        match_result env s2 va pes va = Rval (e', env');\n        Big_Step_Unclocked_Single.evaluate\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         s2 e' bv;\n        \\<lbrakk>is_cupcake_all_env\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env);\n         is_cupcake_exp e'\\<rbrakk>\n        \\<Longrightarrow> s2 = fst bv;\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst bv\n 6. \\<And>env s1 e s2 v pes err.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rraise v));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rraise v));\n        match_result env s2 v pes v = Rerr err; is_cupcake_all_env env;\n        is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr err)\n 7. \\<And>env s1 e s2 a pes.\n       \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s1 e\n                 (s2, Rerr (Rabort a));\n        \\<lbrakk>is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n        \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a));\n        is_cupcake_all_env env; is_cupcake_exp (Handle e pes)\\<rbrakk>\n       \\<Longrightarrow> s1 = fst (s2, Rerr (Rabort a))\n 8. \\<And>env cn es s.\n       \\<lbrakk>\\<not> do_con_check (c env) cn (length es);\n        is_cupcake_all_env env; is_cupcake_exp (Con cn es)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\n 9. \\<And>env n va s.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some va;\n        is_cupcake_all_env env; is_cupcake_exp (Var n)\\<rbrakk>\n       \\<Longrightarrow> s = fst (s, Rval va)\n 10. \\<And>env n s.\n        \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n         is_cupcake_exp (Var n)\\<rbrakk>\n        \\<Longrightarrow> s = fst (s, Rerr (Rabort Rtype_error))\nA total of 30 subgoals...", "qed (fastforce dest:cupcake_list_state_preserve0)+"], ["", "corollary cupcake_single_correct_strong:\n  assumes \"cupcake_evaluate_single env e res\" \"is_cupcake_all_env env\" \"is_cupcake_exp e\"\n  shows \"Big_Step_Unclocked_Single.evaluate env s e (s,res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate env s e (s, res)", "using assms cupcake_single_correct cupcake_state_preserve"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e res\n  is_cupcake_all_env env\n  is_cupcake_exp e\n  \\<lbrakk>cupcake_evaluate_single ?env ?e ?res; is_cupcake_all_env ?env;\n   is_cupcake_exp ?e\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       Big_Step_Unclocked_Single.evaluate ?env ?s ?e\n                        (s', ?res)\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate ?env ?s ?e ?res;\n   is_cupcake_all_env ?env; is_cupcake_exp ?e\\<rbrakk>\n  \\<Longrightarrow> ?s = fst ?res\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate env s e (s, res)", "by fastforce"], ["", "corollary cupcake_single_complete_weak:\n  \"evaluate env s e (s, res) \\<Longrightarrow> is_cupcake_all_env env \\<Longrightarrow> is_cupcake_exp e \\<Longrightarrow> cupcake_evaluate_single env e res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s e (s, res);\n     is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> cupcake_evaluate_single env e res", "using cupcake_single_complete"], ["proof (prove)\nusing this:\n  \\<lbrakk>Big_Step_Unclocked_Single.evaluate ?env ?s ?e (?s', ?res);\n   is_cupcake_all_env ?env; is_cupcake_exp ?e\\<rbrakk>\n  \\<Longrightarrow> cupcake_evaluate_single ?env ?e ?res\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Big_Step_Unclocked_Single.evaluate env s e (s, res);\n     is_cupcake_all_env env; is_cupcake_exp e\\<rbrakk>\n    \\<Longrightarrow> cupcake_evaluate_single env e res", "by fastforce"], ["", "end"], ["", "end"], ["", "hide_const (open) c"], ["", "end"]]}