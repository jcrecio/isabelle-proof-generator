{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Backend/CakeML_Correctness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma mk_rec_env_related:\n  assumes \"fmrel (\\<lambda>cs (n, e). related_fun cs n e) css (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\"\n  assumes \"fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\"\n  shows \"fmrel related_v (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\"", "lemma mk_exp_correctness:\n  \"ids t |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts t \\<Longrightarrow> related_exp t (mk_exp S t)\"\n  \"ids (Sabs cs) |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts (Sabs cs) \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs (mk_clauses S cs)\"\n  \"ids t |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts t \\<Longrightarrow> related_exp t (mk_con S t)\"", "lemma semantic_correctness0:\n  fixes exp\n  assumes \"cupcake_evaluate_single env exp r\" \"is_cupcake_all_env env\"\n  assumes \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\"\n  assumes \"related_exp t exp\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\"\n  assumes \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  shows \"if_rval (\\<lambda>ml_v. \\<exists>v. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v) r\"", "theorem semantic_correctness:\n  fixes exp\n  assumes \"cupcake_evaluate_single env exp (Rval ml_v)\" \"is_cupcake_all_env env\"\n  assumes \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\"\n  assumes \"related_exp t exp\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\"\n  assumes \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  obtains v where \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"related_v v ml_v\""], "translations": [["", "lemma mk_rec_env_related:\n  assumes \"fmrel (\\<lambda>cs (n, e). related_fun cs n e) css (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\"\n  assumes \"fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\"\n  shows \"fmrel related_v (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel related_v (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)", "proof (rule fmrelI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "have \"rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name) (map_of (map (map_prod Name (map_prod Name id)) funs) name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n     (map_of (map (map_prod Name (map_prod Name id)) funs) name)", "using assms"], ["proof (prove)\nusing this:\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n  fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n   \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n     (map_of (map (map_prod Name (map_prod Name id)) funs) name)", "by (auto simp: fmap_of_list.rep_eq)"], ["proof (state)\nthis:\n  rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n   (map_of (map (map_prod Name (map_prod Name id)) funs) name)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "then"], ["proof (chain)\npicking this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n   (map_of (map (map_prod Name (map_prod Name id)) funs) name)", "have \"rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e) (fmlookup css name) (map_of funs (as_string name))\""], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n   (map_of (map (map_prod Name (map_prod Name id)) funs) name)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n     (fmlookup css name) (map_of funs (as_string name))", "unfolding name.map_of_rekey'"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs n e) (fmlookup css name)\n   (map_option (map_prod Name id) (map_of funs (as_string name)))\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n     (fmlookup css name) (map_of funs (as_string name))", "by cases auto"], ["proof (state)\nthis:\n  rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n   (fmlookup css name) (map_of funs (as_string name))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "have *: \"related_v (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) (Recclosure env\\<^sub>\\<Lambda> funs (as_string name))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n     (Recclosure env\\<^sub>\\<Lambda> funs (as_string name))", "using assms"], ["proof (prove)\nusing this:\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n  fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n   \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. related_v (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n     (Recclosure env\\<^sub>\\<Lambda> funs (as_string name))", "by (auto intro: related_v.rec_closure)"], ["proof (state)\nthis:\n  related_v (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n   (Recclosure env\\<^sub>\\<Lambda> funs (as_string name))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "show \"rel_option related_v (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) name) (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v\n     (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) name)\n     (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) name)", "unfolding mk_rec_env_def cake_mk_rec_env_def fmap_of_list.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v\n     (fmlookup\n       (fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css)\n       name)\n     (map_of\n       (map (\\<lambda>(f, uu_).\n                (Name f, Recclosure env\\<^sub>\\<Lambda> funs f))\n         funs)\n       name)", "apply (simp add: map_of_map_keyed name.map_of_rekey option.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x y.\n         related_v (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n          (Recclosure env\\<^sub>\\<Lambda> funs (as_string name)))\n     (fmlookup css name) (map_of funs (as_string name))", "apply (rule option.rel_mono_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_option ?R (fmlookup css name) (map_of funs (as_string name))\n 2. \\<And>z yb.\n       \\<lbrakk>z \\<in> set_option (fmlookup css name);\n        yb \\<in> set_option (map_of funs (as_string name)); ?R z yb\\<rbrakk>\n       \\<Longrightarrow> related_v\n                          (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                          (Recclosure env\\<^sub>\\<Lambda> funs\n                            (as_string name))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z yb.\n       \\<lbrakk>z \\<in> set_option (fmlookup css name);\n        yb \\<in> set_option (map_of funs (as_string name));\n        case yb of (n, e) \\<Rightarrow> related_fun z (Name n) e\\<rbrakk>\n       \\<Longrightarrow> related_v\n                          (Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                          (Recclosure env\\<^sub>\\<Lambda> funs\n                            (as_string name))", "apply (rule *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option related_v\n   (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) name)\n   (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) name)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_exp_correctness:\n  \"ids t |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts t \\<Longrightarrow> related_exp t (mk_exp S t)\"\n  \"ids (Sabs cs) |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts (Sabs cs) \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs (mk_clauses S cs)\"\n  \"ids t |\\<subseteq>| S \\<Longrightarrow> all_consts |\\<subseteq>| S \\<Longrightarrow> \\<not> shadows_consts t \\<Longrightarrow> related_exp t (mk_con S t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n      \\<not> shadows_consts t\\<rbrakk>\n     \\<Longrightarrow> related_exp t (mk_exp S t)) &&&\n    (\\<lbrakk>ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n      \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n     \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                        (mk_clauses S cs)) &&&\n    (\\<lbrakk>ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n      \\<not> shadows_consts t\\<rbrakk>\n     \\<Longrightarrow> related_exp t (mk_con S t))", "proof (induction rule: mk_exp_mk_clauses_mk_con.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>uv_ s.\n       \\<lbrakk>ids (Sconst s) |\\<subseteq>| uv_;\n        all_consts |\\<subseteq>| uv_;\n        \\<not> shadows_consts (Sconst s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sconst s) (mk_exp uv_ (Sconst s))\n 3. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 5. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 6. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "case (2 S name)"], ["proof (state)\nthis:\n  ids (Sconst name) |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts (Sconst name)\n\ngoal (6 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>uv_ s.\n       \\<lbrakk>ids (Sconst s) |\\<subseteq>| uv_;\n        all_consts |\\<subseteq>| uv_;\n        \\<not> shadows_consts (Sconst s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sconst s) (mk_exp uv_ (Sconst s))\n 3. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 5. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 6. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sconst name) (mk_exp S (Sconst name))", "proof (cases \"name |\\<in>| C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. name |\\<in>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))\n 2. name |\\<notin>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))", "case True"], ["proof (state)\nthis:\n  name |\\<in>| C\n\ngoal (2 subgoals):\n 1. name |\\<in>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))\n 2. name |\\<notin>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))", "hence \"related_exp (name $$ []) (mk_exp S (Sconst name))\""], ["proof (prove)\nusing this:\n  name |\\<in>| C\n\ngoal (1 subgoal):\n 1. related_exp (name $$ []) (mk_exp S (Sconst name))", "by (auto intro: related_exp.intros simp del: list_comb.simps)"], ["proof (state)\nthis:\n  related_exp (name $$ []) (mk_exp S (Sconst name))\n\ngoal (2 subgoals):\n 1. name |\\<in>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))\n 2. name |\\<notin>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))", "thus ?thesis"], ["proof (prove)\nusing this:\n  related_exp (name $$ []) (mk_exp S (Sconst name))\n\ngoal (1 subgoal):\n 1. related_exp (Sconst name) (mk_exp S (Sconst name))", "by (simp add: const_sterm_def)"], ["proof (state)\nthis:\n  related_exp (Sconst name) (mk_exp S (Sconst name))\n\ngoal (1 subgoal):\n 1. name |\\<notin>| C \\<Longrightarrow>\n    related_exp (Sconst name) (mk_exp S (Sconst name))", "qed (auto intro: related_exp.intros)"], ["proof (state)\nthis:\n  related_exp (Sconst name) (mk_exp S (Sconst name))\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "case (4 S cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 = fresh_fNext S; ids (Sabs cs) |\\<subseteq>| S;\n   all_consts |\\<subseteq>| S; \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                     (mk_clauses S cs)\n  ids (Sabs cs) |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "have \"fresh_fNext (S |\\<union>| all_consts) |\\<notin>| S |\\<union>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_fNext (S |\\<union>| all_consts) |\\<notin>| S |\\<union>| all_consts", "by (rule fNext_not_member)"], ["proof (state)\nthis:\n  fresh_fNext (S |\\<union>| all_consts) |\\<notin>| S |\\<union>| all_consts\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "hence \"fresh_fNext S |\\<notin>| S |\\<union>| all_consts\""], ["proof (prove)\nusing this:\n  fresh_fNext (S |\\<union>| all_consts) |\\<notin>| S |\\<union>| all_consts\n\ngoal (1 subgoal):\n 1. fresh_fNext S |\\<notin>| S |\\<union>| all_consts", "using \\<open>all_consts |\\<subseteq>| S\\<close>"], ["proof (prove)\nusing this:\n  fresh_fNext (S |\\<union>| all_consts) |\\<notin>| S |\\<union>| all_consts\n  all_consts |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. fresh_fNext S |\\<notin>| S |\\<union>| all_consts", "by (simp add: sup_absorb1)"], ["proof (state)\nthis:\n  fresh_fNext S |\\<notin>| S |\\<union>| all_consts\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "hence \"fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts\""], ["proof (prove)\nusing this:\n  fresh_fNext S |\\<notin>| S |\\<union>| all_consts\n\ngoal (1 subgoal):\n 1. fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts", "using 4"], ["proof (prove)\nusing this:\n  fresh_fNext S |\\<notin>| S |\\<union>| all_consts\n  \\<lbrakk>?x4 = fresh_fNext S; ids (Sabs cs) |\\<subseteq>| S;\n   all_consts |\\<subseteq>| S; \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n  \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                     (mk_clauses S cs)\n  ids (Sabs cs) |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts", "by auto"], ["proof (state)\nthis:\n  fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts\n\ngoal (5 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = fresh_fNext S;\n                    ids (Sabs cs) |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(rel_prod related_pat related_exp) cs (mk_clauses S cs);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Sabs cs) (mk_exp S (Sabs cs))\n 4. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 5. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs) (mk_exp S (Sabs cs))", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs)\n     (Fun (as_string (fresh_fNext S))\n       (Mat (Var (Short (as_string (fresh_fNext S))))\n         (map (\\<lambda>(pat, t).\n                  (mk_ml_pat (mk_pat pat),\n                   mk_con (frees pat |\\<union>| S) t))\n           cs)))", "apply (rule related_exp.fun)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all2 (rel_prod related_pat related_exp) cs\n     (map (\\<lambda>(pat, t).\n              (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t))\n       cs)\n 2. fresh_fNext S |\\<notin>| ids (Sabs cs)\n 3. fresh_fNext S |\\<notin>| all_consts", "apply (rule \"4.IH\"[unfolded mk_clauses.simps])"], ["proof (prove)\ngoal (6 subgoals):\n 1. ?x8 = fresh_fNext S\n 2. ids (Sabs cs) |\\<subseteq>| S\n 3. all_consts |\\<subseteq>| S\n 4. \\<not> shadows_consts (Sabs cs)\n 5. fresh_fNext S |\\<notin>| ids (Sabs cs)\n 6. fresh_fNext S |\\<notin>| all_consts", "apply (rule refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ids (Sabs cs) |\\<subseteq>| S\n 2. all_consts |\\<subseteq>| S\n 3. \\<not> shadows_consts (Sabs cs)\n 4. fresh_fNext S |\\<notin>| ids (Sabs cs)\n 5. fresh_fNext S |\\<notin>| all_consts", "apply fact+"], ["proof (prove)\ngoal (2 subgoals):\n 1. fresh_fNext S |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext S |\\<notin>| all_consts", "using \\<open>fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts\\<close>"], ["proof (prove)\nusing this:\n  fresh_fNext S |\\<notin>| ids (Sabs cs) |\\<union>| all_consts\n\ngoal (2 subgoals):\n 1. fresh_fNext S |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext S |\\<notin>| all_consts", "by auto"], ["proof (state)\nthis:\n  related_exp (Sabs cs) (mk_exp S (Sabs cs))\n\ngoal (4 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "case (5 S t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4; ?x1.4 |\\<in>| C;\n   ?xa4 \\<in> set ?y4; ids ?xa4 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts ?xa4\\<rbrakk>\n  \\<Longrightarrow> related_exp ?xa4 (mk_con S ?xa4)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4;\n   ?x1.4 |\\<notin>| C; ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Svar ?x2.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sabs ?x3.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = ?x41.4 $\\<^sub>s ?x42.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  ids t |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts t\n\ngoal (4 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S t.\n       \\<lbrakk>\\<And>x y x1 xa.\n                   \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1;\n                    x1 |\\<in>| C; xa \\<in> set y; ids xa |\\<subseteq>| S;\n                    all_consts |\\<subseteq>| S;\n                    \\<not> shadows_consts xa\\<rbrakk>\n                   \\<Longrightarrow> related_exp xa (mk_con S xa);\n        \\<And>x y x1.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sconst x1; x1 |\\<notin>| C;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x2.\n           \\<lbrakk>(x, y) = strip_comb t; x = Svar x2;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x3.\n           \\<lbrakk>(x, y) = strip_comb t; x = Sabs x3;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        \\<And>x y x41 x42.\n           \\<lbrakk>(x, y) = strip_comb t; x = x41 $\\<^sub>s x42;\n            ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n            \\<not> shadows_consts t\\<rbrakk>\n           \\<Longrightarrow> related_exp t (mk_exp S t);\n        ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts t\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_con S t)\n 4. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp t (mk_con S t)", "apply (simp add: mk_con.simps split!: prod.splits sterm.splits if_splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<in>| C\\<rbrakk>\n       \\<Longrightarrow> related_exp t\n                          (Con (Some (Short (as_string x1a)))\n                            (map (mk_con S) x2))\n 2. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_exp S t)\n 3. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 4. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 5. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)", "subgoal premises prems for args c"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp t (Con (Some (Short (as_string c))) (map (mk_con S) args))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. related_exp t (Con (Some (Short (as_string c))) (map (mk_con S) args))", "from prems"], ["proof (chain)\npicking this:\n  strip_comb t = (Sconst c, args)\n  c |\\<in>| C", "have \"t = c $$ args\""], ["proof (prove)\nusing this:\n  strip_comb t = (Sconst c, args)\n  c |\\<in>| C\n\ngoal (1 subgoal):\n 1. t = c $$ args", "apply (fold const_sterm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strip_comb t = (const c, args); c |\\<in>| C\\<rbrakk>\n    \\<Longrightarrow> t = c $$ args", "by (metis fst_conv list_strip_comb snd_conv)"], ["proof (state)\nthis:\n  t = c $$ args\n\ngoal (1 subgoal):\n 1. related_exp t (Con (Some (Short (as_string c))) (map (mk_con S) args))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp t (Con (Some (Short (as_string c))) (map (mk_con S) args))", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (c $$ args)\n     (Con (Some (Short (as_string c))) (map (mk_con S) args))", "apply (rule related_exp.constr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. c |\\<in>| C\n 2. list_all2 related_exp args (map (mk_con S) args)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 related_exp args (map (mk_con S) args)", "apply (simp add: list.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. related_exp x (mk_con S y)) args args", "apply (rule list.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> related_exp z (mk_con S z)", "apply (rule 5(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>z.\n       z \\<in> set args \\<Longrightarrow> (?x10 z, ?y10 z) = strip_comb t\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> ?x10 z = Sconst (?x1.10 z)\n 3. \\<And>z. z \\<in> set args \\<Longrightarrow> ?x1.10 z |\\<in>| C\n 4. \\<And>z. z \\<in> set args \\<Longrightarrow> z \\<in> set (?y10 z)\n 5. \\<And>z. z \\<in> set args \\<Longrightarrow> ids z |\\<subseteq>| S\n 6. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 7. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "apply (rule prems(1)[symmetric])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> Sconst c = Sconst (?x1.10 z)\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> ?x1.10 z |\\<in>| C\n 3. \\<And>z. z \\<in> set args \\<Longrightarrow> z \\<in> set args\n 4. \\<And>z. z \\<in> set args \\<Longrightarrow> ids z |\\<subseteq>| S\n 5. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 6. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "apply (rule refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> c |\\<in>| C\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> z \\<in> set args\n 3. \\<And>z. z \\<in> set args \\<Longrightarrow> ids z |\\<subseteq>| S\n 4. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 5. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> c |\\<in>| C", "by (rule prems)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> z \\<in> set args\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> ids z |\\<subseteq>| S\n 3. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 4. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> z_ \\<in> set args", "by assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> ids z |\\<subseteq>| S\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 3. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> ids z_ |\\<subseteq>| S", "using \\<open>ids t |\\<subseteq>| S\\<close>"], ["proof (prove)\nusing this:\n  ids t |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> ids z_ |\\<subseteq>| S", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  ids (c $$ args) |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> ids z_ |\\<subseteq>| S", "apply (auto simp: ids_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>z_ \\<in> set args; x |\\<in>| ids z_;\n        ids (const c) |\\<subseteq>| S;\n        ffUnion (ids |`| fset_of_list args) |\\<subseteq>| S\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "by (meson ffUnion_subset_elem fimage_eqI fset_of_list_elem fset_rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S\n 2. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> all_consts |\\<subseteq>| S", "by (rule 5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z_", "using \\<open>\\<not> shadows_consts t\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z_", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (c $$ args)\n\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z_", "unfolding shadows.list_comb"], ["proof (prove)\nusing this:\n  \\<not> (shadows_consts (const c) \\<or> list_ex shadows_consts args)\n\ngoal (1 subgoal):\n 1. z_ \\<in> set args \\<Longrightarrow> \\<not> shadows_consts z_", "by (auto simp: list_ex_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  related_exp t (Con (Some (Short (as_string c))) (map (mk_con S) args))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_exp S t)\n 2. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 3. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 4. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)", "using 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4; ?x1.4 |\\<in>| C;\n   ?xa4 \\<in> set ?y4; ids ?xa4 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts ?xa4\\<rbrakk>\n  \\<Longrightarrow> related_exp ?xa4 (mk_con S ?xa4)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sconst ?x1.4;\n   ?x1.4 |\\<notin>| C; ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Svar ?x2.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = Sabs ?x3.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  \\<lbrakk>(?x4, ?y4) = strip_comb t; ?x4 = ?x41.4 $\\<^sub>s ?x42.4;\n   ids t |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n   \\<not> shadows_consts t\\<rbrakk>\n  \\<Longrightarrow> related_exp t (mk_exp S t)\n  ids t |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts t\n\ngoal (4 subgoals):\n 1. \\<And>x2 x1a.\n       \\<lbrakk>strip_comb t = (Sconst x1a, x2); x1a |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> related_exp t (mk_exp S t)\n 2. \\<And>x2 x2a.\n       strip_comb t = (Svar x2a, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 3. \\<And>x2 x3.\n       strip_comb t = (Sabs x3, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)\n 4. \\<And>x2 x41 x42.\n       strip_comb t = (x41 $\\<^sub>s x42, x2) \\<Longrightarrow>\n       related_exp t (mk_exp S t)", "by (auto split: prod.splits sterm.splits)"], ["proof (state)\nthis:\n  related_exp t (mk_con S t)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "case (6 S cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x4 \\<in> set cs; (?xa4, ?y4) = ?x4;\n   ids ?y4 |\\<subseteq>| frees ?xa4 |\\<union>| S;\n   all_consts |\\<subseteq>| frees ?xa4 |\\<union>| S;\n   \\<not> shadows_consts ?y4\\<rbrakk>\n  \\<Longrightarrow> related_exp ?y4 (mk_con (frees ?xa4 |\\<union>| S) ?y4)\n  ids (Sabs cs) |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "have \"list_all2 (\\<lambda>x y. rel_prod related_pat related_exp x (case y of (pat, t) \\<Rightarrow> (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t))) cs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x y.\n         rel_prod related_pat related_exp x\n          (case y of\n           (pat, t) \\<Rightarrow>\n             (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t)))\n     cs cs", "proof (rule list.rel_refl_strong, safe intro!: rel_prod.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "fix pat rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "assume \"(pat, rhs) \\<in> set cs\""], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "hence \"consts rhs |\\<subseteq>| S\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| S", "using \\<open>ids (Sabs cs) |\\<subseteq>| S\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  ids (Sabs cs) |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| S", "unfolding ids_def"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  frees (Sabs cs) |\\<union>| consts (Sabs cs) |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(pat, rhs) \\<in> set cs; x |\\<in>| consts rhs;\n        ffUnion\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs) |\\<subseteq>|\n        S;\n        ffUnion\n         ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs) |\\<subseteq>|\n        S\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (drule ffUnion_least_rev)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(pat, rhs) \\<in> set cs; x |\\<in>| consts rhs;\n        fBall\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs)\n         (\\<lambda>X. X |\\<subseteq>| S);\n        fBall ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)\n         (\\<lambda>X. X |\\<subseteq>| S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (auto simp: fset_of_list_elem elim!: fBallE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "have \"frees rhs |\\<subseteq>| frees pat |\\<union>| S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat |\\<union>| S", "using \\<open>ids (Sabs cs) |\\<subseteq>| S\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  ids (Sabs cs) |\\<subseteq>| S\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat |\\<union>| S", "unfolding ids_def"], ["proof (prove)\nusing this:\n  frees (Sabs cs) |\\<union>| consts (Sabs cs) |\\<subseteq>| S\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. frees rhs |\\<subseteq>| frees pat |\\<union>| S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(pat, rhs) \\<in> set cs; x |\\<in>| frees rhs;\n        x |\\<notin>| S;\n        ffUnion\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs) |\\<subseteq>|\n        S;\n        ffUnion\n         ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs) |\\<subseteq>|\n        S\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat", "apply (drule ffUnion_least_rev)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(pat, rhs) \\<in> set cs; x |\\<in>| frees rhs;\n        x |\\<notin>| S;\n        fBall\n         ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n          fset_of_list cs)\n         (\\<lambda>X. X |\\<subseteq>| S);\n        fBall ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)\n         (\\<lambda>X. X |\\<subseteq>| S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat", "apply (auto simp: fset_of_list_elem elim!: fBallE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  frees rhs |\\<subseteq>| frees pat |\\<union>| S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> 6"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<lbrakk>?x4 \\<in> set cs; (?xa4, ?y4) = ?x4;\n   ids ?y4 |\\<subseteq>| frees ?xa4 |\\<union>| S;\n   all_consts |\\<subseteq>| frees ?xa4 |\\<union>| S;\n   \\<not> shadows_consts ?y4\\<rbrakk>\n  \\<Longrightarrow> related_exp ?y4 (mk_con (frees ?xa4 |\\<union>| S) ?y4)\n  ids (Sabs cs) |\\<subseteq>| S\n  all_consts |\\<subseteq>| S\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| S) b)", "show \"related_exp rhs (mk_con (frees pat |\\<union>| S) rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp rhs (mk_con (frees pat |\\<union>| S) rhs)", "apply (rule 6)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?x4 \\<in> set cs\n 2. (pat, rhs) = ?x4\n 3. ids rhs |\\<subseteq>| frees pat |\\<union>| S\n 4. all_consts |\\<subseteq>| frees pat |\\<union>| S\n 5. \\<not> shadows_consts rhs", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. (pat, rhs) = (pat, rhs)\n 2. ids rhs |\\<subseteq>| frees pat |\\<union>| S\n 3. all_consts |\\<subseteq>| frees pat |\\<union>| S\n 4. \\<not> shadows_consts rhs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) = (pat, rhs)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. ids rhs |\\<subseteq>| frees pat |\\<union>| S\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| S\n 3. \\<not> shadows_consts rhs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids rhs |\\<subseteq>| frees pat |\\<union>| S", "unfolding ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees rhs |\\<union>| consts rhs |\\<subseteq>| frees pat |\\<union>| S", "using \\<open>consts rhs |\\<subseteq>| S\\<close> \\<open>frees rhs |\\<subseteq>| frees pat |\\<union>| S\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| S\n  frees rhs |\\<subseteq>| frees pat |\\<union>| S\n\ngoal (1 subgoal):\n 1. frees rhs |\\<union>| consts rhs |\\<subseteq>| frees pat |\\<union>| S", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. all_consts |\\<subseteq>| frees pat |\\<union>| S\n 2. \\<not> shadows_consts rhs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_consts |\\<subseteq>| frees pat |\\<union>| S", "using 6(3)"], ["proof (prove)\nusing this:\n  all_consts |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. all_consts |\\<subseteq>| frees pat |\\<union>| S", "by fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  related_exp rhs (mk_con (frees pat |\\<union>| S) rhs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x y.\n       rel_prod related_pat related_exp x\n        (case y of\n         (pat, t) \\<Rightarrow>\n           (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t)))\n   cs cs\n\ngoal (3 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n 3. \\<And>S cs.\n       \\<lbrakk>\\<And>x xa y.\n                   \\<lbrakk>x \\<in> set cs; (xa, y) = x;\n                    ids y |\\<subseteq>| frees xa |\\<union>| S;\n                    all_consts |\\<subseteq>| frees xa |\\<union>| S;\n                    \\<not> shadows_consts y\\<rbrakk>\n                   \\<Longrightarrow> related_exp y\n(mk_con (frees xa |\\<union>| S) y);\n        ids (Sabs cs) |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (Sabs cs)\\<rbrakk>\n       \\<Longrightarrow> list_all2 (rel_prod related_pat related_exp) cs\n                          (mk_clauses S cs)", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x y.\n       rel_prod related_pat related_exp x\n        (case y of\n         (pat, t) \\<Rightarrow>\n           (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| S) t)))\n   cs cs\n\ngoal (1 subgoal):\n 1. list_all2 (rel_prod related_pat related_exp) cs (mk_clauses S cs)", "by (simp add: list.rel_map)"], ["proof (state)\nthis:\n  list_all2 (rel_prod related_pat related_exp) cs (mk_clauses S cs)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ s.\n       \\<lbrakk>ids (Svar s) |\\<subseteq>| uu_;\n        all_consts |\\<subseteq>| uu_;\n        \\<not> shadows_consts (Svar s)\\<rbrakk>\n       \\<Longrightarrow> related_exp (Svar s) (mk_exp uu_ (Svar s))\n 2. \\<And>S t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>ids t\\<^sub>1 |\\<subseteq>| S;\n                 all_consts |\\<subseteq>| S;\n                 \\<not> shadows_consts t\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> related_exp t\\<^sub>1\n                                   (mk_con S t\\<^sub>1);\n        \\<lbrakk>ids t\\<^sub>2 |\\<subseteq>| S; all_consts |\\<subseteq>| S;\n         \\<not> shadows_consts t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> related_exp t\\<^sub>2 (mk_con S t\\<^sub>2);\n        ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>| S;\n        all_consts |\\<subseteq>| S;\n        \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n                          (mk_exp S (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))", "qed (auto intro: related_exp.intros simp: ids_def fdisjnt_alt_def)"], ["", "context begin"], ["", "private"], ["", "lemma semantic_correctness0:\n  fixes exp\n  assumes \"cupcake_evaluate_single env exp r\" \"is_cupcake_all_env env\"\n  assumes \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\"\n  assumes \"related_exp t exp\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\"\n  assumes \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  shows \"if_rval (\\<lambda>ml_v. \\<exists>v. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     r", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env exp r\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t exp\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     r", "proof (induction arbitrary: \\<Gamma> t)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "case (con1 env cn es ress ml_vs ml_v')"], ["proof (state)\nthis:\n  do_con_check (sem_env.c env) cn (length es)\n  sequence_result ress = Rval ml_vs\n  build_conv (sem_env.c env) cn (rev ml_vs) = Some ml_v'\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev es) ress\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Con cn es)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "obtain name ts where \"cn = Some (Short (as_string name))\" \"name |\\<in>| C\" \"t = name $$ ts\" \"list_all2 related_exp ts es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>name ts.\n        \\<lbrakk>cn = Some (Short (as_string name)); name |\\<in>| C;\n         t = name $$ ts; list_all2 related_exp ts es\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>related_exp t (Con cn es)\\<close>"], ["proof (prove)\nusing this:\n  related_exp t (Con cn es)\n\ngoal (1 subgoal):\n 1. (\\<And>name ts.\n        \\<lbrakk>cn = Some (Short (as_string name)); name |\\<in>| C;\n         t = name $$ ts; list_all2 related_exp ts es\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  cn = Some (Short (as_string name))\n  name |\\<in>| C\n  t = name $$ ts\n  list_all2 related_exp ts es\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "with con1"], ["proof (chain)\npicking this:\n  do_con_check (sem_env.c env) cn (length es)\n  sequence_result ress = Rval ml_vs\n  build_conv (sem_env.c env) cn (rev ml_vs) = Some ml_v'\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev es) ress\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Con cn es)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n  cn = Some (Short (as_string name))\n  name |\\<in>| C\n  t = name $$ ts\n  list_all2 related_exp ts es", "obtain tid where \"ml_v' = Conv (Some (id_to_n (Short (as_string name)), tid)) (rev ml_vs)\""], ["proof (prove)\nusing this:\n  do_con_check (sem_env.c env) cn (length es)\n  sequence_result ress = Rval ml_vs\n  build_conv (sem_env.c env) cn (rev ml_vs) = Some ml_v'\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev es) ress\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Con cn es)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n  cn = Some (Short (as_string name))\n  name |\\<in>| C\n  t = name $$ ts\n  list_all2 related_exp ts es\n\ngoal (1 subgoal):\n 1. (\\<And>tid.\n        ml_v' =\n        Conv (Some (id_to_n (Short (as_string name)), tid))\n         (rev ml_vs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  ml_v' = Conv (Some (id_to_n (Short (as_string name)), tid)) (rev ml_vs)\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "have \"ress = map Rval ml_vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ress = map Rval ml_vs", "using con1"], ["proof (prove)\nusing this:\n  do_con_check (sem_env.c env) cn (length es)\n  sequence_result ress = Rval ml_vs\n  build_conv (sem_env.c env) cn (rev ml_vs) = Some ml_v'\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev es) ress\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Con cn es)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. ress = map Rval ml_vs", "by auto"], ["proof (state)\nthis:\n  ress = map Rval ml_vs\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "define ml_vs' where \"ml_vs' = rev ml_vs\""], ["proof (state)\nthis:\n  ml_vs' = rev ml_vs\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "note IH = \\<open>list_all2_shortcircuit _ _ _\\<close>[\n              unfolded \\<open>ress = _\\<close> list_all2_shortcircuit_rval list_all2_rev1,\n              folded ml_vs'_def]"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x y.\n       cupcake_evaluate_single env x (Rval y) \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>xa xb.\n            fmrel_on_fset (ids xb) related_v xa\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xb x \\<longrightarrow>\n            pre_strong_term_class.wellformed xb \\<longrightarrow>\n            wellformed_venv xa \\<longrightarrow>\n            closed_venv xa \\<longrightarrow>\n            closed_except xb (fmdom xa) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') xa \\<longrightarrow>\n            consts xb |\\<subseteq>| fmdom xa |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom xa) \\<longrightarrow>\n            \\<not> shadows_consts xb \\<longrightarrow>\n            not_shadows_vconsts_env xa \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    xa \\<turnstile>\\<^sub>v xb \\<down> v \\<and>\n                    related_v v ml_v)\n             (Rval y))))\n   es ml_vs'\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x y.\n       cupcake_evaluate_single env x (Rval y) \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>xa xb.\n            fmrel_on_fset (ids xb) related_v xa\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xb x \\<longrightarrow>\n            pre_strong_term_class.wellformed xb \\<longrightarrow>\n            wellformed_venv xa \\<longrightarrow>\n            closed_venv xa \\<longrightarrow>\n            closed_except xb (fmdom xa) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') xa \\<longrightarrow>\n            consts xb |\\<subseteq>| fmdom xa |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom xa) \\<longrightarrow>\n            \\<not> shadows_consts xb \\<longrightarrow>\n            not_shadows_vconsts_env xa \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    xa \\<turnstile>\\<^sub>v xb \\<down> v \\<and>\n                    related_v v ml_v)\n             (Rval y))))\n   es ml_vs'\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "have\n    \"list_all wellformed ts\" \"list_all (\\<lambda>t. \\<not> shadows_consts t) ts\"\n    \"list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts\" \"list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all pre_strong_term_class.wellformed ts &&&\n     list_all (\\<lambda>t. \\<not> shadows_consts t) ts) &&&\n    list_all\n     (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts &&&\n    list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed ts", "using \\<open>wellformed t\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed ts", "unfolding \\<open>t = _\\<close> wellformed.list_comb"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (const name) \\<and>\n  list_all pre_strong_term_class.wellformed ts\n\ngoal (1 subgoal):\n 1. list_all pre_strong_term_class.wellformed ts", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n 2. list_all\n     (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts\n 3. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. \\<not> shadows_consts t) ts", "using \\<open>\\<not> shadows_consts t\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. \\<not> shadows_consts t) ts", "unfolding \\<open>t = _\\<close> shadows.list_comb"], ["proof (prove)\nusing this:\n  \\<not> (shadows_consts (const name) \\<or> list_ex shadows_consts ts)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. \\<not> shadows_consts t) ts", "by (simp add: list_all_iff list_ex_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts\n 2. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts", "using \\<open>consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\\<close>"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) ts", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts.\n       consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "by (metis Ball_set \\<open>t = name $$ ts\\<close> con1.prems(9) special_constants.sconsts_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "using \\<open>closed_except t (fmdom \\<Gamma>)\\<close>"], ["proof (prove)\nusing this:\n  closed_except t (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "unfolding \\<open>t = _\\<close> closed.list_comb"], ["proof (prove)\nusing this:\n  closed_except (const name) (fmdom \\<Gamma>) \\<and>\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all pre_strong_term_class.wellformed ts\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  list_all pre_strong_term_class.wellformed ts\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "have\n    \"list_all (\\<lambda>t'. fmrel_on_fset (ids t') related_v \\<Gamma> (fmap_of_ns (sem_env.v env))) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>t'.\n         fmrel_on_fset (ids t') related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env)))\n     ts", "proof (standard, rule fmrel_on_fsubset)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (?S2 x) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. \\<And>x. x \\<in> set ts \\<Longrightarrow> ids x |\\<subseteq>| ?S2 x", "fix t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (?S2 x) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. \\<And>x. x \\<in> set ts \\<Longrightarrow> ids x |\\<subseteq>| ?S2 x", "assume \"t' \\<in> set ts\""], ["proof (state)\nthis:\n  t' \\<in> set ts\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (?S2 x) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. \\<And>x. x \\<in> set ts \\<Longrightarrow> ids x |\\<subseteq>| ?S2 x", "thus \"ids t' |\\<subseteq>| ids t\""], ["proof (prove)\nusing this:\n  t' \\<in> set ts\n\ngoal (1 subgoal):\n 1. ids t' |\\<subseteq>| ids t", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  t' \\<in> set ts\n\ngoal (1 subgoal):\n 1. ids t' |\\<subseteq>| ids (name $$ ts)", "apply (simp add: ids_list_comb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> set ts \\<Longrightarrow>\n    ids t' |\\<subseteq>|\n    ids (const name) |\\<union>| ffUnion (ids |`| fset_of_list ts)", "apply (subst (2) ids_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> set ts \\<Longrightarrow>\n    ids t' |\\<subseteq>|\n    frees (const name) |\\<union>| consts (const name) |\\<union>|\n    ffUnion (ids |`| fset_of_list ts)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> set ts \\<Longrightarrow>\n    ids t' |\\<subseteq>| finsert name (ffUnion (ids |`| fset_of_list ts))", "apply (rule fsubset_finsertI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> set ts \\<Longrightarrow>\n    ids t' |\\<subseteq>| ffUnion (ids |`| fset_of_list ts)", "apply (auto simp: fset_of_list_elem intro!: ffUnion_subset_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ids t' |\\<subseteq>| ids t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set ts \\<Longrightarrow>\n       fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "show \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "by fact"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>x y.\n       cupcake_evaluate_single env x (Rval y) \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>xa xb.\n            fmrel_on_fset (ids xb) related_v xa\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xb x \\<longrightarrow>\n            pre_strong_term_class.wellformed xb \\<longrightarrow>\n            wellformed_venv xa \\<longrightarrow>\n            closed_venv xa \\<longrightarrow>\n            closed_except xb (fmdom xa) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') xa \\<longrightarrow>\n            consts xb |\\<subseteq>| fmdom xa |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom xa) \\<longrightarrow>\n            \\<not> shadows_consts xb \\<longrightarrow>\n            not_shadows_vconsts_env xa \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    xa \\<turnstile>\\<^sub>v xb \\<down> v \\<and>\n                    related_v v ml_v)\n             (Rval y))))\n   es ml_vs'\n  list_all pre_strong_term_class.wellformed ts\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts", "obtain us where \"list_all2 (veval' \\<Gamma>) ts us\" \"list_all2 related_v us ml_vs'\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x y.\n       cupcake_evaluate_single env x (Rval y) \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>xa xb.\n            fmrel_on_fset (ids xb) related_v xa\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xb x \\<longrightarrow>\n            pre_strong_term_class.wellformed xb \\<longrightarrow>\n            wellformed_venv xa \\<longrightarrow>\n            closed_venv xa \\<longrightarrow>\n            closed_except xb (fmdom xa) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') xa \\<longrightarrow>\n            consts xb |\\<subseteq>| fmdom xa |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom xa) \\<longrightarrow>\n            \\<not> shadows_consts xb \\<longrightarrow>\n            not_shadows_vconsts_env xa \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    xa \\<turnstile>\\<^sub>v xb \\<down> v \\<and>\n                    related_v v ml_v)\n             (Rval y))))\n   es ml_vs'\n  list_all pre_strong_term_class.wellformed ts\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n         list_all2 related_v us ml_vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>list_all2 related_exp ts es\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x y.\n       cupcake_evaluate_single env x (Rval y) \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>xa xb.\n            fmrel_on_fset (ids xb) related_v xa\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xb x \\<longrightarrow>\n            pre_strong_term_class.wellformed xb \\<longrightarrow>\n            wellformed_venv xa \\<longrightarrow>\n            closed_venv xa \\<longrightarrow>\n            closed_except xb (fmdom xa) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') xa \\<longrightarrow>\n            consts xb |\\<subseteq>| fmdom xa |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom xa) \\<longrightarrow>\n            \\<not> shadows_consts xb \\<longrightarrow>\n            not_shadows_vconsts_env xa \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    xa \\<turnstile>\\<^sub>v xb \\<down> v \\<and>\n                    related_v v ml_v)\n             (Rval y))))\n   es ml_vs'\n  list_all pre_strong_term_class.wellformed ts\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts\n  list_all2 related_exp ts es\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n         list_all2 related_v us ml_vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction es ml_vs' arbitrary: ts thesis rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons e es ml_v ml_vs ts0)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)", "obtain t ts where \"ts0 = t # ts\" \"related_exp t e\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n\ngoal (1 subgoal):\n 1. (\\<And>t ts.\n        \\<lbrakk>ts0 = t # ts; related_exp t e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ts0) auto"], ["proof (state)\nthis:\n  ts0 = t # ts\n  related_exp t e\n\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Cons"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n  ts0 = t # ts\n  related_exp t e", "have \"list_all2 related_exp ts es\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n  ts0 = t # ts\n  related_exp t e\n\ngoal (1 subgoal):\n 1. list_all2 related_exp ts es", "by simp"], ["proof (state)\nthis:\n  list_all2 related_exp ts es\n\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Cons"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n  list_all2 related_exp ts es", "obtain us where \"list_all2 (veval' \\<Gamma>) ts us\" \"list_all2 related_v us ml_vs\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n  list_all2 related_exp ts es\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n         list_all2 related_v us ml_vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>ts0 = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) (t # ts) ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  list_all pre_strong_term_class.wellformed (t # ts)\n  list_all (\\<lambda>t. \\<not> shadows_consts t) (t # ts)\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   (t # ts)\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) (t # ts)\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   (t # ts)\n  list_all2 related_exp (t # ts) (e # es)\n  list_all2 related_exp ts es\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n         list_all2 related_v us ml_vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list_all2 (veval' \\<Gamma>) ts us\n  list_all2 related_v us ml_vs\n\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Cons.hyps[simplified, THEN conjunct2, rule_format, of t \\<Gamma>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env));\n   related_exp t e; pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>);\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                       related_v v ml_v", "obtain u where \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u \" \"related_v u ml_v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env));\n   related_exp t e; pre_strong_term_class.wellformed t;\n   wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n   closed_except t (fmdom \\<Gamma>);\n   fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n   consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n   fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n   not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                       related_v v ml_v\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    is_cupcake_all_env env\n 2. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 3. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp t e\n 4. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 5. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv \\<Gamma>\n 6. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv \\<Gamma>\n 7. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom \\<Gamma>)\n 8. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 9. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 10. (\\<And>u.\n         \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n          related_v u ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     fdisjnt C (fmdom \\<Gamma>)\nA total of 13 subgoals...", "show\n            \"is_cupcake_all_env env\" \"related_exp t e\" \"wellformed_venv \\<Gamma>\" \"closed_venv \\<Gamma>\"\n            \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"fdisjnt C (fmdom \\<Gamma>)\"\n            \"not_shadows_vconsts_env \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_cupcake_all_env env &&&\n     related_exp t e &&& wellformed_venv \\<Gamma>) &&&\n    (closed_venv \\<Gamma> &&&\n     fmpred (\\<lambda>_. vwelldefined') \\<Gamma>) &&&\n    fdisjnt C (fmdom \\<Gamma>) &&& not_shadows_vconsts_env \\<Gamma>", "by fact+"], ["proof (state)\nthis:\n  is_cupcake_all_env env\n  related_exp t e\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (6 subgoals):\n 1. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 3. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom \\<Gamma>)\n 4. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 5. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts t\n 6. \\<And>x.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n                    related_v u ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> x \\<and>\n        related_v x ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 3. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom \\<Gamma>)\n 4. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 5. (\\<And>u.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n         related_v u ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts t\n 6. \\<And>x.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n                    related_v u ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> x \\<and>\n        related_v x ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show\n            \"wellformed t\" \"\\<not> shadows_consts t\" \"closed_except t (fmdom \\<Gamma>)\"\n            \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\" \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t &&& \\<not> shadows_consts t) &&&\n    closed_except t (fmdom \\<Gamma>) &&&\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C &&&\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "using Cons"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) ts0 ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  list_all pre_strong_term_class.wellformed ts0\n  list_all (\\<lambda>t. \\<not> shadows_consts t) ts0\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   ts0\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts0\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   ts0\n  list_all2 related_exp ts0 (e # es)\n\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t &&& \\<not> shadows_consts t) &&&\n    closed_except t (fmdom \\<Gamma>) &&&\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C &&&\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "unfolding \\<open>ts0 = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env e (Rval ml_v) \\<and>\n  (is_cupcake_all_env env \\<longrightarrow>\n   (\\<forall>x xa.\n       fmrel_on_fset (ids xa) related_v x\n        (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n       related_exp xa e \\<longrightarrow>\n       pre_strong_term_class.wellformed xa \\<longrightarrow>\n       wellformed_venv x \\<longrightarrow>\n       closed_venv x \\<longrightarrow>\n       closed_except xa (fmdom x) \\<longrightarrow>\n       fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n       consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n       fdisjnt C (fmdom x) \\<longrightarrow>\n       \\<not> shadows_consts xa \\<longrightarrow>\n       not_shadows_vconsts_env x \\<longrightarrow>\n       if_rval\n        (\\<lambda>ml_v.\n            \\<exists>v.\n               x \\<turnstile>\\<^sub>v xa \\<down> v \\<and> related_v v ml_v)\n        (Rval ml_v)))\n  \\<lbrakk>\\<And>us.\n              \\<lbrakk>list_all2 (veval' \\<Gamma>) ?ts6 us;\n               list_all2 related_v us ml_vs\\<rbrakk>\n              \\<Longrightarrow> ?thesis6;\n   list_all pre_strong_term_class.wellformed ?ts6;\n   list_all (\\<lambda>t. \\<not> shadows_consts t) ?ts6;\n   list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n    ?ts6;\n   list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ?ts6;\n   list_all\n    (\\<lambda>t'.\n        fmrel_on_fset (ids t') related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env)))\n    ?ts6;\n   list_all2 related_exp ?ts6 es\\<rbrakk>\n  \\<Longrightarrow> ?thesis6\n  \\<lbrakk>list_all2 (veval' \\<Gamma>) (t # ts) ?us6;\n   list_all2 related_v ?us6 (ml_v # ml_vs)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  list_all pre_strong_term_class.wellformed (t # ts)\n  list_all (\\<lambda>t. \\<not> shadows_consts t) (t # ts)\n  list_all (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   (t # ts)\n  list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) (t # ts)\n  list_all\n   (\\<lambda>t'.\n       fmrel_on_fset (ids t') related_v \\<Gamma>\n        (fmap_of_ns (sem_env.v env)))\n   (t # ts)\n  list_all2 related_exp (t # ts) (e # es)\n\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t &&& \\<not> shadows_consts t) &&&\n    closed_except t (fmdom \\<Gamma>) &&&\n    consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C &&&\n    fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "by auto"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\n  \\<not> shadows_consts t\n  closed_except t (fmdom \\<Gamma>)\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u;\n                    related_v u ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> x \\<and>\n        related_v x ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u\n  related_v u ml_v\n\ngoal (2 subgoals):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a21 a22 b21 b22 ts thesis.\n       \\<lbrakk>cupcake_evaluate_single env a21 (Rval b21) \\<and>\n                (is_cupcake_all_env env \\<longrightarrow>\n                 (\\<forall>x xa.\n                     fmrel_on_fset (ids xa) related_v x\n                      (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                     related_exp xa a21 \\<longrightarrow>\n                     pre_strong_term_class.wellformed xa \\<longrightarrow>\n                     wellformed_venv x \\<longrightarrow>\n                     closed_venv x \\<longrightarrow>\n                     closed_except xa (fmdom x) \\<longrightarrow>\n                     fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                     consts xa |\\<subseteq>|\n                     fmdom x |\\<union>| C \\<longrightarrow>\n                     fdisjnt C (fmdom x) \\<longrightarrow>\n                     \\<not> shadows_consts xa \\<longrightarrow>\n                     not_shadows_vconsts_env x \\<longrightarrow>\n                     if_rval\n                      (\\<lambda>ml_v.\n                          \\<exists>v.\n                             x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                             related_v v ml_v)\n                      (Rval b21)));\n        \\<And>ts thesis.\n           \\<lbrakk>\\<And>us.\n                       \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                        list_all2 related_v us b22\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            list_all pre_strong_term_class.wellformed ts;\n            list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n            list_all\n             (\\<lambda>t.\n                 consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n             ts;\n            list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n            list_all\n             (\\<lambda>t'.\n                 fmrel_on_fset (ids t') related_v \\<Gamma>\n                  (fmap_of_ns (sem_env.v env)))\n             ts;\n            list_all2 related_exp ts a22\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>us.\n           \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n            list_all2 related_v us (b21 # b22)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts (a21 # a22)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule Cons(3)[of \"u # us\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (veval' \\<Gamma>) ts0 (u # us)\n 2. list_all2 related_v (u # us) (ml_v # ml_vs)", "unfolding \\<open>ts0 = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (veval' \\<Gamma>) (t # ts) (u # us)\n 2. list_all2 related_v (u # us) (ml_v # ml_vs)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> u\n 2. list_all2 (veval' \\<Gamma>) ts us\n 3. related_v u ml_v\n 4. list_all2 related_v us ml_vs", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>ts thesis.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>list_all2 (veval' \\<Gamma>) ts us;\n                    list_all2 related_v us []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        list_all pre_strong_term_class.wellformed ts;\n        list_all (\\<lambda>t. \\<not> shadows_consts t) ts;\n        list_all\n         (\\<lambda>t. consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n         ts;\n        list_all (\\<lambda>t. closed_except t (fmdom \\<Gamma>)) ts;\n        list_all\n         (\\<lambda>t'.\n             fmrel_on_fset (ids t') related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env)))\n         ts;\n        list_all2 related_exp ts []\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["proof (state)\nthis:\n  list_all2 (veval' \\<Gamma>) ts us\n  list_all2 related_v us ml_vs'\n\ngoal (12 subgoals):\n 1. \\<And>env cn es rs vs v0 \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rval vs;\n        build_conv (sem_env.c env) cn (rev vs) = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 2. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 3. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 4. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 5. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 7. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 9. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv =\n         Rval (e', uu_, env');\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n          e' bv;\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env\n                      (update_v\n                        (\\<lambda>_.\n                            nsAppend (alist_to_ns env') (sem_env.v env))\n                        env);\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns\n                (sem_env.v\n                  (update_v\n                    (\\<lambda>_.\n                        nsAppend (alist_to_ns env') (sem_env.v env))\n                    env)));\n             related_exp t e'; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               bv;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           bv\nA total of 12 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v'", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> ?v\n 2. related_v ?v ml_v'", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v name $$ ts \\<down> ?v\n 2. related_v ?v ml_v'", "apply (rule veval'.constr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. name |\\<in>| C\n 2. list_all2 (veval' \\<Gamma>) ts ?us2\n 3. related_v (Vconstr name ?us2) ml_v'", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vconstr name us) ml_v'", "unfolding \\<open>ml_v' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vconstr name us)\n     (Conv (Some (id_to_n (Short (as_string name)), tid)) (rev ml_vs))", "apply (subst ml_vs'_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vconstr name us)\n     (Conv (Some (id_to_n (Short (as_string name)), tid)) ml_vs')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vconstr name us) (Conv (Some (as_string name, tid)) ml_vs')", "apply (rule related_v.conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 related_v us ml_vs'", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval ml_v')\n\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "case (var1 env id ml_v)"], ["proof (state)\nthis:\n  nsLookup (sem_env.v env) id = Some ml_v\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Var id)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "from \\<open>related_exp t (Var id)\\<close>"], ["proof (chain)\npicking this:\n  related_exp t (Var id)", "obtain name where \"id = Short (as_string name)\""], ["proof (prove)\nusing this:\n  related_exp t (Var id)\n\ngoal (1 subgoal):\n 1. (\\<And>name.\n        id = Short (as_string name) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  id = Short (as_string name)\n\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "with var1"], ["proof (chain)\npicking this:\n  nsLookup (sem_env.v env) id = Some ml_v\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Var id)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n  id = Short (as_string name)", "have \"cupcake_nsLookup (sem_env.v env) (as_string name) = Some ml_v\""], ["proof (prove)\nusing this:\n  nsLookup (sem_env.v env) id = Some ml_v\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Var id)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n  id = Short (as_string name)\n\ngoal (1 subgoal):\n 1. cupcake_nsLookup (sem_env.v env) (as_string name) = Some ml_v", "by auto"], ["proof (state)\nthis:\n  cupcake_nsLookup (sem_env.v env) (as_string name) = Some ml_v\n\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "from \\<open>related_exp t (Var id)\\<close>"], ["proof (chain)\npicking this:\n  related_exp t (Var id)", "consider\n      (var) \"t = Svar name\"\n    | (const) \"t = Sconst name\" \"name |\\<notin>| C\""], ["proof (prove)\nusing this:\n  related_exp t (Var id)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n     \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding \\<open>id = _\\<close>"], ["proof (prove)\nusing this:\n  related_exp t (Var (Short (as_string name)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n     \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>namea.\n       \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n        \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        t = Svar namea; as_string name = as_string namea\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>namea.\n       \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n        \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        t = Sconst namea; as_string name = as_string namea;\n        namea |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> thesis", "using name.expand"], ["proof (prove)\nusing this:\n  as_string ?name = as_string ?name' \\<Longrightarrow> ?name = ?name'\n\ngoal (2 subgoals):\n 1. \\<And>namea.\n       \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n        \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        t = Svar namea; as_string name = as_string namea\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>namea.\n       \\<lbrakk>t = Svar name \\<Longrightarrow> thesis;\n        \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        t = Sconst namea; as_string name = as_string namea;\n        namea |\\<notin>| C\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast+"], ["proof (state)\nthis:\n  \\<lbrakk>t = Svar name \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n   \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (11 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n v0 \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = Some v0;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval v0)\n 4. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 6. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 8. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 10. \\<And>env e v0 pes err \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rval v0);\n         cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Svar name \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n   \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Svar name \\<Longrightarrow>\n    if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)\n 2. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "case var"], ["proof (state)\nthis:\n  t = Svar name\n\ngoal (2 subgoals):\n 1. t = Svar name \\<Longrightarrow>\n    if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)\n 2. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "hence \"name |\\<in>| ids t\""], ["proof (prove)\nusing this:\n  t = Svar name\n\ngoal (1 subgoal):\n 1. name |\\<in>| ids t", "unfolding ids_def"], ["proof (prove)\nusing this:\n  t = Svar name\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees t |\\<union>| consts t", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| ids t\n\ngoal (2 subgoals):\n 1. t = Svar name \\<Longrightarrow>\n    if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)\n 2. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "have \"rel_option related_v (fmlookup \\<Gamma> name) (cupcake_nsLookup (sem_env.v env) (as_string name))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "using \\<open>fmrel_on_fset (ids t) _ _ _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env)) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply (drule fmrel_on_fsetD[OF \\<open>name |\\<in>| ids t\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (fmlookup (fmap_of_ns (sem_env.v env)) name) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n\ngoal (2 subgoals):\n 1. t = Svar name \\<Longrightarrow>\n    if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)\n 2. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "then"], ["proof (chain)\npicking this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))", "obtain v where \"related_v v ml_v\" \"fmlookup \\<Gamma> name = Some v\""], ["proof (prove)\nusing this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>related_v v ml_v; fmlookup \\<Gamma> name = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cupcake_nsLookup (sem_env.v env) _ = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n  cupcake_nsLookup (sem_env.v env) (as_string name) = Some ml_v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>related_v v ml_v; fmlookup \\<Gamma> name = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  related_v v ml_v\n  fmlookup \\<Gamma> name = Some v\n\ngoal (2 subgoals):\n 1. t = Svar name \\<Longrightarrow>\n    if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)\n 2. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v Svar name \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v Svar name \\<down> v \\<and>\n       related_v v ml_v", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Svar name \\<down> ?v \\<and>\n    related_v ?v ml_v", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Svar name \\<down> ?v\n 2. related_v ?v ml_v", "apply (rule veval'.var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmlookup \\<Gamma> name = Some ?v\n 2. related_v ?v ml_v", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "case const"], ["proof (state)\nthis:\n  t = Sconst name\n  name |\\<notin>| C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "hence \"name |\\<in>| ids t\""], ["proof (prove)\nusing this:\n  t = Sconst name\n  name |\\<notin>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| ids t", "unfolding ids_def"], ["proof (prove)\nusing this:\n  t = Sconst name\n  name |\\<notin>| C\n\ngoal (1 subgoal):\n 1. name |\\<in>| frees t |\\<union>| consts t", "by simp"], ["proof (state)\nthis:\n  name |\\<in>| ids t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "have \"rel_option related_v (fmlookup \\<Gamma> name) (cupcake_nsLookup (sem_env.v env) (as_string name))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "using \\<open>fmrel_on_fset (ids t) _ _ _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env)) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply (drule fmrel_on_fsetD[OF \\<open>name |\\<in>| ids t\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup \\<Gamma> name)\n     (fmlookup (fmap_of_ns (sem_env.v env)) name) \\<Longrightarrow>\n    rel_option related_v (fmlookup \\<Gamma> name)\n     (cupcake_nsLookup (sem_env.v env) (as_string name))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "then"], ["proof (chain)\npicking this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))", "obtain v where \"related_v v ml_v\" \"fmlookup \\<Gamma> name = Some v\""], ["proof (prove)\nusing this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>related_v v ml_v; fmlookup \\<Gamma> name = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>cupcake_nsLookup (sem_env.v env) _ = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option related_v (fmlookup \\<Gamma> name)\n   (cupcake_nsLookup (sem_env.v env) (as_string name))\n  cupcake_nsLookup (sem_env.v env) (as_string name) = Some ml_v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>related_v v ml_v; fmlookup \\<Gamma> name = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  related_v v ml_v\n  fmlookup \\<Gamma> name = Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Sconst name; name |\\<notin>| C\\<rbrakk>\n    \\<Longrightarrow> if_rval\n                       (\\<lambda>ml_v.\n                           \\<exists>v.\n                              \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                              v \\<and> related_v v ml_v)\n                       (Rval ml_v)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v Sconst name \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval ml_v)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v Sconst name \\<down> v \\<and>\n       related_v v ml_v", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Sconst name \\<down> ?v \\<and>\n    related_v ?v ml_v", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Sconst name \\<down> ?v\n 2. related_v ?v ml_v", "apply (rule veval'.const)"], ["proof (prove)\ngoal (3 subgoals):\n 1. name |\\<notin>| C\n 2. fmlookup \\<Gamma> name = Some ?v\n 3. related_v ?v ml_v", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "case (fn env n u)"], ["proof (state)\nthis:\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Fun n u)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "obtain n' where \"n = as_string n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'. n = as_string n' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis name.sel)"], ["proof (state)\nthis:\n  n = as_string n'\n\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "obtain cs ml_cs\n    where \"t = Sabs cs\" \"u = Mat (Var (Short (as_string n'))) ml_cs\" \"n' |\\<notin>| ids (Sabs cs)\" \"n' |\\<notin>| all_consts\"\n      and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs ml_cs.\n        \\<lbrakk>t = Sabs cs; u = Mat (Var (Short (as_string n'))) ml_cs;\n         n' |\\<notin>| ids (Sabs cs); n' |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>related_exp t (Fun n u)\\<close>"], ["proof (prove)\nusing this:\n  related_exp t (Fun n u)\n\ngoal (1 subgoal):\n 1. (\\<And>cs ml_cs.\n        \\<lbrakk>t = Sabs cs; u = Mat (Var (Short (as_string n'))) ml_cs;\n         n' |\\<notin>| ids (Sabs cs); n' |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>n = _\\<close>"], ["proof (prove)\nusing this:\n  related_exp t (Fun (as_string n') u)\n\ngoal (1 subgoal):\n 1. (\\<And>cs ml_cs.\n        \\<lbrakk>t = Sabs cs; u = Mat (Var (Short (as_string n'))) ml_cs;\n         n' |\\<notin>| ids (Sabs cs); n' |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases (auto dest: name.expand)"], ["proof (state)\nthis:\n  t = Sabs cs\n  u = Mat (Var (Short (as_string n'))) ml_cs\n  n' |\\<notin>| ids (Sabs cs)\n  n' |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "obtain ns where \"fmap_of_ns (sem_env.v env) = fmap_of_list ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        fmap_of_ns (sem_env.v env) = fmap_of_list ns \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases env)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>ns.\n                   fmap_of_ns (sem_env.v env) =\n                   fmap_of_list ns \\<Longrightarrow>\n                   thesis;\n        env = make_sem_env x1 x2\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>ns.\n                   fmap_of_ns x1 = fmap_of_list ns \\<Longrightarrow> thesis;\n        env = make_sem_env x1 x2\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ns.\n                fmap_of_ns v = fmap_of_list ns \\<Longrightarrow> thesis;\n     env = make_sem_env v x2_\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases v) simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmap_of_ns (sem_env.v env) = fmap_of_list ns\n\ngoal (10 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env n e \\<Gamma> t.\n       \\<lbrakk>is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Fun n e); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rval (Closure env n e))\n 5. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 6. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 7. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 9. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 10. \\<And>env e err pes \\<Gamma> t.\n        \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n         \\<And>\\<Gamma> t.\n            \\<lbrakk>is_cupcake_all_env env;\n             fmrel_on_fset (ids t) related_v \\<Gamma>\n              (fmap_of_ns (sem_env.v env));\n             related_exp t e; pre_strong_term_class.wellformed t;\n             wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n             closed_except t (fmdom \\<Gamma>);\n             fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n             consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n             fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n             not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n            \\<Longrightarrow> if_rval\n                               (\\<lambda>ml_v.\n                                   \\<exists>v.\n\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n                               (Rerr err);\n         is_cupcake_all_env env;\n         fmrel_on_fset (ids t) related_v \\<Gamma>\n          (fmap_of_ns (sem_env.v env));\n         related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n         wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n         closed_except t (fmdom \\<Gamma>);\n         fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n         consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n         fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n         not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                  v \\<and> related_v v ml_v)\n                           (Rerr err)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     (Rval (Closure env n u))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n       related_v v (Closure env n u)", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> ?v \\<and>\n    related_v ?v (Closure env n u)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> ?v\n 2. related_v ?v (Closure env n u)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> ?v\n 2. related_v ?v (Closure env n u)", "apply (rule veval'.abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vabs cs \\<Gamma>) (Closure env n u)", "unfolding \\<open>n = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vabs cs \\<Gamma>) (Closure env (as_string n') u)", "apply (rule related_v.closure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. related_fun cs n' u\n 2. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "unfolding \\<open>u = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. related_fun cs n' (Mat (Var (Short (as_string n'))) ml_cs)\n 2. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "apply (subst related_fun_alt_def; rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all2 (rel_prod related_pat related_exp) cs ml_cs\n 2. n' |\\<notin>| ids (Sabs cs) \\<and> n' |\\<notin>| all_consts\n 3. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. n' |\\<notin>| ids (Sabs cs) \\<and> n' |\\<notin>| all_consts\n 2. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "apply (rule conjI; fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "using \\<open>fmrel_on_fset (ids t) _ _ _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "unfolding \\<open>t = _\\<close> \\<open>fmap_of_ns (sem_env.v env) = _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma> (fmap_of_list ns)\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma> (fmap_of_list ns)", "by simp"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval (Closure env n u))\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "case (app1 env exps ress ml_vs env' exp' bv)"], ["proof (state)\nthis:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "from \\<open>related_exp t _\\<close>"], ["proof (chain)\npicking this:\n  related_exp t (exp0.App Opapp exps)", "obtain exp\\<^sub>1 exp\\<^sub>2 t\\<^sub>1 t\\<^sub>2\n    where \"rev exps = [exp\\<^sub>2, exp\\<^sub>1]\" \"exps = [exp\\<^sub>1, exp\\<^sub>2]\" \"t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\"\n      and \"related_exp t\\<^sub>1 exp\\<^sub>1\" \"related_exp t\\<^sub>2 exp\\<^sub>2\""], ["proof (prove)\nusing this:\n  related_exp t (exp0.App Opapp exps)\n\ngoal (1 subgoal):\n 1. (\\<And>exp\\<^sub>2 exp\\<^sub>1 t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>rev exps = [exp\\<^sub>2, exp\\<^sub>1];\n         exps = [exp\\<^sub>1, exp\\<^sub>2];\n         t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2;\n         related_exp t\\<^sub>1 exp\\<^sub>1;\n         related_exp t\\<^sub>2 exp\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  rev exps = [exp\\<^sub>2, exp\\<^sub>1]\n  exps = [exp\\<^sub>1, exp\\<^sub>2]\n  t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "moreover"], ["proof (state)\nthis:\n  rev exps = [exp\\<^sub>2, exp\\<^sub>1]\n  exps = [exp\\<^sub>1, exp\\<^sub>2]\n  t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "from app1"], ["proof (chain)\npicking this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>", "have \"ress = map Rval ml_vs\""], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. ress = map Rval ml_vs", "by auto"], ["proof (state)\nthis:\n  ress = map Rval ml_vs\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "ultimately"], ["proof (chain)\npicking this:\n  rev exps = [exp\\<^sub>2, exp\\<^sub>1]\n  exps = [exp\\<^sub>1, exp\\<^sub>2]\n  t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n  ress = map Rval ml_vs", "obtain ml_v\\<^sub>1 ml_v\\<^sub>2 where \"ml_vs = [ml_v\\<^sub>2, ml_v\\<^sub>1]\""], ["proof (prove)\nusing this:\n  rev exps = [exp\\<^sub>2, exp\\<^sub>1]\n  exps = [exp\\<^sub>1, exp\\<^sub>2]\n  t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n  ress = map Rval ml_vs\n\ngoal (1 subgoal):\n 1. (\\<And>ml_v\\<^sub>2 ml_v\\<^sub>1.\n        ml_vs = [ml_v\\<^sub>2, ml_v\\<^sub>1] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using app1(1)"], ["proof (prove)\nusing this:\n  rev exps = [exp\\<^sub>2, exp\\<^sub>1]\n  exps = [exp\\<^sub>1, exp\\<^sub>2]\n  t = t\\<^sub>1 $\\<^sub>s t\\<^sub>2\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n  ress = map Rval ml_vs\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n\ngoal (1 subgoal):\n 1. (\\<And>ml_v\\<^sub>2 ml_v\\<^sub>1.\n        ml_vs = [ml_v\\<^sub>2, ml_v\\<^sub>1] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (smt list_all2_shortcircuit_rval list_all2_Cons1 list_all2_Nil)"], ["proof (state)\nthis:\n  ml_vs = [ml_v\\<^sub>2, ml_v\\<^sub>1]\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"is_cupcake_exp exp\\<^sub>1\" \"is_cupcake_exp exp\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp exp\\<^sub>1 &&& is_cupcake_exp exp\\<^sub>2", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. is_cupcake_exp exp\\<^sub>1 &&& is_cupcake_exp exp\\<^sub>2", "unfolding \\<open>exps = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev [exp\\<^sub>1, exp\\<^sub>2]) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp [exp\\<^sub>1, exp\\<^sub>2])\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. is_cupcake_exp exp\\<^sub>1 &&& is_cupcake_exp exp\\<^sub>2", "by (auto dest: related_exp_is_cupcake)"], ["proof (state)\nthis:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "moreover"], ["proof (state)\nthis:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "unfolding ids_def \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (frees xa |\\<union>| consts xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (frees ?t4 |\\<union>| consts ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset\n   (frees (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<union>|\n    consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n   related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t\\<^sub>1 |\\<union>| consts t\\<^sub>1) related_v\n     \\<Gamma> (fmap_of_ns (sem_env.v env))", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "moreover"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n     (fmap_of_ns (sem_env.v env))", "unfolding ids_def \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (frees xa |\\<union>| consts xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (frees ?t4 |\\<union>| consts ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset\n   (frees (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<union>|\n    consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2))\n   related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (frees t\\<^sub>2 |\\<union>| consts t\\<^sub>2) related_v\n     \\<Gamma> (fmap_of_ns (sem_env.v env))", "by (auto intro: fmrel_on_fsubset)"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))", "have\n    \"cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1)\" \"cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)\" and\n    \"\\<exists>t\\<^sub>1'. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and> related_v t\\<^sub>1' ml_v\\<^sub>1\" \"\\<exists>t\\<^sub>2'. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and> related_v t\\<^sub>2' ml_v\\<^sub>2\""], ["proof (prove)\nusing this:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n\ngoal (1 subgoal):\n 1. (cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1) &&&\n     cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)) &&&\n    \\<exists>t\\<^sub>1'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n       related_v t\\<^sub>1' ml_v\\<^sub>1 &&&\n    \\<exists>t\\<^sub>2'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n       related_v t\\<^sub>2' ml_v\\<^sub>2", "using app1 \\<open>related_exp t\\<^sub>1 exp\\<^sub>1\\<close> \\<open>related_exp t\\<^sub>2 exp\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1) &&&\n     cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)) &&&\n    \\<exists>t\\<^sub>1'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n       related_v t\\<^sub>1' ml_v\\<^sub>1 &&&\n    \\<exists>t\\<^sub>2'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n       related_v t\\<^sub>2' ml_v\\<^sub>2", "unfolding \\<open>ress = _\\<close> \\<open>exps = _\\<close> \\<open>ml_vs = _\\<close> \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_exp exp\\<^sub>1\n  is_cupcake_exp exp\\<^sub>2\n  fmrel_on_fset (ids t\\<^sub>1) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  fmrel_on_fset (ids t\\<^sub>2) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev [exp\\<^sub>1, exp\\<^sub>2]) (map Rval [ml_v\\<^sub>2, ml_v\\<^sub>1])\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result (map Rval [ml_v\\<^sub>2, ml_v\\<^sub>1]) =\n  Rval [ml_v\\<^sub>2, ml_v\\<^sub>1]\n  do_opapp (rev [ml_v\\<^sub>2, ml_v\\<^sub>1]) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n   (exp0.App Opapp [exp\\<^sub>1, exp\\<^sub>2])\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n  related_exp t\\<^sub>1 exp\\<^sub>1\n  related_exp t\\<^sub>2 exp\\<^sub>2\n\ngoal (1 subgoal):\n 1. (cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1) &&&\n     cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)) &&&\n    \\<exists>t\\<^sub>1'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n       related_v t\\<^sub>1' ml_v\\<^sub>1 &&&\n    \\<exists>t\\<^sub>2'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n       related_v t\\<^sub>2' ml_v\\<^sub>2", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1)\n  cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)\n  \\<exists>t\\<^sub>1'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n     related_v t\\<^sub>1' ml_v\\<^sub>1\n  \\<exists>t\\<^sub>2'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n     related_v t\\<^sub>2' ml_v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "then"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1)\n  cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)\n  \\<exists>t\\<^sub>1'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n     related_v t\\<^sub>1' ml_v\\<^sub>1\n  \\<exists>t\\<^sub>2'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n     related_v t\\<^sub>2' ml_v\\<^sub>2", "obtain v\\<^sub>1 v\\<^sub>2\n    where \"\\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\" \"related_v v\\<^sub>1 ml_v\\<^sub>1\"\n      and \"\\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> v\\<^sub>2\" \"related_v v\\<^sub>2 ml_v\\<^sub>2\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env exp\\<^sub>1 (Rval ml_v\\<^sub>1)\n  cupcake_evaluate_single env exp\\<^sub>2 (Rval ml_v\\<^sub>2)\n  \\<exists>t\\<^sub>1'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> t\\<^sub>1' \\<and>\n     related_v t\\<^sub>1' ml_v\\<^sub>1\n  \\<exists>t\\<^sub>2'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> t\\<^sub>2' \\<and>\n     related_v t\\<^sub>2' ml_v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1 v\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1;\n         related_v v\\<^sub>1 ml_v\\<^sub>1;\n         \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> v\\<^sub>2;\n         related_v v\\<^sub>2 ml_v\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n  related_v v\\<^sub>1 ml_v\\<^sub>1\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> v\\<^sub>2\n  related_v v\\<^sub>2 ml_v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"is_cupcake_value ml_v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value ml_v\\<^sub>1", "by (rule cupcake_single_preserve) fact+"], ["proof (state)\nthis:\n  is_cupcake_value ml_v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "moreover"], ["proof (state)\nthis:\n  is_cupcake_value ml_v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"is_cupcake_value ml_v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value ml_v\\<^sub>2", "by (rule cupcake_single_preserve) fact+"], ["proof (state)\nthis:\n  is_cupcake_value ml_v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_value ml_v\\<^sub>1\n  is_cupcake_value ml_v\\<^sub>2", "have \"list_all is_cupcake_value (rev ml_vs)\""], ["proof (prove)\nusing this:\n  is_cupcake_value ml_v\\<^sub>1\n  is_cupcake_value ml_v\\<^sub>2\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev ml_vs)", "unfolding \\<open>ml_vs = _\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_value ml_v\\<^sub>1\n  is_cupcake_value ml_v\\<^sub>2\n\ngoal (1 subgoal):\n 1. list_all is_cupcake_value (rev [ml_v\\<^sub>2, ml_v\\<^sub>1])", "by simp"], ["proof (state)\nthis:\n  list_all is_cupcake_value (rev ml_vs)\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "hence \"is_cupcake_exp exp'\" \"is_cupcake_all_env env'\""], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev ml_vs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp exp' &&& is_cupcake_all_env env'", "using \\<open>do_opapp _ = _\\<close>"], ["proof (prove)\nusing this:\n  list_all is_cupcake_value (rev ml_vs)\n  do_opapp (rev ml_vs) = Some (env', exp')\n\ngoal (1 subgoal):\n 1. is_cupcake_exp exp' &&& is_cupcake_all_env env'", "by (metis cupcake_opapp_preserve)+"], ["proof (state)\nthis:\n  is_cupcake_exp exp'\n  is_cupcake_all_env env'\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vclosed v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>1", "proof (rule veval'_closed)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>1\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "show \"closed_except t\\<^sub>1 (fmdom \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t\\<^sub>1 (fmdom \\<Gamma>)", "using \\<open>closed_except _ (fmdom \\<Gamma>)\\<close>"], ["proof (prove)\nusing this:\n  closed_except t (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed_except t\\<^sub>1 (fmdom \\<Gamma>)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed_except t\\<^sub>1 (fmdom \\<Gamma>)", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  closed_except t\\<^sub>1 (fmdom \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed t\\<^sub>1\n 4. wellformed_venv \\<Gamma>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed t\\<^sub>1\n 4. wellformed_venv \\<Gamma>", "show \"wellformed t\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t\\<^sub>1", "using \\<open>wellformed t\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t\\<^sub>1", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n 2. closed_venv \\<Gamma>\n 3. wellformed_venv \\<Gamma>", "qed fact+"], ["proof (state)\nthis:\n  vclosed v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vclosed v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. closed_except ?t (fmdom ?\\<Gamma>)\n 3. closed_venv ?\\<Gamma>\n 4. pre_strong_term_class.wellformed ?t\n 5. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. closed_except t\\<^sub>2 (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed t\\<^sub>2\n 4. wellformed_venv \\<Gamma>", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. closed_except t\\<^sub>2 (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed t\\<^sub>2\n 4. wellformed_venv \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. closed_except t\\<^sub>2 (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed t\\<^sub>2\n 4. wellformed_venv \\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  vclosed v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vwellformed v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>1", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>1\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>1\n 2. wellformed_venv \\<Gamma>", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>1\n 2. wellformed_venv \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>1\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vwellformed v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>2", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. pre_strong_term_class.wellformed ?t\n 3. wellformed_venv ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>2\n 2. wellformed_venv \\<Gamma>", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>2\n 2. wellformed_venv \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\\<^sub>2\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwellformed v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vwelldefined' v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' v\\<^sub>1", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>1\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>1 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>1\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>1\n 7. not_shadows_vconsts_env \\<Gamma>", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>1 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>1\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>1\n 7. not_shadows_vconsts_env \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>1 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>1\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>1\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"vwelldefined' v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' v\\<^sub>2", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. fdisjnt C (fmdom ?\\<Gamma>)\n 3. consts ?t |\\<subseteq>| fmdom ?\\<Gamma> |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>\n 5. pre_strong_term_class.wellformed ?t\n 6. wellformed_venv ?\\<Gamma>\n 7. \\<not> shadows_consts ?t\n 8. not_shadows_vconsts_env ?\\<Gamma>", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>2 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>2\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>2\n 7. not_shadows_vconsts_env \\<Gamma>", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>2 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>2\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>2\n 7. not_shadows_vconsts_env \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts t\\<^sub>2 |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed t\\<^sub>2\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts t\\<^sub>2\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  vwelldefined' v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"not_shadows_vconsts v\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts v\\<^sub>1", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>1\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>1", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>1", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts v\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"not_shadows_vconsts v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts v\\<^sub>2", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma> \\<turnstile>\\<^sub>v ?t \\<down> v\\<^sub>2\n 2. not_shadows_vconsts_env ?\\<Gamma>\n 3. \\<not> shadows_consts ?t", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>2", "using app1"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>2", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2_shortcircuit\n   (\\<lambda>x1 x2.\n       cupcake_evaluate_single env x1 x2 \\<and>\n       (is_cupcake_all_env env \\<longrightarrow>\n        (\\<forall>x xa.\n            fmrel_on_fset (ids xa) related_v x\n             (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n            related_exp xa x1 \\<longrightarrow>\n            pre_strong_term_class.wellformed xa \\<longrightarrow>\n            wellformed_venv x \\<longrightarrow>\n            closed_venv x \\<longrightarrow>\n            closed_except xa (fmdom x) \\<longrightarrow>\n            fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n            consts xa |\\<subseteq>| fmdom x |\\<union>| C \\<longrightarrow>\n            fdisjnt C (fmdom x) \\<longrightarrow>\n            \\<not> shadows_consts xa \\<longrightarrow>\n            not_shadows_vconsts_env x \\<longrightarrow>\n            if_rval\n             (\\<lambda>ml_v.\n                 \\<exists>v.\n                    x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                    related_v v ml_v)\n             x2)))\n   (rev exps) ress\n  \\<lbrakk>is_cupcake_all_env env';\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env'));\n   related_exp ?t4 exp'; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     bv\n  sequence_result ress = Rval ml_vs\n  do_opapp (rev ml_vs) = Some (env', exp')\n  cupcake_evaluate_single env' exp' bv\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (exp0.App Opapp exps)\n  pre_strong_term_class.wellformed (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2) |\\<subseteq>|\n  fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (t\\<^sub>1 $\\<^sub>s t\\<^sub>2)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts v\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs env' e bv \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = Some (env', e);\n        cupcake_evaluate_single env' e bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env';\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env'));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 5. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 6. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 8. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 9. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     bv", "proof (rule if_rvalI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       bv = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "fix ml_v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       bv = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "assume \"bv = Rval ml_v\""], ["proof (state)\nthis:\n  bv = Rval ml_v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       bv = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "show \"\\<exists>v. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v", "using \\<open>do_opapp _ = _\\<close>"], ["proof (prove)\nusing this:\n  do_opapp (rev ml_vs) = Some (env', exp')\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v", "proof (cases rule: do_opapp_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "case (closure env\\<^sub>\\<Lambda> n)"], ["proof (state)\nthis:\n  rev ml_vs = [Closure env\\<^sub>\\<Lambda> n exp', v0_]\n  env' =\n  update_v (\\<lambda>_. nsBind n v0_ (sem_env.v env\\<^sub>\\<Lambda>))\n   env\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  rev ml_vs = [Closure env\\<^sub>\\<Lambda> n exp', v0_]\n  env' =\n  update_v (\\<lambda>_. nsBind n v0_ (sem_env.v env\\<^sub>\\<Lambda>))\n   env\\<^sub>\\<Lambda>", "have closure':\n            \"ml_v\\<^sub>1 = Closure env\\<^sub>\\<Lambda> (as_string (Name n)) exp'\"\n            \"env' = update_v (\\<lambda>_. nsBind (as_string (Name n)) ml_v\\<^sub>2 (sem_env.v env\\<^sub>\\<Lambda>)) env\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  rev ml_vs = [Closure env\\<^sub>\\<Lambda> n exp', v0_]\n  env' =\n  update_v (\\<lambda>_. nsBind n v0_ (sem_env.v env\\<^sub>\\<Lambda>))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. ml_v\\<^sub>1 = Closure env\\<^sub>\\<Lambda> (as_string (Name n)) exp' &&&\n    env' =\n    update_v\n     (\\<lambda>_.\n         nsBind (as_string (Name n)) ml_v\\<^sub>2\n          (sem_env.v env\\<^sub>\\<Lambda>))\n     env\\<^sub>\\<Lambda>", "unfolding \\<open>ml_vs = _\\<close>"], ["proof (prove)\nusing this:\n  rev [ml_v\\<^sub>2, ml_v\\<^sub>1] =\n  [Closure env\\<^sub>\\<Lambda> n exp', v0_]\n  env' =\n  update_v (\\<lambda>_. nsBind n v0_ (sem_env.v env\\<^sub>\\<Lambda>))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. ml_v\\<^sub>1 = Closure env\\<^sub>\\<Lambda> (as_string (Name n)) exp' &&&\n    env' =\n    update_v\n     (\\<lambda>_.\n         nsBind (as_string (Name n)) ml_v\\<^sub>2\n          (sem_env.v env\\<^sub>\\<Lambda>))\n     env\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  ml_v\\<^sub>1 = Closure env\\<^sub>\\<Lambda> (as_string (Name n)) exp'\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind (as_string (Name n)) ml_v\\<^sub>2\n        (sem_env.v env\\<^sub>\\<Lambda>))\n   env\\<^sub>\\<Lambda>\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "obtain \\<Gamma>\\<^sub>\\<Lambda> cs\n            where \"v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\" \"related_fun cs (Name n) exp'\"\n              and \"fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>;\n         related_fun cs (Name n) exp';\n         fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>related_v v\\<^sub>1 ml_v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  related_v v\\<^sub>1 ml_v\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>cs \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>;\n         related_fun cs (Name n) exp';\n         fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>ml_v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  related_v v\\<^sub>1\n   (Closure env\\<^sub>\\<Lambda> (as_string (Name n)) exp')\n\ngoal (1 subgoal):\n 1. (\\<And>cs \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>;\n         related_fun cs (Name n) exp';\n         fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  related_fun cs (Name n) exp'\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  related_fun cs (Name n) exp'\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "obtain ml_cs\n            where \"exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\" \"Name n |\\<notin>| ids (Sabs cs)\" \"Name n |\\<notin>| all_consts\"\n              and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\""], ["proof (prove)\nusing this:\n  v\\<^sub>1 = Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n  related_fun cs (Name n) exp'\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. (\\<And>ml_cs.\n        \\<lbrakk>exp' = Mat (Var (Short (as_string (Name n)))) ml_cs;\n         Name n |\\<notin>| ids (Sabs cs); Name n |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: related_funE)"], ["proof (state)\nthis:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"cupcake_evaluate_single env' (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)\""], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env'\n     (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)", "using \\<open>cupcake_evaluate_single env' exp' bv\\<close>"], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  cupcake_evaluate_single env' exp' bv\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env'\n     (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  cupcake_evaluate_single env' exp' (Rval ml_v)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env'\n     (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)", "by simp"], ["proof (state)\nthis:\n  cupcake_evaluate_single env'\n   (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env'\n   (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)", "obtain m_env v' ml_rhs ml_pat\n            where \"cupcake_evaluate_single env' (Var (Short (as_string (Name n)))) (Rval v')\"\n              and \"cupcake_match_result (sem_env.c env') v' ml_cs Bindv = Rval (ml_rhs, ml_pat, m_env)\"\n              and \"cupcake_evaluate_single (env' \\<lparr> sem_env.v := nsAppend (alist_to_ns m_env) (sem_env.v env') \\<rparr>) ml_rhs (Rval ml_v)\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env'\n   (Mat (Var (Short (as_string (Name n)))) ml_cs) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v' ml_rhs ml_pat m_env.\n        \\<lbrakk>cupcake_evaluate_single env'\n                  (Var (Short (as_string (Name n)))) (Rval v');\n         cupcake_match_result (sem_env.c env') v' ml_cs Bindv =\n         Rval (ml_rhs, ml_pat, m_env);\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns m_env) (sem_env.v env'))\n            env')\n          ml_rhs (Rval ml_v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  cupcake_evaluate_single env' (Var (Short (as_string (Name n)))) (Rval v')\n  cupcake_match_result (sem_env.c env') v' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, m_env)\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns m_env) (sem_env.v env'))\n     env')\n   ml_rhs (Rval ml_v)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have\n            \"closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\" \"wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\"\n            \"not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\" \"fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vclosed v\\<^sub>1\\<close> \\<open>vclosed v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vwellformed v\\<^sub>1\\<close> \\<open>vwellformed v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n  vwellformed v\\<^sub>1\n  vwellformed v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>not_shadows_vconsts v\\<^sub>1\\<close> \\<open>not_shadows_vconsts v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n  vwellformed v\\<^sub>1\n  vwellformed v\\<^sub>2\n  not_shadows_vconsts v\\<^sub>1\n  not_shadows_vconsts v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vwelldefined' v\\<^sub>1\\<close> \\<open>vwelldefined' v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n  vwellformed v\\<^sub>1\n  vwellformed v\\<^sub>2\n  not_shadows_vconsts v\\<^sub>1\n  not_shadows_vconsts v\\<^sub>2\n  vwelldefined' v\\<^sub>1\n  vwelldefined' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  vclosed v\\<^sub>2\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  vwellformed v\\<^sub>2\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  not_shadows_vconsts v\\<^sub>2\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n  vwelldefined' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. (closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n     wellformed_venv\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)) &&&\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) &&&\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "by auto"], ["proof (state)\nthis:\n  closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n  wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>vclosed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "apply (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n        \\<forall>x\\<in>set cs.\n           case x of\n           (pat, t) \\<Rightarrow>\n             closed_except t\n              (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)\\<rbrakk>\n       \\<Longrightarrow> closed_except b\n                          (finsert (Name n)\n                            (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                             frees a))", "apply (auto simp: closed_except_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"consts (Sabs cs) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C", "using \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C", "unfolding sconsts_sabs"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         consts t |\\<subseteq>|\n         fmdom\n          (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n         C)\n     cs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"\\<not> shadows_consts (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "using \\<open>not_shadows_vconsts v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts v\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "by (auto simp: list_all_iff list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"if_rval (\\<lambda>ml_v. \\<exists>v. fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v \\<and> related_v v ml_v) bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n            \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n            v \\<and> related_v v ml_v)\n     bv", "proof (rule app1(2))"], ["proof (state)\ngoal (12 subgoals):\n 1. is_cupcake_all_env env'\n 2. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmap_of_ns (sem_env.v env'))\n 3. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 4. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 5. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 6. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 7. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 9. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 10. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\nA total of 12 subgoals...", "show \"fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) (fmap_of_ns (sem_env.v env'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmap_of_ns (sem_env.v env'))", "unfolding closure'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmap_of_ns\n       (sem_env.v\n         (update_v\n           (\\<lambda>_.\n               nsBind (as_string (Name n)) ml_v\\<^sub>2\n                (sem_env.v env\\<^sub>\\<Lambda>))\n           env\\<^sub>\\<Lambda>)))", "apply (simp del: frees_sterm.simps(3) consts_sterm.simps(3) name.sel add: ids_def split!: sem_env.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset\n     (finsert (Name n) (frees (Sabs cs) |\\<union>| consts (Sabs cs)))\n     related_v (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmupd (Name n) ml_v\\<^sub>2\n       (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>)))", "apply (rule fmrel_on_fset_updateI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (frees (Sabs cs) |\\<union>| consts (Sabs cs)) related_v\n     \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply (fold ids_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "using \\<open>fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda> _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (2 subgoals):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply (rule \\<open>related_v v\\<^sub>2 ml_v\\<^sub>2\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n   (fmap_of_ns (sem_env.v env'))\n\ngoal (11 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 4. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 6. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 8. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 9. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 10. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 4. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 6. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 8. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 9. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 10. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\nA total of 11 subgoals...", "show \"wellformed (Sabs cs $\\<^sub>s Svar (Name n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "using \\<open>vwellformed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwellformed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "by simp"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n\ngoal (10 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 7. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 8. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 9. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 10. not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 7. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 8. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 9. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 10. not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "show \"related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'", "unfolding \\<open>exp' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs $\\<^sub>s Svar (Name n))\n     (Mat (Var (Short (as_string (Name n)))) ml_cs)", "using \\<open>list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<close>"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (1 subgoal):\n 1. related_exp (Sabs cs $\\<^sub>s Svar (Name n))\n     (Mat (Var (Short (as_string (Name n)))) ml_cs)", "by (auto intro:related_exp.intros simp del: name.sel)"], ["proof (state)\nthis:\n  related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n\ngoal (9 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 6. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 7. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 8. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 9. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 6. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 7. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 8. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 9. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "show \"closed_except (Sabs cs $\\<^sub>s Svar (Name n)) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "by (simp add: closed_except_def)"], ["proof (state)\nthis:\n  closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (8 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 6. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 8. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 6. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 8. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "show \"\\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))", "using \\<open>\\<not> shadows_consts (Sabs cs)\\<close> \\<open>Name n |\\<notin>| all_consts\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n  Name n |\\<notin>| all_consts\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))", "by simp"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n\ngoal (7 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 6. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n 6. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 7. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "show \"consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C", "using \\<open>consts (Sabs cs) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\\<close>"], ["proof (prove)\nusing this:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n\ngoal (1 subgoal):\n 1. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C", "by simp"], ["proof (state)\nthis:\n  consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n\ngoal (6 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 6. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n 6. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "show \"fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>Name n |\\<notin>| all_consts\\<close> \\<open>fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| all_consts\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding fdisjnt_alt_def all_consts_def"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| heads |\\<union>| C\n  C |\\<inter>| fmdom \\<Gamma>\\<^sub>\\<Lambda> = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) =\n    {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (5 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 3. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 5. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)", "qed fact+"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv", "obtain v where \"fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\" \"related_v v ml_v\""], ["proof (prove)\nusing this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n                 \\<turnstile>\\<^sub>v\n                 Sabs cs $\\<^sub>s Svar (Name n) \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\nusing this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>\n                 \\<turnstile>\\<^sub>v\n                 Sabs cs $\\<^sub>s Svar (Name n) \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> \\<turnstile>\\<^sub>v\n  Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> \\<turnstile>\\<^sub>v\n  Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v", "obtain env pat rhs\n            where \"vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\"\n              and \"fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\""], ["proof (prove)\nusing this:\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> \\<turnstile>\\<^sub>v\n  Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v\n\ngoal (1 subgoal):\n 1. (\\<And>env pat rhs.\n        \\<lbrakk>vfind_match cs v\\<^sub>2 = Some (env, pat, rhs);\n         fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n         \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: veval'_sabs_svarE)"], ["proof (state)\nthis:\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) v\\<^sub>2 = Some env\""], ["proof (prove)\nusing this:\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) v\\<^sub>2 = Some env", "by (metis vfind_match_elem)+"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"linear pat\" \"wellformed rhs\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "using \\<open>vwellformed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n  vwellformed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n  vwellformed (Vabs cs \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  Pats.linear pat\n  pre_strong_term_class.wellformed rhs\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  Pats.linear pat\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule \\<open>vmatch (mk_pat pat) v\\<^sub>2 = Some env\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "obtain v' where \"\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v'\" \"v' \\<approx>\\<^sub>e v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule veval'_agree_eq)"], ["proof (state)\ngoal (12 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> ?v6\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t6) erelated ?\\<Gamma>'6 ?\\<Gamma>6\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t6 (fmdom ?\\<Gamma>6)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t6\nA total of 12 subgoals...", "show \"fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n    \\<turnstile>\\<^sub>v rhs \\<down> v", "by fact"], ["proof (state)\nthis:\n  fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\nA total of 11 subgoals...", "have *: \"Name n |\\<notin>| ids rhs\" if \"Name n |\\<notin>| fmdom env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Name n |\\<notin>| ids rhs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Name n |\\<in>| ids rhs \\<Longrightarrow> False", "assume \"Name n |\\<in>| ids rhs\""], ["proof (state)\nthis:\n  Name n |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| ids rhs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Name n |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees rhs |\\<union>| consts rhs\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "case A"], ["proof (state)\nthis:\n  Name n |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Name n |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "have \"Name n |\\<notin>| frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "using that"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "."], ["proof (state)\nthis:\n  Name n |\\<notin>| frees pat\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Name n |\\<in>| frees rhs\n  Name n |\\<notin>| frees pat", "have \"Name n |\\<in>| frees (Sabs cs)\""], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees rhs\n  Name n |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| frees (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)\n                       ((|\\<in>|) (Name n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           Name n |\\<in>|\n                           (case x of\n                            (pat, rhs) \\<Rightarrow>\n                              frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      (case (pat, rhs) of\n                       (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Name n |\\<in>| frees (Sabs cs)\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Name n |\\<notin>| ids (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n  Name n |\\<notin>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n  Name n |\\<notin>| frees (Sabs cs) |\\<union>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "case B"], ["proof (state)\nthis:\n  Name n |\\<notin>| frees rhs\n  Name n |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Name n |\\<in>| consts (Sabs cs)\""], ["proof (prove)\nusing this:\n  Name n |\\<notin>| frees rhs\n  Name n |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| consts (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)\n                       ((|\\<in>|) (Name n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           Name n |\\<in>|\n                           (case x of (uu_, x) \\<Rightarrow> consts x))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      (case (pat, rhs) of (uu_, x) \\<Rightarrow> consts x)\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Name n |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Name n |\\<notin>| ids (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n  Name n |\\<notin>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n  Name n |\\<notin>| frees (Sabs cs) |\\<union>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Name n |\\<notin>| fmdom env \\<Longrightarrow> Name n |\\<notin>| ids rhs\n\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\nA total of 11 subgoals...", "show \"fmrel_on_fset (ids rhs) erelated (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) x)\n        (fmlookup\n          (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n          x)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs; Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 2. \\<lbrakk>Name n |\\<in>| ids rhs; Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 4. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply (rule option.rel_refl; rule erelated_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs; Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "using *"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| fmdom env \\<Longrightarrow> Name n |\\<notin>| ids rhs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs; Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply auto[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; Name n \\<noteq> x;\n        x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply (rule option.rel_refl; rule erelated_refl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) erelated (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (10 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 10. \\<And>v'.\n        \\<lbrakk>\\<And>v'.\n                    \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                             \\<turnstile>\\<^sub>v rhs \\<down> v';\n                     v' \\<approx>\\<^sub>e v\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n         rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 10. \\<And>v'.\n        \\<lbrakk>\\<And>v'.\n                    \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                             \\<turnstile>\\<^sub>v rhs \\<down> v';\n                     v' \\<approx>\\<^sub>e v\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n         rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis", "show \"closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 2. closed_venv env", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vclosed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_venv\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (9 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 9. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n 2. wellformed_venv env", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vwellformed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (8 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 8. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_except rhs (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "using \\<open>fmdom env = frees pat\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = frees pat\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "using \\<open>closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = frees pat\n  (pat, rhs) \\<in> set cs\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "by (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (state)\nthis:\n  closed_except rhs\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (7 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 7. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by fact"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (6 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 6. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"consts rhs |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "using \\<open>consts (Sabs cs) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| C\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "unfolding sconsts_sabs"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(uu_, t).\n       consts t |\\<subseteq>|\n       fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n       C)\n   cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env) |\\<union>|\n    C", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env) |\\<union>|\n  C\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>\\<not> shadows_consts (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_ex_iff fdisjnt_alt_def all_consts_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "using \\<open>Name n |\\<notin>| all_consts\\<close> \\<open>fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n  Name n |\\<notin>| all_consts\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom env = {||}\n  Name n |\\<notin>| all_consts\n  C |\\<inter>| fmdom \\<Gamma>\\<^sub>\\<Lambda> = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) =\n    {||}", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  fdisjnt C\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env))\n\ngoal (4 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 4. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>\\<not> shadows_consts (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "by (rule not_shadows_vconsts.vmatch_env) fact+"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env env\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "using \\<open>not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env env\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by (rule vmatch_welldefined') fact+"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "using \\<open>fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)", "by blast"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env)\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v\n        rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down>\n  v'\n  v' \\<approx>\\<^sub>e v\n\ngoal (2 subgoals):\n 1. \\<And>env n v0.\n       \\<lbrakk>rev ml_vs = [Closure env n exp', v0];\n        env' =\n        update_v (\\<lambda>_. nsBind n v0 (sem_env.v env)) env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v\n 2. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> ?v\n 2. related_v ?v ml_v", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 $\\<^sub>s t\\<^sub>2 \\<down> ?v\n 2. related_v ?v ml_v", "apply (rule veval'.comb)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> Vabs ?cs2 ?\\<Gamma>'2\n 2. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 4. ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 5. related_v ?v ml_v", "using \\<open>\\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n\ngoal (5 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> Vabs ?cs2 ?\\<Gamma>'2\n 2. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 4. ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 5. related_v ?v ml_v", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down>\n  Vabs cs \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (5 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> Vabs ?cs2 ?\\<Gamma>'2\n 2. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 4. ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 5. related_v ?v ml_v", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 2. vfind_match cs ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 3. \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v\n    ?rhs2 \\<down> ?v\n 4. related_v ?v ml_v", "apply fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. vfind_match cs v\\<^sub>2 = Some (?env2, ?uu2, ?rhs2)\n 2. \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v\n    ?rhs2 \\<down> ?v\n 3. related_v ?v ml_v", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v' ml_v", "apply (rule related_v_ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. related_v ?v13 ml_v\n 2. v' \\<approx>\\<^sub>e ?v13", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "case (recclosure env\\<^sub>\\<Lambda> funs name n)"], ["proof (state)\nthis:\n  rev ml_vs = [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "with recclosure"], ["proof (chain)\npicking this:\n  rev ml_vs = [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n  rev ml_vs = [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>", "have recclosure':\n            \"ml_v\\<^sub>1 = Recclosure env\\<^sub>\\<Lambda> funs name\"\n            \"env' = update_v (\\<lambda>_. nsBind (as_string (Name n)) ml_v\\<^sub>2 (build_rec_env funs env\\<^sub>\\<Lambda> (sem_env.v env\\<^sub>\\<Lambda>))) env\\<^sub>\\<Lambda>\""], ["proof (prove)\nusing this:\n  rev ml_vs = [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n  rev ml_vs = [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. ml_v\\<^sub>1 = Recclosure env\\<^sub>\\<Lambda> funs name &&&\n    env' =\n    update_v\n     (\\<lambda>_.\n         nsBind (as_string (Name n)) ml_v\\<^sub>2\n          (build_rec_env funs env\\<^sub>\\<Lambda>\n            (sem_env.v env\\<^sub>\\<Lambda>)))\n     env\\<^sub>\\<Lambda>", "unfolding \\<open>ml_vs = _\\<close>"], ["proof (prove)\nusing this:\n  rev [ml_v\\<^sub>2, ml_v\\<^sub>1] =\n  [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n  rev [ml_v\\<^sub>2, ml_v\\<^sub>1] =\n  [Recclosure env\\<^sub>\\<Lambda> funs name, v0_]\n  allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs)\n  find_recfun name funs = Some (n, exp')\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind n v0_\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. ml_v\\<^sub>1 = Recclosure env\\<^sub>\\<Lambda> funs name &&&\n    env' =\n    update_v\n     (\\<lambda>_.\n         nsBind (as_string (Name n)) ml_v\\<^sub>2\n          (build_rec_env funs env\\<^sub>\\<Lambda>\n            (sem_env.v env\\<^sub>\\<Lambda>)))\n     env\\<^sub>\\<Lambda>", "by auto"], ["proof (state)\nthis:\n  ml_v\\<^sub>1 = Recclosure env\\<^sub>\\<Lambda> funs name\n  env' =\n  update_v\n   (\\<lambda>_.\n       nsBind (as_string (Name n)) ml_v\\<^sub>2\n        (build_rec_env funs env\\<^sub>\\<Lambda>\n          (sem_env.v env\\<^sub>\\<Lambda>)))\n   env\\<^sub>\\<Lambda>\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "obtain \\<Gamma>\\<^sub>\\<Lambda> css\n            where \"v\\<^sub>1 = Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>\"\n              and \"fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\"\n              and \"fmrel (\\<lambda>cs (n, e). related_fun cs n e) css (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>css \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 =\n                 Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>;\n         fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n          \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>));\n         fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n          (fmap_of_list\n            (map (map_prod Name (map_prod Name id)) funs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>related_v v\\<^sub>1 ml_v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  related_v v\\<^sub>1 ml_v\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>css \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 =\n                 Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>;\n         fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n          \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>));\n         fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n          (fmap_of_list\n            (map (map_prod Name (map_prod Name id)) funs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>ml_v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  related_v v\\<^sub>1 (Recclosure env\\<^sub>\\<Lambda> funs name)\n\ngoal (1 subgoal):\n 1. (\\<And>css \\<Gamma>\\<^sub>\\<Lambda>.\n        \\<lbrakk>v\\<^sub>1 =\n                 Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>;\n         fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n          \\<Gamma>\\<^sub>\\<Lambda>\n          (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>));\n         fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n          (fmap_of_list\n            (map (map_prod Name (map_prod Name id)) funs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  v\\<^sub>1 = Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>\n  fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n   \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "from \\<open>fmrel _ _ _\\<close>"], ["proof (chain)\npicking this:\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))", "have \"rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e) (fmlookup css (Name name)) (find_recfun name funs)\""], ["proof (prove)\nusing this:\n  fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n   (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n     (fmlookup css (Name name)) (find_recfun name funs)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n     (fmap_of_list\n       (map (map_prod Name (map_prod Name id)) funs)) \\<Longrightarrow>\n    rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n     (fmlookup css (Name name)) (find_recfun name funs)", "apply (subst option.rel_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n     (fmap_of_list\n       (map (map_prod Name (map_prod Name id)) funs)) \\<Longrightarrow>\n    (fmlookup css (Name name) = None) =\n    (find_recfun name funs = None) \\<and>\n    (fmlookup css (Name name) \\<noteq> None \\<longrightarrow>\n     find_recfun name funs \\<noteq> None \\<longrightarrow>\n     (case option.the (find_recfun name funs) of\n      (n, x) \\<Rightarrow>\n        related_fun (option.the (fmlookup css (Name name))) (Name n) x))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     fmlookup css (Name name) = None\\<rbrakk>\n    \\<Longrightarrow> map_of funs name = None\n 2. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 3. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply (drule fmrel_fmdom_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fmlookup css (Name name) = None;\n     fmdom css =\n     fmdom\n      (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\\<rbrakk>\n    \\<Longrightarrow> map_of funs name = None\n 2. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 3. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply (drule fmdom_notI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>fmdom css =\n             fmdom\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     Name name |\\<notin>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> map_of funs name = None\n 2. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 3. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "using \\<open>v\\<^sub>1 = Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>\\<close> \\<open>vwellformed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  v\\<^sub>1 = Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>\n  vwellformed v\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>fmdom css =\n             fmdom\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     Name name |\\<notin>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> map_of funs name = None\n 2. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 3. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 2. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "using recclosure(3)"], ["proof (prove)\nusing this:\n  find_recfun name funs = Some (n, exp')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n              (fmap_of_list (map (map_prod Name (map_prod Name id)) funs));\n     map_of funs name = None\\<rbrakk>\n    \\<Longrightarrow> fmlookup css (Name name) = None\n 2. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n b.\n       \\<lbrakk>fmrel (\\<lambda>cs (x, y). related_fun cs x y) css\n                 (fmap_of_list\n                   (map (map_prod Name (map_prod Name id)) funs));\n        fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b)\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply (erule fmrel_cases[where x = \"Name name\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y n b.\n       \\<lbrakk>fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b); fmlookup css (Name name) = None;\n        fmlookup\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n         (Name name) =\n        None\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b\n 2. \\<And>y n b a ba.\n       \\<lbrakk>fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b); fmlookup css (Name name) = Some a;\n        fmlookup\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n         (Name name) =\n        Some ba;\n        case ba of (x, xa) \\<Rightarrow> related_fun a x xa\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n b a ba.\n       \\<lbrakk>fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b); fmlookup css (Name name) = Some a;\n        fmlookup\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n         (Name name) =\n        Some ba;\n        case ba of (x, xa) \\<Rightarrow> related_fun a x xa\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply (subst (asm) fmlookup_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n b a ba.\n       \\<lbrakk>fmlookup css (Name name) = Some y;\n        map_of funs name = Some (n, b); fmlookup css (Name name) = Some a;\n        map_of (map (map_prod Name (map_prod Name id)) funs) (Name name) =\n        Some ba;\n        case ba of (x, xa) \\<Rightarrow> related_fun a x xa\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "apply (simp add: name.map_of_rekey')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n b a ba.\n       \\<lbrakk>a = y; map_of funs name = Some (n, b);\n        fmlookup css (Name name) = Some y; (Name n, b) = ba;\n        case ba of (x, xa) \\<Rightarrow> related_fun y x xa\\<rbrakk>\n       \\<Longrightarrow> related_fun y (Name n) b", "by blast"], ["proof (state)\nthis:\n  rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n   (fmlookup css (Name name)) (find_recfun name funs)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n   (fmlookup css (Name name)) (find_recfun name funs)", "obtain cs where \"fmlookup css (Name name) = Some cs\" \"related_fun cs (Name n) exp'\""], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n   (fmlookup css (Name name)) (find_recfun name funs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>fmlookup css (Name name) = Some cs;\n         related_fun cs (Name n) exp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>find_recfun _ _ = _\\<close>"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>cs (n, e). related_fun cs (Name n) e)\n   (fmlookup css (Name name)) (find_recfun name funs)\n  find_recfun name funs = Some (n, exp')\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>fmlookup css (Name name) = Some cs;\n         related_fun cs (Name n) exp'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  fmlookup css (Name name) = Some cs\n  related_fun cs (Name n) exp'\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  fmlookup css (Name name) = Some cs\n  related_fun cs (Name n) exp'", "obtain ml_cs\n            where \"exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\" \"Name n |\\<notin>| ids (Sabs cs)\" \"Name n |\\<notin>| all_consts\"\n              and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\""], ["proof (prove)\nusing this:\n  fmlookup css (Name name) = Some cs\n  related_fun cs (Name n) exp'\n\ngoal (1 subgoal):\n 1. (\\<And>ml_cs.\n        \\<lbrakk>exp' = Mat (Var (Short (as_string (Name n)))) ml_cs;\n         Name n |\\<notin>| ids (Sabs cs); Name n |\\<notin>| all_consts;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: related_funE)"], ["proof (state)\nthis:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)\""], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)", "using \\<open>cupcake_evaluate_single env' exp' bv\\<close>"], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  cupcake_evaluate_single env' exp' bv\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\nusing this:\n  exp' = Mat (Var (Short (as_string (Name n)))) ml_cs\n  Name n |\\<notin>| ids (Sabs cs)\n  Name n |\\<notin>| all_consts\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  cupcake_evaluate_single env' exp' (Rval ml_v)\n\ngoal (1 subgoal):\n 1. cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)", "by simp"], ["proof (state)\nthis:\n  cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)", "obtain m_env v' ml_rhs ml_pat\n            where \"cupcake_evaluate_single env' (Var (Short n)) (Rval v')\"\n              and \"cupcake_match_result (sem_env.c env') v' ml_cs Bindv = Rval (ml_rhs, ml_pat, m_env)\"\n              and \"cupcake_evaluate_single (env' \\<lparr> sem_env.v := nsAppend (alist_to_ns m_env) (sem_env.v env') \\<rparr>) ml_rhs (Rval ml_v)\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env' (Mat (Var (Short n)) ml_cs) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v' ml_rhs ml_pat m_env.\n        \\<lbrakk>cupcake_evaluate_single env' (Var (Short n)) (Rval v');\n         cupcake_match_result (sem_env.c env') v' ml_cs Bindv =\n         Rval (ml_rhs, ml_pat, m_env);\n         cupcake_evaluate_single\n          (update_v\n            (\\<lambda>_. nsAppend (alist_to_ns m_env) (sem_env.v env'))\n            env')\n          ml_rhs (Rval ml_v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases auto"], ["proof (state)\nthis:\n  cupcake_evaluate_single env' (Var (Short n)) (Rval v')\n  cupcake_match_result (sem_env.c env') v' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, m_env)\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns m_env) (sem_env.v env'))\n     env')\n   ml_rhs (Rval ml_v)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"closed_venv (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>vclosed v\\<^sub>1\\<close> \\<open>vclosed v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n  vclosed v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close> mk_rec_env_def"], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  vclosed v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> closed_venv\n                       (fmupd (Name n) v\\<^sub>2\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          fmmap_keys\n                           (\\<lambda>name cs.\n                               Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                           css))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> closed_venv\n                       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                        fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 2. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> vclosed v\\<^sub>2", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> closed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> closed_venv\n                       (fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 3. \\<lbrakk>vclosed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               closed_except t\n                (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat)))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> vclosed v\\<^sub>2", "apply (auto intro: fmdomI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_venv\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"wellformed_venv (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>vwellformed v\\<^sub>1\\<close> \\<open>vwellformed v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vwellformed v\\<^sub>1\n  vwellformed v\\<^sub>2\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwellformed v\\<^sub>1\n  vwellformed v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close> mk_rec_env_def"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  vwellformed v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv\n                       (fmupd (Name n) v\\<^sub>2\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          fmmap_keys\n                           (\\<lambda>name cs.\n                               Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                           css))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv\n                       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                        fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 2. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> vwellformed v\\<^sub>2", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>\n 2. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv\n                       (fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 3. \\<lbrakk>vwellformed v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     wellformed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred (\\<lambda>_. wellformed_clauses) css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> vwellformed v\\<^sub>2", "apply (auto intro: fmdomI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>not_shadows_vconsts v\\<^sub>1\\<close> \\<open>not_shadows_vconsts v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts v\\<^sub>1\n  not_shadows_vconsts v\\<^sub>2\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts v\\<^sub>1\n  not_shadows_vconsts v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close> mk_rec_env_def"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  not_shadows_vconsts v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env\n                       (fmupd (Name n) v\\<^sub>2\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          fmmap_keys\n                           (\\<lambda>name cs.\n                               Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                           css))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env\n                       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                        fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 2. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts v\\<^sub>2", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>\n 2. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env\n                       (fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 3. \\<lbrakk>not_shadows_vconsts v\\<^sub>2;\n     fmlookup css (Name name) = Some cs;\n     not_shadows_vconsts_env \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_.\n          list_all\n           (\\<lambda>(pat, t).\n               fdisjnt all_consts (frees pat) \\<and>\n               \\<not> shadows_consts t))\n      css;\n     Name name |\\<in>| fmdom css\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts v\\<^sub>2", "apply (auto intro: fmdomI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>vwelldefined' v\\<^sub>1\\<close> \\<open>vwelldefined' v\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n  vwelldefined' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n  vwelldefined' v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close> mk_rec_env_def"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  vwelldefined' v\\<^sub>2\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>) css))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined')\n                       (fmupd (Name n) v\\<^sub>2\n                         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                          fmmap_keys\n                           (\\<lambda>name cs.\n                               Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                           css))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined')\n                       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                        fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 2. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> vwelldefined' v\\<^sub>2", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined')\n                       \\<Gamma>\\<^sub>\\<Lambda>\n 2. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> fmpred (\\<lambda>_. vwelldefined')\n                       (fmmap_keys\n                         (\\<lambda>name cs.\n                             Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n                         css)\n 3. \\<lbrakk>vwelldefined' v\\<^sub>2; fmlookup css (Name name) = Some cs;\n     fmpred (\\<lambda>k. vwelldefined') \\<Gamma>\\<^sub>\\<Lambda>;\n     fmpred\n      (\\<lambda>_ cs.\n          list_all\n           (\\<lambda>(pat, t).\n               consts t |\\<subseteq>|\n               fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n               (C |\\<union>| fmdom css))\n           cs \\<and>\n          fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>))\n      css;\n     Name name |\\<in>| fmdom css; fdisjnt C (fmdom css)\\<rbrakk>\n    \\<Longrightarrow> vwelldefined' v\\<^sub>2", "apply (auto intro: fmdomI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "using \\<open>vclosed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vclosed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vclosed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs)\n     (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))", "apply (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n        fmpred\n         (\\<lambda>_ cs.\n             \\<forall>x\\<in>set cs.\n                case x of\n                (pat, t) \\<Rightarrow>\n                  closed_except t\n                   (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat))\n         css;\n        Name name |\\<in>| fmdom css\\<rbrakk>\n       \\<Longrightarrow> closed_except b\n                          (finsert (Name n)\n                            (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                             frees a))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set cs; closed_venv \\<Gamma>\\<^sub>\\<Lambda>;\n        fmpred\n         (\\<lambda>_ cs.\n             \\<forall>x\\<in>set cs.\n                case x of\n                (pat, t) \\<Rightarrow>\n                  closed_except t\n                   (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat))\n         css;\n        Name name |\\<in>| fmdom css\\<rbrakk>\n       \\<Longrightarrow> closed_except b\n                          (finsert (Name n)\n                            (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                             frees a))", "apply (auto simp: closed_except_def dest!: fmpredD[where m = css])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"consts (Sabs cs) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>| (C |\\<union>| fmdom css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n    (C |\\<union>| fmdom css)", "using \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n    (C |\\<union>| fmdom css)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>|\n    fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n    (C |\\<union>| fmdom css)", "unfolding sconsts_sabs"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         consts t |\\<subseteq>|\n         fmdom\n          (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n         (C |\\<union>| fmdom css))\n     cs", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         consts t |\\<subseteq>|\n         fmdom\n          (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n         (C |\\<union>| fmdom css))\n     cs", "by (auto simp: list_all_iff dest!: fmpredD[where m = css])"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n  (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"\\<not> shadows_consts (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "using \\<open>not_shadows_vconsts v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts v\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs)", "by (auto simp: list_all_iff list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "have \"if_rval (\\<lambda>ml_v. \\<exists>v. fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v \\<and> related_v v ml_v) bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            fmupd (Name n) v\\<^sub>2\n             (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n              mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n            \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n            v \\<and> related_v v ml_v)\n     bv", "proof (rule app1(2))"], ["proof (state)\ngoal (12 subgoals):\n 1. is_cupcake_all_env env'\n 2. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmap_of_ns (sem_env.v env'))\n 3. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 4. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 5. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 7. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 9. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 10. fdisjnt C\n      (fmdom\n        (fmupd (Name n) v\\<^sub>2\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\nA total of 12 subgoals...", "have \"fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. ids (Sabs cs) |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids (Sabs cs) |\\<subseteq>| fbind (fmran css) (ids \\<circ> Sabs)", "apply (subst funion_image_bind_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids (Sabs cs) |\\<subseteq>| ffUnion ((ids \\<circ> Sabs) |`| fmran css)", "apply (rule ffUnion_subset_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids (Sabs cs) |\\<in>| (ids \\<circ> Sabs) |`| fmran css", "apply (subst fimage_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex (fmran css) (\\<lambda>x. ids (Sabs cs) = (ids \\<circ> Sabs) x)", "apply (rule fBexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ids (Sabs cs) = (ids \\<circ> Sabs) ?x6\n 2. ?x6 |\\<in>| fmran css", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cs |\\<in>| fmran css", "apply (rule fmranI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmlookup css ?x10 = Some cs", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (12 subgoals):\n 1. is_cupcake_all_env env'\n 2. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmap_of_ns (sem_env.v env'))\n 3. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 4. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 5. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 7. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 9. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 10. fdisjnt C\n      (fmdom\n        (fmupd (Name n) v\\<^sub>2\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\nA total of 12 subgoals...", "have \"fmrel_on_fset (ids (Sabs cs)) related_v (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n       rel_option related_v\n        (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n        (fmlookup (cake_mk_rec_env funs env\\<^sub>\\<Lambda>) x)", "apply (rule mk_rec_env_related[THEN fmrelD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n       fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n        (fmap_of_list (map (map_prod Name (map_prod Name id)) funs))\n 2. \\<And>x.\n       x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n       fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n        \\<Gamma>\\<^sub>\\<Lambda>\n        (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "apply (rule \\<open>fmrel _ css _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids (Sabs cs) \\<Longrightarrow>\n       fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs)) related_v\n        \\<Gamma>\\<^sub>\\<Lambda>\n        (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "apply (rule \\<open>fmrel_on_fset (fbind _ _) related_v \\<Gamma>\\<^sub>\\<Lambda> _\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs)) related_v\n   (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n   (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n\ngoal (12 subgoals):\n 1. is_cupcake_all_env env'\n 2. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmap_of_ns (sem_env.v env'))\n 3. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 4. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 5. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 7. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 8. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 9. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 10. fdisjnt C\n      (fmdom\n        (fmupd (Name n) v\\<^sub>2\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\nA total of 12 subgoals...", "show \"fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) (fmap_of_ns (sem_env.v env'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmap_of_ns (sem_env.v env'))", "unfolding recclosure'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmap_of_ns\n       (sem_env.v\n         (update_v\n           (\\<lambda>_.\n               nsBind (as_string (Name n)) ml_v\\<^sub>2\n                (build_rec_env funs env\\<^sub>\\<Lambda>\n                  (sem_env.v env\\<^sub>\\<Lambda>)))\n           env\\<^sub>\\<Lambda>)))", "apply (simp del: frees_sterm.simps(3) consts_sterm.simps(3) name.sel add: ids_def split!: sem_env.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset\n     (finsert (Name n) (frees (Sabs cs) |\\<union>| consts (Sabs cs)))\n     related_v\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n     (fmupd (Name n) ml_v\\<^sub>2\n       (fmap_of_ns\n         (build_rec_env funs env\\<^sub>\\<Lambda>\n           (sem_env.v env\\<^sub>\\<Lambda>))))", "apply (rule fmrel_on_fset_updateI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (frees (Sabs cs) |\\<union>| consts (Sabs cs)) related_v\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmap_of_ns\n       (build_rec_env funs env\\<^sub>\\<Lambda>\n         (sem_env.v env\\<^sub>\\<Lambda>)))\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "unfolding build_rec_env_fmap"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (frees (Sabs cs) |\\<union>| consts (Sabs cs)) related_v\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>) ++\\<^sub>f\n      cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply (rule fmrel_on_fset_addI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fmrel_on_fset (frees (Sabs cs) |\\<union>| consts (Sabs cs)) related_v\n     \\<Gamma>\\<^sub>\\<Lambda> (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. fmrel_on_fset (frees (Sabs cs) |\\<union>| consts (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n 3. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply (fold ids_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n 2. fmrel_on_fset (ids (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n 3. related_v v\\<^sub>2 ml_v\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "using \\<open>fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda> _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n   (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v \\<Gamma>\\<^sub>\\<Lambda>\n     (fmap_of_ns (sem_env.v env\\<^sub>\\<Lambda>))", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n 2. related_v v\\<^sub>2 ml_v\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)", "using \\<open>fmrel_on_fset (ids (Sabs cs)) related_v (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) _\\<close>"], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids (Sabs cs)) related_v\n   (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n   (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids (Sabs cs)) related_v\n     (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n     (cake_mk_rec_env funs env\\<^sub>\\<Lambda>)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v\\<^sub>2 ml_v\\<^sub>2", "apply (rule \\<open>related_v v\\<^sub>2 ml_v\\<^sub>2\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s Svar (Name n))) related_v\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n   (fmap_of_ns (sem_env.v env'))\n\ngoal (11 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 4. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 8. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 9. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 10. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n 4. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 8. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 9. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 10. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\nA total of 11 subgoals...", "show \"wellformed (Sabs cs $\\<^sub>s Svar (Name n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "using \\<open>vwellformed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwellformed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  vwellformed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))", "by auto"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s Svar (Name n))\n\ngoal (10 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 7. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 8. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 9. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 10. not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2\n        (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. is_cupcake_all_env env'\n 2. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n 3. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 6. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 7. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 8. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 9. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 10. not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2\n        (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "show \"related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'", "unfolding \\<open>exp' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Sabs cs $\\<^sub>s Svar (Name n))\n     (Mat (Var (Short (as_string (Name n)))) ml_cs)", "apply (rule related_exp.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (rel_prod related_pat related_exp) cs ml_cs\n 2. related_exp (Svar (Name n)) (Var (Short (as_string (Name n))))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp (Svar (Name n)) (Var (Short (as_string (Name n))))", "apply (rule related_exp.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  related_exp (Sabs cs $\\<^sub>s Svar (Name n)) exp'\n\ngoal (9 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 7. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 8. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 9. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 5. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 6. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 7. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 8. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 9. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "show \"closed_except (Sabs cs $\\<^sub>s Svar (Name n)) (fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))", "using \\<open>closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))", "by (auto simp: list_all_iff closed_except_def)"], ["proof (state)\nthis:\n  closed_except (Sabs cs $\\<^sub>s Svar (Name n))\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n\ngoal (8 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 6. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 8. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 6. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n 8. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "show \"\\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))", "using \\<open>\\<not> shadows_consts (Sabs cs)\\<close> \\<open>Name n |\\<notin>| all_consts\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n  Name n |\\<notin>| all_consts\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))", "by simp"], ["proof (state)\nthis:\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s Svar (Name n))\n\ngoal (7 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 6. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C\n 6. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 7. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "show \"consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C", "using \\<open>consts (Sabs cs) |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n  (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n    C", "unfolding mk_rec_env_def"], ["proof (prove)\nusing this:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n  (C |\\<union>| fmdom css)\n\ngoal (1 subgoal):\n 1. consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n         css)) |\\<union>|\n    C", "by auto"], ["proof (state)\nthis:\n  consts (Sabs cs $\\<^sub>s Svar (Name n)) |\\<subseteq>|\n  fmdom\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)) |\\<union>|\n  C\n\ngoal (6 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 6. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n 6. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "show \"fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))", "using \\<open>Name n |\\<notin>| all_consts\\<close> \\<open>fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\\<close> \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| all_consts\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))", "unfolding mk_rec_env_def \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| all_consts\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          fmmap_keys\n           (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n           css)))", "by (auto simp: fdisjnt_alt_def all_consts_def)"], ["proof (state)\nthis:\n  fdisjnt C\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)))\n\ngoal (5 subgoals):\n 1. is_cupcake_all_env env'\n 2. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 3. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 4. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 5. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))", "qed fact+"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2\n           (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n            mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2\n           (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n            mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv", "obtain v\n            where \"fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\" \"related_v v ml_v\""], ["proof (prove)\nusing this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2\n           (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n            mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   bv\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmupd (Name n) v\\<^sub>2\n                  (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                   mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                 \\<turnstile>\\<^sub>v\n                 Sabs cs $\\<^sub>s Svar (Name n) \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>bv = _\\<close>"], ["proof (prove)\nusing this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          fmupd (Name n) v\\<^sub>2\n           (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n            mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n          \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down>\n          v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmupd (Name n) v\\<^sub>2\n                  (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                   mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                 \\<turnstile>\\<^sub>v\n                 Sabs cs $\\<^sub>s Svar (Name n) \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "then"], ["proof (chain)\npicking this:\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v", "obtain env pat rhs\n            where \"vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\"\n              and \"fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\""], ["proof (prove)\nusing this:\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n  \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s Svar (Name n) \\<down> v\n  related_v v ml_v\n\ngoal (1 subgoal):\n 1. (\\<And>env pat rhs.\n        \\<lbrakk>vfind_match cs v\\<^sub>2 = Some (env, pat, rhs);\n         fmupd (Name n) v\\<^sub>2\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n         env\n         \\<turnstile>\\<^sub>v rhs \\<down> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: veval'_sabs_svarE)"], ["proof (state)\nthis:\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"(pat, rhs) \\<in> set cs\" \"vmatch (mk_pat pat) v\\<^sub>2 = Some env\""], ["proof (prove)\nusing this:\n  vfind_match cs v\\<^sub>2 = Some (env, pat, rhs)\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& vmatch (mk_pat pat) v\\<^sub>2 = Some env", "by (metis vfind_match_elem)+"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"linear pat\" \"wellformed rhs\""], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "using \\<open>vwellformed v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n  vwellformed v\\<^sub>1\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n  vwellformed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "using \\<open>fmlookup css (Name name) = Some cs\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  vmatch (mk_pat pat) v\\<^sub>2 = Some env\n  vwellformed (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n  fmlookup css (Name name) = Some cs\n\ngoal (1 subgoal):\n 1. Pats.linear pat &&& pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  Pats.linear pat\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"frees pat = patvars (mk_pat pat)\""], ["proof (prove)\nusing this:\n  Pats.linear pat\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat)", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "hence \"fmdom env = frees pat\""], ["proof (prove)\nusing this:\n  frees pat = patvars (mk_pat pat)\n\ngoal (1 subgoal):\n 1. fmdom env = frees pat", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    fmdom env = patvars (mk_pat pat)", "apply (rule vmatch_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees pat = patvars (mk_pat pat) \\<Longrightarrow>\n    vmatch (mk_pat pat) ?v1 = Some env", "apply (rule \\<open>vmatch (mk_pat pat) v\\<^sub>2 = Some env\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmdom env = frees pat\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "obtain v' where \"\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v'\" \"v' \\<approx>\\<^sub>e v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule veval'_agree_eq)"], ["proof (state)\ngoal (12 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?\\<Gamma>6 \\<turnstile>\\<^sub>v ?t6 \\<down> ?v6\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t6) erelated ?\\<Gamma>'6 ?\\<Gamma>6\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t6 (fmdom ?\\<Gamma>6)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t6\nA total of 12 subgoals...", "show \"fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env \\<turnstile>\\<^sub>v rhs \\<down> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env\n    \\<turnstile>\\<^sub>v rhs \\<down> v", "by fact"], ["proof (state)\nthis:\n  fmupd (Name n) v\\<^sub>2\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> v\n\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2\n        (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n       env)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2\n        (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n       env)\nA total of 11 subgoals...", "have *: \"Name n |\\<notin>| ids rhs\" if \"Name n |\\<notin>| fmdom env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Name n |\\<notin>| ids rhs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Name n |\\<in>| ids rhs \\<Longrightarrow> False", "assume \"Name n |\\<in>| ids rhs\""], ["proof (state)\nthis:\n  Name n |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| ids rhs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Name n |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees rhs |\\<union>| consts rhs\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "case A"], ["proof (state)\nthis:\n  Name n |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Name n |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "have \"Name n |\\<notin>| frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "using that"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| fmdom env\n\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. Name n |\\<notin>| frees pat", "."], ["proof (state)\nthis:\n  Name n |\\<notin>| frees pat\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Name n |\\<in>| frees rhs\n  Name n |\\<notin>| frees pat", "have \"Name n |\\<in>| frees (Sabs cs)\""], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees rhs\n  Name n |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| frees (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)\n                       ((|\\<in>|) (Name n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           Name n |\\<in>|\n                           (case x of\n                            (pat, rhs) \\<Rightarrow>\n                              frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      (case (pat, rhs) of\n                       (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<in>| frees rhs; Name n |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Name n |\\<in>| frees (Sabs cs)\n\ngoal (2 subgoals):\n 1. Name n |\\<in>| frees rhs \\<Longrightarrow> False\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Name n |\\<notin>| ids (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n  Name n |\\<notin>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| frees (Sabs cs)\n  Name n |\\<notin>| frees (Sabs cs) |\\<union>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "case B"], ["proof (state)\nthis:\n  Name n |\\<notin>| frees rhs\n  Name n |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"Name n |\\<in>| consts (Sabs cs)\""], ["proof (prove)\nusing this:\n  Name n |\\<notin>| frees rhs\n  Name n |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. Name n |\\<in>| consts (Sabs cs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "unfolding ffUnion_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)\n                       ((|\\<in>|) (Name n))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           Name n |\\<in>|\n                           (case x of (uu_, x) \\<Rightarrow> consts x))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> Name n |\\<in>|\n                      (case (pat, rhs) of (uu_, x) \\<Rightarrow> consts x)\n 2. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) \\<in> set cs", "apply (rule \\<open>(pat, rhs) \\<in> set cs\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Name n |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Name n |\\<notin>| frees rhs; Name n |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Name n |\\<notin>| ids (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n  Name n |\\<notin>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "unfolding ids_def"], ["proof (prove)\nusing this:\n  Name n |\\<in>| consts (Sabs cs)\n  Name n |\\<notin>| frees (Sabs cs) |\\<union>| consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Name n |\\<notin>| fmdom env \\<Longrightarrow> Name n |\\<notin>| ids rhs\n\ngoal (11 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) erelated ?\\<Gamma>'6\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>v'.\n         \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                  env\n                  \\<turnstile>\\<^sub>v rhs \\<down> v';\n          v' \\<approx>\\<^sub>e v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env\n      (fmupd (Name n) v\\<^sub>2\n        (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n       env)\nA total of 11 subgoals...", "show \"fmrel_on_fset (ids rhs) erelated (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f env) (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) erelated\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      env)\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option erelated\n        (fmlookup\n          (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n           env)\n          x)\n        (fmlookup\n          (fmupd (Name n) v\\<^sub>2\n            (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n             mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n           env)\n          x)", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 2. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         (Name n))\n                       (Some v\\<^sub>2)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 4. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n 5. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 6. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 7. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 8. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply (rule option.rel_refl; rule erelated_refl)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n 4. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 5. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 6. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 7. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "using *"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| fmdom env \\<Longrightarrow> Name n |\\<notin>| ids rhs\n\ngoal (7 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>)\n                         (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n 4. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 5. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 6. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 7. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply auto[]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<in>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n                          (fmlookup\n                            (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) x)\n 3. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<in>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated (fmlookup env (Name n))\n                       (fmlookup env (Name n))\n 4. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 5. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 6. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply (rule option.rel_refl; rule erelated_refl)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "using *"], ["proof (prove)\nusing this:\n  Name n |\\<notin>| fmdom env \\<Longrightarrow> Name n |\\<notin>| ids rhs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Name n |\\<in>| ids rhs;\n     Name n |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n     Name n |\\<notin>| fmdom env\\<rbrakk>\n    \\<Longrightarrow> rel_option erelated\n                       (fmlookup \\<Gamma>\\<^sub>\\<Lambda> (Name n))\n                       (Some v\\<^sub>2)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply auto[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<in>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated (fmlookup env x)\n                          (fmlookup env x)\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs;\n        x |\\<notin>| fmdom (mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>);\n        Name n \\<noteq> x; x |\\<notin>| fmdom env\\<rbrakk>\n       \\<Longrightarrow> rel_option erelated\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)\n                          (fmlookup \\<Gamma>\\<^sub>\\<Lambda> x)", "apply (rule option.rel_refl; rule erelated_refl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) erelated\n   (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    env)\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env)\n\ngoal (10 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 10. \\<And>v'.\n        \\<lbrakk>\\<And>v'.\n                    \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                             mk_rec_env css\n                              \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                             env\n                             \\<turnstile>\\<^sub>v rhs \\<down> v';\n                     v' \\<approx>\\<^sub>e v\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         env\n         \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 10. \\<And>v'.\n        \\<lbrakk>\\<And>v'.\n                    \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                             mk_rec_env css\n                              \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                             env\n                             \\<turnstile>\\<^sub>v rhs \\<down> v';\n                     v' \\<approx>\\<^sub>e v\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n         env\n         \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis", "show \"closed_venv (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 2. closed_venv env", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv env", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vclosed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_venv\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env)\n\ngoal (9 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 9. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 9. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed_venv (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n 2. wellformed_venv env", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv env", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some env\n 2. vwellformed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed v\\<^sub>2", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env)\n\ngoal (8 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 8. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 8. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_except rhs (fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))", "using \\<open>fmdom env = frees pat\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = frees pat\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))", "using \\<open>closed_except (Sabs cs) (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  fmdom env = frees pat\n  (pat, rhs) \\<in> set cs\n  closed_except (Sabs cs)\n   (fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. closed_except rhs\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))", "apply (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmdom env = frees pat; (pat, rhs) \\<in> set cs;\n     \\<forall>x\\<in>set cs.\n        case x of\n        (pat, t) \\<Rightarrow>\n          closed_except t\n           (finsert (Name n)\n             (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat))\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (finsert (Name n)\n                         (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                          fmdom\n                           (mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n                          frees pat))", "apply (erule ballE[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fmdom env = frees pat; (pat, rhs) \\<in> set cs;\n     case (pat, rhs) of\n     (pat, t) \\<Rightarrow>\n       closed_except t\n        (finsert (Name n)\n          (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>| frees pat))\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (finsert (Name n)\n                         (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                          fmdom\n                           (mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n                          frees pat))\n 2. \\<lbrakk>fmdom env = frees pat; (pat, rhs) \\<in> set cs;\n     (pat, rhs) \\<notin> set cs\\<rbrakk>\n    \\<Longrightarrow> closed_except rhs\n                       (finsert (Name n)\n                         (fmdom \\<Gamma>\\<^sub>\\<Lambda> |\\<union>|\n                          fmdom\n                           (mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n                          frees pat))", "apply (auto simp: closed_except_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed_except rhs\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env))\n\ngoal (7 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 7. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 7. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by fact"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (6 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 6. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"consts rhs |\\<subseteq>| fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C", "using \\<open>consts (Sabs cs) |\\<subseteq>| _\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  consts (Sabs cs) |\\<subseteq>|\n  fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n  (C |\\<union>| fmdom css)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env) |\\<union>|\n    C", "unfolding sconsts_sabs mk_rec_env_def"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(uu_, t).\n       consts t |\\<subseteq>|\n       fmdom (fmupd (Name n) v\\<^sub>2 \\<Gamma>\\<^sub>\\<Lambda>) |\\<union>|\n       (C |\\<union>| fmdom css))\n   cs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n         css) ++\\<^sub>f\n      env) |\\<union>|\n    C", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env) |\\<union>|\n  C\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fdisjnt C (fmdom env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>\\<not> shadows_consts (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom env)", "unfolding \\<open>fmdom env = frees pat\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_ex_iff all_consts_def fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  fdisjnt C (fmdom env)\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fdisjnt C (fmdom css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom css)", "using \\<open>vwelldefined' v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' v\\<^sub>1\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom css)", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  vwelldefined' (Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom css)", "by simp"], ["proof (state)\nthis:\n  fdisjnt C (fmdom css)\n\ngoal (5 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 5. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)", "show \"fdisjnt C (fmdom (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))", "using \\<open>Name n |\\<notin>| all_consts\\<close> \\<open>fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom env)\n  fdisjnt C (fmdom css)\n  Name n |\\<notin>| all_consts\n  fdisjnt C (fmdom \\<Gamma>\\<^sub>\\<Lambda>)\n\ngoal (1 subgoal):\n 1. fdisjnt C\n     (fmdom\n       (fmupd (Name n) v\\<^sub>2\n         (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n          mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n        env))", "unfolding fdisjnt_alt_def mk_rec_env_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom env = {||}\n  C |\\<inter>| fmdom css = {||}\n  Name n |\\<notin>| all_consts\n  C |\\<inter>| fmdom \\<Gamma>\\<^sub>\\<Lambda> = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>|\n    fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        fmmap_keys\n         (\\<lambda>name cs. Vrecabs css name \\<Gamma>\\<^sub>\\<Lambda>)\n         css) ++\\<^sub>f\n      env) =\n    {||}", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  fdisjnt C\n   (fmdom\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env))\n\ngoal (4 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 4. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>\\<not> shadows_consts (Sabs cs)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"not_shadows_vconsts_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env env", "by (rule not_shadows_vconsts.vmatch_env) fact+"], ["proof (state)\nthis:\n  not_shadows_vconsts_env env\n\ngoal (3 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 3. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env env\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "using \\<open>not_shadows_vconsts_env (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  not_shadows_vconsts_env env\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "by blast"], ["proof (state)\nthis:\n  not_shadows_vconsts_env\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env)\n\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmpred (\\<lambda>_. vwelldefined') env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') env", "by (rule vmatch_welldefined') fact+"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (2 subgoals):\n 1. (\\<And>v'.\n        \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                 env\n                 \\<turnstile>\\<^sub>v rhs \\<down> v';\n         v' \\<approx>\\<^sub>e v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)\n 2. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f env)\""], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "using \\<open>fmpred (\\<lambda>_. vwelldefined') (fmupd (Name n) v\\<^sub>2 (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\\<close>"], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_. vwelldefined') env\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>))\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined')\n     (fmupd (Name n) v\\<^sub>2\n       (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n      env)", "by blast"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined')\n   (fmupd (Name n) v\\<^sub>2\n     (\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n      mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda>) ++\\<^sub>f\n    env)\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>\\<And>v'.\n                   \\<lbrakk>\\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            mk_rec_env css\n                             \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n                            env\n                            \\<turnstile>\\<^sub>v rhs \\<down> v';\n                    v' \\<approx>\\<^sub>e v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n        env\n        \\<turnstile>\\<^sub>v rhs \\<down> v';\n        v' \\<approx>\\<^sub>e v\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed simp"], ["proof (state)\nthis:\n  \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n  env\n  \\<turnstile>\\<^sub>v rhs \\<down> v'\n  v' \\<approx>\\<^sub>e v\n\ngoal (1 subgoal):\n 1. \\<And>env funs name n v0.\n       \\<lbrakk>rev ml_vs = [Recclosure env funs name, v0];\n        allDistinct (map (\\<lambda>(f, uu_, uu_). f) funs);\n        find_recfun name funs = Some (n, exp');\n        env' =\n        update_v\n         (\\<lambda>_. nsBind n v0 (build_rec_env funs env (sem_env.v env)))\n         env\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n                            related_v v ml_v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> ?v\n 2. related_v ?v ml_v", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 $\\<^sub>s t\\<^sub>2 \\<down> ?v\n 2. related_v ?v ml_v", "apply (rule veval'.rec_comb)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down>\n    Vrecabs ?css2 ?name2 ?\\<Gamma>'2\n 2. fmlookup ?css2 ?name2 = Some ?cs2\n 3. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 4. vfind_match ?cs2 ?u'2 = Some (?env2, ?uv2, ?rhs2)\n 5. ?\\<Gamma>'2 ++\\<^sub>f mk_rec_env ?css2 ?\\<Gamma>'2 ++\\<^sub>f ?env2\n    \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 6. related_v ?v ml_v", "using \\<open>\\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down> v\\<^sub>1\n\ngoal (6 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down>\n    Vrecabs ?css2 ?name2 ?\\<Gamma>'2\n 2. fmlookup ?css2 ?name2 = Some ?cs2\n 3. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 4. vfind_match ?cs2 ?u'2 = Some (?env2, ?uv2, ?rhs2)\n 5. ?\\<Gamma>'2 ++\\<^sub>f mk_rec_env ?css2 ?\\<Gamma>'2 ++\\<^sub>f ?env2\n    \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 6. related_v ?v ml_v", "unfolding \\<open>v\\<^sub>1 = _\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down>\n  Vrecabs css (Name name) \\<Gamma>\\<^sub>\\<Lambda>\n\ngoal (6 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>1 \\<down>\n    Vrecabs ?css2 ?name2 ?\\<Gamma>'2\n 2. fmlookup ?css2 ?name2 = Some ?cs2\n 3. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 4. vfind_match ?cs2 ?u'2 = Some (?env2, ?uv2, ?rhs2)\n 5. ?\\<Gamma>'2 ++\\<^sub>f mk_rec_env ?css2 ?\\<Gamma>'2 ++\\<^sub>f ?env2\n    \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 6. related_v ?v ml_v", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. fmlookup css (Name name) = Some ?cs2\n 2. \\<Gamma> \\<turnstile>\\<^sub>v t\\<^sub>2 \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uv2, ?rhs2)\n 4. \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    mk_rec_env css \\<Gamma>\\<^sub>\\<Lambda> ++\\<^sub>f\n    ?env2\n    \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?v\n 5. related_v ?v ml_v", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v v' ml_v", "apply (rule related_v_ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. related_v ?v15 ml_v\n 2. v' \\<approx>\\<^sub>e ?v15", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   bv\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "case (mat1 env ml_scr ml_scr' ml_cs ml_rhs ml_pat env' ml_res)"], ["proof (state)\nthis:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "obtain scr cs\n    where \"t = Sabs cs $\\<^sub>s scr\" \"related_exp scr ml_scr\"\n      and \"list_all2 (rel_prod related_pat related_exp) cs ml_cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs scr.\n        \\<lbrakk>t = Sabs cs $\\<^sub>s scr; related_exp scr ml_scr;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>related_exp t (Mat ml_scr ml_cs)\\<close>"], ["proof (prove)\nusing this:\n  related_exp t (Mat ml_scr ml_cs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs scr.\n        \\<lbrakk>t = Sabs cs $\\<^sub>s scr; related_exp scr ml_scr;\n         list_all2 (rel_prod related_pat related_exp) cs ml_cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  t = Sabs cs $\\<^sub>s scr\n  related_exp scr ml_scr\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"sem_env.c env = as_static_cenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem_env.c env = as_static_cenv", "using \\<open>is_cupcake_all_env env\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_all_env env\n\ngoal (1 subgoal):\n 1. sem_env.c env = as_static_cenv", "by (auto elim: is_cupcake_all_envE)"], ["proof (state)\nthis:\n  sem_env.c env = as_static_cenv\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "obtain scr' where \"\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr'\" \"related_v scr' ml_scr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mat1(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n\ngoal (1 subgoal):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding if_rval.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down> v \\<and>\n                       related_v v ml_scr'\n\ngoal (1 subgoal):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    is_cupcake_all_env env\n 2. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t11) related_v ?\\<Gamma>11\n     (fmap_of_ns (sem_env.v env))\n 3. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t11 ml_scr\n 4. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t11\n 5. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 6. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 7. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t11 (fmdom ?\\<Gamma>11)\n 8. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 9. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t11 |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 10. (\\<And>scr'.\n         \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n          related_v scr' ml_scr'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     fdisjnt C (fmdom ?\\<Gamma>11)\nA total of 13 subgoals...", "show\n        \"is_cupcake_all_env env\" \"related_exp scr ml_scr\" \"wellformed_venv \\<Gamma>\"\n        \"closed_venv \\<Gamma>\" \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"fdisjnt C (fmdom \\<Gamma>)\"\n        \"not_shadows_vconsts_env \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_cupcake_all_env env &&&\n     related_exp scr ml_scr &&& wellformed_venv \\<Gamma>) &&&\n    (closed_venv \\<Gamma> &&&\n     fmpred (\\<lambda>_. vwelldefined') \\<Gamma>) &&&\n    fdisjnt C (fmdom \\<Gamma>) &&& not_shadows_vconsts_env \\<Gamma>", "by fact+"], ["proof (state)\nthis:\n  is_cupcake_all_env env\n  related_exp scr ml_scr\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  fdisjnt C (fmdom \\<Gamma>)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (6 subgoals):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids scr) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed scr\n 3. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except scr (fmdom \\<Gamma>)\n 4. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 5. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts scr\n 6. \\<And>x.\n       \\<lbrakk>\\<And>scr'.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n                    related_v scr' ml_scr'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> x \\<and>\n        related_v x ml_scr'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids scr) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed scr\n 3. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except scr (fmdom \\<Gamma>)\n 4. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 5. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts scr\n 6. \\<And>x.\n       \\<lbrakk>\\<And>scr'.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n                    related_v scr' ml_scr'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> x \\<and>\n        related_v x ml_scr'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmrel_on_fset (ids scr) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids scr) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n 2. ids scr |\\<subseteq>| ?S", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids scr |\\<subseteq>| ids t", "unfolding \\<open>t = _\\<close> ids_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees scr |\\<union>| consts scr |\\<subseteq>|\n    frees (Sabs cs $\\<^sub>s scr) |\\<union>| consts (Sabs cs $\\<^sub>s scr)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids scr) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n\ngoal (5 subgoals):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed scr\n 2. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except scr (fmdom \\<Gamma>)\n 3. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 4. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts scr\n 5. \\<And>x.\n       \\<lbrakk>\\<And>scr'.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n                    related_v scr' ml_scr'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> x \\<and>\n        related_v x ml_scr'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed scr\n 2. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except scr (fmdom \\<Gamma>)\n 3. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 4. (\\<And>scr'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n         related_v scr' ml_scr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts scr\n 5. \\<And>x.\n       \\<lbrakk>\\<And>scr'.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n                    related_v scr' ml_scr'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> x \\<and>\n        related_v x ml_scr'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show\n        \"wellformed scr\" \"consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\"\n        \"closed_except scr (fmdom \\<Gamma>)\" \"\\<not> shadows_consts scr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed scr &&&\n     consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) &&&\n    closed_except scr (fmdom \\<Gamma>) &&& \\<not> shadows_consts scr", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed scr &&&\n     consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) &&&\n    closed_except scr (fmdom \\<Gamma>) &&& \\<not> shadows_consts scr", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed scr &&&\n     consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C) &&&\n    closed_except scr (fmdom \\<Gamma>) &&& \\<not> shadows_consts scr", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed scr\n  consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  closed_except scr (fmdom \\<Gamma>)\n  \\<not> shadows_consts scr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>scr'.\n                   \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr';\n                    related_v scr' ml_scr'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> x \\<and>\n        related_v x ml_scr'\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> scr'\n  related_v scr' ml_scr'\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"list_all (\\<lambda>(pat, _). linear pat) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "obtain rhs pat \\<Gamma>'\n    where \"ml_pat = mk_ml_pat (mk_pat pat)\" \"related_exp rhs ml_rhs\"\n      and \"vfind_match cs scr' = Some (\\<Gamma>', pat, rhs)\"\n      and \"var_env \\<Gamma>' env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs \\<Gamma>'.\n        \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n         vfind_match cs scr' = Some (\\<Gamma>', pat, rhs);\n         var_env \\<Gamma>' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>list_all2 _ cs ml_cs\\<close> \\<open>list_all _ cs\\<close> \\<open>related_v scr' ml_scr'\\<close> mat1(2)"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs\n  related_v scr' ml_scr'\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs \\<Gamma>'.\n        \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n         vfind_match cs scr' = Some (\\<Gamma>', pat, rhs);\n         var_env \\<Gamma>' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>sem_env.c env = as_static_cenv\\<close>"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod related_pat related_exp) cs ml_cs\n  list_all (\\<lambda>(pat, uu_). Pats.linear pat) cs\n  related_v scr' ml_scr'\n  cupcake_match_result as_static_cenv ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs \\<Gamma>'.\n        \\<lbrakk>related_pat pat ml_pat; related_exp rhs ml_rhs;\n         vfind_match cs scr' = Some (\\<Gamma>', pat, rhs);\n         var_env \\<Gamma>' env'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: match_all_related)"], ["proof (state)\nthis:\n  related_pat pat ml_pat\n  related_exp rhs ml_rhs\n  vfind_match cs scr' = Some (\\<Gamma>', pat, rhs)\n  var_env \\<Gamma>' env'\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "hence \"vmatch (mk_pat pat) scr' = Some \\<Gamma>'\""], ["proof (prove)\nusing this:\n  related_pat pat ml_pat\n  related_exp rhs ml_rhs\n  vfind_match cs scr' = Some (\\<Gamma>', pat, rhs)\n  var_env \\<Gamma>' env'\n\ngoal (1 subgoal):\n 1. vmatch (mk_pat pat) scr' = Some \\<Gamma>'", "by (auto dest: vfind_match_elem)"], ["proof (state)\nthis:\n  vmatch (mk_pat pat) scr' = Some \\<Gamma>'\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "hence \"patvars (mk_pat pat) = fmdom \\<Gamma>'\""], ["proof (prove)\nusing this:\n  vmatch (mk_pat pat) scr' = Some \\<Gamma>'\n\ngoal (1 subgoal):\n 1. patvars (mk_pat pat) = fmdom \\<Gamma>'", "by (auto simp: vmatch_dom)"], ["proof (state)\nthis:\n  patvars (mk_pat pat) = fmdom \\<Gamma>'\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"(pat, rhs) \\<in> set cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs", "by (rule vfind_match_elem) fact"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "have \"linear pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pats.linear pat", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>wellformed t\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. Pats.linear pat", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n\ngoal (1 subgoal):\n 1. Pats.linear pat", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  Pats.linear pat\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "hence \"fmdom \\<Gamma>' = frees pat\""], ["proof (prove)\nusing this:\n  Pats.linear pat\n\ngoal (1 subgoal):\n 1. fmdom \\<Gamma>' = frees pat", "using \\<open>patvars (mk_pat pat) = fmdom \\<Gamma>'\\<close>"], ["proof (prove)\nusing this:\n  Pats.linear pat\n  patvars (mk_pat pat) = fmdom \\<Gamma>'\n\ngoal (1 subgoal):\n 1. fmdom \\<Gamma>' = frees pat", "by (simp add: mk_pat_frees)"], ["proof (state)\nthis:\n  fmdom \\<Gamma>' = frees pat\n\ngoal (8 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes e' uu_ env' bv \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv =\n        Rval (e', uu_, env');\n        cupcake_evaluate_single\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)\n         e' bv;\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env\n                     (update_v\n                       (\\<lambda>_.\n                           nsAppend (alist_to_ns env') (sem_env.v env))\n                       env);\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns\n               (sem_env.v\n                 (update_v\n                   (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n                   env)));\n            related_exp t e'; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              bv;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          bv\n 7. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 8. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if_rval\n     (\\<lambda>ml_v.\n         \\<exists>v.\n            \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and>\n            related_v v ml_v)\n     ml_res", "proof (rule if_rvalI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       ml_res = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "fix ml_rhs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       ml_res = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "assume \"ml_res = Rval ml_rhs'\""], ["proof (state)\nthis:\n  ml_res = Rval ml_rhs'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       ml_res = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "obtain rhs' where \"\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down> rhs'\" \"related_v rhs' ml_rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mat1(5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>ml_res = _\\<close> if_rval.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down> v \\<and>\n                       related_v v ml_rhs'\n\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (13 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t11) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t11 ml_rhs\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t11 (fmdom ?\\<Gamma>11)\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t11 |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     fdisjnt C (fmdom ?\\<Gamma>11)\nA total of 13 subgoals...", "show \"is_cupcake_all_env (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n       env)", "proof (rule cupcake_v_update_preserve)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "have \"list_all (is_cupcake_value \\<circ> snd) env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (is_cupcake_value \\<circ> snd) env'", "proof (rule match_all_preserve)"], ["proof (state)\ngoal (4 subgoals):\n 1. cupcake_match_result ?cenv ?v0.0 ?pes ?err_v = Rval (?e, ?p, env')\n 2. cupcake_c_ns ?cenv\n 3. is_cupcake_value ?v0.0\n 4. cupcake_clauses ?pes", "show \"cupcake_c_ns (sem_env.c env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_c_ns (sem_env.c env)", "unfolding \\<open>sem_env.c env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_c_ns as_static_cenv", "by (rule static_cenv)"], ["proof (state)\nthis:\n  cupcake_c_ns (sem_env.c env)\n\ngoal (3 subgoals):\n 1. cupcake_match_result (sem_env.c env) ?v0.0 ?pes ?err_v =\n    Rval (?e, ?p, env')\n 2. is_cupcake_value ?v0.0\n 3. cupcake_clauses ?pes", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. cupcake_match_result (sem_env.c env) ?v0.0 ?pes ?err_v =\n    Rval (?e, ?p, env')\n 2. is_cupcake_value ?v0.0\n 3. cupcake_clauses ?pes", "have \"is_cupcake_exp (Mat ml_scr ml_cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp (Mat ml_scr ml_cs)", "apply (rule related_exp_is_cupcake)"], ["proof (prove)\ngoal (2 subgoals):\n 1. related_exp ?t (Mat ml_scr ml_cs)\n 2. pre_strong_term_class.wellformed ?t", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. related_exp ?t (Mat ml_scr ml_cs)\n 2. pre_strong_term_class.wellformed ?t", "by auto"], ["proof (state)\nthis:\n  is_cupcake_exp (Mat ml_scr ml_cs)\n\ngoal (3 subgoals):\n 1. cupcake_match_result (sem_env.c env) ?v0.0 ?pes ?err_v =\n    Rval (?e, ?p, env')\n 2. is_cupcake_value ?v0.0\n 3. cupcake_clauses ?pes", "thus \"cupcake_clauses ml_cs\""], ["proof (prove)\nusing this:\n  is_cupcake_exp (Mat ml_scr ml_cs)\n\ngoal (1 subgoal):\n 1. cupcake_clauses ml_cs", "by simp"], ["proof (state)\nthis:\n  cupcake_clauses ml_cs\n\ngoal (2 subgoals):\n 1. cupcake_match_result (sem_env.c env) ?v0.0 ml_cs ?err_v =\n    Rval (?e, ?p, env')\n 2. is_cupcake_value ?v0.0", "show \"is_cupcake_value ml_scr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value ml_scr'", "apply (rule cupcake_single_preserve)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cupcake_evaluate_single ?env ?e (Rval ml_scr')\n 2. is_cupcake_all_env ?env\n 3. is_cupcake_exp ?e", "apply (rule mat1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_exp ml_scr", "apply (rule mat1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp ml_scr", "using \\<open>is_cupcake_exp (Mat ml_scr ml_cs)\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_exp (Mat ml_scr ml_cs)\n\ngoal (1 subgoal):\n 1. is_cupcake_exp ml_scr", "by simp"], ["proof (state)\nthis:\n  is_cupcake_value ml_scr'\n\ngoal (1 subgoal):\n 1. cupcake_match_result (sem_env.c env) ml_scr' ml_cs ?err_v =\n    Rval (?e, ?p, env')", "qed fact+"], ["proof (state)\nthis:\n  list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "hence \"is_cupcake_ns (alist_to_ns env')\""], ["proof (prove)\nusing this:\n  list_all (is_cupcake_value \\<circ> snd) env'\n\ngoal (1 subgoal):\n 1. is_cupcake_ns (alist_to_ns env')", "by (rule cupcake_alist_to_ns_preserve)"], ["proof (state)\nthis:\n  is_cupcake_ns (alist_to_ns env')\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "moreover"], ["proof (state)\nthis:\n  is_cupcake_ns (alist_to_ns env')\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "have \"is_cupcake_ns (sem_env.v env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_ns (sem_env.v env)", "by (rule is_cupcake_all_envD) fact"], ["proof (state)\nthis:\n  is_cupcake_ns (sem_env.v env)\n\ngoal (2 subgoals):\n 1. is_cupcake_all_env env\n 2. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "ultimately"], ["proof (chain)\npicking this:\n  is_cupcake_ns (alist_to_ns env')\n  is_cupcake_ns (sem_env.v env)", "show \"is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))\""], ["proof (prove)\nusing this:\n  is_cupcake_ns (alist_to_ns env')\n  is_cupcake_ns (sem_env.v env)\n\ngoal (1 subgoal):\n 1. is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))", "by (rule cupcake_nsAppend_preserve)"], ["proof (state)\nthis:\n  is_cupcake_ns (nsAppend (alist_to_ns env') (sem_env.v env))\n\ngoal (1 subgoal):\n 1. is_cupcake_all_env env", "qed fact"], ["proof (state)\nthis:\n  is_cupcake_all_env\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n\ngoal (12 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t11) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t11 ml_rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t11 (fmdom ?\\<Gamma>11)\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t11 |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t11\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t11) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t11 ml_rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t11 (fmdom ?\\<Gamma>11)\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t11 |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t11\nA total of 12 subgoals...", "show \"related_exp rhs ml_rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp rhs ml_rhs", "by fact"], ["proof (state)\nthis:\n  related_exp rhs ml_rhs\n\ngoal (11 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom ?\\<Gamma>11)\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>11\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom ?\\<Gamma>11)\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>11\nA total of 11 subgoals...", "have *: \"fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'", "using \\<open>var_env \\<Gamma>' env'\\<close>"], ["proof (prove)\nusing this:\n  var_env \\<Gamma>' env'\n\ngoal (1 subgoal):\n 1. fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'", "by (metis fmrel_fmdom_eq)"], ["proof (state)\nthis:\n  fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'\n\ngoal (11 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom ?\\<Gamma>11)\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>11\nA total of 11 subgoals...", "have **: \"id |\\<in>| ids t\" if \"id |\\<in>| ids rhs\" \"id |\\<notin>| fmdom \\<Gamma>'\" for id"], ["proof (prove)\ngoal (1 subgoal):\n 1. id |\\<in>| ids t", "using \\<open>id |\\<in>| ids rhs\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| ids rhs\n\ngoal (1 subgoal):\n 1. id |\\<in>| ids t", "unfolding ids_def"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs |\\<union>| consts rhs\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees t |\\<union>| consts t", "proof (cases rule: funion_strictE)"], ["proof (state)\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    id |\\<in>| frees t |\\<union>| consts t\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "case A"], ["proof (state)\nthis:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    id |\\<in>| frees t |\\<union>| consts t\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "from that"], ["proof (chain)\npicking this:\n  id |\\<in>| ids rhs\n  id |\\<notin>| fmdom \\<Gamma>'", "have \"id |\\<notin>| frees pat\""], ["proof (prove)\nusing this:\n  id |\\<in>| ids rhs\n  id |\\<notin>| fmdom \\<Gamma>'\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "unfolding \\<open>fmdom \\<Gamma>' = frees pat\\<close>"], ["proof (prove)\nusing this:\n  id |\\<in>| ids rhs\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. id |\\<notin>| frees pat", "by simp"], ["proof (state)\nthis:\n  id |\\<notin>| frees pat\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    id |\\<in>| frees t |\\<union>| consts t\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "hence \"id |\\<in>| frees t\""], ["proof (prove)\nusing this:\n  id |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees t", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| frees pat\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees t", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| frees pat\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees (Sabs cs $\\<^sub>s scr)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)", "apply (subst ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`|\n                        fset_of_list cs)\n                       ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           id |\\<in>|\n                           (case x of\n                            (pat, rhs) \\<Rightarrow>\n                              frees rhs |-| frees pat))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>|\n                      (case (pat, rhs) of\n                       (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "using A"], ["proof (prove)\nusing this:\n  id |\\<in>| frees rhs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>|\n                      (case (pat, rhs) of\n                       (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)\n 2. \\<lbrakk>id |\\<notin>| frees pat; (pat, rhs) \\<in> set cs;\n     id |\\<notin>| frees scr\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| frees t\n\ngoal (2 subgoals):\n 1. id |\\<in>| frees rhs \\<Longrightarrow>\n    id |\\<in>| frees t |\\<union>| consts t\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "thus \"id |\\<in>| frees t |\\<union>| consts t\""], ["proof (prove)\nusing this:\n  id |\\<in>| frees t\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees t |\\<union>| consts t", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| frees t |\\<union>| consts t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "case B"], ["proof (state)\nthis:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "hence \"id |\\<in>| consts t\""], ["proof (prove)\nusing this:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n\ngoal (1 subgoal):\n 1. id |\\<in>| consts t", "using \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. id |\\<in>| consts t", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  id |\\<notin>| frees rhs\n  id |\\<in>| consts rhs\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. id |\\<in>| consts (Sabs cs $\\<^sub>s scr)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs;\n     (pat, rhs) \\<in> set cs; id |\\<notin>| consts scr\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>|\n                      ffUnion\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "apply (subst ffUnion_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs;\n     (pat, rhs) \\<in> set cs; id |\\<notin>| consts scr\\<rbrakk>\n    \\<Longrightarrow> fBex\n                       ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)\n                       ((|\\<in>|) id)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs;\n     (pat, rhs) \\<in> set cs; id |\\<notin>| consts scr\\<rbrakk>\n    \\<Longrightarrow> fBex (fset_of_list cs)\n                       (\\<lambda>x.\n                           id |\\<in>|\n                           (case x of (uu_, x) \\<Rightarrow> consts x))", "apply (rule fBexI[where x = \"(pat, rhs)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs;\n     (pat, rhs) \\<in> set cs; id |\\<notin>| consts scr\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>|\n                      (case (pat, rhs) of (uu_, x) \\<Rightarrow> consts x)\n 2. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs;\n     (pat, rhs) \\<in> set cs; id |\\<notin>| consts scr\\<rbrakk>\n    \\<Longrightarrow> (pat, rhs) |\\<in>| fset_of_list cs", "apply (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  id |\\<in>| consts t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>id |\\<notin>| frees rhs; id |\\<in>| consts rhs\\<rbrakk>\n    \\<Longrightarrow> id |\\<in>| frees t |\\<union>| consts t", "thus \"id |\\<in>| frees t |\\<union>| consts t\""], ["proof (prove)\nusing this:\n  id |\\<in>| consts t\n\ngoal (1 subgoal):\n 1. id |\\<in>| frees t |\\<union>| consts t", "by simp"], ["proof (state)\nthis:\n  id |\\<in>| frees t |\\<union>| consts t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?id4 |\\<in>| ids rhs; ?id4 |\\<notin>| fmdom \\<Gamma>'\\<rbrakk>\n  \\<Longrightarrow> ?id4 |\\<in>| ids t\n\ngoal (11 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom ?\\<Gamma>11)\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>11\nA total of 11 subgoals...", "have \"fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>') (fmap_of_ns (sem_env.v env) ++\\<^sub>f fmap_of_list (map (map_prod Name id) env'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n     (fmap_of_ns (sem_env.v env) ++\\<^sub>f\n      fmap_of_list (map (map_prod Name id) env'))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       rel_option related_v (fmlookup (\\<Gamma> ++\\<^sub>f \\<Gamma>') x)\n        (fmlookup\n          (fmap_of_ns (sem_env.v env) ++\\<^sub>f\n           fmap_of_list (map (map_prod Name id) env'))\n          x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| ids rhs \\<Longrightarrow>\n       (x |\\<in>| fmdom \\<Gamma>' \\<longrightarrow>\n        (x |\\<in>|\n         (Name \\<circ> fst) |`| fset_of_list env' \\<longrightarrow>\n         rel_option related_v (fmlookup \\<Gamma>' x)\n          (fmlookup (fmap_of_list (map (map_prod Name id) env')) x)) \\<and>\n        (x |\\<notin>|\n         (Name \\<circ> fst) |`| fset_of_list env' \\<longrightarrow>\n         rel_option related_v (fmlookup \\<Gamma>' x)\n          (cupcake_nsLookup (sem_env.v env) (as_string x)))) \\<and>\n       (x |\\<notin>| fmdom \\<Gamma>' \\<longrightarrow>\n        (x |\\<in>|\n         (Name \\<circ> fst) |`| fset_of_list env' \\<longrightarrow>\n         rel_option related_v (fmlookup \\<Gamma> x)\n          (fmlookup (fmap_of_list (map (map_prod Name id) env')) x)) \\<and>\n        (x |\\<notin>|\n         (Name \\<circ> fst) |`| fset_of_list env' \\<longrightarrow>\n         rel_option related_v (fmlookup \\<Gamma> x)\n          (cupcake_nsLookup (sem_env.v env) (as_string x))))", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>(Name \\<circ> fst) (a, b) |\\<in>| ids rhs;\n        (Name \\<circ> fst) (a, b) |\\<in>| fmdom \\<Gamma>';\n        (a, b) |\\<in>| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v\n                          (fmlookup \\<Gamma>' ((Name \\<circ> fst) (a, b)))\n                          (fmlookup\n                            (fmap_of_list (map (map_prod Name id) env'))\n                            ((Name \\<circ> fst) (a, b)))\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<in>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>' x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))\n 3. \\<And>x a b.\n       \\<lbrakk>(Name \\<circ> fst) (a, b) |\\<in>| ids rhs;\n        (Name \\<circ> fst) (a, b) |\\<notin>| fmdom \\<Gamma>';\n        (a, b) |\\<in>| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v\n                          (fmlookup \\<Gamma> ((Name \\<circ> fst) (a, b)))\n                          (fmlookup\n                            (fmap_of_list (map (map_prod Name id) env'))\n                            ((Name \\<circ> fst) (a, b)))\n 4. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<notin>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Name \\<circ> fst) (a_, b_) |\\<in>| ids rhs;\n     (Name \\<circ> fst) (a_, b_) |\\<in>| fmdom \\<Gamma>';\n     (a_, b_) |\\<in>| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v\n                       (fmlookup \\<Gamma>' ((Name \\<circ> fst) (a_, b_)))\n                       (fmlookup\n                         (fmap_of_list (map (map_prod Name id) env'))\n                         ((Name \\<circ> fst) (a_, b_)))", "apply (rule fmrelD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Name \\<circ> fst) (a_, b_) |\\<in>| ids rhs;\n     (Name \\<circ> fst) (a_, b_) |\\<in>| fmdom \\<Gamma>';\n     (a_, b_) |\\<in>| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> var_env \\<Gamma>' env'", "apply (rule \\<open>var_env \\<Gamma>' env'\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<in>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>' x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))\n 2. \\<And>x a b.\n       \\<lbrakk>(Name \\<circ> fst) (a, b) |\\<in>| ids rhs;\n        (Name \\<circ> fst) (a, b) |\\<notin>| fmdom \\<Gamma>';\n        (a, b) |\\<in>| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v\n                          (fmlookup \\<Gamma> ((Name \\<circ> fst) (a, b)))\n                          (fmlookup\n                            (fmap_of_list (map (map_prod Name id) env'))\n                            ((Name \\<circ> fst) (a, b)))\n 3. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<notin>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ |\\<in>| ids rhs; x_ |\\<in>| fmdom \\<Gamma>';\n     x_ |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>' x_)\n                       (cupcake_nsLookup (sem_env.v env) (as_string x_))", "using *"], ["proof (prove)\nusing this:\n  fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ |\\<in>| ids rhs; x_ |\\<in>| fmdom \\<Gamma>';\n     x_ |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma>' x_)\n                       (cupcake_nsLookup (sem_env.v env) (as_string x_))", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>(Name \\<circ> fst) (a, b) |\\<in>| ids rhs;\n        (Name \\<circ> fst) (a, b) |\\<notin>| fmdom \\<Gamma>';\n        (a, b) |\\<in>| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v\n                          (fmlookup \\<Gamma> ((Name \\<circ> fst) (a, b)))\n                          (fmlookup\n                            (fmap_of_list (map (map_prod Name id) env'))\n                            ((Name \\<circ> fst) (a, b)))\n 2. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<notin>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Name \\<circ> fst) (a_, b_) |\\<in>| ids rhs;\n     (Name \\<circ> fst) (a_, b_) |\\<notin>| fmdom \\<Gamma>';\n     (a_, b_) |\\<in>| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v\n                       (fmlookup \\<Gamma> ((Name \\<circ> fst) (a_, b_)))\n                       (fmlookup\n                         (fmap_of_list (map (map_prod Name id) env'))\n                         ((Name \\<circ> fst) (a_, b_)))", "using *"], ["proof (prove)\nusing this:\n  fmdom (fmap_of_list (map (map_prod Name id) env')) = fmdom \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(Name \\<circ> fst) (a_, b_) |\\<in>| ids rhs;\n     (Name \\<circ> fst) (a_, b_) |\\<notin>| fmdom \\<Gamma>';\n     (a_, b_) |\\<in>| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v\n                       (fmlookup \\<Gamma> ((Name \\<circ> fst) (a_, b_)))\n                       (fmlookup\n                         (fmap_of_list (map (map_prod Name id) env'))\n                         ((Name \\<circ> fst) (a_, b_)))", "by (metis (no_types, hide_lams) comp_def fimageI fmdom_fmap_of_list fset_of_list_map fst_comp_map_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<in>| ids rhs; x |\\<notin>| fmdom \\<Gamma>';\n        x |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n       \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x)\n                          (cupcake_nsLookup (sem_env.v env) (as_string x))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ |\\<in>| ids rhs; x_ |\\<notin>| fmdom \\<Gamma>';\n     x_ |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x_)\n                       (cupcake_nsLookup (sem_env.v env) (as_string x_))", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>?id4 |\\<in>| ids rhs; ?id4 |\\<notin>| fmdom \\<Gamma>'\\<rbrakk>\n  \\<Longrightarrow> ?id4 |\\<in>| ids t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ |\\<in>| ids rhs; x_ |\\<notin>| fmdom \\<Gamma>';\n     x_ |\\<notin>| (Name \\<circ> fst) |`| fset_of_list env'\\<rbrakk>\n    \\<Longrightarrow> rel_option related_v (fmlookup \\<Gamma> x_)\n                       (cupcake_nsLookup (sem_env.v env) (as_string x_))", "by (metis fmlookup_ns fmrel_on_fsetD mat1.prems(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n   (fmap_of_ns (sem_env.v env) ++\\<^sub>f\n    fmap_of_list (map (map_prod Name id) env'))\n\ngoal (11 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids rhs) related_v ?\\<Gamma>11\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>11\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>11\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom ?\\<Gamma>11)\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>11\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>| fmdom ?\\<Gamma>11 |\\<union>| C\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>11)\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 10. (\\<And>rhs'.\n         \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                  rhs \\<down> rhs';\n          related_v rhs' ml_rhs'\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>11\nA total of 11 subgoals...", "thus \"fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>') (fmap_of_ns (sem_env.v (env \\<lparr> sem_env.v := nsAppend (alist_to_ns env') (sem_env.v env) \\<rparr>)))\""], ["proof (prove)\nusing this:\n  fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n   (fmap_of_ns (sem_env.v env) ++\\<^sub>f\n    fmap_of_list (map (map_prod Name id) env'))\n\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n     (fmap_of_ns\n       (sem_env.v\n         (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n           env)))", "by (auto split: sem_env.splits)"], ["proof (state)\nthis:\n  fmrel_on_fset (ids rhs) related_v (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n   (fmap_of_ns\n     (sem_env.v\n       (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n         env)))\n\ngoal (10 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 10. \\<And>x.\n        \\<lbrakk>\\<And>rhs'.\n                    \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                             \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                     related_v rhs' ml_rhs'\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n         x \\<and> related_v x ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 9. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 10. \\<And>x.\n        \\<lbrakk>\\<And>rhs'.\n                    \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                             \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                     related_v rhs' ml_rhs'\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n         \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n         x \\<and> related_v x ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis", "show \"wellformed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. wellformed_venv \\<Gamma>\n 2. wellformed_venv \\<Gamma>'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv \\<Gamma>'", "apply (rule vwellformed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some \\<Gamma>'\n 2. vwellformed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwellformed scr'", "apply (rule veval'_wellformed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>8 \\<turnstile>\\<^sub>v ?t8 \\<down> scr'\n 2. pre_strong_term_class.wellformed ?t8\n 3. wellformed_venv ?\\<Gamma>8", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed scr\n 2. wellformed_venv \\<Gamma>", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed scr\n 2. wellformed_venv \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed scr\n 2. wellformed_venv \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  wellformed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (9 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 9. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 8. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 9. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_venv \\<Gamma>\n 2. closed_venv \\<Gamma>'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv \\<Gamma>'", "apply (rule vclosed.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some \\<Gamma>'\n 2. vclosed ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vclosed scr'", "apply (rule veval'_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<Gamma>8 \\<turnstile>\\<^sub>v ?t8 \\<down> scr'\n 2. closed_except ?t8 (fmdom ?\\<Gamma>8)\n 3. closed_venv ?\\<Gamma>8\n 4. pre_strong_term_class.wellformed ?t8\n 5. wellformed_venv ?\\<Gamma>8", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. closed_except scr (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed scr\n 4. wellformed_venv \\<Gamma>", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. closed_except scr (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed scr\n 4. wellformed_venv \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (4 subgoals):\n 1. closed_except scr (fmdom \\<Gamma>)\n 2. closed_venv \\<Gamma>\n 3. pre_strong_term_class.wellformed scr\n 4. wellformed_venv \\<Gamma>", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_venv (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (8 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 8. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 7. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 8. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 2. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>'", "apply (rule vmatch_welldefined')"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some \\<Gamma>'\n 2. vwelldefined' ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. vwelldefined' scr'", "apply (rule veval'_welldefined')"], ["proof (prove)\ngoal (8 subgoals):\n 1. ?\\<Gamma>8 \\<turnstile>\\<^sub>v ?t8 \\<down> scr'\n 2. fdisjnt C (fmdom ?\\<Gamma>8)\n 3. consts ?t8 |\\<subseteq>| fmdom ?\\<Gamma>8 |\\<union>| C\n 4. fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>8\n 5. pre_strong_term_class.wellformed ?t8\n 6. wellformed_venv ?\\<Gamma>8\n 7. \\<not> shadows_consts ?t8\n 8. not_shadows_vconsts_env ?\\<Gamma>8", "apply fact"], ["proof (prove)\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed scr\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts scr\n 7. not_shadows_vconsts_env \\<Gamma>", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed scr\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts scr\n 7. not_shadows_vconsts_env \\<Gamma>", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (7 subgoals):\n 1. fdisjnt C (fmdom \\<Gamma>)\n 2. consts scr |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n 3. fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n 4. pre_strong_term_class.wellformed scr\n 5. wellformed_venv \\<Gamma>\n 6. \\<not> shadows_consts scr\n 7. not_shadows_vconsts_env \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (7 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 7. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n 7. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. not_shadows_vconsts_env \\<Gamma>'", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env \\<Gamma>'", "apply (rule not_shadows_vconsts.vmatch_env)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vmatch ?pat4 ?v4 = Some \\<Gamma>'\n 2. not_shadows_vconsts ?v4", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts scr'", "apply (rule veval'_shadows)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<Gamma>8 \\<turnstile>\\<^sub>v ?t8 \\<down> scr'\n 2. not_shadows_vconsts_env ?\\<Gamma>8\n 3. \\<not> shadows_consts ?t8", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts scr", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts scr", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (2 subgoals):\n 1. not_shadows_vconsts_env \\<Gamma>\n 2. \\<not> shadows_consts scr", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (6 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed rhs\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 5. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 6. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>wellformed t\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (5 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 4. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 5. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| fmdom \\<Gamma>')", "unfolding \\<open>fmdom \\<Gamma>' = frees pat\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>closed_except t (fmdom \\<Gamma>)\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  closed_except t (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. closed_except rhs (fmdom \\<Gamma> |\\<union>| frees pat)", "by (auto simp: Sterm.closed_except_simps list_all_iff)"], ["proof (state)\nthis:\n  closed_except rhs (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n\ngoal (4 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "using mat1"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\n  related_exp t (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed t\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except t (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts t\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single env ml_scr (Rval ml_scr')\n  cupcake_match_result (sem_env.c env) ml_scr' ml_cs Bindv =\n  Rval (ml_rhs, ml_pat, env')\n  cupcake_evaluate_single\n   (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env)) env)\n   ml_rhs ml_res\n  \\<lbrakk>is_cupcake_all_env env;\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns (sem_env.v env));\n   related_exp ?t4 ml_scr; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     (Rval ml_scr')\n  \\<lbrakk>is_cupcake_all_env\n            (update_v\n              (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n              env);\n   fmrel_on_fset (ids ?t4) related_v ?\\<Gamma>4\n    (fmap_of_ns\n      (sem_env.v\n        (update_v (\\<lambda>_. nsAppend (alist_to_ns env') (sem_env.v env))\n          env)));\n   related_exp ?t4 ml_rhs; pre_strong_term_class.wellformed ?t4;\n   wellformed_venv ?\\<Gamma>4; closed_venv ?\\<Gamma>4;\n   closed_except ?t4 (fmdom ?\\<Gamma>4);\n   fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>4;\n   consts ?t4 |\\<subseteq>| fmdom ?\\<Gamma>4 |\\<union>| C;\n   fdisjnt C (fmdom ?\\<Gamma>4); \\<not> shadows_consts ?t4;\n   not_shadows_vconsts_env ?\\<Gamma>4\\<rbrakk>\n  \\<Longrightarrow> if_rval\n                     (\\<lambda>ml_v.\n                         \\<exists>v.\n                            ?\\<Gamma>4 \\<turnstile>\\<^sub>v ?t4 \\<down>\n                            v \\<and> related_v v ml_v)\n                     ml_res\n  is_cupcake_all_env env\n  fmrel_on_fset (ids (Sabs cs $\\<^sub>s scr)) related_v \\<Gamma>\n   (fmap_of_ns (sem_env.v env))\n  related_exp (Sabs cs $\\<^sub>s scr) (Mat ml_scr ml_cs)\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s scr)\n  wellformed_venv \\<Gamma>\n  closed_venv \\<Gamma>\n  closed_except (Sabs cs $\\<^sub>s scr) (fmdom \\<Gamma>)\n  fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\n  consts (Sabs cs $\\<^sub>s scr) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n  fdisjnt C (fmdom \\<Gamma>)\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  not_shadows_vconsts_env \\<Gamma>\n\ngoal (1 subgoal):\n 1. consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C", "by auto"], ["proof (state)\nthis:\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (4 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 3. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 4. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"consts rhs |\\<subseteq>| fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma> |\\<union>| fmdom \\<Gamma>' |\\<union>| C", "unfolding \\<open>fmdom \\<Gamma>' = frees pat\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma> |\\<union>| frees pat |\\<union>| C", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>consts (Sabs cs) |\\<subseteq>| _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  consts (Sabs cs) |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma> |\\<union>| frees pat |\\<union>| C", "unfolding sconsts_sabs"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  list_all\n   (\\<lambda>(uu_, t). consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C)\n   cs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>|\n    fmdom \\<Gamma> |\\<union>| frees pat |\\<union>| C", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>|\n  fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') |\\<union>| C\n\ngoal (3 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fdisjnt C (fmdom \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom \\<Gamma>')", "unfolding \\<open>fmdom \\<Gamma>' = frees pat\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "using \\<open>\\<not> shadows_consts t\\<close> \\<open>(pat, rhs) \\<in> set cs\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts t\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n  (pat, rhs) \\<in> set cs\n\ngoal (1 subgoal):\n 1. fdisjnt C (frees pat)", "by (auto simp: list_ex_iff fdisjnt_alt_def all_consts_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (3 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n 2. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 3. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus \"fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\""], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>')\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))", "using \\<open>fdisjnt C (fmdom \\<Gamma>)\\<close>"], ["proof (prove)\nusing this:\n  fdisjnt C (fmdom \\<Gamma>')\n  fdisjnt C (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  C |\\<inter>| fmdom \\<Gamma>' = {||}\n  C |\\<inter>| fmdom \\<Gamma> = {||}\n\ngoal (1 subgoal):\n 1. C |\\<inter>| fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>') = {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n\ngoal (2 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 2. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>rhs'.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v\n                 rhs \\<down> rhs';\n         related_v rhs' ml_rhs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts rhs\n 2. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> \\<open>\\<not> shadows_consts t\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  \\<not> shadows_consts (Sabs cs $\\<^sub>s scr)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>rhs'.\n                   \\<lbrakk>\\<Gamma> ++\\<^sub>f \\<Gamma>'\n                            \\<turnstile>\\<^sub>v rhs \\<down> rhs';\n                    related_v rhs' ml_rhs'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down>\n        x \\<and> related_v x ml_rhs'\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  \\<Gamma> ++\\<^sub>f \\<Gamma>' \\<turnstile>\\<^sub>v rhs \\<down> rhs'\n  related_v rhs' ml_rhs'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       ml_res = Rval v \\<Longrightarrow>\n       \\<exists>va.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> va \\<and> related_v va v", "show \"\\<exists>t'. \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> t' \\<and> related_v t' ml_rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> t' \\<and>\n       related_v t' ml_rhs'", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s scr \\<down> t' \\<and>\n       related_v t' ml_rhs'", "apply (intro exI conjI seval.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs $\\<^sub>s scr \\<down> ?t'\n 2. related_v ?t' ml_rhs'", "apply (rule veval'.intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v Sabs cs \\<down> Vabs ?cs2 ?\\<Gamma>'2\n 2. \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> ?u'2\n 3. vfind_match ?cs2 ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 4. ?\\<Gamma>'2 ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?t'\n 5. related_v ?t' ml_rhs'", "apply (rule veval'.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Gamma> \\<turnstile>\\<^sub>v scr \\<down> ?u'2\n 2. vfind_match cs ?u'2 = Some (?env2, ?uu2, ?rhs2)\n 3. \\<Gamma> ++\\<^sub>f ?env2 \\<turnstile>\\<^sub>v ?rhs2 \\<down> ?t'\n 4. related_v ?t' ml_rhs'", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>t'.\n     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> t' \\<and> related_v t' ml_rhs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   ml_res\n\ngoal (7 subgoals):\n 1. \\<And>env cn es \\<Gamma> t.\n       \\<lbrakk>\\<not> do_con_check (sem_env.c env) cn (length es);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 2. \\<And>env cn es rs err \\<Gamma> t.\n       \\<lbrakk>do_con_check (sem_env.c env) cn (length es);\n        list_all2_shortcircuit\n         (\\<lambda>x1 x2.\n             cupcake_evaluate_single env x1 x2 \\<and>\n             (is_cupcake_all_env env \\<longrightarrow>\n              (\\<forall>x xa.\n                  fmrel_on_fset (ids xa) related_v x\n                   (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                  related_exp xa x1 \\<longrightarrow>\n                  pre_strong_term_class.wellformed xa \\<longrightarrow>\n                  wellformed_venv x \\<longrightarrow>\n                  closed_venv x \\<longrightarrow>\n                  closed_except xa (fmdom x) \\<longrightarrow>\n                  fmpred (\\<lambda>_. vwelldefined') x \\<longrightarrow>\n                  consts xa |\\<subseteq>|\n                  fmdom x |\\<union>| C \\<longrightarrow>\n                  fdisjnt C (fmdom x) \\<longrightarrow>\n                  \\<not> shadows_consts xa \\<longrightarrow>\n                  not_shadows_vconsts_env x \\<longrightarrow>\n                  if_rval\n                   (\\<lambda>ml_v.\n                       \\<exists>v.\n                          x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                          related_v v ml_v)\n                   x2)))\n         (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Con cn es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 3. \\<And>env n \\<Gamma> t.\n       \\<lbrakk>nsLookup (sem_env.v env) n = None; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Var n); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 4. \\<And>env es rs vs \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rval vs; do_opapp (rev vs) = None;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App Opapp es);\n        pre_strong_term_class.wellformed t; wellformed_venv \\<Gamma>;\n        closed_venv \\<Gamma>; closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr (Rabort Rtype_error))\n 5. \\<And>env es rs err op0 \\<Gamma> t.\n       \\<lbrakk>list_all2_shortcircuit\n                 (\\<lambda>x1 x2.\n                     cupcake_evaluate_single env x1 x2 \\<and>\n                     (is_cupcake_all_env env \\<longrightarrow>\n                      (\\<forall>x xa.\n                          fmrel_on_fset (ids xa) related_v x\n                           (fmap_of_ns (sem_env.v env)) \\<longrightarrow>\n                          related_exp xa x1 \\<longrightarrow>\n                          pre_strong_term_class.wellformed\n                           xa \\<longrightarrow>\n                          wellformed_venv x \\<longrightarrow>\n                          closed_venv x \\<longrightarrow>\n                          closed_except xa (fmdom x) \\<longrightarrow>\n                          fmpred (\\<lambda>_. vwelldefined')\n                           x \\<longrightarrow>\n                          consts xa |\\<subseteq>|\n                          fmdom x |\\<union>| C \\<longrightarrow>\n                          fdisjnt C (fmdom x) \\<longrightarrow>\n                          \\<not> shadows_consts xa \\<longrightarrow>\n                          not_shadows_vconsts_env x \\<longrightarrow>\n                          if_rval\n                           (\\<lambda>ml_v.\n                               \\<exists>v.\n                                  x \\<turnstile>\\<^sub>v xa \\<down> v \\<and>\n                                  related_v v ml_v)\n                           x2)))\n                 (rev es) rs;\n        sequence_result rs = Rerr err; is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (exp0.App op0 es); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 6. \\<And>env e v0 pes err \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rval v0);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rval v0);\n        cupcake_match_result (sem_env.c env) v0 pes Bindv = Rerr err;\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)\n 7. \\<And>env e err pes \\<Gamma> t.\n       \\<lbrakk>cupcake_evaluate_single env e (Rerr err);\n        \\<And>\\<Gamma> t.\n           \\<lbrakk>is_cupcake_all_env env;\n            fmrel_on_fset (ids t) related_v \\<Gamma>\n             (fmap_of_ns (sem_env.v env));\n            related_exp t e; pre_strong_term_class.wellformed t;\n            wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n            closed_except t (fmdom \\<Gamma>);\n            fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n            consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n            fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n            not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> if_rval\n                              (\\<lambda>ml_v.\n                                  \\<exists>v.\n                                     \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                     v \\<and> related_v v ml_v)\n                              (Rerr err);\n        is_cupcake_all_env env;\n        fmrel_on_fset (ids t) related_v \\<Gamma>\n         (fmap_of_ns (sem_env.v env));\n        related_exp t (Mat e pes); pre_strong_term_class.wellformed t;\n        wellformed_venv \\<Gamma>; closed_venv \\<Gamma>;\n        closed_except t (fmdom \\<Gamma>);\n        fmpred (\\<lambda>_. vwelldefined') \\<Gamma>;\n        consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C;\n        fdisjnt C (fmdom \\<Gamma>); \\<not> shadows_consts t;\n        not_shadows_vconsts_env \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> if_rval\n                          (\\<lambda>ml_v.\n                              \\<exists>v.\n                                 \\<Gamma> \\<turnstile>\\<^sub>v t \\<down>\n                                 v \\<and> related_v v ml_v)\n                          (Rerr err)", "qed auto"], ["", "theorem semantic_correctness:\n  fixes exp\n  assumes \"cupcake_evaluate_single env exp (Rval ml_v)\" \"is_cupcake_all_env env\"\n  assumes \"fmrel_on_fset (ids t) related_v \\<Gamma> (fmap_of_ns (sem_env.v env))\"\n  assumes \"related_exp t exp\"\n  assumes \"wellformed t\" \"wellformed_venv \\<Gamma>\"\n  assumes \"closed_venv \\<Gamma>\" \"closed_except t (fmdom \\<Gamma>)\"\n  assumes \"fmpred (\\<lambda>_. vwelldefined') \\<Gamma>\" \"consts t |\\<subseteq>| fmdom \\<Gamma> |\\<union>| C\"\n  assumes \"fdisjnt C (fmdom \\<Gamma>)\"\n  assumes \"\\<not> shadows_consts t\" \"not_shadows_vconsts_env \\<Gamma>\"\n  obtains v where \"\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v\" \"related_v v ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using semantic_correctness0[OF assms]"], ["proof (prove)\nusing this:\n  if_rval\n   (\\<lambda>ml_v.\n       \\<exists>v.\n          \\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v \\<and> related_v v ml_v)\n   (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "end"], ["", "end"], ["", "end"]]}