{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Utils/CakeML_Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma [measure_function]: \"is_measure (size_sem_env size)\"", "lemma if_rvalI: \"(\\<And>v. r = Rval v \\<Longrightarrow> P v) \\<Longrightarrow> if_rval P r\"", "lemma sequence_result_rvalD[dest]:\n  assumes \"sequence_result rs = Rval vs\"\n  shows \"rs = map Rval vs\"", "lemma sequence_result_Rval[simp]: \"sequence_result (map Rval rs) = Rval rs\""], "translations": [["", "lemma [measure_function]: \"is_measure (size_sem_env size)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_measure (size_sem_env size)", "by rule"], ["", "declare all_distinct_alt_def[simp]"], ["", "fun if_rval where\n\"if_rval f (Rval v0) \\<longleftrightarrow> f v0\" |\n\"if_rval _ _ \\<longleftrightarrow> True\""], ["", "lemma if_rvalI: \"(\\<And>v. r = Rval v \\<Longrightarrow> P v) \\<Longrightarrow> if_rval P r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. r = Rval v \\<Longrightarrow> P v) \\<Longrightarrow>\n    if_rval P r", "by (cases r) auto"], ["", "fun if_match where\n\"if_match f (Match env) \\<longleftrightarrow> f env\" |\n\"if_match _ _ \\<longleftrightarrow> True\""], ["", "fun sequence_result :: \"('a, 'b) result list \\<Rightarrow> ('a list, 'b) result\" where\n\"sequence_result [] = Rval []\" |\n\"sequence_result (Rerr err # rs) = Rerr err\" |\n\"sequence_result (Rval v0 # rs) = map_result (\\<lambda>vs. v0 # vs) id (sequence_result rs)\""], ["", "lemma sequence_result_rvalD[dest]:\n  assumes \"sequence_result rs = Rval vs\"\n  shows \"rs = map Rval vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = map Rval vs", "using assms"], ["proof (prove)\nusing this:\n  sequence_result rs = Rval vs\n\ngoal (1 subgoal):\n 1. rs = map Rval vs", "proof (induction rs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       sequence_result [] = Rval vs \\<Longrightarrow> [] = map Rval vs\n 2. \\<And>a rs vs.\n       \\<lbrakk>\\<And>vs.\n                   sequence_result rs = Rval vs \\<Longrightarrow>\n                   rs = map Rval vs;\n        sequence_result (a # rs) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> a # rs = map Rval vs", "case (Cons r rs)"], ["proof (state)\nthis:\n  sequence_result rs = Rval ?vs \\<Longrightarrow> rs = map Rval ?vs\n  sequence_result (r # rs) = Rval vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       sequence_result [] = Rval vs \\<Longrightarrow> [] = map Rval vs\n 2. \\<And>a rs vs.\n       \\<lbrakk>\\<And>vs.\n                   sequence_result rs = Rval vs \\<Longrightarrow>\n                   rs = map Rval vs;\n        sequence_result (a # rs) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> a # rs = map Rval vs", "then"], ["proof (chain)\npicking this:\n  sequence_result rs = Rval ?vs \\<Longrightarrow> rs = map Rval ?vs\n  sequence_result (r # rs) = Rval vs", "obtain v0 vs0 where \"r = Rval v0\" \"vs = v0 # vs0\" \"sequence_result rs = Rval vs0\""], ["proof (prove)\nusing this:\n  sequence_result rs = Rval ?vs \\<Longrightarrow> rs = map Rval ?vs\n  sequence_result (r # rs) = Rval vs\n\ngoal (1 subgoal):\n 1. (\\<And>v0 vs0.\n        \\<lbrakk>r = Rval v0; vs = v0 # vs0;\n         sequence_result rs = Rval vs0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r; cases \"sequence_result rs\") auto"], ["proof (state)\nthis:\n  r = Rval v0\n  vs = v0 # vs0\n  sequence_result rs = Rval vs0\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       sequence_result [] = Rval vs \\<Longrightarrow> [] = map Rval vs\n 2. \\<And>a rs vs.\n       \\<lbrakk>\\<And>vs.\n                   sequence_result rs = Rval vs \\<Longrightarrow>\n                   rs = map Rval vs;\n        sequence_result (a # rs) = Rval vs\\<rbrakk>\n       \\<Longrightarrow> a # rs = map Rval vs", "with Cons"], ["proof (chain)\npicking this:\n  sequence_result rs = Rval ?vs \\<Longrightarrow> rs = map Rval ?vs\n  sequence_result (r # rs) = Rval vs\n  r = Rval v0\n  vs = v0 # vs0\n  sequence_result rs = Rval vs0", "show ?case"], ["proof (prove)\nusing this:\n  sequence_result rs = Rval ?vs \\<Longrightarrow> rs = map Rval ?vs\n  sequence_result (r # rs) = Rval vs\n  r = Rval v0\n  vs = v0 # vs0\n  sequence_result rs = Rval vs0\n\ngoal (1 subgoal):\n 1. r # rs = map Rval vs", "by auto"], ["proof (state)\nthis:\n  r # rs = map Rval vs\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       sequence_result [] = Rval vs \\<Longrightarrow> [] = map Rval vs", "qed simp"], ["", "lemma sequence_result_Rval[simp]: \"sequence_result (map Rval rs) = Rval rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_result (map Rval rs) = Rval rs", "by (induction rs) auto"], ["", "(* FIXME move to CakeML entry *)"], ["", "context begin"], ["", "qualified"], ["", "definition tapp_0 where\n\"tapp_0 tc = Tapp [] tc\""], ["", "qualified"], ["", "definition tapp_1 where\n\"tapp_1 tc t1 = Tapp [t1] tc\""], ["", "qualified"], ["", "definition tapp_2 where\n\"tapp_2 tc t1 t2 = Tapp [t1, t2] tc\""], ["", "end"], ["", "quickcheck_generator Ast.t\n  constructors:\n    Ast.Tvar,\n    Ast.Tvar_db,\n    CakeML_Utils.tapp_0,\n    CakeML_Utils.tapp_1,\n    CakeML_Utils.tapp_2"], ["", "end"]]}