{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Terms/Pterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma sterm_to_pterm_total:\n  obtains t' where \"t = sterm_to_pterm t'\"", "lemma pterm_induct[case_names Pconst Pvar Pabs Papp]:\n  assumes \"\\<And>x. P (Pconst x)\"\n  assumes \"\\<And>x. P (Pvar x)\"\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Pabs cs)\"\n  assumes \"\\<And>t u. P t \\<Longrightarrow> P u \\<Longrightarrow> P (t $\\<^sub>p u)\"\n  shows \"P t\"", "lemma sterm_to_pterm_frees[simp]: \"frees (sterm_to_pterm t) = frees t\"", "lemma sterm_to_pterm_consts[simp]: \"consts (sterm_to_pterm t) = consts t\"", "lemma subst_sterm_to_pterm:\n  \"subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) = sterm_to_pterm (subst t env)\"", "lemma abs_pred_trivI0: \"P t \\<Longrightarrow> abs_pred P (t::pterm)\"", "lemma no_abs_abs[simp]: \"\\<not> no_abs (Pabs cs)\"", "lemma sterm_to_pterm:\n  assumes \"no_abs t\"\n  shows \"sterm_to_pterm t = convert_term t\"", "lemma closed_except_simps:\n  \"closed_except (Pvar x) S \\<longleftrightarrow> x |\\<in>| S\"\n  \"closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S \\<longleftrightarrow> closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S\"\n  \"closed_except (Pabs cs) S \\<longleftrightarrow> fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\"\n  \"closed_except (Pconst name) S \\<longleftrightarrow> True\"", "lemma sterm_to_pterm_all_frees[simp]: \"all_frees (sterm_to_pterm t) = all_frees t\"", "lemma wellformed_PabsI:\n  assumes \"is_fmap cs\" \"pattern_compatibles cs\" \"cs \\<noteq> {||}\"\n  assumes \"\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\"\n  assumes \"\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> wellformed t\"\n  shows \"wellformed (Pabs cs)\"", "lemma (in constants) shadows_consts_pterm_simps[simp]:\n  \"shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<longleftrightarrow> shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2\"\n  \"shadows_consts (Pvar name) \\<longleftrightarrow> name |\\<in>| all_consts\"\n  \"shadows_consts (Pabs cs) \\<longleftrightarrow> fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\"\n  \"shadows_consts (Pconst name) \\<longleftrightarrow> False\""], "translations": [["", "lemma sterm_to_pterm_total:\n  obtains t' where \"t = sterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t = sterm_to_pterm t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction t arbitrary: thesis)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x thesis.\n       (\\<And>t'.\n           Pconst x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>x thesis.\n       (\\<And>t'.\n           Pvar x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 3. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Pconst x)"], ["proof (state)\nthis:\n  Pconst x = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (4 subgoals):\n 1. \\<And>x thesis.\n       (\\<And>t'.\n           Pconst x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>x thesis.\n       (\\<And>t'.\n           Pvar x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 3. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Pconst x = sterm_to_pterm ?t' \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\nusing this:\n  Pconst x = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis sterm_to_pterm.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>x thesis.\n       (\\<And>t'.\n           Pvar x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x thesis.\n       (\\<And>t'.\n           Pvar x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Pvar x)"], ["proof (state)\nthis:\n  Pvar x = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (3 subgoals):\n 1. \\<And>x thesis.\n       (\\<And>t'.\n           Pvar x = sterm_to_pterm t' \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Pvar x = sterm_to_pterm ?t' \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\nusing this:\n  Pvar x = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis sterm_to_pterm.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Pabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Pabs cs = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Pabs.IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain cs' where \"cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        cs =\n        fset_of_list\n         (map (map_prod id sterm_to_pterm) cs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xa xaa thesis.\n        \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n         \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')", "proof (induction cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>xa xaa thesis.\n        \\<lbrakk>xa \\<in> fset {||}; xaa \\<in> Basic_BNFs.snds xa;\n         \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>cs'. {||} = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n 2. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> fset {||}; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. (\\<And>xa xaa thesis.\n        \\<lbrakk>xa \\<in> fset {||}; xaa \\<in> Basic_BNFs.snds xa;\n         \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>cs'. {||} = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n 2. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs'. {||} = fset_of_list (map (map_prod id sterm_to_pterm) cs')", "apply (rule exI[where x = \"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {||} = fset_of_list (map (map_prod id sterm_to_pterm) [])", "by simp"], ["proof (state)\nthis:\n  \\<exists>cs'. {||} = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "case (insert c cs)"], ["proof (state)\nthis:\n  c |\\<notin>| cs\n  (\\<And>xa xaa thesis.\n      \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n       \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n  \\<lbrakk>?xa \\<in> fset (finsert c cs); ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "obtain pat rhs where \"c = (pat, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        c = (pat, rhs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "have \"\\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')", "apply (rule insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa thesis.\n       \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n        \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset (finsert c cs); ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa thesis.\n       \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n        \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "unfolding finsert.rep_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> insert c (fset cs); ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa thesis.\n       \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n        \\<And>t'. xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "then"], ["proof (chain)\npicking this:\n  \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')", "obtain cs' where \"cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\""], ["proof (prove)\nusing this:\n  \\<exists>cs'. cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        cs =\n        fset_of_list\n         (map (map_prod id sterm_to_pterm) cs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "obtain rhs' where \"rhs = sterm_to_pterm rhs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rhs'.\n        rhs = sterm_to_pterm rhs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule insert.prems[of \"(pat, rhs)\" rhs])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>rhs'.\n        rhs = sterm_to_pterm rhs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    (pat, rhs) \\<in> fset (finsert c cs)\n 2. (\\<And>rhs'.\n        rhs = sterm_to_pterm rhs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    rhs \\<in> Basic_BNFs.snds (pat, rhs)\n 3. \\<And>t'.\n       \\<lbrakk>\\<And>rhs'.\n                   rhs = sterm_to_pterm rhs' \\<Longrightarrow> thesis;\n        rhs = sterm_to_pterm t'\\<rbrakk>\n       \\<Longrightarrow> thesis", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>rhs'.\n        rhs = sterm_to_pterm rhs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    (pat, rhs) \\<in> fset (finsert (pat, rhs) cs)\n 2. (\\<And>rhs'.\n        rhs = sterm_to_pterm rhs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    rhs \\<in> Basic_BNFs.snds (pat, rhs)\n 3. \\<And>t'.\n       \\<lbrakk>\\<And>rhs'.\n                   rhs = sterm_to_pterm rhs' \\<Longrightarrow> thesis;\n        rhs = sterm_to_pterm t'\\<rbrakk>\n       \\<Longrightarrow> thesis", "by simp+"], ["proof (state)\nthis:\n  rhs = sterm_to_pterm rhs'\n\ngoal (1 subgoal):\n 1. \\<And>x cs.\n       \\<lbrakk>x |\\<notin>| cs;\n        (\\<And>xa xaa thesis.\n            \\<lbrakk>xa \\<in> fset cs; xaa \\<in> Basic_BNFs.snds xa;\n             \\<And>t'.\n                xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        \\<exists>cs'.\n           cs = fset_of_list (map (map_prod id sterm_to_pterm) cs');\n        \\<And>xa xaa thesis.\n           \\<lbrakk>xa \\<in> fset (finsert x cs);\n            xaa \\<in> Basic_BNFs.snds xa;\n            \\<And>t'.\n               xaa = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs'.\n                            finsert x cs =\n                            fset_of_list\n                             (map (map_prod id sterm_to_pterm) cs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs'.\n       finsert c cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')", "apply (rule exI[where x = \"(pat, rhs') # cs'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsert c cs =\n    fset_of_list (map (map_prod id sterm_to_pterm) ((pat, rhs') # cs'))", "unfolding \\<open>c = _\\<close> \\<open>cs = _\\<close> \\<open>rhs = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsert (pat, sterm_to_pterm rhs')\n     (fset_of_list (map (map_prod id sterm_to_pterm) cs')) =\n    fset_of_list (map (map_prod id sterm_to_pterm) ((pat, rhs') # cs'))", "by (simp add: id_def)"], ["proof (state)\nthis:\n  \\<exists>cs'.\n     finsert c cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (2 subgoals):\n 1. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"Pabs cs = sterm_to_pterm (Sabs cs')\""], ["proof (prove)\nusing this:\n  cs = fset_of_list (map (map_prod id sterm_to_pterm) cs')\n\ngoal (1 subgoal):\n 1. Pabs cs = sterm_to_pterm (Sabs cs')", "by simp"], ["proof (state)\nthis:\n  Pabs cs = sterm_to_pterm (Sabs cs')\n\ngoal (2 subgoals):\n 1. \\<And>x thesis.\n       \\<lbrakk>\\<And>xa xaa thesis.\n                   \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa;\n                    \\<And>t'.\n                       xaa = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>t'.\n           Pabs x = sterm_to_pterm t' \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Pabs cs = sterm_to_pterm (Sabs cs')", "show ?case"], ["proof (prove)\nusing this:\n  Pabs cs = sterm_to_pterm (Sabs cs')\n\ngoal (1 subgoal):\n 1. thesis", "using Pabs"], ["proof (prove)\nusing this:\n  Pabs cs = sterm_to_pterm (Sabs cs')\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa;\n   \\<And>t'. ?xaa = sterm_to_pterm t' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Pabs cs = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Papp t1 t2)"], ["proof (state)\nthis:\n  (\\<And>t'.\n      t1 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>t'.\n      t2 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (\\<And>t'.\n      t1 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>t'.\n      t2 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm ?t' \\<Longrightarrow> thesis", "obtain t1' t2' where \"t1 = sterm_to_pterm t1'\" \"t2 = sterm_to_pterm t2'\""], ["proof (prove)\nusing this:\n  (\\<And>t'.\n      t1 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>t'.\n      t2 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm ?t' \\<Longrightarrow> thesisa__\n\ngoal (1 subgoal):\n 1. (\\<And>t1' t2'.\n        \\<lbrakk>t1 = sterm_to_pterm t1'; t2 = sterm_to_pterm t2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  t1 = sterm_to_pterm t1'\n  t2 = sterm_to_pterm t2'\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  t1 = sterm_to_pterm t1'\n  t2 = sterm_to_pterm t2'", "have \"t1 $\\<^sub>p t2 = sterm_to_pterm (t1' $\\<^sub>s t2')\""], ["proof (prove)\nusing this:\n  t1 = sterm_to_pterm t1'\n  t2 = sterm_to_pterm t2'\n\ngoal (1 subgoal):\n 1. t1 $\\<^sub>p t2 = sterm_to_pterm (t1' $\\<^sub>s t2')", "by simp"], ["proof (state)\nthis:\n  t1 $\\<^sub>p t2 = sterm_to_pterm (t1' $\\<^sub>s t2')\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>t'.\n                       t1 = sterm_to_pterm t' \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>thesis.\n           (\\<And>t'.\n               t2 = sterm_to_pterm t' \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>t'.\n           t1 $\\<^sub>p t2 = sterm_to_pterm t' \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Papp"], ["proof (chain)\npicking this:\n  (\\<And>t'.\n      t1 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>t'.\n      t2 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm (t1' $\\<^sub>s t2')", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>t'.\n      t1 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>t'.\n      t2 = sterm_to_pterm t' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm ?t' \\<Longrightarrow> thesis\n  t1 $\\<^sub>p t2 = sterm_to_pterm (t1' $\\<^sub>s t2')\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pterm_induct[case_names Pconst Pvar Pabs Papp]:\n  assumes \"\\<And>x. P (Pconst x)\"\n  assumes \"\\<And>x. P (Pvar x)\"\n  assumes \"\\<And>cs. (\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> P t) \\<Longrightarrow> P (Pabs cs)\"\n  assumes \"\\<And>t u. P t \\<Longrightarrow> P u \\<Longrightarrow> P (t $\\<^sub>p u)\"\n  shows \"P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "proof (rule pterm.induct, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. P (Pconst x)\n 2. \\<And>x. P (Pvar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> P xaa) \\<Longrightarrow>\n       P (Pabs x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>P x1a; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (x1a $\\<^sub>p x2a)", "case (3 cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa\\<rbrakk>\n  \\<Longrightarrow> P ?xaa\n\ngoal (4 subgoals):\n 1. \\<And>x. P (Pconst x)\n 2. \\<And>x. P (Pvar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> fset x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> P xaa) \\<Longrightarrow>\n       P (Pabs x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>P x1a; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (x1a $\\<^sub>p x2a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (Pabs cs)", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> P t", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> fset cs; ?xaa \\<in> Basic_BNFs.snds ?xa\\<rbrakk>\n  \\<Longrightarrow> P ?xaa\n\ngoal (1 subgoal):\n 1. \\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> P t", "apply (subst (asm) fmember.rep_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pat t.\n       \\<lbrakk>(pat, t) |\\<in>| cs;\n        \\<And>xa xaa.\n           \\<lbrakk>xa |\\<in>| cs; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P t", "by auto"], ["proof (state)\nthis:\n  P (Pabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x. P (Pconst x)\n 2. \\<And>x. P (Pvar x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>P x1a; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (x1a $\\<^sub>p x2a)", "qed fact+"], ["", "instantiation pterm :: pre_term begin"], ["", "definition app_pterm where\n\"app_pterm t u = t $\\<^sub>p u\""], ["", "fun unapp_pterm where\n\"unapp_pterm (t $\\<^sub>p u) = Some (t, u)\" |\n\"unapp_pterm _ = None\""], ["", "definition const_pterm where\n\"const_pterm = Pconst\""], ["", "fun unconst_pterm where\n\"unconst_pterm (Pconst name) = Some name\" |\n\"unconst_pterm _ = None\""], ["", "definition free_pterm where\n\"free_pterm = Pvar\""], ["", "fun unfree_pterm where\n\"unfree_pterm (Pvar name) = Some name\" |\n\"unfree_pterm _ = None\""], ["", "function (sequential) subst_pterm where\n\"subst_pterm (Pvar s) env = (case fmlookup env s of Some t \\<Rightarrow> t | None \\<Rightarrow> Pvar s)\" |\n\"subst_pterm (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) env = subst_pterm t\\<^sub>1 env $\\<^sub>p subst_pterm t\\<^sub>2 env\" |\n\"subst_pterm (Pabs cs) env = Pabs ((\\<lambda>(pat, rhs). (pat, subst_pterm rhs (fmdrop_fset (frees pat) env))) |`| cs)\" |\n\"subst_pterm t _ = t\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>s env. x = (Pvar s, env) \\<Longrightarrow> P;\n        \\<And>t\\<^sub>1 t\\<^sub>2 env.\n           x = (t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env) \\<Longrightarrow> P;\n        \\<And>cs env. x = (Pabs cs, env) \\<Longrightarrow> P;\n        \\<And>v uu_. x = (Pconst v, uu_) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s env sa enva.\n       (Pvar s, env) = (Pvar sa, enva) \\<Longrightarrow>\n       (case fmlookup env s of None \\<Rightarrow> Pvar s\n        | Some t \\<Rightarrow> t) =\n       (case fmlookup enva sa of None \\<Rightarrow> Pvar sa\n        | Some t \\<Rightarrow> t)\n 3. \\<And>s env t\\<^sub>1 t\\<^sub>2 enva.\n       (Pvar s, env) =\n       (t\\<^sub>1 $\\<^sub>p t\\<^sub>2, enva) \\<Longrightarrow>\n       (case fmlookup env s of None \\<Rightarrow> Pvar s\n        | Some t \\<Rightarrow> t) =\n       subst_pterm_sumC (t\\<^sub>1, enva) $\\<^sub>p\n       subst_pterm_sumC (t\\<^sub>2, enva)\n 4. \\<And>s env cs enva.\n       (Pvar s, env) = (Pabs cs, enva) \\<Longrightarrow>\n       (case fmlookup env s of None \\<Rightarrow> Pvar s\n        | Some t \\<Rightarrow> t) =\n       Pabs\n        ((\\<lambda>(pat, rhs).\n             (pat,\n              subst_pterm_sumC (rhs, fmdrop_fset (frees pat) enva))) |`|\n         cs)\n 5. \\<And>s env v uu_.\n       (Pvar s, env) = (Pconst v, uu_) \\<Longrightarrow>\n       (case fmlookup env s of None \\<Rightarrow> Pvar s\n        | Some t \\<Rightarrow> t) =\n       Pconst v\n 6. \\<And>t\\<^sub>1 t\\<^sub>2 env t\\<^sub>1' t\\<^sub>2' enva.\n       (t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env) =\n       (t\\<^sub>1' $\\<^sub>p t\\<^sub>2', enva) \\<Longrightarrow>\n       subst_pterm_sumC (t\\<^sub>1, env) $\\<^sub>p\n       subst_pterm_sumC (t\\<^sub>2, env) =\n       subst_pterm_sumC (t\\<^sub>1', enva) $\\<^sub>p\n       subst_pterm_sumC (t\\<^sub>2', enva)\n 7. \\<And>t\\<^sub>1 t\\<^sub>2 env cs enva.\n       (t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env) =\n       (Pabs cs, enva) \\<Longrightarrow>\n       subst_pterm_sumC (t\\<^sub>1, env) $\\<^sub>p\n       subst_pterm_sumC (t\\<^sub>2, env) =\n       Pabs\n        ((\\<lambda>(pat, rhs).\n             (pat,\n              subst_pterm_sumC (rhs, fmdrop_fset (frees pat) enva))) |`|\n         cs)\n 8. \\<And>t\\<^sub>1 t\\<^sub>2 env v uu_.\n       (t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env) =\n       (Pconst v, uu_) \\<Longrightarrow>\n       subst_pterm_sumC (t\\<^sub>1, env) $\\<^sub>p\n       subst_pterm_sumC (t\\<^sub>2, env) =\n       Pconst v\n 9. \\<And>cs env csa enva.\n       (Pabs cs, env) = (Pabs csa, enva) \\<Longrightarrow>\n       Pabs\n        ((\\<lambda>(pat, rhs).\n             (pat, subst_pterm_sumC (rhs, fmdrop_fset (frees pat) env))) |`|\n         cs) =\n       Pabs\n        ((\\<lambda>(pat, rhs).\n             (pat,\n              subst_pterm_sumC (rhs, fmdrop_fset (frees pat) enva))) |`|\n         csa)\n 10. \\<And>cs env v uu_.\n        (Pabs cs, env) = (Pconst v, uu_) \\<Longrightarrow>\n        Pabs\n         ((\\<lambda>(pat, rhs).\n              (pat,\n               subst_pterm_sumC (rhs, fmdrop_fset (frees pat) env))) |`|\n          cs) =\n        Pconst v\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All subst_pterm_dom", "proof (relation \"measure (size \\<circ> fst)\", goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf (measure (size \\<circ> fst))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>1, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>2, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)\n 4. \\<And>cs env z x y.\n       \\<lbrakk>z \\<in> fset cs; (x, y) = z\\<rbrakk>\n       \\<Longrightarrow> ((y, fmdrop_fset (frees x) env), Pabs cs, env)\n                         \\<in> measure (size \\<circ> fst)", "case 4"], ["proof (state)\nthis:\n  z_ \\<in> fset cs_\n  (x_, y_) = z_\n\ngoal (4 subgoals):\n 1. wf (measure (size \\<circ> fst))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>1, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>2, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)\n 4. \\<And>cs env z x y.\n       \\<lbrakk>z \\<in> fset cs; (x, y) = z\\<rbrakk>\n       \\<Longrightarrow> ((y, fmdrop_fset (frees x) env), Pabs cs, env)\n                         \\<in> measure (size \\<circ> fst)", "then"], ["proof (chain)\npicking this:\n  z_ \\<in> fset cs_\n  (x_, y_) = z_", "show ?case"], ["proof (prove)\nusing this:\n  z_ \\<in> fset cs_\n  (x_, y_) = z_\n\ngoal (1 subgoal):\n 1. ((y_, fmdrop_fset (frees x_) env_), Pabs cs_, env_)\n    \\<in> measure (size \\<circ> fst)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x_, y_) \\<in> fset cs_; z_ = (x_, y_)\\<rbrakk>\n    \\<Longrightarrow> size y_\n                      < Suc (\\<Sum>x\\<in>map_prod (\\<lambda>x. x)\n    (\\<lambda>pterm. (pterm, size pterm)) `\n   fset cs_.\n                               Suc (size_prod (\\<lambda>_. 0) snd x))", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x_, y_) \\<in> fset cs_; z_ = (x_, y_)\\<rbrakk>\n    \\<Longrightarrow> size y_\n                      < Suc (\\<Sum>x\\<in>map_prod (\\<lambda>x. x)\n    (\\<lambda>pterm. (pterm, size pterm)) `\n   fset cs_.\n                               Suc (size_prod (\\<lambda>_. 0) snd x))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y cs z.\n       \\<lbrakk>finite cs; (x, y) \\<in> cs; z = (x, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         < Suc (\\<Sum>x\n\\<in>map_prod (\\<lambda>x. x) (\\<lambda>pterm. (pterm, size pterm)) ` cs.\n                                  Suc (size_prod (\\<lambda>_. 0) snd x))", "apply (rule le_imp_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y cs z.\n       \\<lbrakk>finite cs; (x, y) \\<in> cs; z = (x, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         \\<le> (\\<Sum>x\n\\<in>map_prod (\\<lambda>x. x) (\\<lambda>pterm. (pterm, size pterm)) ` cs.\n                                  Suc (size_prod (\\<lambda>_. 0) snd x))", "apply (rule sum_nat_le_single[where y = \"(a, (b, size b))\" for a b])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y cs z.\n       \\<lbrakk>finite cs; (x, y) \\<in> cs; z = (x, y)\\<rbrakk>\n       \\<Longrightarrow> (?a225 x y cs z, ?b225 x y cs z,\n                          size (?b225 x y cs z))\n                         \\<in> map_prod (\\<lambda>x. x)\n                                (\\<lambda>pterm. (pterm, size pterm)) `\n                               cs\n 2. \\<And>x y cs z.\n       \\<lbrakk>finite cs; (x, y) \\<in> cs; z = (x, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         \\<le> Suc (size_prod (\\<lambda>_. 0) snd\n                                     (?a225 x y cs z, ?b225 x y cs z,\nsize (?b225 x y cs z)))\n 3. \\<And>x y cs z.\n       \\<lbrakk>finite cs; (x, y) \\<in> cs; z = (x, y)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (map_prod (\\<lambda>x. x)\n                            (\\<lambda>pterm. (pterm, size pterm)) `\n                           cs)", "by auto"], ["proof (state)\nthis:\n  ((y_, fmdrop_fset (frees x_) env_), Pabs cs_, env_)\n  \\<in> measure (size \\<circ> fst)\n\ngoal (3 subgoals):\n 1. wf (measure (size \\<circ> fst))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>1, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       ((t\\<^sub>2, env), t\\<^sub>1 $\\<^sub>p t\\<^sub>2, env)\n       \\<in> measure (size \\<circ> fst)", "qed auto"], ["", "primrec consts_pterm :: \"pterm \\<Rightarrow> name fset\" where\n\"consts_pterm (Pconst x) = {|x|}\" |\n\"consts_pterm (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) = consts_pterm t\\<^sub>1 |\\<union>| consts_pterm t\\<^sub>2\" |\n\"consts_pterm (Pabs cs) = ffUnion (snd |`| map_prod id consts_pterm |`| cs)\" |\n\"consts_pterm (Pvar _) = {||}\""], ["", "primrec frees_pterm :: \"pterm \\<Rightarrow> name fset\" where\n\"frees_pterm (Pvar x) = {|x|}\" |\n\"frees_pterm (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) = frees_pterm t\\<^sub>1 |\\<union>| frees_pterm t\\<^sub>2\" |\n\"frees_pterm (Pabs cs) = ffUnion ((\\<lambda>(pv, tv). tv - frees pv) |`| map_prod id frees_pterm |`| cs)\" |\n\"frees_pterm (Pconst _) = {||}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pterm, pre_term_class)", "by standard\n   (auto\n      simp: app_pterm_def const_pterm_def free_pterm_def\n      elim: unapp_pterm.elims unconst_pterm.elims unfree_pterm.elims\n      split: option.splits)"], ["", "end"], ["", "corollary subst_pabs_id:\n  assumes \"\\<And>pat rhs. (pat, rhs) |\\<in>| cs \\<Longrightarrow> subst rhs (fmdrop_fset (frees pat) env) = rhs\"\n  shows \"subst (Pabs cs) env = Pabs cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (Pabs cs) env = Pabs cs", "apply (subst subst_pterm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pabs\n     ((\\<lambda>(pat, rhs).\n          (pat, subst rhs (fmdrop_fset (frees pat) env))) |`|\n      cs) =\n    Pabs cs", "apply (rule arg_cong[where f = Pabs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(pat, rhs).\n        (pat, subst rhs (fmdrop_fset (frees pat) env))) |`|\n    cs =\n    cs", "apply (rule fset_map_snd_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pat rhs e.\n       (pat, rhs) \\<in> fset cs \\<Longrightarrow>\n       subst rhs (fmdrop_fset (frees pat) env) = rhs", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pat rhs e.\n       (pat, rhs) \\<in> fset cs \\<Longrightarrow> (pat, rhs) |\\<in>| cs", "apply (subst (asm) fmember.rep_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pat rhs e.\n       (pat, rhs) |\\<in>| cs \\<Longrightarrow> (pat, rhs) |\\<in>| cs", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary frees_pabs_alt_def:\n  \"frees (Pabs cs) = ffUnion ((\\<lambda>(pat, rhs). frees rhs - frees pat) |`| cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Pabs cs) =\n    ffUnion ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n      cs) =\n    ffUnion ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| cs)", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n    cs =\n    (\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| cs", "apply (rule fset.map_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> fset cs \\<Longrightarrow>\n       ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) z =\n       (case z of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)", "by auto"], ["", "lemma sterm_to_pterm_frees[simp]: \"frees (sterm_to_pterm t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (sterm_to_pterm t) = frees t", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. frees (sterm_to_pterm (Sconst x)) = frees (Sconst x)\n 2. \\<And>x. frees (sterm_to_pterm (Svar x)) = frees (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> frees (sterm_to_pterm xaa) =\n                             frees xaa) \\<Longrightarrow>\n       frees (sterm_to_pterm (Sabs x)) = frees (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>frees (sterm_to_pterm t1) = frees t1;\n        frees (sterm_to_pterm t2) = frees t2\\<rbrakk>\n       \\<Longrightarrow> frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         frees (t1 $\\<^sub>s t2)", "case (Sabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> set cs; ?xaa \\<in> Basic_BNFs.snds ?xa\\<rbrakk>\n  \\<Longrightarrow> frees (sterm_to_pterm ?xaa) = frees ?xaa\n\ngoal (4 subgoals):\n 1. \\<And>x. frees (sterm_to_pterm (Sconst x)) = frees (Sconst x)\n 2. \\<And>x. frees (sterm_to_pterm (Svar x)) = frees (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> frees (sterm_to_pterm xaa) =\n                             frees xaa) \\<Longrightarrow>\n       frees (sterm_to_pterm (Sabs x)) = frees (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>frees (sterm_to_pterm t1) = frees t1;\n        frees (sterm_to_pterm t2) = frees t2\\<rbrakk>\n       \\<Longrightarrow> frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         frees (t1 $\\<^sub>s t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (sterm_to_pterm (Sabs cs)) = frees (Sabs cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n       (map_prod id frees \\<circ> map_prod id sterm_to_pterm)) |`|\n      fset_of_list cs) =\n    ffUnion\n     ((\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs)", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n     (map_prod id frees \\<circ> map_prod id sterm_to_pterm)) |`|\n    fset_of_list cs =\n    (\\<lambda>(pat, rhs). frees rhs |-| frees pat) |`| fset_of_list cs", "apply (rule fimage_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n        (map_prod id frees \\<circ> map_prod id sterm_to_pterm))\n        x =\n       (case x of (pat, rhs) \\<Rightarrow> frees rhs |-| frees pat)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       frees (sterm_to_pterm b) |-| frees a = frees b |-| frees a", "apply (subst Sabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ?xa6 a b \\<in> set cs\n 2. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       b \\<in> Basic_BNFs.snds (?xa6 a b)\n 3. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       frees b |-| frees a = frees b |-| frees a", "by (auto simp: fset_of_list_elem snds.simps)"], ["proof (state)\nthis:\n  frees (sterm_to_pterm (Sabs cs)) = frees (Sabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x. frees (sterm_to_pterm (Sconst x)) = frees (Sconst x)\n 2. \\<And>x. frees (sterm_to_pterm (Svar x)) = frees (Svar x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>frees (sterm_to_pterm t1) = frees t1;\n        frees (sterm_to_pterm t2) = frees t2\\<rbrakk>\n       \\<Longrightarrow> frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         frees (t1 $\\<^sub>s t2)", "qed auto"], ["", "lemma sterm_to_pterm_consts[simp]: \"consts (sterm_to_pterm t) = consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (sterm_to_pterm t) = consts t", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. consts (sterm_to_pterm (Sconst x)) = consts (Sconst x)\n 2. \\<And>x. consts (sterm_to_pterm (Svar x)) = consts (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> consts (sterm_to_pterm xaa) =\n                             consts xaa) \\<Longrightarrow>\n       consts (sterm_to_pterm (Sabs x)) = consts (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>consts (sterm_to_pterm t1) = consts t1;\n        consts (sterm_to_pterm t2) = consts t2\\<rbrakk>\n       \\<Longrightarrow> consts (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         consts (t1 $\\<^sub>s t2)", "case (Sabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> set cs; ?xaa \\<in> Basic_BNFs.snds ?xa\\<rbrakk>\n  \\<Longrightarrow> consts (sterm_to_pterm ?xaa) = consts ?xaa\n\ngoal (4 subgoals):\n 1. \\<And>x. consts (sterm_to_pterm (Sconst x)) = consts (Sconst x)\n 2. \\<And>x. consts (sterm_to_pterm (Svar x)) = consts (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> consts (sterm_to_pterm xaa) =\n                             consts xaa) \\<Longrightarrow>\n       consts (sterm_to_pterm (Sabs x)) = consts (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>consts (sterm_to_pterm t1) = consts t1;\n        consts (sterm_to_pterm t2) = consts t2\\<rbrakk>\n       \\<Longrightarrow> consts (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         consts (t1 $\\<^sub>s t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (sterm_to_pterm (Sabs cs)) = consts (Sabs cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     ((snd \\<circ>\n       (map_prod id consts \\<circ> map_prod id sterm_to_pterm)) |`|\n      fset_of_list cs) =\n    ffUnion ((\\<lambda>(uu_, y). consts y) |`| fset_of_list cs)", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ>\n     (map_prod id consts \\<circ> map_prod id sterm_to_pterm)) |`|\n    fset_of_list cs =\n    (\\<lambda>(uu_, y). consts y) |`| fset_of_list cs", "apply (rule fimage_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       (snd \\<circ> (map_prod id consts \\<circ> map_prod id sterm_to_pterm))\n        x =\n       (case x of (uu_, x) \\<Rightarrow> consts x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       consts (sterm_to_pterm b) = consts b", "apply (subst Sabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ?xa6 a b \\<in> set cs\n 2. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       b \\<in> Basic_BNFs.snds (?xa6 a b)\n 3. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow> consts b = consts b", "by (auto simp: fset_of_list_elem snds.simps)"], ["proof (state)\nthis:\n  consts (sterm_to_pterm (Sabs cs)) = consts (Sabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x. consts (sterm_to_pterm (Sconst x)) = consts (Sconst x)\n 2. \\<And>x. consts (sterm_to_pterm (Svar x)) = consts (Svar x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>consts (sterm_to_pterm t1) = consts t1;\n        consts (sterm_to_pterm t2) = consts t2\\<rbrakk>\n       \\<Longrightarrow> consts (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         consts (t1 $\\<^sub>s t2)", "qed auto"], ["", "lemma subst_sterm_to_pterm:\n  \"subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) = sterm_to_pterm (subst t env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n    sterm_to_pterm (subst t env)", "proof (induction t arbitrary: env rule: sterm_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x env.\n       subst (sterm_to_pterm (Sconst x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Sconst x) env)\n 2. \\<And>x env.\n       subst (sterm_to_pterm (Svar x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Svar x) env)\n 3. \\<And>cs env.\n       (\\<And>pat t env.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n           sterm_to_pterm (subst t env)) \\<Longrightarrow>\n       subst (sterm_to_pterm (Sabs cs)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Sabs cs) env)\n 4. \\<And>t u env.\n       \\<lbrakk>\\<And>env.\n                   subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n                   sterm_to_pterm (subst t env);\n        \\<And>env.\n           subst (sterm_to_pterm u) (fmmap sterm_to_pterm env) =\n           sterm_to_pterm (subst u env)\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t $\\<^sub>s u))\n                          (fmmap sterm_to_pterm env) =\n                         sterm_to_pterm (subst (t $\\<^sub>s u) env)", "case (Sabs cs)"], ["proof (state)\nthis:\n  (?pat, ?t) \\<in> set cs \\<Longrightarrow>\n  subst (sterm_to_pterm ?t) (fmmap sterm_to_pterm ?env) =\n  sterm_to_pterm (subst ?t ?env)\n\ngoal (4 subgoals):\n 1. \\<And>x env.\n       subst (sterm_to_pterm (Sconst x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Sconst x) env)\n 2. \\<And>x env.\n       subst (sterm_to_pterm (Svar x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Svar x) env)\n 3. \\<And>cs env.\n       (\\<And>pat t env.\n           (pat, t) \\<in> set cs \\<Longrightarrow>\n           subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n           sterm_to_pterm (subst t env)) \\<Longrightarrow>\n       subst (sterm_to_pterm (Sabs cs)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Sabs cs) env)\n 4. \\<And>t u env.\n       \\<lbrakk>\\<And>env.\n                   subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n                   sterm_to_pterm (subst t env);\n        \\<And>env.\n           subst (sterm_to_pterm u) (fmmap sterm_to_pterm env) =\n           sterm_to_pterm (subst u env)\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t $\\<^sub>s u))\n                          (fmmap sterm_to_pterm env) =\n                         sterm_to_pterm (subst (t $\\<^sub>s u) env)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (sterm_to_pterm (Sabs cs)) (fmmap sterm_to_pterm env) =\n    sterm_to_pterm (subst (Sabs cs) env)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(pat, rhs).\n         (pat,\n          subst rhs\n           (fmmap sterm_to_pterm (fmdrop_fset (frees pat) env)))) \\<circ>\n     map_prod id sterm_to_pterm) |`|\n    fset_of_list cs =\n    (map_prod id sterm_to_pterm \\<circ>\n     (\\<lambda>(pat, rhs).\n         (pat, subst rhs (fmdrop_fset (frees pat) env)))) |`|\n    fset_of_list cs", "apply (rule fset.map_cong0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> fset (fset_of_list cs) \\<Longrightarrow>\n       ((\\<lambda>(pat, rhs).\n            (pat,\n             subst rhs\n              (fmmap sterm_to_pterm (fmdrop_fset (frees pat) env)))) \\<circ>\n        map_prod id sterm_to_pterm)\n        z =\n       (map_prod id sterm_to_pterm \\<circ>\n        (\\<lambda>(pat, rhs).\n            (pat, subst rhs (fmdrop_fset (frees pat) env))))\n        z", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) \\<in> fset (fset_of_list cs) \\<Longrightarrow>\n       subst (sterm_to_pterm x2)\n        (fmmap sterm_to_pterm (fmdrop_fset (frees x1) env)) =\n       sterm_to_pterm (subst x2 (fmdrop_fset (frees x1) env))", "apply (rule Sabs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (x1, x2) \\<in> fset (fset_of_list cs) \\<Longrightarrow>\n       (?pat17 x1 x2, x2) \\<in> set cs", "by (auto simp: fset_of_list.rep_eq)"], ["proof (state)\nthis:\n  subst (sterm_to_pterm (Sabs cs)) (fmmap sterm_to_pterm env) =\n  sterm_to_pterm (subst (Sabs cs) env)\n\ngoal (3 subgoals):\n 1. \\<And>x env.\n       subst (sterm_to_pterm (Sconst x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Sconst x) env)\n 2. \\<And>x env.\n       subst (sterm_to_pterm (Svar x)) (fmmap sterm_to_pterm env) =\n       sterm_to_pterm (subst (Svar x) env)\n 3. \\<And>t u env.\n       \\<lbrakk>\\<And>env.\n                   subst (sterm_to_pterm t) (fmmap sterm_to_pterm env) =\n                   sterm_to_pterm (subst t env);\n        \\<And>env.\n           subst (sterm_to_pterm u) (fmmap sterm_to_pterm env) =\n           sterm_to_pterm (subst u env)\\<rbrakk>\n       \\<Longrightarrow> subst (sterm_to_pterm (t $\\<^sub>s u))\n                          (fmmap sterm_to_pterm env) =\n                         sterm_to_pterm (subst (t $\\<^sub>s u) env)", "qed (auto split: option.splits)"], ["", "instantiation pterm :: \"term\" begin"], ["", "definition abs_pred_pterm :: \"(pterm \\<Rightarrow> bool) \\<Rightarrow> pterm \\<Rightarrow> bool\" where\n[code del]: \"abs_pred P t \\<longleftrightarrow> (\\<forall>cs. t = Pabs cs \\<longrightarrow> (\\<forall>pat t. (pat, t) |\\<in>| cs \\<longrightarrow> P t) \\<longrightarrow> P t)\""], ["", "context begin"], ["", "private"], ["", "lemma abs_pred_trivI0: \"P t \\<Longrightarrow> abs_pred P (t::pterm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t \\<Longrightarrow> abs_pred P t", "unfolding abs_pred_pterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t \\<Longrightarrow>\n    \\<forall>cs.\n       t = Pabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow> P t) \\<longrightarrow>\n       P t", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pterm, term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (1 P t)"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (1 subgoal):\n 1. P t", "by (induction t rule: pterm_induct)\n       (auto simp: const_pterm_def free_pterm_def app_pterm_def abs_pred_pterm_def)"], ["proof (state)\nthis:\n  P t\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "(* FIXME proving 2, 3 and 4 via sterm probably requires lifting setup *)\n  (* lifting setup requires a consistent ordering without assumptions! *)\n  (* but: other parts (in Eq_Logic_PM_Seq) require a key-ordering that only works with assumptions *)\n  (* solution: don't try to abstract over the ordering *)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (2 t)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n     t", "unfolding abs_pred_pterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cs.\n       t = Pabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env.\n               id_env env \\<longrightarrow>\n               subst t env = t)) \\<longrightarrow>\n       (\\<forall>env. id_env env \\<longrightarrow> subst t env = t)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env. id_env env \\<longrightarrow> subst t env = t);\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> subst (Pabs cs) env = Pabs cs", "apply (rule subst_pabs_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env pat rhs.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env. id_env env \\<longrightarrow> subst t env = t);\n        id_env env; (pat, rhs) |\\<in>| cs\\<rbrakk>\n       \\<Longrightarrow> subst rhs (fmdrop_fset (frees pat) env) = rhs", "by blast"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t. \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n   t\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (3 x t)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 5. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         x |\\<notin>| frees t \\<longrightarrow>\n         (\\<forall>env. subst t (fmdrop x env) = subst t env))\n     t", "unfolding abs_pred_pterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cs.\n       t = Pabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           x |\\<notin>| frees t \\<longrightarrow>\n           (\\<forall>env.\n               subst t (fmdrop x env) = subst t env)) \\<longrightarrow>\n       x |\\<notin>| frees t \\<longrightarrow>\n       (\\<forall>env. subst t (fmdrop x env) = subst t env)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           x |\\<notin>| frees t \\<longrightarrow>\n           (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(pat, rhs).\n                             (pat,\n                              subst rhs\n                               (fmdrop x\n                                 (fmdrop_fset (frees pat) env)))) |`|\n                         cs =\n                         (\\<lambda>(pat, rhs).\n                             (pat,\n                              subst rhs (fmdrop_fset (frees pat) env))) |`|\n                         cs", "apply (rule fset.map_cong0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env z.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           x |\\<notin>| frees t \\<longrightarrow>\n           (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs);\n        z \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> (case z of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs\n                              (fmdrop x (fmdrop_fset (frees pat) env)))) =\n                         (case z of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat, subst rhs (fmdrop_fset (frees pat) env)))", "apply (rename_tac c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env c.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           x |\\<notin>| frees t \\<longrightarrow>\n           (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs);\n        c \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> (case c of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs\n                              (fmdrop x (fmdrop_fset (frees pat) env)))) =\n                         (case c of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat, subst rhs (fmdrop_fset (frees pat) env)))", "apply (case_tac c; hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env c a b.\n       \\<lbrakk>\\<forall>pat t.\n                   (pat, t) |\\<in>| cs \\<longrightarrow>\n                   x |\\<notin>| frees t \\<longrightarrow>\n                   (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs);\n        (a, b) \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> (case (a, b) of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs\n                              (fmdrop x (fmdrop_fset (frees pat) env)))) =\n                         (case (a, b) of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat, subst rhs (fmdrop_fset (frees pat) env)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env a b.\n       \\<lbrakk>\\<forall>pat t.\n                   (pat, t) |\\<in>| cs \\<longrightarrow>\n                   x |\\<notin>| frees t \\<longrightarrow>\n                   (\\<forall>env. subst t (fmdrop x env) = subst t env);\n        x |\\<notin>|\n        ffUnion\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs);\n        (a, b) \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> subst b (fmdrop x (fmdrop_fset (frees a) env)) =\n                         subst b (fmdrop_fset (frees a) env)", "subgoal for cs env pat rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "apply (cases \"x |\\<in>| frees pat\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)\n 2. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs; x |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "apply (rule arg_cong[where f = \"subst rhs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs; x |\\<in>| frees pat\\<rbrakk>\n    \\<Longrightarrow> fmdrop x (fmdrop_fset (frees pat) env) =\n                      fmdrop_fset (frees pat) env", "by (auto intro: fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>pat t.\n                (pat, t) |\\<in>| cs \\<longrightarrow>\n                x |\\<notin>| frees t \\<longrightarrow>\n                (\\<forall>env. subst t (fmdrop x env) = subst t env);\n     x |\\<notin>|\n     ffUnion\n      (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`|\n       cs);\n     (pat, rhs) \\<in> fset cs; x |\\<notin>| frees pat\\<rbrakk>\n    \\<Longrightarrow> subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n                      subst rhs (fmdrop_fset (frees pat) env)", "subgoal premises prems[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop_fset (frees pat) env)", "apply (subst (2) prems(1)[symmetric, where pat = pat])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (pat, rhs) |\\<in>| cs\n 2. x |\\<notin>| frees rhs\n 3. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) |\\<in>| cs", "by (subst fmember.rep_eq) fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. x |\\<notin>| frees rhs\n 2. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs; x |\\<notin>| frees ?t\\<rbrakk>\n  \\<Longrightarrow> subst ?t (fmdrop x ?env) = subst ?t ?env\n  x |\\<notin>|\n  ffUnion\n   (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ> map_prod id frees) |`| cs)\n  (pat, rhs) \\<in> fset cs\n  x |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "unfolding ffUnion_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs; x |\\<notin>| frees ?t\\<rbrakk>\n  \\<Longrightarrow> subst ?t (fmdrop x ?env) = subst ?t ?env\n  \\<not> fBex\n          (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n            map_prod id frees) |`|\n           cs)\n          ((|\\<in>|) x)\n  (pat, rhs) \\<in> fset cs\n  x |\\<notin>| frees pat\n\ngoal (1 subgoal):\n 1. x |\\<notin>| frees rhs", "by (auto simp: fmember.rep_eq fset_of_list.rep_eq elim!: fBallE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop x (fmdrop_fset (frees pat) env)) =\n    subst rhs (fmdrop x (fmdrop_fset (frees pat) env))", "apply (rule arg_cong[where f = \"subst rhs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdrop x (fmdrop_fset (frees pat) env) =\n    fmdrop x (fmdrop_fset (frees pat) env)", "by (auto intro: fmap_ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       x |\\<notin>| frees t \\<longrightarrow>\n       (\\<forall>env. subst t (fmdrop x env) = subst t env))\n   t\n\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (4 t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 4. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env\\<^sub>1 env\\<^sub>2.\n            closed_env env\\<^sub>2 \\<longrightarrow>\n            fdisjnt (fmdom env\\<^sub>1)\n             (fmdom env\\<^sub>2) \\<longrightarrow>\n            subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n            subst (subst t env\\<^sub>2) env\\<^sub>1)\n     t", "unfolding abs_pred_pterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cs.\n       t = Pabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)) \\<longrightarrow>\n       (\\<forall>env\\<^sub>1 env\\<^sub>2.\n           closed_env env\\<^sub>2 \\<longrightarrow>\n           fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2) \\<longrightarrow>\n           subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n           subst (subst t env\\<^sub>2) env\\<^sub>1)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1);\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(pat, rhs).\n                             (pat,\n                              subst rhs\n                               (fmdrop_fset (frees pat)\n                                 env\\<^sub>1 ++\\<^sub>f\n                                fmdrop_fset (frees pat) env\\<^sub>2))) |`|\n                         cs =\n                         ((\\<lambda>(pat, rhs).\n                              (pat,\n                               subst rhs\n                                (fmdrop_fset (frees pat)\n                                  env\\<^sub>1))) \\<circ>\n                          (\\<lambda>(pat, rhs).\n                              (pat,\n                               subst rhs\n                                (fmdrop_fset (frees pat) env\\<^sub>2)))) |`|\n                         cs", "apply (rule fset.map_cong0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env\\<^sub>1 env\\<^sub>2 z.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1);\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n        z \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> (case z of\n                          (pat, rhs) \\<Rightarrow>\n                            (pat,\n                             subst rhs\n                              (fmdrop_fset (frees pat)\n                                env\\<^sub>1 ++\\<^sub>f\n                               fmdrop_fset (frees pat) env\\<^sub>2))) =\n                         ((\\<lambda>(pat, rhs).\n                              (pat,\n                               subst rhs\n                                (fmdrop_fset (frees pat)\n                                  env\\<^sub>1))) \\<circ>\n                          (\\<lambda>(pat, rhs).\n                              (pat,\n                               subst rhs\n                                (fmdrop_fset (frees pat) env\\<^sub>2))))\n                          z", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env\\<^sub>1 env\\<^sub>2 a b.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           (\\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1);\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n        (a, b) \\<in> fset cs\\<rbrakk>\n       \\<Longrightarrow> subst b\n                          (fmdrop_fset (frees a) env\\<^sub>1 ++\\<^sub>f\n                           fmdrop_fset (frees a) env\\<^sub>2) =\n                         subst (subst b (fmdrop_fset (frees a) env\\<^sub>2))\n                          (fmdrop_fset (frees a) env\\<^sub>1)", "subgoal premises prems[rule_format] for cs env\\<^sub>1 env\\<^sub>2 a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst b\n     (fmdrop_fset (frees a) env\\<^sub>1 ++\\<^sub>f\n      fmdrop_fset (frees a) env\\<^sub>2) =\n    subst (subst b (fmdrop_fset (frees a) env\\<^sub>2))\n     (fmdrop_fset (frees a) env\\<^sub>1)", "apply (rule prems(2)[unfolded fmember.rep_eq, OF prems(5)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_env (fmdrop_fset (frees a) env\\<^sub>2)\n 2. fdisjnt (fmdom (fmdrop_fset (frees a) env\\<^sub>1))\n     (fmdom (fmdrop_fset (frees a) env\\<^sub>2))", "using prems"], ["proof (prove)\nusing this:\n  t = Pabs cs\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs; closed_env ?env\\<^sub>2;\n   fdisjnt (fmdom ?env\\<^sub>1) (fmdom ?env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> subst ?t (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2) =\n                    subst (subst ?t ?env\\<^sub>2) ?env\\<^sub>1\n  closed_env env\\<^sub>2\n  fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\n  (a, b) \\<in> fset cs\n\ngoal (2 subgoals):\n 1. closed_env (fmdrop_fset (frees a) env\\<^sub>2)\n 2. fdisjnt (fmdom (fmdrop_fset (frees a) env\\<^sub>1))\n     (fmdom (fmdrop_fset (frees a) env\\<^sub>2))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  t = Pabs cs\n  \\<lbrakk>(?pat, ?t) |\\<in>| cs; closed_env ?env\\<^sub>2;\n   fmdom ?env\\<^sub>1 |\\<inter>| fmdom ?env\\<^sub>2 = {||}\\<rbrakk>\n  \\<Longrightarrow> subst ?t (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2) =\n                    subst (subst ?t ?env\\<^sub>2) ?env\\<^sub>1\n  closed_env env\\<^sub>2\n  fmdom env\\<^sub>1 |\\<inter>| fmdom env\\<^sub>2 = {||}\n  (a, b) \\<in> fset cs\n\ngoal (2 subgoals):\n 1. closed_env (fmdrop_fset (frees a) env\\<^sub>2)\n 2. fmdom (fmdrop_fset (frees a) env\\<^sub>1) |\\<inter>|\n    fmdom (fmdrop_fset (frees a) env\\<^sub>2) =\n    {||}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       \\<forall>env\\<^sub>1 env\\<^sub>2.\n          closed_env env\\<^sub>2 \\<longrightarrow>\n          fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2) \\<longrightarrow>\n          subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n          subst (subst t env\\<^sub>2) env\\<^sub>1)\n   t\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 3. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         \\<forall>env.\n            closed_env env \\<longrightarrow>\n            frees (subst t env) = frees t |-| fmdom env)\n     t_", "proof (rule abs_pred_trivI0, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env.\n       closed_env env \\<Longrightarrow>\n       frees (subst t_ env) = frees t_ |-| fmdom env", "fix t :: pterm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env.\n       closed_env env \\<Longrightarrow>\n       frees (subst t_ env) = frees t_ |-| fmdom env", "fix env :: \"(name, pterm) fmap\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>env.\n       closed_env env \\<Longrightarrow>\n       frees (subst t_ env) = frees t_ |-| fmdom env", "obtain t' where \"t = sterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t = sterm_to_pterm t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule sterm_to_pterm_total)"], ["proof (state)\nthis:\n  t = sterm_to_pterm t'\n\ngoal (1 subgoal):\n 1. \\<And>env.\n       closed_env env \\<Longrightarrow>\n       frees (subst t_ env) = frees t_ |-| fmdom env", "obtain env' where \"env = fmmap sterm_to_pterm env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        env = fmmap sterm_to_pterm env' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis fmmap_total sterm_to_pterm_total)"], ["proof (state)\nthis:\n  env = fmmap sterm_to_pterm env'\n\ngoal (1 subgoal):\n 1. \\<And>env.\n       closed_env env \\<Longrightarrow>\n       frees (subst t_ env) = frees t_ |-| fmdom env", "show \"frees (subst t env) = frees t - fmdom env\" if \"fmpred (\\<lambda>_. closed) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst t env) = frees t |-| fmdom env", "unfolding \\<open>t = _\\<close> \\<open>env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    frees (sterm_to_pterm t') |-| fmdom (fmmap sterm_to_pterm env')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    frees t' |-| fmdom env'", "apply (subst subst_sterm_to_pterm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (sterm_to_pterm (subst t' env')) = frees t' |-| fmdom env'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (subst t' env') = frees t' |-| fmdom env'", "apply (rule subst_frees)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env'", "using that"], ["proof (prove)\nusing this:\n  closed_env env\n\ngoal (1 subgoal):\n 1. closed_env env'", "unfolding \\<open>env = _\\<close>"], ["proof (prove)\nusing this:\n  closed_env (fmmap sterm_to_pterm env')\n\ngoal (1 subgoal):\n 1. closed_env env'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>k v. closed (sterm_to_pterm v)) env' \\<Longrightarrow>\n    closed_env env'", "apply (rule fmpred_mono_strong; assumption?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>fmpred (\\<lambda>k v. closed (sterm_to_pterm v)) env';\n        fmlookup env' x = Some y; closed (sterm_to_pterm y)\\<rbrakk>\n       \\<Longrightarrow> closed y", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>fmpred\n                 (\\<lambda>k v. frees (sterm_to_pterm v) |\\<subseteq>| {||})\n                 env';\n        fmlookup env' x = Some y;\n        frees (sterm_to_pterm y) |\\<subseteq>| {||}\\<rbrakk>\n       \\<Longrightarrow> frees y |\\<subseteq>| {||}", "by simp"], ["proof (state)\nthis:\n  closed_env env \\<Longrightarrow>\n  frees (subst t env) = frees t |-| fmdom env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       \\<forall>env.\n          closed_env env \\<longrightarrow>\n          frees (subst t env) = frees t |-| fmdom env)\n   t_\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 2. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         \\<forall>x.\n            consts (subst a x) =\n            consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n     t_", "proof (rule abs_pred_trivI0, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       consts (subst t_ x) =\n       consts t_ |\\<union>| ffUnion (consts |`| fmimage x (frees t_))", "fix t :: pterm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       consts (subst t_ x) =\n       consts t_ |\\<union>| ffUnion (consts |`| fmimage x (frees t_))", "fix env :: \"(name, pterm) fmap\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       consts (subst t_ x) =\n       consts t_ |\\<union>| ffUnion (consts |`| fmimage x (frees t_))", "obtain t' where \"t = sterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t = sterm_to_pterm t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule sterm_to_pterm_total)"], ["proof (state)\nthis:\n  t = sterm_to_pterm t'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       consts (subst t_ x) =\n       consts t_ |\\<union>| ffUnion (consts |`| fmimage x (frees t_))", "obtain env' where \"env = fmmap sterm_to_pterm env'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        env = fmmap sterm_to_pterm env' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis fmmap_total sterm_to_pterm_total)"], ["proof (state)\nthis:\n  env = fmmap sterm_to_pterm env'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       consts (subst t_ x) =\n       consts t_ |\\<union>| ffUnion (consts |`| fmimage x (frees t_))", "show \"consts (subst t env) = consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst t env) =\n    consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))", "unfolding \\<open>t = _\\<close> \\<open>env = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    consts (sterm_to_pterm t') |\\<union>|\n    ffUnion\n     (consts |`|\n      fmimage (fmmap sterm_to_pterm env') (frees (sterm_to_pterm t')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    consts t' |\\<union>|\n    ffUnion ((consts \\<circ> sterm_to_pterm) |`| fmimage env' (frees t'))", "apply (subst comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    consts t' |\\<union>|\n    ffUnion\n     ((\\<lambda>x. consts (sterm_to_pterm x)) |`| fmimage env' (frees t'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (sterm_to_pterm t') (fmmap sterm_to_pterm env')) =\n    consts t' |\\<union>| ffUnion (consts |`| fmimage env' (frees t'))", "apply (subst subst_sterm_to_pterm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (sterm_to_pterm (subst t' env')) =\n    consts t' |\\<union>| ffUnion (consts |`| fmimage env' (frees t'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst t' env') =\n    consts t' |\\<union>| ffUnion (consts |`| fmimage env' (frees t'))", "apply (rule subst_consts')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts (subst t env) =\n  consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       \\<forall>x.\n          consts (subst a x) =\n          consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n   t_\n\ngoal (1 subgoal):\n 1. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "qed (rule abs_pred_trivI0)"], ["", "end"], ["", "end"], ["", "lemma no_abs_abs[simp]: \"\\<not> no_abs (Pabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> no_abs (Pabs cs)", "by (subst no_abs.simps) (auto simp: term_cases_def)"], ["", "lemma sterm_to_pterm:\n  assumes \"no_abs t\"\n  shows \"sterm_to_pterm t = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm t = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. sterm_to_pterm t = convert_term t", "proof induction"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name. sterm_to_pterm (free name) = convert_term (free name)\n 2. \\<And>name. sterm_to_pterm (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (free name)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>name. sterm_to_pterm (free name) = convert_term (free name)\n 2. \\<And>name. sterm_to_pterm (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (free name) = convert_term (free name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (free name) = free name", "apply (simp add: free_sterm_def free_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sterm_to_pterm (free name) = convert_term (free name)\n\ngoal (2 subgoals):\n 1. \\<And>name. sterm_to_pterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name. sterm_to_pterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (const name)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>name. sterm_to_pterm (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (const name) = convert_term (const name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sterm_to_pterm (const name) = const name", "apply (simp add: const_sterm_def const_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sterm_to_pterm (const name) = convert_term (const name)\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1\n  sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1; sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1\n  sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1\n  sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n\ngoal (1 subgoal):\n 1. sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n    convert_term (app t\\<^sub>1 t\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sterm_to_pterm t\\<^sub>1 = convert_term t\\<^sub>1;\n     sterm_to_pterm t\\<^sub>2 = convert_term t\\<^sub>2; no_abs t\\<^sub>1;\n     no_abs t\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n                      app (convert_term t\\<^sub>1) (convert_term t\\<^sub>2)", "apply (simp add: app_sterm_def app_pterm_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sterm_to_pterm (app t\\<^sub>1 t\\<^sub>2) =\n  convert_term (app t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation Pabs_single (\"\\<Lambda>\\<^sub>p _. _\" [0, 50] 50) where\n\"Pabs_single x rhs \\<equiv> Pabs {| (Free x, rhs) |}\""], ["", "lemma closed_except_simps:\n  \"closed_except (Pvar x) S \\<longleftrightarrow> x |\\<in>| S\"\n  \"closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S \\<longleftrightarrow> closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S\"\n  \"closed_except (Pabs cs) S \\<longleftrightarrow> fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\"\n  \"closed_except (Pconst name) S \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (closed_except (Pvar x) S = (x |\\<in>| S) &&&\n     closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S =\n     (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)) &&&\n    closed_except (Pabs cs) S =\n    fBall cs\n     (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat)) &&&\n    closed_except (Pconst name) S = True", "proof goal_cases"], ["proof (state)\ngoal (4 subgoals):\n 1. closed_except (Pvar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Pabs cs) S =\n    fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n 4. closed_except (Pconst name) S = True", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. closed_except (Pvar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Pabs cs) S =\n    fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n 4. closed_except (Pconst name) S = True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (Pabs cs) S =\n    fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_except (Pabs cs) S \\<Longrightarrow>\n    fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n 2. fBall cs\n     (\\<lambda>(pat, t).\n         closed_except t (S |\\<union>| frees pat)) \\<Longrightarrow>\n    closed_except (Pabs cs) S", "case 1"], ["proof (state)\nthis:\n  closed_except (Pabs cs) S\n\ngoal (2 subgoals):\n 1. closed_except (Pabs cs) S \\<Longrightarrow>\n    fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n 2. fBall cs\n     (\\<lambda>(pat, t).\n         closed_except t (S |\\<union>| frees pat)) \\<Longrightarrow>\n    closed_except (Pabs cs) S", "then"], ["proof (chain)\npicking this:\n  closed_except (Pabs cs) S", "show ?case"], ["proof (prove)\nusing this:\n  closed_except (Pabs cs) S\n\ngoal (1 subgoal):\n 1. fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))", "apply (auto simp: ffUnion_alt_def closed_except_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>ffUnion\n                 (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n                   map_prod id frees) |`|\n                  cs) |\\<subseteq>|\n                S;\n        (a, b) |\\<in>| cs; x |\\<in>| frees b; x |\\<notin>| frees a\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply (drule ffUnion_least_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) |\\<in>| cs; x |\\<in>| frees b; x |\\<notin>| frees a;\n        fBall\n         (((\\<lambda>(pv, tv). tv |-| frees pv) \\<circ>\n           map_prod id frees) |`|\n          cs)\n         (\\<lambda>X. X |\\<subseteq>| S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) |\\<in>| cs; x |\\<in>| frees b; x |\\<notin>| frees a;\n        fBall cs\n         (\\<lambda>x.\n             (case map_prod id frees x of\n              (pv, tv) \\<Rightarrow> tv |-| frees pv) |\\<subseteq>|\n             S)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| S", "by (smt case_prod_conv fBall_alt_def fminus_iff fset_rev_mp id_apply map_prod_simp)"], ["proof (state)\nthis:\n  fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n\ngoal (1 subgoal):\n 1. fBall cs\n     (\\<lambda>(pat, t).\n         closed_except t (S |\\<union>| frees pat)) \\<Longrightarrow>\n    closed_except (Pabs cs) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fBall cs\n     (\\<lambda>(pat, t).\n         closed_except t (S |\\<union>| frees pat)) \\<Longrightarrow>\n    closed_except (Pabs cs) S", "case 2"], ["proof (state)\nthis:\n  fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n\ngoal (1 subgoal):\n 1. fBall cs\n     (\\<lambda>(pat, t).\n         closed_except t (S |\\<union>| frees pat)) \\<Longrightarrow>\n    closed_except (Pabs cs) S", "then"], ["proof (chain)\npicking this:\n  fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))", "show ?case"], ["proof (prove)\nusing this:\n  fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n\ngoal (1 subgoal):\n 1. closed_except (Pabs cs) S", "by (fastforce simp: ffUnion_alt_def closed_except_def)"], ["proof (state)\nthis:\n  closed_except (Pabs cs) S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_except (Pabs cs) S =\n  fBall cs (\\<lambda>(pat, t). closed_except t (S |\\<union>| frees pat))\n\ngoal (3 subgoals):\n 1. closed_except (Pvar x) S = (x |\\<in>| S)\n 2. closed_except (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) S =\n    (closed_except t\\<^sub>1 S \\<and> closed_except t\\<^sub>2 S)\n 3. closed_except (Pconst name) S = True", "qed (auto simp: ffUnion_alt_def closed_except_def)"], ["", "instantiation pterm :: pre_strong_term  begin"], ["", "function (sequential) wellformed_pterm :: \"pterm \\<Rightarrow> bool\" where\n\"wellformed_pterm (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<longleftrightarrow> wellformed_pterm t\\<^sub>1 \\<and> wellformed_pterm t\\<^sub>2\" |\n\"wellformed_pterm (Pabs cs) \\<longleftrightarrow> fBall cs (\\<lambda>(pat, t). linear pat \\<and> wellformed_pterm t) \\<and> is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||}\" |\n\"wellformed_pterm _ \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>t\\<^sub>1 t\\<^sub>2.\n                   x = t\\<^sub>1 $\\<^sub>p t\\<^sub>2 \\<Longrightarrow> P;\n        \\<And>cs. x = Pabs cs \\<Longrightarrow> P;\n        \\<And>v. x = Pconst v \\<Longrightarrow> P;\n        \\<And>v. x = Pvar v \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 t\\<^sub>1' t\\<^sub>2'.\n       t\\<^sub>1 $\\<^sub>p t\\<^sub>2 =\n       t\\<^sub>1' $\\<^sub>p t\\<^sub>2' \\<Longrightarrow>\n       (wellformed_pterm_sumC t\\<^sub>1 \\<and>\n        wellformed_pterm_sumC t\\<^sub>2) =\n       (wellformed_pterm_sumC t\\<^sub>1' \\<and>\n        wellformed_pterm_sumC t\\<^sub>2')\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 cs.\n       t\\<^sub>1 $\\<^sub>p t\\<^sub>2 = Pabs cs \\<Longrightarrow>\n       (wellformed_pterm_sumC t\\<^sub>1 \\<and>\n        wellformed_pterm_sumC t\\<^sub>2) =\n       (fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> wellformed_pterm_sumC t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||})\n 4. \\<And>t\\<^sub>1 t\\<^sub>2 v.\n       t\\<^sub>1 $\\<^sub>p t\\<^sub>2 = Pconst v \\<Longrightarrow>\n       (wellformed_pterm_sumC t\\<^sub>1 \\<and>\n        wellformed_pterm_sumC t\\<^sub>2) =\n       True\n 5. \\<And>t\\<^sub>1 t\\<^sub>2 v.\n       t\\<^sub>1 $\\<^sub>p t\\<^sub>2 = Pvar v \\<Longrightarrow>\n       (wellformed_pterm_sumC t\\<^sub>1 \\<and>\n        wellformed_pterm_sumC t\\<^sub>2) =\n       True\n 6. \\<And>cs csa.\n       Pabs cs = Pabs csa \\<Longrightarrow>\n       (fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> wellformed_pterm_sumC t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||}) =\n       (fBall csa\n         (\\<lambda>(pat, t).\n             linear pat \\<and> wellformed_pterm_sumC t) \\<and>\n        is_fmap csa \\<and> pattern_compatibles csa \\<and> csa \\<noteq> {||})\n 7. \\<And>cs v.\n       Pabs cs = Pconst v \\<Longrightarrow>\n       (fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> wellformed_pterm_sumC t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||}) =\n       True\n 8. \\<And>cs v.\n       Pabs cs = Pvar v \\<Longrightarrow>\n       (fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> wellformed_pterm_sumC t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||}) =\n       True\n 9. \\<And>v va. Pconst v = Pconst va \\<Longrightarrow> True = True\n 10. \\<And>v va. Pconst v = Pvar va \\<Longrightarrow> True = True\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All wellformed_pterm_dom", "proof (relation \"measure size\", goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf (measure size)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>1, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>2, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size\n 4. \\<And>cs x xa y.\n       \\<lbrakk>x |\\<in>| cs; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (y, Pabs cs) \\<in> measure size", "case 4"], ["proof (state)\nthis:\n  x_ |\\<in>| cs_\n  (xa_, y_) = x_\n\ngoal (4 subgoals):\n 1. wf (measure size)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>1, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>2, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size\n 4. \\<And>cs x xa y.\n       \\<lbrakk>x |\\<in>| cs; (xa, y) = x\\<rbrakk>\n       \\<Longrightarrow> (y, Pabs cs) \\<in> measure size", "then"], ["proof (chain)\npicking this:\n  x_ |\\<in>| cs_\n  (xa_, y_) = x_", "show ?case"], ["proof (prove)\nusing this:\n  x_ |\\<in>| cs_\n  (xa_, y_) = x_\n\ngoal (1 subgoal):\n 1. (y_, Pabs cs_) \\<in> measure size", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xa_, y_) |\\<in>| cs_; x_ = (xa_, y_)\\<rbrakk>\n    \\<Longrightarrow> size y_\n                      < Suc (\\<Sum>x\\<in>map_prod (\\<lambda>x. x)\n    (\\<lambda>pterm. (pterm, size pterm)) `\n   fset cs_.\n                               Suc (size_prod (\\<lambda>_. 0) snd x))", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xa_, y_) |\\<in>| cs_; x_ = (xa_, y_)\\<rbrakk>\n    \\<Longrightarrow> size y_\n                      < Suc (\\<Sum>x\\<in>map_prod (\\<lambda>x. x)\n    (\\<lambda>pterm. (pterm, size pterm)) `\n   fset cs_.\n                               Suc (size_prod (\\<lambda>_. 0) snd x))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y cs x.\n       \\<lbrakk>finite cs; (xa, y) \\<in> cs; x = (xa, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         < Suc (\\<Sum>x\n\\<in>map_prod (\\<lambda>x. x) (\\<lambda>pterm. (pterm, size pterm)) ` cs.\n                                  Suc (size_prod (\\<lambda>_. 0) snd x))", "apply (rule le_imp_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y cs x.\n       \\<lbrakk>finite cs; (xa, y) \\<in> cs; x = (xa, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         \\<le> (\\<Sum>x\n\\<in>map_prod (\\<lambda>x. x) (\\<lambda>pterm. (pterm, size pterm)) ` cs.\n                                  Suc (size_prod (\\<lambda>_. 0) snd x))", "apply (rule sum_nat_le_single[where y = \"(a, (b, size b))\" for a b])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa y cs x.\n       \\<lbrakk>finite cs; (xa, y) \\<in> cs; x = (xa, y)\\<rbrakk>\n       \\<Longrightarrow> (?a223 xa y cs x, ?b223 xa y cs x,\n                          size (?b223 xa y cs x))\n                         \\<in> map_prod (\\<lambda>x. x)\n                                (\\<lambda>pterm. (pterm, size pterm)) `\n                               cs\n 2. \\<And>xa y cs x.\n       \\<lbrakk>finite cs; (xa, y) \\<in> cs; x = (xa, y)\\<rbrakk>\n       \\<Longrightarrow> size y\n                         \\<le> Suc (size_prod (\\<lambda>_. 0) snd\n                                     (?a223 xa y cs x, ?b223 xa y cs x,\nsize (?b223 xa y cs x)))\n 3. \\<And>xa y cs x.\n       \\<lbrakk>finite cs; (xa, y) \\<in> cs; x = (xa, y)\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (map_prod (\\<lambda>x. x)\n                            (\\<lambda>pterm. (pterm, size pterm)) `\n                           cs)", "by auto"], ["proof (state)\nthis:\n  (y_, Pabs cs_) \\<in> measure size\n\ngoal (3 subgoals):\n 1. wf (measure size)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>1, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size\n 3. \\<And>t\\<^sub>1 t\\<^sub>2.\n       (t\\<^sub>2, t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<in> measure size", "qed auto"], ["", "primrec all_frees_pterm :: \"pterm \\<Rightarrow> name fset\" where\n\"all_frees_pterm (Pvar x) = {|x|}\" |\n\"all_frees_pterm (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) = all_frees_pterm t\\<^sub>1 |\\<union>| all_frees_pterm t\\<^sub>2\" |\n\"all_frees_pterm (Pabs cs) = ffUnion ((\\<lambda>(P, T). P |\\<union>| T) |`| map_prod frees all_frees_pterm |`| cs)\" |\n\"all_frees_pterm (Pconst _) = {||}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pterm, pre_strong_term_class)", "by standard (auto simp: const_pterm_def free_pterm_def app_pterm_def)"], ["", "end"], ["", "lemma sterm_to_pterm_all_frees[simp]: \"all_frees (sterm_to_pterm t) = all_frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees (sterm_to_pterm t) = all_frees t", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. all_frees (sterm_to_pterm (Sconst x)) = all_frees (Sconst x)\n 2. \\<And>x. all_frees (sterm_to_pterm (Svar x)) = all_frees (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> all_frees (sterm_to_pterm xaa) =\n                             all_frees xaa) \\<Longrightarrow>\n       all_frees (sterm_to_pterm (Sabs x)) = all_frees (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>all_frees (sterm_to_pterm t1) = all_frees t1;\n        all_frees (sterm_to_pterm t2) = all_frees t2\\<rbrakk>\n       \\<Longrightarrow> all_frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         all_frees (t1 $\\<^sub>s t2)", "case (Sabs cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> set cs; ?xaa \\<in> Basic_BNFs.snds ?xa\\<rbrakk>\n  \\<Longrightarrow> all_frees (sterm_to_pterm ?xaa) = all_frees ?xaa\n\ngoal (4 subgoals):\n 1. \\<And>x. all_frees (sterm_to_pterm (Sconst x)) = all_frees (Sconst x)\n 2. \\<And>x. all_frees (sterm_to_pterm (Svar x)) = all_frees (Svar x)\n 3. \\<And>x.\n       (\\<And>xa xaa.\n           \\<lbrakk>xa \\<in> set x; xaa \\<in> Basic_BNFs.snds xa\\<rbrakk>\n           \\<Longrightarrow> all_frees (sterm_to_pterm xaa) =\n                             all_frees xaa) \\<Longrightarrow>\n       all_frees (sterm_to_pterm (Sabs x)) = all_frees (Sabs x)\n 4. \\<And>t1 t2.\n       \\<lbrakk>all_frees (sterm_to_pterm t1) = all_frees t1;\n        all_frees (sterm_to_pterm t2) = all_frees t2\\<rbrakk>\n       \\<Longrightarrow> all_frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         all_frees (t1 $\\<^sub>s t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_frees (sterm_to_pterm (Sabs cs)) = all_frees (Sabs cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffUnion\n     (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n       (map_prod frees all_frees \\<circ> map_prod id sterm_to_pterm)) |`|\n      fset_of_list cs) =\n    ffUnion\n     (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n       map_prod frees all_frees) |`|\n      fset_of_list cs)", "apply (rule arg_cong[where f = ffUnion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n     (map_prod frees all_frees \\<circ> map_prod id sterm_to_pterm)) |`|\n    fset_of_list cs =\n    ((\\<lambda>(x, y). x |\\<union>| y) \\<circ> map_prod frees all_frees) |`|\n    fset_of_list cs", "apply (rule fimage_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n        (map_prod frees all_frees \\<circ> map_prod id sterm_to_pterm))\n        x =\n       ((\\<lambda>(x, y). x |\\<union>| y) \\<circ> map_prod frees all_frees)\n        x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       frees a |\\<union>| all_frees (sterm_to_pterm b) =\n       frees a |\\<union>| all_frees b", "apply (subst Sabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       ?xa6 a b \\<in> set cs\n 2. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       b \\<in> Basic_BNFs.snds (?xa6 a b)\n 3. \\<And>a b.\n       (a, b) |\\<in>| fset_of_list cs \\<Longrightarrow>\n       frees a |\\<union>| all_frees b = frees a |\\<union>| all_frees b", "by (auto simp: fset_of_list_elem snds.simps)"], ["proof (state)\nthis:\n  all_frees (sterm_to_pterm (Sabs cs)) = all_frees (Sabs cs)\n\ngoal (3 subgoals):\n 1. \\<And>x. all_frees (sterm_to_pterm (Sconst x)) = all_frees (Sconst x)\n 2. \\<And>x. all_frees (sterm_to_pterm (Svar x)) = all_frees (Svar x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>all_frees (sterm_to_pterm t1) = all_frees t1;\n        all_frees (sterm_to_pterm t2) = all_frees t2\\<rbrakk>\n       \\<Longrightarrow> all_frees (sterm_to_pterm (t1 $\\<^sub>s t2)) =\n                         all_frees (t1 $\\<^sub>s t2)", "qed auto"], ["", "instance pterm :: strong_term"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pterm, strong_term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case (1 t)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "obtain t' where \"t = sterm_to_pterm t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t = sterm_to_pterm t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis sterm_to_pterm_total)"], ["proof (state)\nthis:\n  t = sterm_to_pterm t'\n\ngoal (2 subgoals):\n 1. \\<And>t. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t", "apply (rule abs_pred_trivI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| all_frees t", "unfolding \\<open>t = _\\<close> sterm_to_pterm_all_frees sterm_to_pterm_frees"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t' |\\<subseteq>| all_frees t'", "by (rule frees_all_frees)"], ["proof (state)\nthis:\n  abs_pred (\\<lambda>t. frees t |\\<subseteq>| all_frees t) t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "case (2 t)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            pre_strong_term_class.wellformed t \\<longrightarrow>\n            (\\<forall>env.\n                wellformed_env env \\<longrightarrow>\n                pre_strong_term_class.wellformed (subst t env)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>t.\n         pre_strong_term_class.wellformed t \\<longrightarrow>\n         (\\<forall>env.\n             wellformed_env env \\<longrightarrow>\n             pre_strong_term_class.wellformed (subst t env)))\n     t", "unfolding abs_pred_pterm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cs.\n       t = Pabs cs \\<longrightarrow>\n       (\\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed\n                (subst t env))) \\<longrightarrow>\n       pre_strong_term_class.wellformed t \\<longrightarrow>\n       (\\<forall>env.\n           wellformed_env env \\<longrightarrow>\n           pre_strong_term_class.wellformed (subst t env))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        pre_strong_term_class.wellformed t; wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (subst t env)", "apply (simp add: case_prod_twice, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> fBall cs\n                          (\\<lambda>x.\n                              case x of\n                              (pat, rhs) \\<Rightarrow>\n                                linear pat \\<and>\n                                pre_strong_term_class.wellformed\n                                 (subst rhs (fmdrop_fset (frees pat) env)))\n 2. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> is_fmap\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env))) |`|\n                           cs)\n 3. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> fpairwise\n                          (\\<lambda>x y.\n                              (case x of\n                               (pat, rhs) \\<Rightarrow>\n                                 \\<lambda>(lhs\\<^sub>2, uu_).\n                                    pattern_compatible pat lhs\\<^sub>2)\n                               (case y of\n                                (pat, rhs) \\<Rightarrow>\n                                  (pat,\n                                   subst rhs\n                                    (fmdrop_fset (frees pat) env))))\n                          cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Pabs cs_;\n     \\<forall>pat t.\n        (pat, t) |\\<in>| cs_ \\<longrightarrow>\n        pre_strong_term_class.wellformed t \\<longrightarrow>\n        (\\<forall>env.\n            wellformed_env env \\<longrightarrow>\n            pre_strong_term_class.wellformed (subst t env));\n     fBall cs_\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n     is_fmap cs_ \\<and> pattern_compatibles cs_ \\<and> cs_ \\<noteq> {||};\n     wellformed_env env_\\<rbrakk>\n    \\<Longrightarrow> fBall cs_\n                       (\\<lambda>x.\n                           case x of\n                           (pat, rhs) \\<Rightarrow>\n                             linear pat \\<and>\n                             pre_strong_term_class.wellformed\n                              (subst rhs (fmdrop_fset (frees pat) env_)))", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> is_fmap\n                          ((\\<lambda>(pat, rhs).\n                               (pat,\n                                subst rhs\n                                 (fmdrop_fset (frees pat) env))) |`|\n                           cs)\n 2. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> fpairwise\n                          (\\<lambda>x y.\n                              (case x of\n                               (pat, rhs) \\<Rightarrow>\n                                 \\<lambda>(lhs\\<^sub>2, uu_).\n                                    pattern_compatible pat lhs\\<^sub>2)\n                               (case y of\n                                (pat, rhs) \\<Rightarrow>\n                                  (pat,\n                                   subst rhs\n                                    (fmdrop_fset (frees pat) env))))\n                          cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Pabs cs_;\n     \\<forall>pat t.\n        (pat, t) |\\<in>| cs_ \\<longrightarrow>\n        pre_strong_term_class.wellformed t \\<longrightarrow>\n        (\\<forall>env.\n            wellformed_env env \\<longrightarrow>\n            pre_strong_term_class.wellformed (subst t env));\n     fBall cs_\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n     is_fmap cs_ \\<and> pattern_compatibles cs_ \\<and> cs_ \\<noteq> {||};\n     wellformed_env env_\\<rbrakk>\n    \\<Longrightarrow> is_fmap\n                       ((\\<lambda>(pat, rhs).\n                            (pat,\n                             subst rhs (fmdrop_fset (frees pat) env_))) |`|\n                        cs_)", "by (auto intro: is_fmap_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs env.\n       \\<lbrakk>t = Pabs cs;\n        \\<forall>pat t.\n           (pat, t) |\\<in>| cs \\<longrightarrow>\n           pre_strong_term_class.wellformed t \\<longrightarrow>\n           (\\<forall>env.\n               wellformed_env env \\<longrightarrow>\n               pre_strong_term_class.wellformed (subst t env));\n        fBall cs\n         (\\<lambda>(pat, t).\n             linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n        is_fmap cs \\<and> pattern_compatibles cs \\<and> cs \\<noteq> {||};\n        wellformed_env env\\<rbrakk>\n       \\<Longrightarrow> fpairwise\n                          (\\<lambda>x y.\n                              (case x of\n                               (pat, rhs) \\<Rightarrow>\n                                 \\<lambda>(lhs\\<^sub>2, uu_).\n                                    pattern_compatible pat lhs\\<^sub>2)\n                               (case y of\n                                (pat, rhs) \\<Rightarrow>\n                                  (pat,\n                                   subst rhs\n                                    (fmdrop_fset (frees pat) env))))\n                          cs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Pabs cs_;\n     \\<forall>pat t.\n        (pat, t) |\\<in>| cs_ \\<longrightarrow>\n        pre_strong_term_class.wellformed t \\<longrightarrow>\n        (\\<forall>env.\n            wellformed_env env \\<longrightarrow>\n            pre_strong_term_class.wellformed (subst t env));\n     fBall cs_\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n     is_fmap cs_ \\<and> pattern_compatibles cs_ \\<and> cs_ \\<noteq> {||};\n     wellformed_env env_\\<rbrakk>\n    \\<Longrightarrow> fpairwise\n                       (\\<lambda>x y.\n                           (case x of\n                            (pat, rhs) \\<Rightarrow>\n                              \\<lambda>(lhs\\<^sub>2, uu_).\n                                 pattern_compatible pat lhs\\<^sub>2)\n                            (case y of\n                             (pat, rhs) \\<Rightarrow>\n                               (pat,\n                                subst rhs (fmdrop_fset (frees pat) env_))))\n                       cs_", "unfolding fpairwise_image fpairwise_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t = Pabs cs_;\n     \\<forall>pat t.\n        (pat, t) |\\<in>| cs_ \\<longrightarrow>\n        pre_strong_term_class.wellformed t \\<longrightarrow>\n        (\\<forall>env.\n            wellformed_env env \\<longrightarrow>\n            pre_strong_term_class.wellformed (subst t env));\n     fBall cs_\n      (\\<lambda>(pat, t).\n          linear pat \\<and> pre_strong_term_class.wellformed t) \\<and>\n     is_fmap cs_ \\<and>\n     fBall cs_\n      (\\<lambda>m.\n          fBall cs_\n           (case m of\n            (lhs\\<^sub>1, uu_) \\<Rightarrow>\n              \\<lambda>(lhs\\<^sub>2, uu_).\n                 pattern_compatible lhs\\<^sub>1 lhs\\<^sub>2)) \\<and>\n     cs_ \\<noteq> {||};\n     wellformed_env env_\\<rbrakk>\n    \\<Longrightarrow> fBall cs_\n                       (\\<lambda>m.\n                           fBall cs_\n                            (\\<lambda>y.\n                                (case m of\n                                 (pat, rhs) \\<Rightarrow>\n                                   \\<lambda>(lhs\\<^sub>2, uu_).\npattern_compatible pat lhs\\<^sub>2)\n                                 (case y of\n                                  (pat, rhs) \\<Rightarrow>\n                                    (pat,\n                                     subst rhs\n(fmdrop_fset (frees pat) env_)))))", "by (auto elim!: fBallE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>t.\n       pre_strong_term_class.wellformed t \\<longrightarrow>\n       (\\<forall>env.\n           wellformed_env env \\<longrightarrow>\n           pre_strong_term_class.wellformed (subst t env)))\n   t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wellformed_PabsI:\n  assumes \"is_fmap cs\" \"pattern_compatibles cs\" \"cs \\<noteq> {||}\"\n  assumes \"\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> linear pat\"\n  assumes \"\\<And>pat t. (pat, t) |\\<in>| cs \\<Longrightarrow> wellformed t\"\n  shows \"wellformed (Pabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Pabs cs)", "using assms"], ["proof (prove)\nusing this:\n  is_fmap cs\n  pattern_compatibles cs\n  cs \\<noteq> {||}\n  (?pat, ?t) |\\<in>| cs \\<Longrightarrow> linear ?pat\n  (?pat, ?t) |\\<in>| cs \\<Longrightarrow>\n  pre_strong_term_class.wellformed ?t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (Pabs cs)", "by auto"], ["", "corollary subst_closed_pabs:\n  assumes \"(pat, rhs) |\\<in>| cs\" \"closed (Pabs cs)\"\n  shows \"subst rhs (fmdrop_fset (frees pat) env) = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst rhs (fmdrop_fset (frees pat) env) = rhs", "using assms"], ["proof (prove)\nusing this:\n  (pat, rhs) |\\<in>| cs\n  closed (Pabs cs)\n\ngoal (1 subgoal):\n 1. subst rhs (fmdrop_fset (frees pat) env) = rhs", "by (subst subst_closed_except_id) (auto simp: fdisjnt_alt_def closed_except_simps)"], ["", "lemma (in constants) shadows_consts_pterm_simps[simp]:\n  \"shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) \\<longleftrightarrow> shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2\"\n  \"shadows_consts (Pvar name) \\<longleftrightarrow> name |\\<in>| all_consts\"\n  \"shadows_consts (Pabs cs) \\<longleftrightarrow> fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\"\n  \"shadows_consts (Pconst name) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n     (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2) &&&\n     shadows_consts (Pvar name) = (name |\\<in>| all_consts)) &&&\n    shadows_consts (Pabs cs) =\n    fBex cs\n     (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t) &&&\n    shadows_consts (Pconst name) = False", "proof goal_cases"], ["proof (state)\ngoal (4 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Pvar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Pabs cs) =\n    fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\n 4. shadows_consts (Pconst name) = False", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Pvar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Pabs cs) =\n    fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\n 4. shadows_consts (Pconst name) = False", "(* FIXME duplicated from Sterm *)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Pvar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Pabs cs) =\n    fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\n 4. shadows_consts (Pconst name) = False", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. shadows_consts (Pabs cs) =\n    fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)", "unfolding shadows_consts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> fdisjnt all_consts (all_frees (Pabs cs))) =\n    fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> fdisjnt all_consts (all_frees (Pabs cs)) \\<Longrightarrow>\n    fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t))\n 2. fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t)) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Pabs cs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> fdisjnt all_consts (all_frees (Pabs cs)) \\<Longrightarrow>\n    fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t))", "by (force simp: ffUnion_alt_def fset_of_list_elem fdisjnt_alt_def elim!: ballE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t)) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Pabs cs))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex cs\n     (\\<lambda>(pat, t).\n         \\<not> fdisjnt all_consts (all_frees pat) \\<or>\n         \\<not> fdisjnt all_consts (all_frees t)) \\<Longrightarrow>\n    \\<not> fdisjnt all_consts (all_frees (Pabs cs))", "apply (auto simp: fset_of_list_elem fdisjnt_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>(a, b) |\\<in>| cs;\n        all_consts |\\<inter>|\n        ffUnion\n         (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n           map_prod frees all_frees) |`|\n          cs) =\n        {||};\n        x |\\<in>| all_consts; x |\\<in>| frees a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b x.\n       \\<lbrakk>(a, b) |\\<in>| cs;\n        all_consts |\\<inter>|\n        ffUnion\n         (((\\<lambda>(x, y). x |\\<union>| y) \\<circ>\n           map_prod frees all_frees) |`|\n          cs) =\n        {||};\n        x |\\<in>| all_consts; x |\\<in>| all_frees b\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp: fset_eq_empty_iff ffUnion_alt_def fset_of_list_elem elim!: allE fBallE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  shadows_consts (Pabs cs) =\n  fBex cs (\\<lambda>(pat, t). shadows_consts pat \\<or> shadows_consts t)\n\ngoal (3 subgoals):\n 1. shadows_consts (t\\<^sub>1 $\\<^sub>p t\\<^sub>2) =\n    (shadows_consts t\\<^sub>1 \\<or> shadows_consts t\\<^sub>2)\n 2. shadows_consts (Pvar name) = (name |\\<in>| all_consts)\n 3. shadows_consts (Pconst name) = False", "qed (auto simp: shadows_consts_def fdisjnt_alt_def)"], ["", "end"]]}