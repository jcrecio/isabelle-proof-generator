{"file_name": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen/Compiler/Composition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CakeML_Codegen", "problem_names": ["lemma (in prules) prewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"closed t\"\n  shows \"closed t'\"", "lemma (in prules) compile_correct_rt:\n  assumes \"Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow>* u'\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>* sterm_to_pterm u'\"", "lemma srewrite_stepD:\n  assumes \"srewrite_step rs name t\"\n  shows \"(name, t) \\<in> set rs\"", "lemma (in srules) srewrite_wellformed:\n  assumes \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t'\" \"wellformed t\"\n  shows \"wellformed t'\"", "lemma (in srules) srewrite_wellformed_rt:\n  assumes \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* t'\" \"wellformed t\"\n  shows \"wellformed t'\"", "lemma vno_abs_value_to_sterm: \"no_abs (value_to_sterm v) \\<longleftrightarrow> vno_abs v\" for v", "lemma rules_transform_iter0:\n  assumes \"irules C_info rs\"\n  shows \"irules C_info ((transform_irule_set ^^ n) rs)\"", "lemma (in irules) rules_transform_iter: \"irules C_info ((transform_irule_set ^^ n) rs)\"", "lemma transform_irule_set_n_heads: \"fst |`| ((transform_irule_set ^^ n) rs) = fst |`| rs\"", "lemma transform_irule_set_iter_heads: \"fst |`| transform_irule_set_iter rs = fst |`| rs\"", "lemma (in irules) finished_alt_def: \"finished rs \\<longleftrightarrow> max_arity rs = 0\"", "lemma (in irules) transform_finished_id: \"finished rs \\<Longrightarrow> transform_irule_set rs = rs\"", "lemma (in irules) max_arity_decr: \"max_arity (transform_irule_set rs) = max_arity rs - 1\"", "lemma max_arity_decr'0:\n  assumes \"irules C rs\"\n  shows \"max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\"", "lemma (in irules) max_arity_decr': \"max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\"", "lemma (in irules) transform_finished: \"finished (transform_irule_set_iter rs)\"", "lemma fmdom_global_css: \"fmdom global_css = fst |`| fset_of_list rs\"", "lemma as_vrules_fst[simp]: \"fst |`| fset_of_list as_vrules = fst |`| fset_of_list rs\"", "lemma as_vrules_fst'[simp]: \"map fst as_vrules = map fst rs\"", "lemma list_all_as_vrulesI:\n  assumes \"list_all (\\<lambda>(_, t). P fmempty (clauses t)) rs\"\n  assumes \"R (fst |`| fset_of_list rs)\"\n  shows \"list_all (\\<lambda>(_, t). value_pred.pred P Q R t) as_vrules\"", "lemma srules_as_vrules: \"vrules C_info as_vrules\"", "lemma rs'_rs_eq: \"srules_as_vrules.rs' = rs\"", "lemma veval_correct:\n  fixes v\n  assumes \"as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\" \"wellformed t\" \"closed t\"\n  shows \"rs, fmempty \\<turnstile>\\<^sub>s t \\<down> value_to_sterm v\"", "lemma as_vrules_mk_rec_env: \"fmap_of_list as_vrules = mk_rec_env global_css fmempty\"", "lemma vrecabs_global_css_refl:\n  assumes \"name |\\<in>| fmdom global_css\"\n  shows \"\\<turnstile>\\<^sub>v Vrecabs global_css name fmempty \\<approx> Vrecabs global_css name fmempty\"", "lemma as_vrules_refl_rs: \"fmrel_on_fset (fst |`| fset_of_list as_vrules) vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\"", "lemma as_vrules_refl_C: \"fmrel_on_fset C vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\"", "lemma veval'_correct'':\n  fixes t v\n  assumes \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\"\n  assumes \"wellformed t\"\n  assumes \"\\<not> shadows_consts t\"\n  assumes \"welldefined t\"\n  assumes \"closed t\"\n  assumes \"vno_abs v\"\n  shows \"as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\"", "lemma compile_sem_env:\n  \"evaluate_dec ck mn env state (compile_group all_consts rs) (state, Rval (as_sem_env env))\"", "lemma compile_sem_env':\n  \"fun_evaluate_decs mn state env [(compile_group all_consts rs)] = (state, Rval (as_sem_env env))\"", "lemma compile_prog[unfolded combine_dec_result.simps, simplified]:\n  \"evaluate_prog ck env state (compile rs) (state, combine_dec_result (as_sem_env env) (Rval \\<lparr> sem_env.v = nsEmpty, sem_env.c = nsEmpty \\<rparr>))\"", "lemma compile_prog'[unfolded combine_dec_result.simps, simplified]:\n  \"fun_evaluate_prog state env (compile rs) = (state, combine_dec_result (as_sem_env env) (Rval \\<lparr> sem_env.v = nsEmpty, sem_env.c = nsEmpty \\<rparr>))\"", "lemma cupcake_sem_env: \"is_cupcake_all_env sem_env\"", "lemma sem_env_refl: \"fmrel related_v (fmap_of_list as_vrules) (fmap_of_ns (sem_env.v sem_env))\"", "lemma semantic_correctness':\n  assumes \"cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  obtains v where \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\" \"related_v v ml_v\"", "lemma cake_to_value_abs_free:\n  assumes \"is_cupcake_value v\" \"cake_no_abs v\"\n  shows \"vno_abs (cake_to_value v)\"", "lemma cake_to_value_related:\n  assumes \"cake_no_abs v\" \"is_cupcake_value v\"\n  shows \"related_v (cake_to_value v) v\"", "lemma related_v_abs_free_uniq:\n  assumes \"related_v v\\<^sub>1 ml_v\" \"related_v v\\<^sub>2 ml_v\" \"cake_no_abs ml_v\"\n  shows \"v\\<^sub>1 = v\\<^sub>2\"", "lemma cupcake_sem_env_preserve:\n  assumes \"cupcake_evaluate_single sem_env (mk_con S t) (Rval ml_v)\" \"wellformed t\"\n  shows \"is_cupcake_value ml_v\"", "lemma semantic_correctness'':\n  assumes \"cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  assumes \"cake_no_abs ml_v\"\n  shows \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v\"", "lemma fmdom_compiled: \"fmdom (fmap_of_list compiled) = heads_of rs\"", "lemma cake_semantic_correctness:\n  assumes \"cupcake_evaluate_single cake_sem_env (sterm_to_cake t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  assumes \"cake_no_abs ml_v\"\n  shows \"fmap_of_list compiled \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v\"", "theorem compiled_correct:\n  \\<comment> \\<open>If CakeML evaluation of a term succeeds ...\\<close>\n  assumes \"\\<exists>k. Evaluate_Single.evaluate cake_sem_env (s \\<lparr> clock := k \\<rparr>) (term_to_cake t) = (s', Rval ml_v)\"\n  \\<comment> \\<open>... producing a constructor term without closures ...\\<close>\n  assumes \"cake_no_abs ml_v\"\n  \\<comment> \\<open>... and some syntactic properties of the involved terms hold ...\\<close>\n  assumes \"closed t\" \"\\<not> shadows_consts t\" \"welldefined t\" \"wellformed t\"\n  \\<comment> \\<open>... then this evaluation can be reproduced in the term-rewriting semantics\\<close>\n  shows \"rs \\<turnstile> t \\<longrightarrow>* cake_to_term ml_v\""], "translations": [["", "lemma (in prules) prewrite_closed:\n  assumes \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\" \"closed t\"\n  shows \"closed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_term_class.closed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t'\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. pre_term_class.closed t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>(name, rhs) |\\<in>| rs;\n        pre_term_class.closed (Pconst name)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "case (step name rhs)"], ["proof (state)\nthis:\n  (name, rhs) |\\<in>| rs\n  pre_term_class.closed (Pconst name)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>(name, rhs) |\\<in>| rs;\n        pre_term_class.closed (Pconst name)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed rhs\n 2. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "thus ?case"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| rs\n  pre_term_class.closed (Pconst name)\n\ngoal (1 subgoal):\n 1. pre_term_class.closed rhs", "using all_rules"], ["proof (prove)\nusing this:\n  (name, rhs) |\\<in>| rs\n  pre_term_class.closed (Pconst name)\n  fBall rs prule\n\ngoal (1 subgoal):\n 1. pre_term_class.closed rhs", "by force"], ["proof (state)\nthis:\n  pre_term_class.closed rhs\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "case (beta c)"], ["proof (state)\nthis:\n  c |\\<in>| cs_\n  c \\<turnstile> t_ \\<rightarrow> t'_\n  pre_term_class.closed (Pabs cs_ $\\<^sub>p t_)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "obtain pat rhs where \"c = (pat, rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs.\n        c = (pat, rhs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c) auto"], ["proof (state)\nthis:\n  c = (pat, rhs)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "with beta"], ["proof (chain)\npicking this:\n  c |\\<in>| cs_\n  c \\<turnstile> t_ \\<rightarrow> t'_\n  pre_term_class.closed (Pabs cs_ $\\<^sub>p t_)\n  c = (pat, rhs)", "have \"closed_except rhs (frees pat)\""], ["proof (prove)\nusing this:\n  c |\\<in>| cs_\n  c \\<turnstile> t_ \\<rightarrow> t'_\n  pre_term_class.closed (Pabs cs_ $\\<^sub>p t_)\n  c = (pat, rhs)\n\ngoal (1 subgoal):\n 1. closed_except rhs (frees pat)", "by (auto simp: closed_except_simps)"], ["proof (state)\nthis:\n  closed_except rhs (frees pat)\n\ngoal (3 subgoals):\n 1. \\<And>c cs t t'.\n       \\<lbrakk>c |\\<in>| cs; c \\<turnstile> t \\<rightarrow> t';\n        pre_term_class.closed (Pabs cs $\\<^sub>p t)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_term_class.closed t'_", "apply (rule rewrite_step_closed[OF _ beta(2)[unfolded \\<open>c = _\\<close>]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees rhs |\\<subseteq>| frees pat\n 2. pre_term_class.closed t_", "using \\<open>closed_except rhs (frees pat)\\<close> beta"], ["proof (prove)\nusing this:\n  closed_except rhs (frees pat)\n  c |\\<in>| cs_\n  c \\<turnstile> t_ \\<rightarrow> t'_\n  pre_term_class.closed (Pabs cs_ $\\<^sub>p t_)\n\ngoal (2 subgoals):\n 1. frees rhs |\\<subseteq>| frees pat\n 2. pre_term_class.closed t_", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  pre_term_class.closed t'_\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p t \\<longrightarrow> t';\n        pre_term_class.closed t \\<Longrightarrow> pre_term_class.closed t';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t' $\\<^sub>p u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>p u \\<longrightarrow> u';\n        pre_term_class.closed u \\<Longrightarrow> pre_term_class.closed u';\n        pre_term_class.closed (t $\\<^sub>p u)\\<rbrakk>\n       \\<Longrightarrow> pre_term_class.closed (t $\\<^sub>p u')", "qed (auto simp: closed_except_def)"], ["", "corollary (in prules) prewrite_rt_closed:\n  assumes \"rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* t'\" \"closed t\"\n  shows \"closed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_term_class.closed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* t'\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. pre_term_class.closed t'", "by induction (auto intro: prewrite_closed)"], ["", "corollary (in irules) compile_correct_rt:\n  assumes \"Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* t'\" \"finished rs\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "using assms"], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* t'\n  finished rs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'", "proof (induction rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow>\n    rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t\n 2. \\<And>y z.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow>* y;\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p y \\<longrightarrow>\n        z;\n        finished rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* y;\n        finished rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* z", "case step"], ["proof (state)\nthis:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* y_\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p y_ \\<longrightarrow> z_\n  finished rs \\<Longrightarrow>\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* y_\n  finished rs\n\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow>\n    rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t\n 2. \\<And>y z.\n       \\<lbrakk>Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p\n                t \\<longrightarrow>* y;\n        Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p y \\<longrightarrow>\n        z;\n        finished rs \\<Longrightarrow>\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* y;\n        finished rs\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* z", "thus ?case"], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p t \\<longrightarrow>* y_\n  Rewriting_Pterm.compile rs \\<turnstile>\\<^sub>p y_ \\<longrightarrow> z_\n  finished rs \\<Longrightarrow>\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* y_\n  finished rs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* z_", "by (meson compile_correct rtranclp.simps)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* z_\n\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow>\n    rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t", "qed auto"], ["", "subsection \\<open>Reflexive-transitive closure of @{thm [source=true] prules.compile_correct}.\\<close>"], ["", "lemma (in prules) compile_correct_rt:\n  assumes \"Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow>* u'\"\n  shows \"rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>* sterm_to_pterm u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm u'", "using assms"], ["proof (prove)\nusing this:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow>* u'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm u'", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm u\n 2. \\<And>y z.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow>* y;\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s y \\<longrightarrow>\n        z;\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n        sterm_to_pterm y\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm u \\<longrightarrow>*\n                         sterm_to_pterm z", "case step"], ["proof (state)\nthis:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow>* y_\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s y_ \\<longrightarrow> z_\n  rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n  sterm_to_pterm y_\n\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm u\n 2. \\<And>y z.\n       \\<lbrakk>Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s\n                u \\<longrightarrow>* y;\n        Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s y \\<longrightarrow>\n        z;\n        rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n        sterm_to_pterm y\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>p\n                         sterm_to_pterm u \\<longrightarrow>*\n                         sterm_to_pterm z", "thus ?case"], ["proof (prove)\nusing this:\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s u \\<longrightarrow>* y_\n  Rewriting_Sterm.compile rs \\<turnstile>\\<^sub>s y_ \\<longrightarrow> z_\n  rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n  sterm_to_pterm y_\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm z_", "by (meson compile_correct rtranclp.simps)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n  sterm_to_pterm z_\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>p sterm_to_pterm u \\<longrightarrow>*\n    sterm_to_pterm u", "qed auto"], ["", "lemma srewrite_stepD:\n  assumes \"srewrite_step rs name t\"\n  shows \"(name, t) \\<in> set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name, t) \\<in> set rs", "using assms"], ["proof (prove)\nusing this:\n  srewrite_step rs name t\n\ngoal (1 subgoal):\n 1. (name, t) \\<in> set rs", "by induct auto"], ["", "lemma (in srules) srewrite_wellformed:\n  assumes \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t'\" \"wellformed t\"\n  shows \"wellformed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t'\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t'", "proof induction"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step rs name rhs;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "case (step name rhs)"], ["proof (state)\nthis:\n  srewrite_step rs name rhs\n  pre_strong_term_class.wellformed (Sconst name)\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step rs name rhs;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "hence \"(name, rhs) \\<in> set rs\""], ["proof (prove)\nusing this:\n  srewrite_step rs name rhs\n  pre_strong_term_class.wellformed (Sconst name)\n\ngoal (1 subgoal):\n 1. (name, rhs) \\<in> set rs", "by (auto dest: srewrite_stepD)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n\ngoal (4 subgoals):\n 1. \\<And>name rhs.\n       \\<lbrakk>srewrite_step rs name rhs;\n        pre_strong_term_class.wellformed (Sconst name)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed rhs\n 2. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 3. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 4. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "thus ?case"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using all_rules"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (3 subgoals):\n 1. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "case (beta cs t t')"], ["proof (state)\nthis:\n  rewrite_first cs t t'\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\n\ngoal (3 subgoals):\n 1. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "then"], ["proof (chain)\npicking this:\n  rewrite_first cs t t'\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)", "obtain pat rhs env where \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\" \"t' = subst rhs env\""], ["proof (prove)\nusing this:\n  rewrite_first cs t t'\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs env.\n        \\<lbrakk>(pat, rhs) \\<in> set cs; match pat t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim rewrite_firstE)"], ["proof (state)\nthis:\n  (pat, rhs) \\<in> set cs\n  match pat t = Some env\n  t' = subst rhs env\n\ngoal (3 subgoals):\n 1. \\<And>cs t t'.\n       \\<lbrakk>rewrite_first cs t t';\n        pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed t'\n 2. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 3. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t'", "unfolding \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed (subst rhs env)", "proof (rule subst_wellformed)"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed rhs\n 2. wellformed_env env", "show \"wellformed rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "using \\<open>(pat, rhs) \\<in> set cs\\<close> beta"], ["proof (prove)\nusing this:\n  (pat, rhs) \\<in> set cs\n  rewrite_first cs t t'\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed rhs", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed rhs\n\ngoal (1 subgoal):\n 1. wellformed_env env", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wellformed_env env", "show \"wellformed_env env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_env env", "using \\<open>match pat t = Some env\\<close> beta"], ["proof (prove)\nusing this:\n  match pat t = Some env\n  rewrite_first cs t t'\n  pre_strong_term_class.wellformed (Sabs cs $\\<^sub>s t)\n\ngoal (1 subgoal):\n 1. wellformed_env env", "by (auto intro: wellformed.match)"], ["proof (state)\nthis:\n  wellformed_env env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t'\n\ngoal (2 subgoals):\n 1. \\<And>t t' u.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s t \\<longrightarrow> t';\n        pre_strong_term_class.wellformed t \\<Longrightarrow>\n        pre_strong_term_class.wellformed t';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t' $\\<^sub>s u)\n 2. \\<And>u u' t.\n       \\<lbrakk>rs \\<turnstile>\\<^sub>s u \\<longrightarrow> u';\n        pre_strong_term_class.wellformed u \\<Longrightarrow>\n        pre_strong_term_class.wellformed u';\n        pre_strong_term_class.wellformed (t $\\<^sub>s u)\\<rbrakk>\n       \\<Longrightarrow> pre_strong_term_class.wellformed (t $\\<^sub>s u')", "qed auto"], ["", "lemma (in srules) srewrite_wellformed_rt:\n  assumes \"rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* t'\" \"wellformed t\"\n  shows \"wellformed t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t'", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>s t \\<longrightarrow>* t'\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t'", "by induction (auto intro: srewrite_wellformed)"], ["", "lemma vno_abs_value_to_sterm: \"no_abs (value_to_sterm v) \\<longleftrightarrow> vno_abs v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs (value_to_sterm v) = vno_abs v", "by (induction v) (auto simp: no_abs.list_comb list_all_iff)"], ["", "subsection \\<open>Reflexive-transitive closure of @{thm [source=true] rules.compile_correct}.\\<close>"], ["", "corollary (in rules) compile_correct_rt:\n  assumes \"compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* u'\" \"closed u\"\n  shows \"rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'", "using assms"], ["proof (prove)\nusing this:\n  local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* u'\n  pre_term_class.closed u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u\n 2. \\<And>y z.\n       \\<lbrakk>local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* y;\n        local.compile \\<turnstile>\\<^sub>n y \\<longrightarrow> z;\n        pre_term_class.closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n        nterm_to_term' y;\n        pre_term_class.closed u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n                         nterm_to_term' z", "case (step u' u'')"], ["proof (state)\nthis:\n  local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* u'\n  local.compile \\<turnstile>\\<^sub>n u' \\<longrightarrow> u''\n  pre_term_class.closed u \\<Longrightarrow>\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\n  pre_term_class.closed u\n\ngoal (2 subgoals):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u\n 2. \\<And>y z.\n       \\<lbrakk>local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* y;\n        local.compile \\<turnstile>\\<^sub>n y \\<longrightarrow> z;\n        pre_term_class.closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n        nterm_to_term' y;\n        pre_term_class.closed u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n                         nterm_to_term' z", "hence \"rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\""], ["proof (prove)\nusing this:\n  local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* u'\n  local.compile \\<turnstile>\\<^sub>n u' \\<longrightarrow> u''\n  pre_term_class.closed u \\<Longrightarrow>\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\n  pre_term_class.closed u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'", "by auto"], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\n\ngoal (2 subgoals):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u\n 2. \\<And>y z.\n       \\<lbrakk>local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* y;\n        local.compile \\<turnstile>\\<^sub>n y \\<longrightarrow> z;\n        pre_term_class.closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n        nterm_to_term' y;\n        pre_term_class.closed u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n                         nterm_to_term' z", "also"], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\n\ngoal (2 subgoals):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u\n 2. \\<And>y z.\n       \\<lbrakk>local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* y;\n        local.compile \\<turnstile>\\<^sub>n y \\<longrightarrow> z;\n        pre_term_class.closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n        nterm_to_term' y;\n        pre_term_class.closed u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n                         nterm_to_term' z", "have \"rs \\<turnstile> nterm_to_term' u' \\<longrightarrow> nterm_to_term' u''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u' \\<longrightarrow> nterm_to_term' u''", "using step"], ["proof (prove)\nusing this:\n  local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* u'\n  local.compile \\<turnstile>\\<^sub>n u' \\<longrightarrow> u''\n  pre_term_class.closed u \\<Longrightarrow>\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u'\n  pre_term_class.closed u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u' \\<longrightarrow> nterm_to_term' u''", "by (auto dest: rewrite_rt_closed intro!: compile_correct simp: closed_except_def)"], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' u' \\<longrightarrow> nterm_to_term' u''\n\ngoal (2 subgoals):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u\n 2. \\<And>y z.\n       \\<lbrakk>local.compile \\<turnstile>\\<^sub>n u \\<longrightarrow>* y;\n        local.compile \\<turnstile>\\<^sub>n y \\<longrightarrow> z;\n        pre_term_class.closed u \\<Longrightarrow>\n        rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n        nterm_to_term' y;\n        pre_term_class.closed u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile> nterm_to_term' u \\<longrightarrow>*\n                         nterm_to_term' z", "finally"], ["proof (chain)\npicking this:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u''", "show ?case"], ["proof (prove)\nusing this:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u''\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u''", "."], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u''\n\ngoal (1 subgoal):\n 1. pre_term_class.closed u \\<Longrightarrow>\n    rs \\<turnstile> nterm_to_term' u \\<longrightarrow>* nterm_to_term' u", "qed auto"], ["", "subsection \\<open>Reflexive-transitive closure of @{thm [source=true] irules.transform_correct}.\\<close>"], ["", "corollary (in irules) transform_correct_rt:\n  assumes \"transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u''\" \"t \\<approx>\\<^sub>p u\" \"closed t\"\n  obtains t'' where \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t''\" \"t'' \\<approx>\\<^sub>p u''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u''\n  t \\<approx>\\<^sub>p u\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction arbitrary: thesis t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        transform_irule_set rs \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t''.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t'';\n                        t'' \\<approx>\\<^sub>p y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t''.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n            t'' \\<approx>\\<^sub>p z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step u' u'')"], ["proof (state)\nthis:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\n  transform_irule_set rs \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\n  \\<lbrakk>\\<And>t''.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t4 \\<longrightarrow>* t'';\n               t'' \\<approx>\\<^sub>p u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   ?t4 \\<approx>\\<^sub>p u; pre_term_class.closed ?t4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t''4;\n   ?t''4 \\<approx>\\<^sub>p u''\\<rbrakk>\n  \\<Longrightarrow> thesis\n  t \\<approx>\\<^sub>p u\n  pre_term_class.closed t\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        transform_irule_set rs \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t''.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t'';\n                        t'' \\<approx>\\<^sub>p y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t''.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n            t'' \\<approx>\\<^sub>p z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t' where \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\" \"t' \\<approx>\\<^sub>p u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step"], ["proof (prove)\nusing this:\n  transform_irule_set rs \\<turnstile>\\<^sub>i u \\<longrightarrow>* u'\n  transform_irule_set rs \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\n  \\<lbrakk>\\<And>t''.\n              \\<lbrakk>rs \\<turnstile>\\<^sub>i ?t4 \\<longrightarrow>* t'';\n               t'' \\<approx>\\<^sub>p u'\\<rbrakk>\n              \\<Longrightarrow> ?thesis4;\n   ?t4 \\<approx>\\<^sub>p u; pre_term_class.closed ?t4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n  \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t''4;\n   ?t''4 \\<approx>\\<^sub>p u''\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  t \\<approx>\\<^sub>p u\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>p u'\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        transform_irule_set rs \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t''.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t'';\n                        t'' \\<approx>\\<^sub>p y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t''.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n            t'' \\<approx>\\<^sub>p z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t'' where \"rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t''\" \"t'' \\<approx>\\<^sub>p u''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule transform_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i ?u6 \\<longrightarrow> ?u'6\n 2. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?t6 \\<approx>\\<^sub>p ?u6\n 3. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed ?t6\n 4. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i ?t6 \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p ?u'6\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule \\<open>transform_irule_set rs \\<turnstile>\\<^sub>i u' \\<longrightarrow> u''\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?t6 \\<approx>\\<^sub>p u'\n 2. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed ?t6\n 3. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i ?t6 \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule \\<open>t' \\<approx>\\<^sub>p u'\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed t'\n 2. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule irewrite_rt_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    rs \\<turnstile>\\<^sub>i ?t11 \\<longrightarrow>* t'\n 2. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed ?t11\n 3. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule \\<open>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>t''.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'';\n         t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed t\n 2. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule \\<open>closed t\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u''\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t'a;\n        t'a \\<approx>\\<^sub>p u''\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t' \\<longrightarrow>* t''\n  t'' \\<approx>\\<^sub>p u''\n\ngoal (2 subgoals):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>y z thesis t.\n       \\<lbrakk>transform_irule_set rs \\<turnstile>\\<^sub>i\n                u \\<longrightarrow>* y;\n        transform_irule_set rs \\<turnstile>\\<^sub>i y \\<longrightarrow> z;\n        \\<And>thesis t.\n           \\<lbrakk>\\<And>t''.\n                       \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                                t'';\n                        t'' \\<approx>\\<^sub>p y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t''.\n           \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n            t'' \\<approx>\\<^sub>p z\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule step.prems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?t''4\n 2. ?t''4 \\<approx>\\<^sub>p u''", "apply (rule rtranclp_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* ?y7\n 2. rs \\<turnstile>\\<^sub>i ?y7 \\<longrightarrow>* ?t''4\n 3. ?t''4 \\<approx>\\<^sub>p u''", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>thesis t.\n       \\<lbrakk>\\<And>t''.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n                            t'';\n                    t'' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        t \\<approx>\\<^sub>p u; pre_term_class.closed t\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["", "corollary (in irules) transform_correct_rt_no_abs:\n  assumes \"transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\" \"closed t\" \"no_abs u\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "have \"t \\<approx>\\<^sub>p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>p t", "by (rule prelated_refl)"], ["proof (state)\nthis:\n  t \\<approx>\\<^sub>p t\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "obtain t' where \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\" \"t' \\<approx>\\<^sub>p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule transform_correct_rt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    transform_irule_set rs \\<turnstile>\\<^sub>i ?u6 \\<longrightarrow>* ?u''6\n 2. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?t6 \\<approx>\\<^sub>p ?u6\n 3. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed ?t6\n 4. \\<And>t''.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i ?t6 \\<longrightarrow>* t'';\n        t'' \\<approx>\\<^sub>p ?u''6\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule assms)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?t6 \\<approx>\\<^sub>p t\n 2. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed ?t6\n 3. \\<And>t''.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i ?t6 \\<longrightarrow>* t'';\n        t'' \\<approx>\\<^sub>p u\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule \\<open>t \\<approx>\\<^sub>p t\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>t'.\n        \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_term_class.closed t\n 2. \\<And>t''.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n        t'' \\<approx>\\<^sub>p u\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t''.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t';\n                    t' \\<approx>\\<^sub>p u\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'';\n        t'' \\<approx>\\<^sub>p u\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "thus ?thesis"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>p u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "using assms"], ["proof (prove)\nusing this:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>p u\n  transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n  pre_term_class.closed t\n  no_abs u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "by (metis prelated_no_abs_right)"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary transform_correct_rt_n_no_abs0:\n  assumes \"irules C rs\" \"(transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\" \"closed t\" \"no_abs u\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "using assms(1,2)"], ["proof (prove)\nusing this:\n  irules C rs\n  (transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "proof (induction n arbitrary: rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       \\<lbrakk>irules C rs;\n        (transform_irule_set ^^ 0) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n 2. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   \\<lbrakk>irules C rs;\n                    (transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i\n                    t \\<longrightarrow>* u\\<rbrakk>\n                   \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                                     t \\<longrightarrow>* u;\n        irules C rs;\n        (transform_irule_set ^^ Suc n) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>irules C ?rs;\n   (transform_irule_set ^^ n) ?rs \\<turnstile>\\<^sub>i t \\<longrightarrow>*\n   u\\<rbrakk>\n  \\<Longrightarrow> ?rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n  irules C rs\n  (transform_irule_set ^^ Suc n) rs \\<turnstile>\\<^sub>i\n  t \\<longrightarrow>* u\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       \\<lbrakk>irules C rs;\n        (transform_irule_set ^^ 0) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n 2. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   \\<lbrakk>irules C rs;\n                    (transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i\n                    t \\<longrightarrow>* u\\<rbrakk>\n                   \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                                     t \\<longrightarrow>* u;\n        irules C rs;\n        (transform_irule_set ^^ Suc n) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "interpret irules C rs"], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C rs", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       \\<lbrakk>irules C rs;\n        (transform_irule_set ^^ 0) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n 2. \\<And>n rs.\n       \\<lbrakk>\\<And>rs.\n                   \\<lbrakk>irules C rs;\n                    (transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i\n                    t \\<longrightarrow>* u\\<rbrakk>\n                   \\<Longrightarrow> rs \\<turnstile>\\<^sub>i\n                                     t \\<longrightarrow>* u;\n        irules C rs;\n        (transform_irule_set ^^ Suc n) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "apply (rule transform_correct_rt_no_abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. transform_irule_set rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n 2. pre_term_class.closed t\n 3. no_abs u", "apply (rule Suc.IH)"], ["proof (prove)\ngoal (4 subgoals):\n 1. irules C (transform_irule_set rs)\n 2. (transform_irule_set ^^ n) (transform_irule_set rs) \\<turnstile>\\<^sub>i\n    t \\<longrightarrow>* u\n 3. pre_term_class.closed t\n 4. no_abs u", "apply (rule rules_transform)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (transform_irule_set ^^ n) (transform_irule_set rs) \\<turnstile>\\<^sub>i\n    t \\<longrightarrow>* u\n 2. pre_term_class.closed t\n 3. no_abs u", "using Suc(3)"], ["proof (prove)\nusing this:\n  (transform_irule_set ^^ Suc n) rs \\<turnstile>\\<^sub>i\n  t \\<longrightarrow>* u\n\ngoal (3 subgoals):\n 1. (transform_irule_set ^^ n) (transform_irule_set rs) \\<turnstile>\\<^sub>i\n    t \\<longrightarrow>* u\n 2. pre_term_class.closed t\n 3. no_abs u", "apply (simp add: funpow_swap1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_term_class.closed t\n 2. no_abs u", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       \\<lbrakk>irules C rs;\n        (transform_irule_set ^^ 0) rs \\<turnstile>\\<^sub>i\n        t \\<longrightarrow>* u\\<rbrakk>\n       \\<Longrightarrow> rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "qed auto"], ["", "corollary (in irules) transform_correct_rt_n_no_abs:\n  assumes \"(transform_irule_set ^^ n) rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\" \"closed t\" \"no_abs u\"\n  shows \"rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\\<^sub>i t \\<longrightarrow>* u", "by (rule transform_correct_rt_n_no_abs0) (rule irules_axioms assms)+"], ["", "hide_fact transform_correct_rt_n_no_abs0"], ["", "subsection \\<open>Iterated application of @{const transform_irule_set}.\\<close>"], ["", "definition max_arity :: \"irule_set \\<Rightarrow> nat\" where\n\"max_arity rs = fMax ((arity \\<circ> snd) |`| rs)\""], ["", "lemma rules_transform_iter0:\n  assumes \"irules C_info rs\"\n  shows \"irules C_info ((transform_irule_set ^^ n) rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info ((transform_irule_set ^^ n) rs)", "using assms"], ["proof (prove)\nusing this:\n  irules C_info rs\n\ngoal (1 subgoal):\n 1. irules C_info ((transform_irule_set ^^ n) rs)", "by (induction n) (auto intro: irules.rules_transform del: irulesI)"], ["", "lemma (in irules) rules_transform_iter: \"irules C_info ((transform_irule_set ^^ n) rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info ((transform_irule_set ^^ n) rs)", "by (rule rules_transform_iter0) (rule irules_axioms)"], ["", "lemma transform_irule_set_n_heads: \"fst |`| ((transform_irule_set ^^ n) rs) = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| (transform_irule_set ^^ n) rs = fst |`| rs", "by (induction n) (auto simp: transform_irule_set_heads)"], ["", "hide_fact rules_transform_iter0"], ["", "definition transform_irule_set_iter :: \"irule_set \\<Rightarrow> irule_set\" where\n\"transform_irule_set_iter rs = (transform_irule_set ^^ max_arity rs) rs\""], ["", "lemma transform_irule_set_iter_heads: \"fst |`| transform_irule_set_iter rs = fst |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| transform_irule_set_iter rs = fst |`| rs", "unfolding transform_irule_set_iter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| (transform_irule_set ^^ max_arity rs) rs = fst |`| rs", "by (simp add: transform_irule_set_n_heads)"], ["", "lemma (in irules) finished_alt_def: \"finished rs \\<longleftrightarrow> max_arity rs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finished rs = (max_arity rs = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0\n 2. max_arity rs = 0 \\<Longrightarrow> finished rs", "assume \"max_arity rs = 0\""], ["proof (state)\nthis:\n  max_arity rs = 0\n\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0\n 2. max_arity rs = 0 \\<Longrightarrow> finished rs", "hence \"\\<not> fBex ((arity \\<circ> snd) |`| rs) (\\<lambda>x. 0 < x)\""], ["proof (prove)\nusing this:\n  max_arity rs = 0\n\ngoal (1 subgoal):\n 1. \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)", "using nonempty"], ["proof (prove)\nusing this:\n  max_arity rs = 0\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)", "unfolding max_arity_def"], ["proof (prove)\nusing this:\n  fMax ((arity \\<circ> snd) |`| rs) = 0\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)", "by (metis fBex_fempty fmax_ex_gr not_less0)"], ["proof (state)\nthis:\n  \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)\n\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0\n 2. max_arity rs = 0 \\<Longrightarrow> finished rs", "thus \"finished rs\""], ["proof (prove)\nusing this:\n  \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)\n\ngoal (1 subgoal):\n 1. finished rs", "unfolding finished_def"], ["proof (prove)\nusing this:\n  \\<not> fBex ((arity \\<circ> snd) |`| rs) ((<) 0)\n\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(uu_, irs). arity irs = 0)", "by force"], ["proof (state)\nthis:\n  finished rs\n\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0", "assume \"finished rs\""], ["proof (state)\nthis:\n  finished rs\n\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0", "have \"fMax ((arity \\<circ> snd) |`| rs) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax ((arity \\<circ> snd) |`| rs) \\<le> 0", "proof (rule fMax_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)\n 2. (arity \\<circ> snd) |`| rs \\<noteq> {||}", "show \"fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)", "using \\<open>finished rs\\<close>"], ["proof (prove)\nusing this:\n  finished rs\n\ngoal (1 subgoal):\n 1. fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)", "unfolding finished_def"], ["proof (prove)\nusing this:\n  fBall rs (\\<lambda>(uu_, irs). arity irs = 0)\n\ngoal (1 subgoal):\n 1. fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)", "by force"], ["proof (state)\nthis:\n  fBall ((arity \\<circ> snd) |`| rs) (\\<lambda>x. x \\<le> 0)\n\ngoal (1 subgoal):\n 1. (arity \\<circ> snd) |`| rs \\<noteq> {||}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (arity \\<circ> snd) |`| rs \\<noteq> {||}", "show \"(arity \\<circ> snd) |`| rs \\<noteq> {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arity \\<circ> snd) |`| rs \\<noteq> {||}", "using nonempty"], ["proof (prove)\nusing this:\n  rs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. (arity \\<circ> snd) |`| rs \\<noteq> {||}", "by force"], ["proof (state)\nthis:\n  (arity \\<circ> snd) |`| rs \\<noteq> {||}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fMax ((arity \\<circ> snd) |`| rs) \\<le> 0\n\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow> max_arity rs = 0", "thus \"max_arity rs = 0\""], ["proof (prove)\nusing this:\n  fMax ((arity \\<circ> snd) |`| rs) \\<le> 0\n\ngoal (1 subgoal):\n 1. max_arity rs = 0", "unfolding max_arity_def"], ["proof (prove)\nusing this:\n  fMax ((arity \\<circ> snd) |`| rs) \\<le> 0\n\ngoal (1 subgoal):\n 1. fMax ((arity \\<circ> snd) |`| rs) = 0", "by simp"], ["proof (state)\nthis:\n  max_arity rs = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in irules) transform_finished_id: \"finished rs \\<Longrightarrow> transform_irule_set rs = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finished rs \\<Longrightarrow> transform_irule_set rs = rs", "unfolding transform_irule_set_def finished_def transform_irules_def map_prod_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall rs (\\<lambda>(uu_, irs). arity irs = 0) \\<Longrightarrow>\n    (\\<lambda>(x, y).\n        (x, if arity y = 0 then y\n            else (\\<lambda>(x, y). (x, Pabs y)) |`|\n                 fgroup_by\n                  (\\<lambda>(pats, rhs). (butlast pats, last pats, rhs))\n                  y)) |`|\n    rs =\n    rs", "by (rule fset_map_snd_id) (auto simp: fmember.rep_eq elim!: fBallE)"], ["", "lemma (in irules) max_arity_decr: \"max_arity (transform_irule_set rs) = max_arity rs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_arity (transform_irule_set rs) = max_arity rs - 1", "proof (cases \"finished rs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1\n 2. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "case True"], ["proof (state)\nthis:\n  finished rs\n\ngoal (2 subgoals):\n 1. finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1\n 2. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  finished rs\n\ngoal (1 subgoal):\n 1. max_arity (transform_irule_set rs) = max_arity rs - 1", "by (auto simp: transform_finished_id finished_alt_def)"], ["proof (state)\nthis:\n  max_arity (transform_irule_set rs) = max_arity rs - 1\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "case False"], ["proof (state)\nthis:\n  \\<not> finished rs\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "have \"(arity \\<circ> snd) |`| transform_irule_set rs = (\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arity \\<circ> snd) |`| transform_irule_set rs =\n    (\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs", "unfolding transform_irule_set_def fset.map_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (arity \\<circ> snd \\<circ> map_prod id transform_irules) |`| rs =\n    ((\\<lambda>x. x - 1) \\<circ> (arity \\<circ> snd)) |`| rs", "proof (rule fset.map_cong0, safe, unfold o_apply map_prod_simp id_apply snd_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> fset rs \\<Longrightarrow>\n       arity (transform_irules b) = arity b - 1", "fix name irs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> fset rs \\<Longrightarrow>\n       arity (transform_irules b) = arity b - 1", "assume \"(name, irs) \\<in> fset rs\""], ["proof (state)\nthis:\n  (name, irs) \\<in> fset rs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> fset rs \\<Longrightarrow>\n       arity (transform_irules b) = arity b - 1", "hence \"(name, irs) |\\<in>| rs\""], ["proof (prove)\nusing this:\n  (name, irs) \\<in> fset rs\n\ngoal (1 subgoal):\n 1. (name, irs) |\\<in>| rs", "by (simp add: fmember.rep_eq)"], ["proof (state)\nthis:\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> fset rs \\<Longrightarrow>\n       arity (transform_irules b) = arity b - 1", "hence \"arity_compatibles irs\" \"irs \\<noteq> {||}\""], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs &&& irs \\<noteq> {||}", "using nonempty inner"], ["proof (prove)\nusing this:\n  (name, irs) |\\<in>| rs\n  rs \\<noteq> {||}\n  fBall rs\n   (\\<lambda>(uu_, irs).\n       Rewriting_Nterm.arity_compatibles irs \\<and>\n       is_fmap irs \\<and>\n       patterns_compatibles irs \\<and>\n       irs \\<noteq> {||} \\<and>\n       fBall irs\n        (\\<lambda>(pats, rhs).\n            linears pats \\<and>\n            abs_ish pats rhs \\<and>\n            closed_except rhs (freess pats) \\<and>\n            fdisjnt (freess pats) all_consts \\<and>\n            pre_strong_term_class.wellformed rhs \\<and>\n            \\<not> shadows_consts rhs \\<and>\n            consts rhs |\\<subseteq>| all_consts))\n\ngoal (1 subgoal):\n 1. Rewriting_Nterm.arity_compatibles irs &&& irs \\<noteq> {||}", "by (blast dest: fpairwiseD)+"], ["proof (state)\nthis:\n  Rewriting_Nterm.arity_compatibles irs\n  irs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> fset rs \\<Longrightarrow>\n       arity (transform_irules b) = arity b - 1", "thus \"arity (transform_irules irs) = arity irs - 1\""], ["proof (prove)\nusing this:\n  Rewriting_Nterm.arity_compatibles irs\n  irs \\<noteq> {||}\n\ngoal (1 subgoal):\n 1. arity (transform_irules irs) = arity irs - 1", "by (simp add: arity_transform_irules)"], ["proof (state)\nthis:\n  arity (transform_irules irs) = arity irs - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (arity \\<circ> snd) |`| transform_irule_set rs =\n  (\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "hence \"max_arity (transform_irule_set rs) = fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs)\""], ["proof (prove)\nusing this:\n  (arity \\<circ> snd) |`| transform_irule_set rs =\n  (\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs\n\ngoal (1 subgoal):\n 1. max_arity (transform_irule_set rs) =\n    fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs)", "unfolding max_arity_def"], ["proof (prove)\nusing this:\n  (arity \\<circ> snd) |`| transform_irule_set rs =\n  (\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs\n\ngoal (1 subgoal):\n 1. fMax ((arity \\<circ> snd) |`| transform_irule_set rs) =\n    fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs)", "by simp"], ["proof (state)\nthis:\n  max_arity (transform_irule_set rs) =\n  fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs)\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "also"], ["proof (state)\nthis:\n  max_arity (transform_irule_set rs) =\n  fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs)\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "have \"\\<dots> = fMax ((arity \\<circ> snd) |`| rs) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs) =\n    fMax ((arity \\<circ> snd) |`| rs) - 1", "proof (rule fmax_decr)"], ["proof (state)\ngoal (1 subgoal):\n 1. fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)", "show \"fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)", "using False"], ["proof (prove)\nusing this:\n  \\<not> finished rs\n\ngoal (1 subgoal):\n 1. fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)", "unfolding finished_def"], ["proof (prove)\nusing this:\n  \\<not> fBall rs (\\<lambda>(uu_, irs). arity irs = 0)\n\ngoal (1 subgoal):\n 1. fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)", "by force"], ["proof (state)\nthis:\n  fBex ((arity \\<circ> snd) |`| rs) ((\\<le>) 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fMax ((\\<lambda>x. x - 1) |`| (arity \\<circ> snd) |`| rs) =\n  fMax ((arity \\<circ> snd) |`| rs) - 1\n\ngoal (1 subgoal):\n 1. \\<not> finished rs \\<Longrightarrow>\n    max_arity (transform_irule_set rs) = max_arity rs - 1", "finally"], ["proof (chain)\npicking this:\n  max_arity (transform_irule_set rs) = fMax ((arity \\<circ> snd) |`| rs) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  max_arity (transform_irule_set rs) = fMax ((arity \\<circ> snd) |`| rs) - 1\n\ngoal (1 subgoal):\n 1. max_arity (transform_irule_set rs) = max_arity rs - 1", "unfolding max_arity_def"], ["proof (prove)\nusing this:\n  fMax ((arity \\<circ> snd) |`| transform_irule_set rs) =\n  fMax ((arity \\<circ> snd) |`| rs) - 1\n\ngoal (1 subgoal):\n 1. fMax ((arity \\<circ> snd) |`| transform_irule_set rs) =\n    fMax ((arity \\<circ> snd) |`| rs) - 1", "by simp"], ["proof (state)\nthis:\n  max_arity (transform_irule_set rs) = max_arity rs - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_arity_decr'0:\n  assumes \"irules C rs\"\n  shows \"max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. max_arity ((transform_irule_set ^^ 0) rs) = max_arity rs - 0\n 2. \\<And>n.\n       max_arity ((transform_irule_set ^^ n) rs) =\n       max_arity rs - n \\<Longrightarrow>\n       max_arity ((transform_irule_set ^^ Suc n) rs) = max_arity rs - Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\n\ngoal (2 subgoals):\n 1. max_arity ((transform_irule_set ^^ 0) rs) = max_arity rs - 0\n 2. \\<And>n.\n       max_arity ((transform_irule_set ^^ n) rs) =\n       max_arity rs - n \\<Longrightarrow>\n       max_arity ((transform_irule_set ^^ Suc n) rs) = max_arity rs - Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_arity ((transform_irule_set ^^ Suc n) rs) = max_arity rs - Suc n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_arity (transform_irule_set ((transform_irule_set ^^ n) rs)) =\n    max_arity rs - Suc n", "apply (subst irules.max_arity_decr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. irules ?C_info ((transform_irule_set ^^ n) rs)\n 2. max_arity ((transform_irule_set ^^ n) rs) - 1 = max_arity rs - Suc n", "using Suc assms"], ["proof (prove)\nusing this:\n  max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\n  irules C rs\n\ngoal (2 subgoals):\n 1. irules ?C_info ((transform_irule_set ^^ n) rs)\n 2. max_arity ((transform_irule_set ^^ n) rs) - 1 = max_arity rs - Suc n", "by (auto intro: irules.rules_transform_iter del: irulesI)"], ["proof (state)\nthis:\n  max_arity ((transform_irule_set ^^ Suc n) rs) = max_arity rs - Suc n\n\ngoal (1 subgoal):\n 1. max_arity ((transform_irule_set ^^ 0) rs) = max_arity rs - 0", "qed auto"], ["", "lemma (in irules) max_arity_decr': \"max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_arity ((transform_irule_set ^^ n) rs) = max_arity rs - n", "by (rule max_arity_decr'0) (rule irules_axioms)"], ["", "hide_fact max_arity_decr'0"], ["", "lemma (in irules) transform_finished: \"finished (transform_irule_set_iter rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finished (transform_irule_set_iter rs)", "unfolding transform_irule_set_iter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finished ((transform_irule_set ^^ max_arity rs) rs)", "by (subst irules.finished_alt_def)\n   (auto simp: max_arity_decr' intro: rules_transform_iter del: Rewriting_Pterm_Elim.irulesI)"], ["", "text \\<open>Trick as described in \\<open>\\<section>7.1\\<close> in the locale manual.\\<close>"], ["", "locale irules' = irules"], ["", "sublocale irules' \\<subseteq> irules'_as_irules: irules C_info \"transform_irule_set_iter rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (transform_irule_set_iter rs)", "unfolding transform_irule_set_iter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info ((transform_irule_set ^^ max_arity rs) rs)", "by (rule rules_transform_iter)"], ["", "sublocale crules \\<subseteq> crules_as_irules': irules' C_info \"Rewriting_Pterm_Elim.compile rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irules' C_info (Rewriting_Pterm_Elim.compile rs)", "unfolding irules'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. irules C_info (Rewriting_Pterm_Elim.compile rs)", "by (fact compile_rules)"], ["", "sublocale irules' \\<subseteq> irules'_as_prules: prules C_info \"Rewriting_Pterm.compile (transform_irule_set_iter rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prules C_info (Rewriting_Pterm.compile (transform_irule_set_iter rs))", "by (rule irules'_as_irules.compile_rules) (rule transform_finished)"], ["", "subsection \\<open>Big-step semantics\\<close>"], ["", "context srules begin"], ["", "definition global_css :: \"(name, sclauses) fmap\" where\n\"global_css = fmap_of_list (map (map_prod id clauses) rs)\""], ["", "lemma fmdom_global_css: \"fmdom global_css = fst |`| fset_of_list rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom global_css = fst |`| fset_of_list rs", "unfolding global_css_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom (fmap_of_list (map (map_prod id clauses) rs)) =\n    fst |`| fset_of_list rs", "by simp"], ["", "definition as_vrules :: \"vrule list\" where\n\"as_vrules = map (\\<lambda>(name, _). (name, Vrecabs global_css name fmempty)) rs\""], ["", "lemma as_vrules_fst[simp]: \"fst |`| fset_of_list as_vrules = fst |`| fset_of_list rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`| fset_of_list as_vrules = fst |`| fset_of_list rs", "unfolding as_vrules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`|\n    fset_of_list\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    fst |`| fset_of_list rs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst \\<circ>\n     (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))) |`|\n    fset_of_list rs =\n    fst |`| fset_of_list rs", "apply (rule fset.map_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fset_of_list rs = fset_of_list rs\n 2. \\<And>z.\n       z \\<in> fset (fset_of_list rs) \\<Longrightarrow>\n       (fst \\<circ>\n        (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty)))\n        z =\n       fst z", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> fset (fset_of_list rs) \\<Longrightarrow>\n       (fst \\<circ>\n        (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty)))\n        z =\n       fst z", "by auto"], ["", "lemma as_vrules_fst'[simp]: \"map fst as_vrules = map fst rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst as_vrules = map fst rs", "unfolding as_vrules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    map fst rs", "by auto"], ["", "lemma list_all_as_vrulesI:\n  assumes \"list_all (\\<lambda>(_, t). P fmempty (clauses t)) rs\"\n  assumes \"R (fst |`| fset_of_list rs)\"\n  shows \"list_all (\\<lambda>(_, t). value_pred.pred P Q R t) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, t). value_pred.pred P Q R t) as_vrules", "proof (rule list_allI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "fix name rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "assume \"(name, rhs) \\<in> set as_vrules\""], ["proof (state)\nthis:\n  (name, rhs) \\<in> set as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "hence \"rhs = Vrecabs global_css name fmempty\""], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set as_vrules\n\ngoal (1 subgoal):\n 1. rhs = Vrecabs global_css name fmempty", "unfolding as_vrules_def"], ["proof (prove)\nusing this:\n  (name, rhs)\n  \\<in> set (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs)\n\ngoal (1 subgoal):\n 1. rhs = Vrecabs global_css name fmempty", "by auto"], ["proof (state)\nthis:\n  rhs = Vrecabs global_css name fmempty\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "moreover"], ["proof (state)\nthis:\n  rhs = Vrecabs global_css name fmempty\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "have \"fmpred (\\<lambda>_. P fmempty) global_css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P fmempty) global_css", "unfolding global_css_def list.pred_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P fmempty)\n     (fmap_of_list (map (map_prod id clauses) rs))", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). P fmempty (clauses t)) rs\n  R (fst |`| fset_of_list rs)\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P fmempty)\n     (fmap_of_list (map (map_prod id clauses) rs))", "by (auto simp: list_all_iff intro!: fmpred_of_list)"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. P fmempty) global_css\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "moreover"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. P fmempty) global_css\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "have \"name |\\<in>| fmdom global_css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom global_css", "unfolding global_css_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| fmdom (fmap_of_list (map (map_prod id clauses) rs))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs", "using \\<open>(name, rhs) \\<in> set as_vrules\\<close>"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set as_vrules\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs", "unfolding as_vrules_def"], ["proof (prove)\nusing this:\n  (name, rhs)\n  \\<in> set (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs)\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs", "including fset.lifting"], ["proof (prove)\nusing this:\n  (name, rhs)\n  \\<in> set (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs)\n\ngoal (1 subgoal):\n 1. name |\\<in>| fst |`| fset_of_list rs", "apply transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>name rhs rs.\n       (name, rhs)\n       \\<in> set (map (\\<lambda>(name, uu_).\n                          (name,\n                           Vrecabs (srules.global_css rs) name fmempty))\n                   rs) \\<Longrightarrow>\n       name \\<in> fst ` set rs", "by force"], ["proof (state)\nthis:\n  name |\\<in>| fmdom global_css\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "moreover"], ["proof (state)\nthis:\n  name |\\<in>| fmdom global_css\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "have \"R (fmdom global_css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (fmdom global_css)", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). P fmempty (clauses t)) rs\n  R (fst |`| fset_of_list rs)\n\ngoal (1 subgoal):\n 1. R (fmdom global_css)", "unfolding global_css_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). P fmempty (clauses t)) rs\n  R (fst |`| fset_of_list rs)\n\ngoal (1 subgoal):\n 1. R (fmdom (fmap_of_list (map (map_prod id clauses) rs)))", "by auto"], ["proof (state)\nthis:\n  R (fmdom global_css)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set as_vrules \\<Longrightarrow> value_pred.pred P Q R b", "ultimately"], ["proof (chain)\npicking this:\n  rhs = Vrecabs global_css name fmempty\n  fmpred (\\<lambda>_. P fmempty) global_css\n  name |\\<in>| fmdom global_css\n  R (fmdom global_css)", "show \"value_pred.pred P Q R rhs\""], ["proof (prove)\nusing this:\n  rhs = Vrecabs global_css name fmempty\n  fmpred (\\<lambda>_. P fmempty) global_css\n  name |\\<in>| fmdom global_css\n  R (fmdom global_css)\n\ngoal (1 subgoal):\n 1. value_pred.pred P Q R rhs", "by (simp add: value_pred.pred_alt_def)"], ["proof (state)\nthis:\n  value_pred.pred P Q R rhs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma srules_as_vrules: \"vrules C_info as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vrules C_info as_vrules", "proof (standard, unfold as_vrules_fst)"], ["proof (state)\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "have \"list_all (\\<lambda>(_, t). vwellformed t) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, t). vwellformed t) as_vrules", "unfolding vwellformed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         value_pred.pred (\\<lambda>_. wellformed_clauses) (\\<lambda>_. True)\n          (\\<lambda>_. True) t)\n     as_vrules", "apply (rule list_all_as_vrulesI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>(uu_, t). wellformed_clauses (clauses t)) rs\n 2. True", "apply (rule list.pred_mono_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all ?P3 rs\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; ?P3 z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, t) \\<Rightarrow>\n                           wellformed_clauses (clauses t)\n 3. True", "apply (rule all_rules)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; srule z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, t) \\<Rightarrow>\n                           wellformed_clauses (clauses t)\n 2. True", "apply (auto elim: clausesE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, t). vwellformed t) as_vrules\n\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, t). vwellformed t) as_vrules\n\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "have \"list_all (\\<lambda>(_, t). vclosed t) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, t). vclosed t) as_vrules", "unfolding vclosed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         value_pred.pred\n          (\\<lambda>\\<Gamma>.\n              list_all\n               (\\<lambda>(pat, t).\n                   closed_except t (fmdom \\<Gamma> |\\<union>| frees pat)))\n          (\\<lambda>_. True) (\\<lambda>_. True) t)\n     as_vrules", "apply (rule list_all_as_vrulesI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         list_all\n          (\\<lambda>(pat, t).\n              closed_except t (fmdom fmempty |\\<union>| frees pat))\n          (clauses t))\n     rs\n 2. True", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, t).\n         list_all (\\<lambda>(pat, t). closed_except t (frees pat))\n          (clauses t))\n     rs", "apply (rule list.pred_mono_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all ?P3 rs\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; ?P3 z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, t) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(pat, t). closed_except t (frees pat))\n                            (clauses t)", "apply (rule all_rules)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; srule z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, t) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(pat, t). closed_except t (frees pat))\n                            (clauses t)", "apply (auto elim: clausesE simp: Sterm.closed_except_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, t). vclosed t) as_vrules\n\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, t). vclosed t) as_vrules\n\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "have \"list_all (\\<lambda>(_, t). \\<not> is_Vconstr t) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, t). \\<not> is_Vconstr t) as_vrules", "unfolding as_vrules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, t). \\<not> is_Vconstr t)\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs)", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, t). \\<not> is_Vconstr t) as_vrules\n\ngoal (7 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all vrule as_vrules\n 4. distinct (map fst as_vrules)\n 5. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 6. vconstructor_value_rs as_vrules\n 7. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "ultimately"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>(uu_, t). vwellformed t) as_vrules\n  list_all (\\<lambda>(uu_, t). vclosed t) as_vrules\n  list_all (\\<lambda>(uu_, t). \\<not> is_Vconstr t) as_vrules", "show \"list_all vrule as_vrules\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). vwellformed t) as_vrules\n  list_all (\\<lambda>(uu_, t). vclosed t) as_vrules\n  list_all (\\<lambda>(uu_, t). \\<not> is_Vconstr t) as_vrules\n\ngoal (1 subgoal):\n 1. list_all vrule as_vrules", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, y)\\<in>set as_vrules. vwellformed y\n  \\<forall>(uu_, y)\\<in>set as_vrules. vclosed y\n  \\<forall>(uu_, t)\\<in>set as_vrules. \\<not> is_Vconstr t\n\ngoal (1 subgoal):\n 1. Ball (set as_vrules) vrule", "by fastforce"], ["proof (state)\nthis:\n  list_all vrule as_vrules\n\ngoal (6 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. distinct (map fst as_vrules)\n 4. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 5. vconstructor_value_rs as_vrules\n 6. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. distinct (map fst as_vrules)\n 4. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 5. vconstructor_value_rs as_vrules\n 6. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "show \"distinct (map fst as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst as_vrules)", "using distinct"], ["proof (prove)\nusing this:\n  distinct (map fst rs)\n\ngoal (1 subgoal):\n 1. distinct (map fst as_vrules)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst as_vrules)\n\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 4. vconstructor_value_rs as_vrules\n 5. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fdisjnt (fst |`| fset_of_list rs) C\n 2. distinct all_constructors\n 3. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 4. vconstructor_value_rs as_vrules\n 5. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "show \"fdisjnt (fst |`| fset_of_list rs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| fset_of_list rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| fset_of_list rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| fset_of_list rs) C", "by simp"], ["proof (state)\nthis:\n  fdisjnt (fst |`| fset_of_list rs) C\n\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 3. vconstructor_value_rs as_vrules\n 4. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct all_constructors\n 2. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n 3. vconstructor_value_rs as_vrules\n 4. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "show \"list_all (\\<lambda>(_, rhs). not_shadows_vconsts rhs) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules", "unfolding not_shadows_vconsts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         value_pred.pred\n          (\\<lambda>_.\n              list_all\n               (\\<lambda>(pat, t).\n                   fdisjnt all_consts (frees pat) \\<and>\n                   \\<not> shadows_consts t))\n          (\\<lambda>_. True) (\\<lambda>_. True) rhs)\n     as_vrules", "apply (rule list_all_as_vrulesI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         list_all\n          (\\<lambda>(pat, t).\n              fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n          (clauses rhs))\n     rs\n 2. True", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         list_all\n          (\\<lambda>(pat, t).\n              fdisjnt all_consts (frees pat) \\<and> \\<not> shadows_consts t)\n          (clauses rhs))\n     rs", "apply (rule list.pred_mono_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all ?P3 rs\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; ?P3 z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, rhs) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(pat, t).\n                                fdisjnt all_consts (frees pat) \\<and>\n                                \\<not> shadows_consts t)\n                            (clauses rhs)", "apply (rule not_shadows)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set rs;\n        case z of\n        (uu_, rhs) \\<Rightarrow> \\<not> shadows_consts rhs\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, rhs) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(pat, t).\n                                fdisjnt all_consts (frees pat) \\<and>\n                                \\<not> shadows_consts t)\n                            (clauses rhs)", "by (auto simp: list_all_iff list_ex_iff all_consts_def elim!: clausesE)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, y). not_shadows_vconsts y) as_vrules\n\ngoal (3 subgoals):\n 1. distinct all_constructors\n 2. vconstructor_value_rs as_vrules\n 3. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct all_constructors\n 2. vconstructor_value_rs as_vrules\n 3. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "show \"vconstructor_value_rs as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vconstructor_value_rs as_vrules", "unfolding vconstructor_value_rs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, y). vconstructor_value y) as_vrules \\<and>\n    fdisjnt (fset_of_list (map fst as_vrules)) C", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>(uu_, y). vconstructor_value y) as_vrules\n 2. fdisjnt (fset_of_list (map fst as_vrules)) C", "unfolding vconstructor_value_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(uu_, y).\n         value_pred.pred (\\<lambda>_ _. True)\n          (\\<lambda>name. name |\\<in>| C) (\\<lambda>_. True) y)\n     as_vrules\n 2. fdisjnt (fset_of_list (map fst as_vrules)) C", "apply (rule list_all_as_vrulesI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all (\\<lambda>(uu_, t). True) rs\n 2. True\n 3. fdisjnt (fset_of_list (map fst as_vrules)) C", "apply (simp add: list_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. True\n 2. fdisjnt (fset_of_list (map fst as_vrules)) C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list (map fst as_vrules)) C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| fset_of_list rs) C", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| fset_of_list rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt (fst |`| fset_of_list rs) C", "by simp"], ["proof (state)\nthis:\n  vconstructor_value_rs as_vrules\n\ngoal (2 subgoals):\n 1. distinct all_constructors\n 2. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct all_constructors\n 2. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "show \"list_all (\\<lambda>(_, rhs). vwelldefined rhs) as_vrules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules", "unfolding vwelldefined_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         value_pred.pred\n          (\\<lambda>_.\n              list_all\n               (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts))\n          (\\<lambda>name. name |\\<in>| C)\n          (\\<lambda>dom. dom |\\<subseteq>| fst |`| fset_of_list rs) rhs)\n     as_vrules", "apply (rule list_all_as_vrulesI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n          (clauses rhs))\n     rs\n 2. fst |`| fset_of_list rs |\\<subseteq>| fst |`| fset_of_list rs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(uu_, rhs).\n         list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n          (clauses rhs))\n     rs", "apply (rule list.pred_mono_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all ?P3 rs\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> set rs; ?P3 z\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, rhs) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(uu_, t).\n                                consts t |\\<subseteq>| all_consts)\n                            (clauses rhs)", "apply (rule swelldefined_rs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> set rs;\n        case z of\n        (uu_, rhs) \\<Rightarrow>\n          consts rhs |\\<subseteq>| all_consts\\<rbrakk>\n       \\<Longrightarrow> case z of\n                         (uu_, rhs) \\<Rightarrow>\n                           list_all\n                            (\\<lambda>(uu_, t).\n                                consts t |\\<subseteq>| all_consts)\n                            (clauses rhs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set rs;\n        consts b |\\<subseteq>| all_consts\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(uu_, t).\n                              consts t |\\<subseteq>| all_consts)\n                          (clauses b)", "apply (erule clausesE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b cs.\n       \\<lbrakk>consts b |\\<subseteq>| all_consts; b = Sabs cs\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>(uu_, t).\n                              consts t |\\<subseteq>| all_consts)\n                          (clauses b)", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b cs.\n       consts (Sabs cs) |\\<subseteq>| all_consts \\<Longrightarrow>\n       list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n        (clauses (Sabs cs))", "apply (subst (asm) welldefined_sabs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b cs.\n       list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n        cs \\<Longrightarrow>\n       list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts)\n        (clauses (Sabs cs))", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>(uu_, y). vwelldefined y) as_vrules\n\ngoal (1 subgoal):\n 1. distinct all_constructors", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct all_constructors", "show \"distinct all_constructors\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct all_constructors", "by (fact distinct_ctr)"], ["proof (state)\nthis:\n  distinct all_constructors\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale srules_as_vrules: vrules C_info as_vrules"], ["proof (prove)\ngoal (1 subgoal):\n 1. vrules C_info as_vrules", "by (fact srules_as_vrules)"], ["", "lemma rs'_rs_eq: \"srules_as_vrules.rs' = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srules_as_vrules.rs' = rs", "unfolding srules_as_vrules.rs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_to_sterm_rules as_vrules = rs", "unfolding as_vrules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. value_to_sterm_rules\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    rs", "apply (subst map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). (id x, value_to_sterm y))\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    rs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>(x, y). (x, value_to_sterm y)) \\<circ>\n         (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty)))\n     rs =\n    rs", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x.\n            case case x of\n                 (name, uu_) \\<Rightarrow>\n                   (name, Vrecabs global_css name fmempty) of\n            (x, y) \\<Rightarrow> (x, value_to_sterm y))\n     rs =\n    rs", "apply (subst case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(a, b).\n            (a, value_to_sterm (Vrecabs global_css a fmempty)))\n     rs =\n    rs", "apply (rule list_map_snd_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b e.\n       (a, b) \\<in> set rs \\<Longrightarrow>\n       value_to_sterm (Vrecabs global_css a fmempty) = b", "unfolding global_css_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b e.\n       (a, b) \\<in> set rs \\<Longrightarrow>\n       value_to_sterm\n        (Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) a fmempty) =\n       b", "using all_rules map"], ["proof (prove)\nusing this:\n  list_all srule rs\n  is_map (set rs)\n\ngoal (1 subgoal):\n 1. \\<And>a b e.\n       (a, b) \\<in> set rs \\<Longrightarrow>\n       value_to_sterm\n        (Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) a fmempty) =\n       b", "apply (auto simp: list_all_iff map_of_is_map map_of_map map_prod_def fmap_of_list.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set rs; \\<forall>x\\<in>set rs. srule x;\n        is_map (set rs)\\<rbrakk>\n       \\<Longrightarrow> Sabs (clauses b) = b", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set rs; \\<forall>x\\<in>set rs. srule x;\n     is_map (set rs)\\<rbrakk>\n    \\<Longrightarrow> Sabs (clauses b) = b", "by (erule ballE[where x = \"(a, b)\"], cases b, auto simp: is_abs_def term_cases_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma veval_correct:\n  fixes v\n  assumes \"as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\" \"wellformed t\" \"closed t\"\n  shows \"rs, fmempty \\<turnstile>\\<^sub>s t \\<down> value_to_sterm v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs, fmempty \\<turnstile>\\<^sub>s t \\<down> value_to_sterm v", "using assms"], ["proof (prove)\nusing this:\n  as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\n  pre_strong_term_class.wellformed t\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. rs, fmempty \\<turnstile>\\<^sub>s t \\<down> value_to_sterm v", "by (rule srules_as_vrules.veval_correct[unfolded rs'_rs_eq])"], ["", "end"], ["", "subsection \\<open>ML-style semantics\\<close>"], ["", "context srules begin"], ["", "lemma as_vrules_mk_rec_env: \"fmap_of_list as_vrules = mk_rec_env global_css fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list as_vrules = mk_rec_env global_css fmempty", "apply (subst global_css_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list as_vrules =\n    mk_rec_env (fmap_of_list (map (map_prod id clauses) rs)) fmempty", "apply (subst as_vrules_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    mk_rec_env (fmap_of_list (map (map_prod id clauses) rs)) fmempty", "apply (subst mk_rec_env_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list\n     (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n       rs) =\n    fmmap_keys\n     (\\<lambda>name cs.\n         Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) name fmempty)\n     (fmap_of_list (map (map_prod id clauses) rs))", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup\n        (fmap_of_list\n          (map (\\<lambda>(name, uu_).\n                   (name, Vrecabs global_css name fmempty))\n            rs))\n        x =\n       fmlookup\n        (fmmap_keys\n          (\\<lambda>name cs.\n              Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) name\n               fmempty)\n          (fmap_of_list (map (map_prod id clauses) rs)))\n        x", "apply (subst fmlookup_fmmap_keys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup\n        (fmap_of_list\n          (map (\\<lambda>(name, uu_).\n                   (name, Vrecabs global_css name fmempty))\n            rs))\n        x =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (fmlookup (fmap_of_list (map (map_prod id clauses) rs)) x)", "apply (subst fmap_of_list.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of\n        (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n          rs)\n        x =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (fmlookup (fmap_of_list (map (map_prod id clauses) rs)) x)", "apply (subst fmap_of_list.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_of\n        (map (\\<lambda>(name, uu_). (name, Vrecabs global_css name fmempty))\n          rs)\n        x =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (map_of (map (map_prod id clauses) rs) x)", "apply (subst map_of_map_keyed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (map_of (map (map_prod id clauses) rs) x)", "apply (subst (2) map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (map_of (map (\\<lambda>(x, y). (id x, clauses y)) rs) x)", "apply (subst id_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (map_of (map (\\<lambda>(x, y). (x, clauses y)) rs) x)", "apply (subst map_of_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        ((map_option clauses \\<circ> map_of rs) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        (\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x fmempty)\n        (map_option clauses (map_of rs x))", "apply (subst option.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_option (\\<lambda>_. Vrecabs global_css x fmempty) (map_of rs x) =\n       map_option\n        ((\\<lambda>cs.\n             Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x\n              fmempty) \\<circ>\n         clauses)\n        (map_of rs x)", "apply (rule option.map_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. map_of rs x = map_of rs x\n 2. \\<And>x z.\n       z \\<in> set_option (map_of rs x) \\<Longrightarrow>\n       Vrecabs global_css x fmempty =\n       ((\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x\n             fmempty) \\<circ>\n        clauses)\n        z", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z.\n       z \\<in> set_option (map_of rs x) \\<Longrightarrow>\n       Vrecabs global_css x fmempty =\n       ((\\<lambda>cs.\n            Vrecabs (fmap_of_list (map (map_prod id clauses) rs)) x\n             fmempty) \\<circ>\n        clauses)\n        z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z.\n       map_of rs x = Some z \\<Longrightarrow>\n       global_css = fmap_of_list (map (map_prod id clauses) rs)", "apply (subst global_css_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z.\n       map_of rs x = Some z \\<Longrightarrow>\n       fmap_of_list (map (map_prod id clauses) rs) =\n       fmap_of_list (map (map_prod id clauses) rs)", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation (input) \"vrelated \\<equiv> srules_as_vrules.vrelated\""], ["", "notation srules_as_vrules.vrelated (\"\\<turnstile>\\<^sub>v/ _ \\<approx> _\" [0, 50] 50)"], ["", "lemma vrecabs_global_css_refl:\n  assumes \"name |\\<in>| fmdom global_css\"\n  shows \"\\<turnstile>\\<^sub>v Vrecabs global_css name fmempty \\<approx> Vrecabs global_css name fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>v\n    Vrecabs global_css name\n     fmempty \\<approx> Vrecabs global_css name fmempty", "using assms"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom global_css\n\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>v\n    Vrecabs global_css name\n     fmempty \\<approx> Vrecabs global_css name fmempty", "proof (coinduction arbitrary: name)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name.\n       name |\\<in>| fmdom global_css \\<Longrightarrow>\n       (\\<exists>ts us namea.\n           Vrecabs global_css name fmempty = Vconstr namea ts \\<and>\n           Vrecabs global_css name fmempty = Vconstr namea us \\<and>\n           list_all2\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            ts us) \\<or>\n       (\\<exists>cs \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2.\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (frees (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (consts (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            (fmap_of_list as_vrules) \\<Gamma>\\<^sub>2) \\<or>\n       (\\<exists>\\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 css namea.\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>2 \\<and>\n           pred_fmap\n            (\\<lambda>cs.\n                fmrel_on_fset (frees (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n                fmrel_on_fset (consts (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 (fmap_of_list as_vrules)\n                 (\\<Gamma>\\<^sub>2 ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>2))\n            css \\<and>\n           namea |\\<in>| fmdom css)", "case vrelated"], ["proof (state)\nthis:\n  name |\\<in>| fmdom global_css\n\ngoal (1 subgoal):\n 1. \\<And>name.\n       name |\\<in>| fmdom global_css \\<Longrightarrow>\n       (\\<exists>ts us namea.\n           Vrecabs global_css name fmempty = Vconstr namea ts \\<and>\n           Vrecabs global_css name fmempty = Vconstr namea us \\<and>\n           list_all2\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            ts us) \\<or>\n       (\\<exists>cs \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2.\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (frees (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (consts (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            (fmap_of_list as_vrules) \\<Gamma>\\<^sub>2) \\<or>\n       (\\<exists>\\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 css namea.\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>2 \\<and>\n           pred_fmap\n            (\\<lambda>cs.\n                fmrel_on_fset (frees (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n                fmrel_on_fset (consts (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 (fmap_of_list as_vrules)\n                 (\\<Gamma>\\<^sub>2 ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>2))\n            css \\<and>\n           namea |\\<in>| fmdom css)", "have \"rel_option (\\<lambda>v\\<^sub>1 v\\<^sub>2. (\\<exists>name. v\\<^sub>1 = Vrecabs global_css name fmempty \\<and> v\\<^sub>2 = Vrecabs global_css name fmempty \\<and> name |\\<in>| fmdom global_css) \\<or> \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2) (fmlookup (fmap_of_list as_vrules) y) (fmlookup (mk_rec_env global_css fmempty) y)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2.\n         (\\<exists>name.\n             v\\<^sub>1 = Vrecabs global_css name fmempty \\<and>\n             v\\<^sub>2 = Vrecabs global_css name fmempty \\<and>\n             name |\\<in>| fmdom global_css) \\<or>\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2)\n     (fmlookup (fmap_of_list as_vrules) y)\n     (fmlookup (mk_rec_env global_css fmempty) y)", "apply (subst as_vrules_mk_rec_env)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>v\\<^sub>1 v\\<^sub>2.\n         (\\<exists>name.\n             v\\<^sub>1 = Vrecabs global_css name fmempty \\<and>\n             v\\<^sub>2 = Vrecabs global_css name fmempty \\<and>\n             name |\\<in>| fmdom global_css) \\<or>\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2)\n     (fmlookup (mk_rec_env global_css fmempty) y)\n     (fmlookup (mk_rec_env global_css fmempty) y)", "apply (rule option.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set_option\n                (fmlookup (mk_rec_env global_css fmempty)\n                  y) \\<Longrightarrow>\n       (\\<exists>name.\n           z = Vrecabs global_css name fmempty \\<and>\n           z = Vrecabs global_css name fmempty \\<and>\n           name |\\<in>| fmdom global_css) \\<or>\n       \\<turnstile>\\<^sub>v z \\<approx> z", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set_option\n                (fmlookup (mk_rec_env global_css fmempty)\n                  y) \\<Longrightarrow>\n       \\<exists>name.\n          z = Vrecabs global_css name fmempty \\<and>\n          z = Vrecabs global_css name fmempty \\<and>\n          name |\\<in>| fmdom global_css", "apply (simp add: mk_rec_env_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. fmlookup global_css y = Some z \\<Longrightarrow>\n    y |\\<in>| fmdom global_css", "apply (elim conjE exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       fmlookup global_css y = Some z \\<Longrightarrow>\n       y |\\<in>| fmdom global_css", "by (auto intro: fmdomI)"], ["proof (state)\nthis:\n  rel_option\n   (\\<lambda>v\\<^sub>1 v\\<^sub>2.\n       (\\<exists>name.\n           v\\<^sub>1 = Vrecabs global_css name fmempty \\<and>\n           v\\<^sub>2 = Vrecabs global_css name fmempty \\<and>\n           name |\\<in>| fmdom global_css) \\<or>\n       \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2)\n   (fmlookup (fmap_of_list as_vrules) ?y4)\n   (fmlookup (mk_rec_env global_css fmempty) ?y4)\n\ngoal (1 subgoal):\n 1. \\<And>name.\n       name |\\<in>| fmdom global_css \\<Longrightarrow>\n       (\\<exists>ts us namea.\n           Vrecabs global_css name fmempty = Vconstr namea ts \\<and>\n           Vrecabs global_css name fmempty = Vconstr namea us \\<and>\n           list_all2\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            ts us) \\<or>\n       (\\<exists>cs \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2.\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (frees (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (consts (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            (fmap_of_list as_vrules) \\<Gamma>\\<^sub>2) \\<or>\n       (\\<exists>\\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 css namea.\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>1 \\<and>\n           Vrecabs global_css name fmempty =\n           Vrecabs css namea \\<Gamma>\\<^sub>2 \\<and>\n           pred_fmap\n            (\\<lambda>cs.\n                fmrel_on_fset (frees (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n                fmrel_on_fset (consts (Sabs cs))\n                 (\\<lambda>uu_ uua_.\n                     (\\<exists>name.\n                         uu_ = Vrecabs global_css name fmempty \\<and>\n                         uua_ = Vrecabs global_css name fmempty \\<and>\n                         name |\\<in>| fmdom global_css) \\<or>\n                     \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n                 (fmap_of_list as_vrules)\n                 (\\<Gamma>\\<^sub>2 ++\\<^sub>f\n                  mk_rec_env css \\<Gamma>\\<^sub>2))\n            css \\<and>\n           namea |\\<in>| fmdom css)", "with vrelated"], ["proof (chain)\npicking this:\n  name |\\<in>| fmdom global_css\n  rel_option\n   (\\<lambda>v\\<^sub>1 v\\<^sub>2.\n       (\\<exists>name.\n           v\\<^sub>1 = Vrecabs global_css name fmempty \\<and>\n           v\\<^sub>2 = Vrecabs global_css name fmempty \\<and>\n           name |\\<in>| fmdom global_css) \\<or>\n       \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2)\n   (fmlookup (fmap_of_list as_vrules) ?y4)\n   (fmlookup (mk_rec_env global_css fmempty) ?y4)", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<in>| fmdom global_css\n  rel_option\n   (\\<lambda>v\\<^sub>1 v\\<^sub>2.\n       (\\<exists>name.\n           v\\<^sub>1 = Vrecabs global_css name fmempty \\<and>\n           v\\<^sub>2 = Vrecabs global_css name fmempty \\<and>\n           name |\\<in>| fmdom global_css) \\<or>\n       \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<^sub>2)\n   (fmlookup (fmap_of_list as_vrules) ?y4)\n   (fmlookup (mk_rec_env global_css fmempty) ?y4)\n\ngoal (1 subgoal):\n 1. (\\<exists>ts us name.\n        Vrecabs global_css name fmempty = Vconstr name ts \\<and>\n        Vrecabs global_css name fmempty = Vconstr name us \\<and>\n        list_all2\n         (\\<lambda>uu_ uua_.\n             (\\<exists>name.\n                 uu_ = Vrecabs global_css name fmempty \\<and>\n                 uua_ = Vrecabs global_css name fmempty \\<and>\n                 name |\\<in>| fmdom global_css) \\<or>\n             \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n         ts us) \\<or>\n    (\\<exists>cs \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2.\n        Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>1 \\<and>\n        Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>2 \\<and>\n        fmrel_on_fset (frees (Sabs cs))\n         (\\<lambda>uu_ uua_.\n             (\\<exists>name.\n                 uu_ = Vrecabs global_css name fmempty \\<and>\n                 uua_ = Vrecabs global_css name fmempty \\<and>\n                 name |\\<in>| fmdom global_css) \\<or>\n             \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n         \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n        fmrel_on_fset (consts (Sabs cs))\n         (\\<lambda>uu_ uua_.\n             (\\<exists>name.\n                 uu_ = Vrecabs global_css name fmempty \\<and>\n                 uua_ = Vrecabs global_css name fmempty \\<and>\n                 name |\\<in>| fmdom global_css) \\<or>\n             \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n         (fmap_of_list as_vrules) \\<Gamma>\\<^sub>2) \\<or>\n    (\\<exists>\\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 css name.\n        Vrecabs global_css name fmempty =\n        Vrecabs css name \\<Gamma>\\<^sub>1 \\<and>\n        Vrecabs global_css name fmempty =\n        Vrecabs css name \\<Gamma>\\<^sub>2 \\<and>\n        pred_fmap\n         (\\<lambda>cs.\n             fmrel_on_fset (frees (Sabs cs))\n              (\\<lambda>uu_ uua_.\n                  (\\<exists>name.\n                      uu_ = Vrecabs global_css name fmempty \\<and>\n                      uua_ = Vrecabs global_css name fmempty \\<and>\n                      name |\\<in>| fmdom global_css) \\<or>\n                  \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n              \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n             fmrel_on_fset (consts (Sabs cs))\n              (\\<lambda>uu_ uua_.\n                  (\\<exists>name.\n                      uu_ = Vrecabs global_css name fmempty \\<and>\n                      uua_ = Vrecabs global_css name fmempty \\<and>\n                      name |\\<in>| fmdom global_css) \\<or>\n                  \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n              (fmap_of_list as_vrules)\n              (\\<Gamma>\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>2))\n         css \\<and>\n        name |\\<in>| fmdom css)", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>ts us name.\n      Vrecabs global_css name fmempty = Vconstr name ts \\<and>\n      Vrecabs global_css name fmempty = Vconstr name us \\<and>\n      list_all2\n       (\\<lambda>uu_ uua_.\n           (\\<exists>name.\n               uu_ = Vrecabs global_css name fmempty \\<and>\n               uua_ = Vrecabs global_css name fmempty \\<and>\n               name |\\<in>| fmdom global_css) \\<or>\n           \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n       ts us) \\<or>\n  (\\<exists>cs \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2.\n      Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>1 \\<and>\n      Vrecabs global_css name fmempty = Vabs cs \\<Gamma>\\<^sub>2 \\<and>\n      fmrel_on_fset (frees (Sabs cs))\n       (\\<lambda>uu_ uua_.\n           (\\<exists>name.\n               uu_ = Vrecabs global_css name fmempty \\<and>\n               uua_ = Vrecabs global_css name fmempty \\<and>\n               name |\\<in>| fmdom global_css) \\<or>\n           \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n       \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n      fmrel_on_fset (consts (Sabs cs))\n       (\\<lambda>uu_ uua_.\n           (\\<exists>name.\n               uu_ = Vrecabs global_css name fmempty \\<and>\n               uua_ = Vrecabs global_css name fmempty \\<and>\n               name |\\<in>| fmdom global_css) \\<or>\n           \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n       (fmap_of_list as_vrules) \\<Gamma>\\<^sub>2) \\<or>\n  (\\<exists>\\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 css name.\n      Vrecabs global_css name fmempty =\n      Vrecabs css name \\<Gamma>\\<^sub>1 \\<and>\n      Vrecabs global_css name fmempty =\n      Vrecabs css name \\<Gamma>\\<^sub>2 \\<and>\n      pred_fmap\n       (\\<lambda>cs.\n           fmrel_on_fset (frees (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            \\<Gamma>\\<^sub>1 \\<Gamma>\\<^sub>2 \\<and>\n           fmrel_on_fset (consts (Sabs cs))\n            (\\<lambda>uu_ uua_.\n                (\\<exists>name.\n                    uu_ = Vrecabs global_css name fmempty \\<and>\n                    uua_ = Vrecabs global_css name fmempty \\<and>\n                    name |\\<in>| fmdom global_css) \\<or>\n                \\<turnstile>\\<^sub>v uu_ \\<approx> uua_)\n            (fmap_of_list as_vrules)\n            (\\<Gamma>\\<^sub>2 ++\\<^sub>f mk_rec_env css \\<Gamma>\\<^sub>2))\n       css \\<and>\n      name |\\<in>| fmdom css)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma as_vrules_refl_rs: \"fmrel_on_fset (fst |`| fset_of_list as_vrules) vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (fst |`| fset_of_list as_vrules) srules_as_vrules.vrelated\n     (fmap_of_list as_vrules) (fmap_of_list as_vrules)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fst |`| fset_of_list as_vrules \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "apply (subst (2) as_vrules_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fst |`| fset_of_list as_vrules \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup\n          (fmap_of_list\n            (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs))\n          x)\n        (fmlookup (fmap_of_list as_vrules) x)", "apply (subst (2) as_vrules_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fst |`| fset_of_list as_vrules \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup\n          (fmap_of_list\n            (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs))\n          x)\n        (fmlookup\n          (fmap_of_list\n            (map (\\<lambda>(name, uu_).\n                     (name, Vrecabs global_css name fmempty))\n              rs))\n          x)", "apply (simp add: fmap_of_list.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| fst |`| fset_of_list rs \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (map_of\n          (map (\\<lambda>(name, uu_).\n                   (name, Vrecabs global_css name fmempty))\n            rs)\n          x)\n        (map_of\n          (map (\\<lambda>(name, uu_).\n                   (name, Vrecabs global_css name fmempty))\n            rs)\n          x)", "apply (rule rel_option_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x |\\<in>| fst |`| fset_of_list rs;\n        xa \\<in> set_option\n                  (map_of\n                    (map (\\<lambda>(name, uu_).\n                             (name, Vrecabs global_css name fmempty))\n                      rs)\n                    x)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>v xa \\<approx> xa", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x |\\<in>| fst |`| fset_of_list rs;\n        map_of\n         (map (\\<lambda>(name, uu_).\n                  (name, Vrecabs global_css name fmempty))\n           rs)\n         x =\n        Some xa\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>v xa \\<approx> xa", "apply (drule map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x |\\<in>| fst |`| fset_of_list rs;\n        (x, xa)\n        \\<in> set (map (\\<lambda>(name, uu_).\n                           (name, Vrecabs global_css name fmempty))\n                    rs)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>v xa \\<approx> xa", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) |\\<in>| fset_of_list rs;\n        (a, ba) \\<in> set rs\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<^sub>v\n                         Vrecabs global_css a\n                          fmempty \\<approx> Vrecabs global_css a fmempty", "apply (rule vrecabs_global_css_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) |\\<in>| fset_of_list rs;\n        (a, ba) \\<in> set rs\\<rbrakk>\n       \\<Longrightarrow> a |\\<in>| fmdom global_css", "unfolding global_css_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>(a, b) |\\<in>| fset_of_list rs;\n        (a, ba) \\<in> set rs\\<rbrakk>\n       \\<Longrightarrow> a |\\<in>|\n                         fmdom (fmap_of_list (map (map_prod id clauses) rs))", "by (auto simp: fset_of_list_elem intro: rev_fimage_eqI)"], ["", "lemma as_vrules_refl_C: \"fmrel_on_fset C vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset C srules_as_vrules.vrelated (fmap_of_list as_vrules)\n     (fmap_of_list as_vrules)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "assume \"c |\\<in>| C\""], ["proof (state)\nthis:\n  c |\\<in>| C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "hence \"c |\\<notin>| fset_of_list (map fst as_vrules)\""], ["proof (prove)\nusing this:\n  c |\\<in>| C\n\ngoal (1 subgoal):\n 1. c |\\<notin>| fset_of_list (map fst as_vrules)", "using srules_as_vrules.vconstructor_value_rs"], ["proof (prove)\nusing this:\n  c |\\<in>| C\n  vconstructor_value_rs as_vrules\n\ngoal (1 subgoal):\n 1. c |\\<notin>| fset_of_list (map fst as_vrules)", "unfolding vconstructor_value_rs_def fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  c |\\<in>| C\n  list_all (\\<lambda>(uu_, y). vconstructor_value y) as_vrules \\<and>\n  fset_of_list (map fst as_vrules) |\\<inter>| C = {||}\n\ngoal (1 subgoal):\n 1. c |\\<notin>| fset_of_list (map fst as_vrules)", "by auto"], ["proof (state)\nthis:\n  c |\\<notin>| fset_of_list (map fst as_vrules)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "hence \"c |\\<notin>| fmdom (fmap_of_list as_vrules)\""], ["proof (prove)\nusing this:\n  c |\\<notin>| fset_of_list (map fst as_vrules)\n\ngoal (1 subgoal):\n 1. c |\\<notin>| fmdom (fmap_of_list as_vrules)", "by simp"], ["proof (state)\nthis:\n  c |\\<notin>| fmdom (fmap_of_list as_vrules)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "hence \"fmlookup (fmap_of_list as_vrules) c = None\""], ["proof (prove)\nusing this:\n  c |\\<notin>| fmdom (fmap_of_list as_vrules)\n\ngoal (1 subgoal):\n 1. fmlookup (fmap_of_list as_vrules) c = None", "by (metis fmdom_notD)"], ["proof (state)\nthis:\n  fmlookup (fmap_of_list as_vrules) c = None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| C \\<Longrightarrow>\n       rel_option srules_as_vrules.vrelated\n        (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_list as_vrules) x)", "thus \"rel_option vrelated (fmlookup (fmap_of_list as_vrules) c) (fmlookup (fmap_of_list as_vrules) c)\""], ["proof (prove)\nusing this:\n  fmlookup (fmap_of_list as_vrules) c = None\n\ngoal (1 subgoal):\n 1. rel_option srules_as_vrules.vrelated\n     (fmlookup (fmap_of_list as_vrules) c)\n     (fmlookup (fmap_of_list as_vrules) c)", "by simp"], ["proof (state)\nthis:\n  rel_option srules_as_vrules.vrelated (fmlookup (fmap_of_list as_vrules) c)\n   (fmlookup (fmap_of_list as_vrules) c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma veval'_correct'':\n  fixes t v\n  assumes \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\"\n  assumes \"wellformed t\"\n  assumes \"\\<not> shadows_consts t\"\n  assumes \"welldefined t\"\n  assumes \"closed t\"\n  assumes \"vno_abs v\"\n  shows \"as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v", "obtain v\\<^sub>1 where \"as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\" \"\\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                 v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<close>"], ["proof (prove)\nusing this:\n  fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>1.\n        \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                 v\\<^sub>1;\n         \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule srules_as_vrules.veval'_correct', unfold as_vrules_fst)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> pre_strong_term_class.wellformed t\n 2. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv (fmap_of_list as_vrules)\n 3. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> \\<not> shadows_consts t\n 4. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env (fmap_of_list as_vrules)\n 5. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> consts t |\\<subseteq>| all_consts\n 6. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> pre_term_class.closed t\n 7. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 8. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed t\" \"\\<not> shadows_consts t\" \"closed t\" \"consts t |\\<subseteq>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pre_strong_term_class.wellformed t &&& \\<not> shadows_consts t) &&&\n    pre_term_class.closed t &&& consts t |\\<subseteq>| all_consts", "by fact+"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\n  \\<not> shadows_consts t\n  pre_term_class.closed t\n  consts t |\\<subseteq>| all_consts\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv (fmap_of_list as_vrules)\n 2. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env (fmap_of_list as_vrules)\n 3. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 4. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> wellformed_venv (fmap_of_list as_vrules)\n 2. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env (fmap_of_list as_vrules)\n 3. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 4. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed_venv (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (fmap_of_list as_vrules)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vwellformed v", "using srules_as_vrules.all_rules"], ["proof (prove)\nusing this:\n  list_all vrule as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vwellformed v", "apply (auto simp: list_all_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wellformed_venv (fmap_of_list as_vrules)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env (fmap_of_list as_vrules)\n 2. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 3. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> not_shadows_vconsts_env (fmap_of_list as_vrules)\n 2. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 3. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"not_shadows_vconsts_env (fmap_of_list as_vrules) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (fmap_of_list as_vrules)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set as_vrules \\<Longrightarrow> not_shadows_vconsts v", "using srules_as_vrules.not_shadows"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, y). srules_as_vrules.not_shadows_vconsts y)\n   as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set as_vrules \\<Longrightarrow> not_shadows_vconsts v", "apply (auto simp: list_all_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (fmap_of_list as_vrules)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 2. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 2. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"fmrel_on_fset (fst |`| fset_of_list as_vrules |\\<union>| C) vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (fst |`| fset_of_list as_vrules |\\<union>| C)\n     srules_as_vrules.vrelated (fmap_of_list as_vrules)\n     (fmap_of_list as_vrules)", "apply (rule fmrel_on_fset_unionI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset (fst |`| fset_of_list as_vrules) srules_as_vrules.vrelated\n     (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 2. fmrel_on_fset C srules_as_vrules.vrelated (fmap_of_list as_vrules)\n     (fmap_of_list as_vrules)", "apply (rule as_vrules_refl_rs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset C srules_as_vrules.vrelated (fmap_of_list as_vrules)\n     (fmap_of_list as_vrules)", "apply (rule as_vrules_refl_C)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (fst |`| fset_of_list as_vrules |\\<union>| C)\n   srules_as_vrules.vrelated (fmap_of_list as_vrules)\n   (fmap_of_list as_vrules)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v\\<^sub>1.\n                \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down>\n                         v\\<^sub>1;\n                 \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n    \\<Longrightarrow> fmrel_on_fset (consts t) srules_as_vrules.vrelated\n                       (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n 2. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmrel_on_fset (consts t) vrelated (fmap_of_list as_vrules) (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (consts t) srules_as_vrules.vrelated\n     (fmap_of_list as_vrules) (fmap_of_list as_vrules)", "apply (rule fmrel_on_fsubset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmrel_on_fset ?S srules_as_vrules.vrelated (fmap_of_list as_vrules)\n     (fmap_of_list as_vrules)\n 2. consts t |\\<subseteq>| ?S", "apply fact+"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fst |`| fset_of_list as_vrules |\\<union>| C", "using assms"], ["proof (prove)\nusing this:\n  fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\n  pre_strong_term_class.wellformed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  vno_abs v\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fst |`| fset_of_list as_vrules |\\<union>| C", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  fmrel_on_fset (consts t) srules_as_vrules.vrelated\n   (fmap_of_list as_vrules) (fmap_of_list as_vrules)\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1.\n       \\<lbrakk>\\<And>v\\<^sub>1.\n                   \\<lbrakk>as_vrules, fmempty \\<turnstile>\\<^sub>v\n                            t \\<down> v\\<^sub>1;\n                    \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1;\n        \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["proof (state)\nthis:\n  as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\n  \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\n\ngoal (1 subgoal):\n 1. as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\n  \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\n\ngoal (1 subgoal):\n 1. as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v", "using assms"], ["proof (prove)\nusing this:\n  as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\\<^sub>1\n  \\<turnstile>\\<^sub>v v\\<^sub>1 \\<approx> v\n  fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\n  pre_strong_term_class.wellformed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  vno_abs v\n\ngoal (1 subgoal):\n 1. as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v", "by (metis srules_as_vrules.vrelated.eq_right)"], ["proof (state)\nthis:\n  as_vrules, fmempty \\<turnstile>\\<^sub>v t \\<down> v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>CakeML\\<close>"], ["", "context srules begin"], ["", "definition as_sem_env :: \"v sem_env \\<Rightarrow> v sem_env\" where\n\"as_sem_env env = \\<lparr> sem_env.v = build_rec_env (mk_letrec_body all_consts rs) env nsEmpty, sem_env.c = nsEmpty \\<rparr>\""], ["", "lemma compile_sem_env:\n  \"evaluate_dec ck mn env state (compile_group all_consts rs) (state, Rval (as_sem_env env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env state (compile_group all_consts rs)\n     (state, Rval (as_sem_env env))", "unfolding compile_group_def as_sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_dec ck mn env state\n     (Dletrec empty_locs (mk_letrec_body all_consts rs))\n     (state,\n      Rval\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) env nsEmpty)\n         nsEmpty))", "apply (rule evaluate_dec.dletrec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct\n     (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n       (mk_letrec_body all_consts rs))", "unfolding mk_letrec_body_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. allDistinct\n     (map (\\<lambda>x. case x of (x, y, z) \\<Rightarrow> x)\n       (map (\\<lambda>(name, rhs).\n                (as_string name, as_string (fresh_fNext all_consts),\n                 Mat (Var (Short (as_string (fresh_fNext all_consts))))\n                  (mk_clauses all_consts (clauses rhs))))\n         rs))", "apply (simp add:comp_def case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. case x of (name, rhs) \\<Rightarrow> as_string name)\n       rs)", "using name_as_string.fst_distinct[OF distinct]"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(k, uu_). as_string k) rs)\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. case x of (name, rhs) \\<Rightarrow> as_string name)\n       rs)", "by auto"], ["", "lemma compile_sem_env':\n  \"fun_evaluate_decs mn state env [(compile_group all_consts rs)] = (state, Rval (as_sem_env env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate_decs mn state env [compile_group all_consts rs] =\n    (state, Rval (as_sem_env env))", "unfolding compile_group_def as_sem_env_def mk_letrec_body_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate_decs mn state env\n     [Dletrec empty_locs\n       (map (\\<lambda>(name, rhs).\n                (as_string name, as_string (fresh_fNext all_consts),\n                 Mat (Var (Short (as_string (fresh_fNext all_consts))))\n                  (mk_clauses all_consts (clauses rhs))))\n         rs)] =\n    (state,\n     Rval\n      (make_sem_env\n        (build_rec_env\n          (map (\\<lambda>(name, rhs).\n                   (as_string name, as_string (fresh_fNext all_consts),\n                    Mat (Var (Short (as_string (fresh_fNext all_consts))))\n                     (mk_clauses all_consts (clauses rhs))))\n            rs)\n          env nsEmpty)\n        nsEmpty))", "apply (simp add: comp_def case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(name, rhs). as_string name) rs)", "using name_as_string.fst_distinct[OF distinct]"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(k, uu_). as_string k) rs)\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(name, rhs). as_string name) rs)", "by auto"], ["", "lemma compile_prog[unfolded combine_dec_result.simps, simplified]:\n  \"evaluate_prog ck env state (compile rs) (state, combine_dec_result (as_sem_env env) (Rval \\<lparr> sem_env.v = nsEmpty, sem_env.c = nsEmpty \\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck env state (srules_as_cake.compile rs)\n     (state,\n      combine_dec_result (as_sem_env env)\n       (Rval (make_sem_env nsEmpty nsEmpty)))", "unfolding compile_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck env state [Tdec (compile_group all_consts rs)]\n     (state,\n      combine_dec_result (as_sem_env env)\n       (Rval (make_sem_env nsEmpty nsEmpty)))", "apply (rule evaluate_prog.cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_top ck env state (Tdec (compile_group all_consts rs))\n     (?s2.0, Rval (as_sem_env env)) \\<and>\n    evaluate_prog ck (extend_dec_env (as_sem_env env) env) ?s2.0 []\n     (state, Rval (make_sem_env nsEmpty nsEmpty))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_top ck env state (Tdec (compile_group all_consts rs))\n     (?s2.0, Rval (as_sem_env env))\n 2. evaluate_prog ck (extend_dec_env (as_sem_env env) env) ?s2.0 []\n     (state, Rval (make_sem_env nsEmpty nsEmpty))", "apply (rule evaluate_top.tdec1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. evaluate_dec ck [] env state (compile_group all_consts rs)\n     (?s2.0, Rval (as_sem_env env))\n 2. evaluate_prog ck (extend_dec_env (as_sem_env env) env) ?s2.0 []\n     (state, Rval (make_sem_env nsEmpty nsEmpty))", "apply (rule compile_sem_env)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_prog ck (extend_dec_env (as_sem_env env) env) state []\n     (state, Rval (make_sem_env nsEmpty nsEmpty))", "apply (rule evaluate_prog.empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compile_prog'[unfolded combine_dec_result.simps, simplified]:\n  \"fun_evaluate_prog state env (compile rs) = (state, combine_dec_result (as_sem_env env) (Rval \\<lparr> sem_env.v = nsEmpty, sem_env.c = nsEmpty \\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_evaluate_prog state env (srules_as_cake.compile rs) =\n    (state,\n     combine_dec_result (as_sem_env env)\n      (Rval (make_sem_env nsEmpty nsEmpty)))", "unfolding compile_def fun_evaluate_prog_def no_dup_mods_def no_dup_top_types_def prog_to_mods_def prog_to_top_types_def decs_to_types_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (allDistinct\n          (concat\n            (map (case_top0 (\\<lambda>mn x xa. [[mn]]) (\\<lambda>dec. []))\n              [Tdec (compile_group all_consts rs)])) \\<and>\n         disjnt\n          (set (concat\n                 (map (case_top0 (\\<lambda>mn x xa. [[mn]])\n                        (\\<lambda>dec. []))\n                   [Tdec (compile_group all_consts rs)])))\n          (defined_mods state)) \\<and>\n        allDistinct\n         (concat\n           (map (case_top0 (\\<lambda>list1 option list2. [])\n                  (\\<lambda>d.\n                      concat\n                       (map (case_dec (\\<lambda>prod pat exp0. [])\n                              (\\<lambda>prod list. [])\n                              (\\<lambda>locs.\n                                  map (\\<lambda>(tvs, tn, ctors). tn))\n                              (\\<lambda>prod list1 list2 t. [])\n                              (\\<lambda>prod list1 list2. []))\n                         [d])))\n             [Tdec (compile_group all_consts rs)])) \\<and>\n        disjnt\n         (set (map (\\<lambda>tn. TypeId (Short tn))\n                (concat\n                  (map (case_top0 (\\<lambda>list1 option list2. [])\n                         (\\<lambda>d.\n                             concat\n                              (map (case_dec (\\<lambda>prod pat exp0. [])\n                                     (\\<lambda>prod list. [])\n                                     (\\<lambda>locs.\n   map (\\<lambda>(tvs, tn, ctors). tn))\n                                     (\\<lambda>prod list1 list2 t. [])\n                                     (\\<lambda>prod list1 list2. []))\n                                [d])))\n                    [Tdec (compile_group all_consts rs)]))))\n         (defined_types state)\n     then evaluate_tops state env [Tdec (compile_group all_consts rs)]\n     else (state, Rerr (Rabort Rtype_error))) =\n    (state,\n     combine_dec_result (as_sem_env env)\n      (Rval (make_sem_env nsEmpty nsEmpty)))", "using compile_sem_env' compile_group_def"], ["proof (prove)\nusing this:\n  fun_evaluate_decs ?mn ?state ?env [compile_group all_consts rs] =\n  (?state, Rval (as_sem_env ?env))\n  compile_group ?S ?rs = Dletrec empty_locs (mk_letrec_body ?S ?rs)\n\ngoal (1 subgoal):\n 1. (if (allDistinct\n          (concat\n            (map (case_top0 (\\<lambda>mn x xa. [[mn]]) (\\<lambda>dec. []))\n              [Tdec (compile_group all_consts rs)])) \\<and>\n         disjnt\n          (set (concat\n                 (map (case_top0 (\\<lambda>mn x xa. [[mn]])\n                        (\\<lambda>dec. []))\n                   [Tdec (compile_group all_consts rs)])))\n          (defined_mods state)) \\<and>\n        allDistinct\n         (concat\n           (map (case_top0 (\\<lambda>list1 option list2. [])\n                  (\\<lambda>d.\n                      concat\n                       (map (case_dec (\\<lambda>prod pat exp0. [])\n                              (\\<lambda>prod list. [])\n                              (\\<lambda>locs.\n                                  map (\\<lambda>(tvs, tn, ctors). tn))\n                              (\\<lambda>prod list1 list2 t. [])\n                              (\\<lambda>prod list1 list2. []))\n                         [d])))\n             [Tdec (compile_group all_consts rs)])) \\<and>\n        disjnt\n         (set (map (\\<lambda>tn. TypeId (Short tn))\n                (concat\n                  (map (case_top0 (\\<lambda>list1 option list2. [])\n                         (\\<lambda>d.\n                             concat\n                              (map (case_dec (\\<lambda>prod pat exp0. [])\n                                     (\\<lambda>prod list. [])\n                                     (\\<lambda>locs.\n   map (\\<lambda>(tvs, tn, ctors). tn))\n                                     (\\<lambda>prod list1 list2 t. [])\n                                     (\\<lambda>prod list1 list2. []))\n                                [d])))\n                    [Tdec (compile_group all_consts rs)]))))\n         (defined_types state)\n     then evaluate_tops state env [Tdec (compile_group all_consts rs)]\n     else (state, Rerr (Rabort Rtype_error))) =\n    (state,\n     combine_dec_result (as_sem_env env)\n      (Rval (make_sem_env nsEmpty nsEmpty)))", "by simp"], ["", "definition sem_env :: \"v sem_env\" where\n\"sem_env \\<equiv> extend_dec_env (as_sem_env empty_sem_env) empty_sem_env\""], ["", "(* FIXME introduce lemma: is_cupcake_all_env extend_dec_env *)\n(* FIXME introduce lemma: is_cupcake_all_env empty_sem_env *)"], ["", "lemma cupcake_sem_env: \"is_cupcake_all_env sem_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env sem_env", "unfolding as_sem_env_def sem_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env)", "apply (rule is_cupcake_all_envI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns\n     (sem_env.v\n       (extend_dec_env\n         (make_sem_env\n           (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n             nsEmpty)\n           nsEmpty)\n         empty_sem_env))\n 2. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (simp add: extend_dec_env_def empty_sem_env_def nsEmpty_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns\n     (nsAppend\n       (build_rec_env (mk_letrec_body all_consts rs)\n         (make_sem_env (Bind [] []) as_static_cenv) (Bind [] []))\n       (Bind [] []))\n 2. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (rule cupcake_nsAppend_preserve)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_cupcake_ns\n     (build_rec_env (mk_letrec_body all_consts rs)\n       (make_sem_env (Bind [] []) as_static_cenv) (Bind [] []))\n 2. is_cupcake_ns (Bind [] [])\n 3. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (rule cupcake_build_rec_preserve)"], ["proof (prove)\ngoal (5 subgoals):\n 1. is_cupcake_all_env (make_sem_env (Bind [] []) as_static_cenv)\n 2. is_cupcake_ns (Bind [] [])\n 3. list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n     (mk_letrec_body all_consts rs)\n 4. is_cupcake_ns (Bind [] [])\n 5. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (simp add: empty_sem_env_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. is_cupcake_ns (Bind [] [])\n 2. list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n     (mk_letrec_body all_consts rs)\n 3. is_cupcake_ns (Bind [] [])\n 4. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (simp add: nsEmpty_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all (\\<lambda>(uu_, uu_, e). is_cupcake_exp e)\n     (mk_letrec_body all_consts rs)\n 2. is_cupcake_ns (Bind [] [])\n 3. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (rule mk_letrec_cupcake)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_ns (Bind [] [])\n 2. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sem_env.c\n     (extend_dec_env\n       (make_sem_env\n         (build_rec_env (mk_letrec_body all_consts rs) empty_sem_env\n           nsEmpty)\n         nsEmpty)\n       empty_sem_env) =\n    as_static_cenv", "apply (simp add: empty_sem_env_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sem_env_refl: \"fmrel related_v (fmap_of_list as_vrules) (fmap_of_ns (sem_env.v sem_env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_ns (sem_env.v sem_env)) x)", "fix name"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option related_v (fmlookup (fmap_of_list as_vrules) x)\n        (fmlookup (fmap_of_ns (sem_env.v sem_env)) x)", "show \"rel_option related_v (fmlookup (fmap_of_list as_vrules) name) (fmlookup (fmap_of_ns (sem_env.v sem_env)) name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option related_v (fmlookup (fmap_of_list as_vrules) name)\n     (fmlookup (fmap_of_ns (sem_env.v sem_env)) name)", "apply (simp add:\n            as_sem_env_def build_rec_env_fmap cake_mk_rec_env_def sem_env_def\n            fmap_of_list.rep_eq map_of_map_keyed option.rel_map\n            as_vrules_def mk_letrec_body_def comp_def case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option\n     (\\<lambda>x y.\n         related_v (Vrecabs global_css name fmempty)\n          (Recclosure empty_sem_env\n            (map (\\<lambda>(name, rhs).\n                     (as_string name,\n                      let n = fresh_fNext all_consts\n                      in (as_string n,\n                          Mat (Var (Short (as_string n)))\n                           (map (\\<lambda>(pat, t).\n                                    (mk_ml_pat (mk_pat pat),\n                                     mk_con\n(frees pat |\\<union>| all_consts) t))\n                             (clauses rhs)))))\n              rs)\n            (as_string name)))\n     (map_of rs name) (map_of rs name)", "apply (rule option.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set_option (map_of rs name) \\<Longrightarrow>\n       related_v (Vrecabs global_css name fmempty)\n        (Recclosure empty_sem_env\n          (map (\\<lambda>(name, rhs).\n                   (as_string name,\n                    let n = fresh_fNext all_consts\n                    in (as_string n,\n                        Mat (Var (Short (as_string n)))\n                         (map (\\<lambda>(pat, t).\n                                  (mk_ml_pat (mk_pat pat),\n                                   mk_con (frees pat |\\<union>| all_consts)\n                                    t))\n                           (clauses rhs)))))\n            rs)\n          (as_string name))", "apply (rule related_v.rec_closure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       z \\<in> set_option (map_of rs name) \\<Longrightarrow>\n       fmrel_on_fset (fbind (fmran global_css) (ids \\<circ> Sabs)) related_v\n        fmempty (fmap_of_ns (sem_env.v empty_sem_env))\n 2. \\<And>z.\n       z \\<in> set_option (map_of rs name) \\<Longrightarrow>\n       fmrel (\\<lambda>cs (n, e). related_fun cs n e) global_css\n        (fmap_of_list\n          (map (map_prod Name (map_prod Name id))\n            (map (\\<lambda>(name, rhs).\n                     (as_string name,\n                      let n = fresh_fNext all_consts\n                      in (as_string n,\n                          Mat (Var (Short (as_string n)))\n                           (map (\\<lambda>(pat, t).\n                                    (mk_ml_pat (mk_pat pat),\n                                     mk_con\n(frees pat |\\<union>| all_consts) t))\n                             (clauses rhs)))))\n              rs)))", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set_option (map_of rs name) \\<Longrightarrow>\n       fmrel (\\<lambda>cs (n, e). related_fun cs n e) global_css\n        (fmap_of_list\n          (map (map_prod Name (map_prod Name id))\n            (map (\\<lambda>(name, rhs).\n                     (as_string name,\n                      let n = fresh_fNext all_consts\n                      in (as_string n,\n                          Mat (Var (Short (as_string n)))\n                           (map (\\<lambda>(pat, t).\n                                    (mk_ml_pat (mk_pat pat),\n                                     mk_con\n(frees pat |\\<union>| all_consts) t))\n                             (clauses rhs)))))\n              rs)))", "apply (simp add:\n            fmmap_of_list[symmetric, unfolded apsnd_def map_prod_def id_def] fmap.rel_map\n            global_css_def Let_def map_prod_def comp_def case_prod_twice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       map_of rs name = Some z \\<Longrightarrow>\n       fmrel\n        (\\<lambda>x y.\n            related_fun (clauses x) (fresh_fNext all_consts)\n             (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n               (map (\\<lambda>(pat, t).\n                        (mk_ml_pat (mk_pat pat),\n                         mk_con (frees pat |\\<union>| all_consts) t))\n                 (clauses y))))\n        (fmap_of_list rs) (fmap_of_list rs)", "apply (thin_tac \"map_of rs name = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       fmrel\n        (\\<lambda>x y.\n            related_fun (clauses x) (fresh_fNext all_consts)\n             (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n               (map (\\<lambda>(pat, t).\n                        (mk_ml_pat (mk_pat pat),\n                         mk_con (frees pat |\\<union>| all_consts) t))\n                 (clauses y))))\n        (fmap_of_list rs) (fmap_of_list rs)", "apply (rule fmap.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z za.\n       za \\<in> fmran' (fmap_of_list rs) \\<Longrightarrow>\n       related_fun (clauses za) (fresh_fNext all_consts)\n        (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n          (map (\\<lambda>(pat, t).\n                   (mk_ml_pat (mk_pat pat),\n                    mk_con (frees pat |\\<union>| all_consts) t))\n            (clauses za)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>za.\n       za \\<in> fmran' (fmap_of_list rs) \\<Longrightarrow>\n       related_fun (clauses za) (fresh_fNext all_consts)\n        (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n          (map (\\<lambda>(pat, t).\n                   (mk_ml_pat (mk_pat pat),\n                    mk_con (frees pat |\\<union>| all_consts) t))\n            (clauses za)))", "subgoal premises prems for rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "obtain name where \"(name, rhs) \\<in> set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>name.\n        (name, rhs) \\<in> set rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prems"], ["proof (prove)\nusing this:\n  rhs \\<in> fmran' (fmap_of_list rs)\n\ngoal (1 subgoal):\n 1. (\\<And>name.\n        (name, rhs) \\<in> set rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "including fmap.lifting"], ["proof (prove)\nusing this:\n  rhs \\<in> fmran' (fmap_of_list rs)\n\ngoal (1 subgoal):\n 1. (\\<And>name.\n        (name, rhs) \\<in> set rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer' (auto dest: map_of_SomeD)"], ["proof (state)\nthis:\n  (name, rhs) \\<in> set rs\n\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "hence \"is_abs rhs\" \"closed rhs\" \"welldefined rhs\""], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n\ngoal (1 subgoal):\n 1. is_abs rhs &&&\n    pre_term_class.closed rhs &&& consts rhs |\\<subseteq>| all_consts", "using all_rules swelldefined_rs"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  list_all srule rs\n  list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts) rs\n\ngoal (1 subgoal):\n 1. is_abs rhs &&&\n    pre_term_class.closed rhs &&& consts rhs |\\<subseteq>| all_consts", "by (auto simp add: list_all_iff)"], ["proof (state)\nthis:\n  is_abs rhs\n  pre_term_class.closed rhs\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "then"], ["proof (chain)\npicking this:\n  is_abs rhs\n  pre_term_class.closed rhs\n  consts rhs |\\<subseteq>| all_consts", "obtain cs where \"clauses rhs = cs\" \"rhs = Sabs cs\" \"wellformed_clauses cs\""], ["proof (prove)\nusing this:\n  is_abs rhs\n  pre_term_class.closed rhs\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>clauses rhs = cs; rhs = Sabs cs;\n         wellformed_clauses cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(name, rhs) \\<in> set rs\\<close> all_rules"], ["proof (prove)\nusing this:\n  is_abs rhs\n  pre_term_class.closed rhs\n  consts rhs |\\<subseteq>| all_consts\n  (name, rhs) \\<in> set rs\n  list_all srule rs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>clauses rhs = cs; rhs = Sabs cs;\n         wellformed_clauses cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rhs) (auto simp: list_all_iff is_abs_def term_cases_def)"], ["proof (state)\nthis:\n  clauses rhs = cs\n  rhs = Sabs cs\n  wellformed_clauses cs\n\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_fun (clauses rhs) (fresh_fNext all_consts)\n     (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n       (map (\\<lambda>(pat, t).\n                (mk_ml_pat (mk_pat pat),\n                 mk_con (frees pat |\\<union>| all_consts) t))\n         (clauses rhs)))", "unfolding related_fun_alt_def \\<open>clauses rhs = cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod related_pat related_exp) cs\n     (map (\\<lambda>(pat, t).\n              (mk_ml_pat (mk_pat pat),\n               mk_con (frees pat |\\<union>| all_consts) t))\n       cs) \\<and>\n    fresh_fNext all_consts |\\<notin>| ids (Sabs cs) \\<and>\n    fresh_fNext all_consts |\\<notin>| all_consts", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. list_all2 (rel_prod related_pat related_exp) cs\n     (map (\\<lambda>(pat, t).\n              (mk_ml_pat (mk_pat pat),\n               mk_con (frees pat |\\<union>| all_consts) t))\n       cs)\n 2. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n 3. fresh_fNext all_consts |\\<notin>| all_consts", "show \"list_all2 (rel_prod related_pat related_exp) cs (map (\\<lambda>(pat, t). (mk_ml_pat (mk_pat pat), mk_con (frees pat |\\<union>| all_consts) t)) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod related_pat related_exp) cs\n     (map (\\<lambda>(pat, t).\n              (mk_ml_pat (mk_pat pat),\n               mk_con (frees pat |\\<union>| all_consts) t))\n       cs)", "unfolding list.rel_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x y.\n         rel_prod related_pat related_exp x\n          (case y of\n           (pat, t) \\<Rightarrow>\n             (mk_ml_pat (mk_pat pat),\n              mk_con (frees pat |\\<union>| all_consts) t)))\n     cs cs", "apply (rule list.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> set cs \\<Longrightarrow>\n       rel_prod related_pat related_exp z\n        (case z of\n         (pat, t) \\<Rightarrow>\n           (mk_ml_pat (mk_pat pat),\n            mk_con (frees pat |\\<union>| all_consts) t))", "apply (rename_tac z, case_tac z, hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       rel_prod related_pat related_exp (a, b)\n        (case (a, b) of\n         (pat, t) \\<Rightarrow>\n           (mk_ml_pat (mk_pat pat),\n            mk_con (frees pat |\\<union>| all_consts) t))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set cs \\<Longrightarrow>\n       related_exp b (mk_con (frees a |\\<union>| all_consts) b)", "subgoal premises prems for pat t"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp t (mk_con (frees pat |\\<union>| all_consts) t)", "proof (rule mk_exp_correctness)"], ["proof (state)\ngoal (3 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts\n 3. \\<not> shadows_consts t", "have \"\\<not> shadows_consts rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "using \\<open>(name, rhs) \\<in> set rs\\<close> not_shadows"], ["proof (prove)\nusing this:\n  (name, rhs) \\<in> set rs\n  list_all (\\<lambda>(uu_, rhs). \\<not> shadows_consts rhs) rs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts rhs", "by (auto simp: list_all_iff all_consts_def)"], ["proof (state)\nthis:\n  \\<not> shadows_consts rhs\n\ngoal (3 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts\n 3. \\<not> shadows_consts t", "thus \"\\<not> shadows_consts t\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts rhs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "unfolding \\<open>rhs = Sabs cs\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "using prems"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts (Sabs cs)\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "by (auto simp: list_all_iff list_ex_iff)"], ["proof (state)\nthis:\n  \\<not> shadows_consts t\n\ngoal (2 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "have \"frees t |\\<subseteq>| frees pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees pat", "using \\<open>closed rhs\\<close> prems"], ["proof (prove)\nusing this:\n  pre_term_class.closed rhs\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees pat", "unfolding \\<open>rhs = _\\<close>"], ["proof (prove)\nusing this:\n  pre_term_class.closed (Sabs cs)\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees pat", "apply (auto simp: list_all_iff Sterm.closed_except_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set cs.\n                   case x of\n                   (pat, t) \\<Rightarrow> closed_except t (frees pat);\n        (pat, t) \\<in> set cs; x |\\<in>| frees t\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat", "apply (erule ballE[where x = \"(pat, t)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(pat, t) \\<in> set cs; x |\\<in>| frees t;\n        case (pat, t) of\n        (pat, t) \\<Rightarrow> closed_except t (frees pat)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat\n 2. \\<And>x.\n       \\<lbrakk>(pat, t) \\<in> set cs; x |\\<in>| frees t;\n        (pat, t) \\<notin> set cs\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees pat", "apply (auto simp: closed_except_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  frees t |\\<subseteq>| frees pat\n\ngoal (2 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "moreover"], ["proof (state)\nthis:\n  frees t |\\<subseteq>| frees pat\n\ngoal (2 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "have \"consts t |\\<subseteq>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "using \\<open>welldefined rhs\\<close> prems"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "unfolding \\<open>rhs = _\\<close> welldefined_sabs"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs\n  (pat, t) \\<in> set cs\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by (auto simp: list_all_iff all_consts_def)"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| all_consts\n\ngoal (2 subgoals):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n 2. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "ultimately"], ["proof (chain)\npicking this:\n  frees t |\\<subseteq>| frees pat\n  consts t |\\<subseteq>| all_consts", "show \"ids t |\\<subseteq>| frees pat |\\<union>| all_consts\""], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| frees pat\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. ids t |\\<subseteq>| frees pat |\\<union>| all_consts", "unfolding ids_def"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| frees pat\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. frees t |\\<union>| consts t |\\<subseteq>|\n    frees pat |\\<union>| all_consts", "by auto"], ["proof (state)\nthis:\n  ids t |\\<subseteq>| frees pat |\\<union>| all_consts\n\ngoal (1 subgoal):\n 1. all_consts |\\<subseteq>| frees pat |\\<union>| all_consts", "qed (auto simp: all_consts_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all2 (rel_prod related_pat related_exp) cs\n   (map (\\<lambda>(pat, t).\n            (mk_ml_pat (mk_pat pat),\n             mk_con (frees pat |\\<union>| all_consts) t))\n     cs)\n\ngoal (2 subgoals):\n 1. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext all_consts |\\<notin>| all_consts", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext all_consts |\\<notin>| all_consts", "have 1: \"frees (Sabs cs) = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Sabs cs) = {||}", "using \\<open>closed rhs\\<close>"], ["proof (prove)\nusing this:\n  pre_term_class.closed rhs\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) = {||}", "unfolding \\<open>rhs = Sabs cs\\<close>"], ["proof (prove)\nusing this:\n  pre_term_class.closed (Sabs cs)\n\ngoal (1 subgoal):\n 1. frees (Sabs cs) = {||}", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  frees (Sabs cs) = {||}\n\ngoal (2 subgoals):\n 1. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext all_consts |\\<notin>| all_consts", "have 2: \"welldefined rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "using swelldefined_rs \\<open>(name, rhs) \\<in> set rs\\<close>"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts) rs\n  (name, rhs) \\<in> set rs\n\ngoal (1 subgoal):\n 1. consts rhs |\\<subseteq>| all_consts", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  consts rhs |\\<subseteq>| all_consts\n\ngoal (2 subgoals):\n 1. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n 2. fresh_fNext all_consts |\\<notin>| all_consts", "show \"fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_fNext all_consts |\\<notin>| ids (Sabs cs)", "apply (rule fNext_not_member_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ids (Sabs cs) |\\<subseteq>| all_consts", "unfolding ids_def 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. {||} |\\<union>| consts (Sabs cs) |\\<subseteq>| all_consts", "using 2 \\<open>rhs = _\\<close>"], ["proof (prove)\nusing this:\n  consts rhs |\\<subseteq>| all_consts\n  rhs = Sabs cs\n\ngoal (1 subgoal):\n 1. {||} |\\<union>| consts (Sabs cs) |\\<subseteq>| all_consts", "by (simp add: all_consts_def del: consts_sterm.simps)"], ["proof (state)\nthis:\n  fresh_fNext all_consts |\\<notin>| ids (Sabs cs)\n\ngoal (1 subgoal):\n 1. fresh_fNext all_consts |\\<notin>| all_consts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fresh_fNext all_consts |\\<notin>| all_consts", "show \"fresh_fNext all_consts |\\<notin>| all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_fNext all_consts |\\<notin>| all_consts", "by (rule fNext_not_member)"], ["proof (state)\nthis:\n  fresh_fNext all_consts |\\<notin>| all_consts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  related_fun (clauses rhs) (fresh_fNext all_consts)\n   (Mat (Var (Short (as_string (fresh_fNext all_consts))))\n     (map (\\<lambda>(pat, t).\n              (mk_ml_pat (mk_pat pat),\n               mk_con (frees pat |\\<union>| all_consts) t))\n       (clauses rhs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_option related_v (fmlookup (fmap_of_list as_vrules) name)\n   (fmlookup (fmap_of_ns (sem_env.v sem_env)) name)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma semantic_correctness':\n  assumes \"cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  obtains v where \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v\" \"related_v v ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule semantic_correctness)"], ["proof (state)\ngoal (13 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    is_cupcake_all_env sem_env\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t6) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t6 (mk_con all_consts t)\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t6 (fmdom ?\\<Gamma>6)\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 9. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 10. (\\<And>v.\n         \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n          related_v v ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     fdisjnt C (fmdom ?\\<Gamma>6)\nA total of 13 subgoals...", "show \"is_cupcake_all_env sem_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env sem_env", "by (fact cupcake_sem_env)"], ["proof (state)\nthis:\n  is_cupcake_all_env sem_env\n\ngoal (12 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t6) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t6 (mk_con all_consts t)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t6 (fmdom ?\\<Gamma>6)\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 9. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 10. (\\<And>v.\n         \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n          related_v v ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t6\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids ?t6) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    related_exp ?t6 (mk_con all_consts t)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed ?t6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except ?t6 (fmdom ?\\<Gamma>6)\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts ?t6 |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 9. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 10. (\\<And>v.\n         \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n          related_v v ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     \\<not> shadows_consts ?t6\nA total of 12 subgoals...", "show \"related_exp t (mk_con all_consts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_exp t (mk_con all_consts t)", "apply (rule mk_exp_correctness)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ids t |\\<subseteq>| all_consts\n 2. all_consts |\\<subseteq>| all_consts\n 3. \\<not> shadows_consts t", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  pre_strong_term_class.wellformed t\n\ngoal (3 subgoals):\n 1. ids t |\\<subseteq>| all_consts\n 2. all_consts |\\<subseteq>| all_consts\n 3. \\<not> shadows_consts t", "unfolding ids_def closed_except_def"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\n  consts t |\\<subseteq>| all_consts\n  frees t |\\<subseteq>| {||}\n  \\<not> shadows_consts t\n  pre_strong_term_class.wellformed t\n\ngoal (3 subgoals):\n 1. frees t |\\<union>| consts t |\\<subseteq>| all_consts\n 2. all_consts |\\<subseteq>| all_consts\n 3. \\<not> shadows_consts t", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  related_exp t (mk_con all_consts t)\n\ngoal (11 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom ?\\<Gamma>6)\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 9. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts t\n 10. (\\<And>v.\n         \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n          related_v v ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>6\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    pre_strong_term_class.wellformed t\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom ?\\<Gamma>6)\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 9. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<not> shadows_consts t\n 10. (\\<And>v.\n         \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n          related_v v ml_v\\<rbrakk>\n         \\<Longrightarrow> thesis) \\<Longrightarrow>\n     not_shadows_vconsts_env ?\\<Gamma>6\nA total of 11 subgoals...", "show \"wellformed t\" \"\\<not> shadows_consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t &&& \\<not> shadows_consts t", "by fact+"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed t\n  \\<not> shadows_consts t\n\ngoal (9 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom ?\\<Gamma>6)\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env ?\\<Gamma>6\n 9. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ?\\<Gamma>6 \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v ?\\<Gamma>6\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv ?\\<Gamma>6\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv ?\\<Gamma>6\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_except t (fmdom ?\\<Gamma>6)\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') ?\\<Gamma>6\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom ?\\<Gamma>6 |\\<union>| C\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom ?\\<Gamma>6)\n 8. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env ?\\<Gamma>6\n 9. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ?\\<Gamma>6 \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_except t (fmdom (fmap_of_list as_vrules))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (fmdom (fmap_of_list as_vrules))", "using \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. closed_except t (fmdom (fmap_of_list as_vrules))", "by (auto simp: closed_except_def)"], ["proof (state)\nthis:\n  closed_except t (fmdom (fmap_of_list as_vrules))\n\ngoal (8 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (fmap_of_list as_vrules)\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 8. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_venv (fmap_of_list as_vrules)\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 7. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 8. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"closed_venv (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_venv (fmap_of_list as_vrules)", "apply (rule fmpred_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vclosed v", "using srules_as_vrules.all_rules"], ["proof (prove)\nusing this:\n  list_all vrule as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vclosed v", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  closed_venv (fmap_of_list as_vrules)\n\ngoal (7 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    wellformed_venv (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 6. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 7. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"wellformed_venv (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed_venv (fmap_of_list as_vrules)", "apply (rule fmpred_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vwellformed v", "using srules_as_vrules.all_rules"], ["proof (prove)\nusing this:\n  list_all vrule as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vwellformed v", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  wellformed_venv (fmap_of_list as_vrules)\n\ngoal (6 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 6. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 6. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"fmpred (\\<lambda>_. list_all (\\<lambda>(pat, t). consts t |\\<subseteq>| C |\\<union>| fmdom global_css)) global_css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred\n     (\\<lambda>_.\n         list_all\n          (\\<lambda>(pat, t).\n              consts t |\\<subseteq>| C |\\<union>| fmdom global_css))\n     global_css", "apply (subst (2) global_css_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred\n     (\\<lambda>_.\n         list_all\n          (\\<lambda>(pat, t).\n              consts t |\\<subseteq>| C |\\<union>| fmdom global_css))\n     (fmap_of_list (map (map_prod id clauses) rs))", "apply (rule fmpred_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set (map (map_prod id clauses) rs) \\<Longrightarrow>\n       list_all\n        (\\<lambda>(pat, t).\n            consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n        v", "apply (auto simp: map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set rs \\<Longrightarrow>\n       list_all\n        (\\<lambda>(pat, t).\n            consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n        (clauses b)", "subgoal premises prems for pat t"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "from prems"], ["proof (chain)\npicking this:\n  (pat, t) \\<in> set rs", "obtain cs where \"t = Sabs cs\""], ["proof (prove)\nusing this:\n  (pat, t) \\<in> set rs\n\ngoal (1 subgoal):\n 1. (\\<And>cs. t = Sabs cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim clausesE)"], ["proof (state)\nthis:\n  t = Sabs cs\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "have \"welldefined t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "using swelldefined_rs prems"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, rhs). consts rhs |\\<subseteq>| all_consts) rs\n  (pat, t) \\<in> set rs\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "by (auto simp: list_all_iff fmdom_global_css)"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "using \\<open>welldefined t\\<close>"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses t)", "unfolding \\<open>t = _\\<close> welldefined_sabs"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, t). consts t |\\<subseteq>| all_consts) cs\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(pat, t).\n         consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n     (clauses (Sabs cs))", "by (auto simp: all_consts_def list_all_iff fmdom_global_css)"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(pat, t). consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n   (clauses t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred\n   (\\<lambda>_.\n       list_all\n        (\\<lambda>(pat, t).\n            consts t |\\<subseteq>| C |\\<union>| fmdom global_css))\n   global_css\n\ngoal (6 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 5. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 6. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)", "apply (rule fmpred_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set as_vrules \\<Longrightarrow> vwelldefined' v", "unfolding as_vrules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v)\n       \\<in> set (map (\\<lambda>(name, uu_).\n                          (name, Vrecabs global_css name fmempty))\n                   rs) \\<Longrightarrow>\n       vwelldefined' v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v)\n       \\<in> (\\<lambda>x.\n                 case x of\n                 (name, uu_) \\<Rightarrow>\n                   (name, Vrecabs global_css name fmempty)) `\n             set rs \\<Longrightarrow>\n       vwelldefined' v", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v x.\n       \\<lbrakk>(k, v) =\n                (case x of\n                 (name, uu_) \\<Rightarrow>\n                   (name, Vrecabs global_css name fmempty));\n        x \\<in> set rs\\<rbrakk>\n       \\<Longrightarrow> vwelldefined' v", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow>\n       fmpred\n        (\\<lambda>_ cs.\n            list_all\n             (\\<lambda>(pat, t).\n                 consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n             cs \\<and>\n            fdisjnt C {||})\n        global_css\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> k |\\<in>| fmdom global_css\n 3. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "apply (subst fdisjnt_alt_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow>\n       fmpred\n        (\\<lambda>_ cs.\n            list_all\n             (\\<lambda>(pat, t).\n                 consts t |\\<subseteq>| C |\\<union>| fmdom global_css)\n             cs \\<and>\n            C |\\<inter>| {||} = {||})\n        global_css\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> k |\\<in>| fmdom global_css\n 3. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow>\n       fmpred\n        (\\<lambda>_.\n            list_all\n             (\\<lambda>(pat, t).\n                 consts t |\\<subseteq>| C |\\<union>| fmdom global_css))\n        global_css\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> k |\\<in>| fmdom global_css\n 3. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "apply (rule 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> k |\\<in>| fmdom global_css\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "apply (subst global_css_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow>\n       k |\\<in>| fmdom (fmap_of_list (map (map_prod id clauses) rs))\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow>\n       k |\\<in>| fst |`| fset_of_list rs\n 2. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "subgoal for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> set rs \\<Longrightarrow>\n    x1 |\\<in>| fst |`| fset_of_list rs", "apply (rule fimage_eqI[where x = \"(x1, x2)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x1, x2) \\<in> set rs \\<Longrightarrow> x1 = fst (x1, x2)\n 2. (x1, x2) \\<in> set rs \\<Longrightarrow> (x1, x2) |\\<in>| fset_of_list rs", "by (auto simp: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k x2.\n       (k, x2) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k_, x2_) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| fset_of_list rs) C\n\ngoal (1 subgoal):\n 1. (k_, x2_) \\<in> set rs \\<Longrightarrow> fdisjnt C (fmdom global_css)", "by (auto simp: fdisjnt_alt_def fmdom_global_css)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_. vwelldefined') (fmap_of_list as_vrules)\n\ngoal (5 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 5. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 4. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    not_shadows_vconsts_env (fmap_of_list as_vrules)\n 5. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"not_shadows_vconsts_env (fmap_of_list as_vrules)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_shadows_vconsts_env (fmap_of_list as_vrules)", "apply (rule fmpred_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set as_vrules \\<Longrightarrow> not_shadows_vconsts v", "using srules_as_vrules.not_shadows"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(uu_, y). srules_as_vrules.not_shadows_vconsts y)\n   as_vrules\n\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set as_vrules \\<Longrightarrow> not_shadows_vconsts v", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, y)\\<in>set as_vrules.\n     srules_as_vrules.not_shadows_vconsts y\n\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (k, v) \\<in> set as_vrules \\<Longrightarrow> not_shadows_vconsts v", "by auto"], ["proof (state)\nthis:\n  not_shadows_vconsts_env (fmap_of_list as_vrules)\n\ngoal (4 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 4. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fdisjnt C (fmdom (fmap_of_list as_vrules))\n 4. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fdisjnt C (fmdom (fmap_of_list as_vrules))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (fmap_of_list as_vrules))", "using disjnt"], ["proof (prove)\nusing this:\n  fdisjnt (fst |`| fset_of_list rs) C\n\ngoal (1 subgoal):\n 1. fdisjnt C (fmdom (fmap_of_list as_vrules))", "by (auto simp: fdisjnt_alt_def)"], ["proof (state)\nthis:\n  fdisjnt C (fmdom (fmap_of_list as_vrules))\n\ngoal (3 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))\n 2. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 3. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules) (fmap_of_ns (sem_env.v sem_env))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))", "unfolding fmrel_on_fset_fmrel_restrict"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel related_v (fmrestrict_fset (ids t) (fmap_of_list as_vrules))\n     (fmrestrict_fset (ids t) (fmap_of_ns (sem_env.v sem_env)))", "apply (rule fmrel_restrict_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrel related_v (fmap_of_list as_vrules)\n     (fmap_of_ns (sem_env.v sem_env))", "apply (rule sem_env_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmrel_on_fset (ids t) related_v (fmap_of_list as_vrules)\n   (fmap_of_ns (sem_env.v sem_env))\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 2. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>v.\n        \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n         related_v v ml_v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n 2. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C", "apply (subst fmdom_fmap_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fset_of_list (map fst as_vrules) |\\<union>| C", "apply (subst as_vrules_fst')"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fset_of_list (map fst rs) |\\<union>| C", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fst |`| fset_of_list rs |\\<union>| C", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| fst |`| fset_of_list rs |\\<union>| C", "by (auto simp: all_consts_def)"], ["proof (state)\nthis:\n  consts t |\\<subseteq>| fmdom (fmap_of_list as_vrules) |\\<union>| C\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>fmap_of_list as_vrules \\<turnstile>\\<^sub>v\n                            t \\<down> v;\n                    related_v v ml_v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> v;\n        related_v v ml_v\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["", "end"], ["", "fun cake_to_value :: \"v \\<Rightarrow> value\" where\n\"cake_to_value (Conv (Some (name, _)) vs) = Vconstr (Name name) (map cake_to_value vs)\""], ["", "context cakeml' begin"], ["", "lemma cake_to_value_abs_free:\n  assumes \"is_cupcake_value v\" \"cake_no_abs v\"\n  shows \"vno_abs (cake_to_value v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vno_abs (cake_to_value v)", "using assms"], ["proof (prove)\nusing this:\n  is_cupcake_value v\n  cake_no_abs v\n\ngoal (1 subgoal):\n 1. vno_abs (cake_to_value v)", "by (induction v) (auto elim: is_cupcake_value.elims simp: list_all_iff)"], ["", "lemma cake_to_value_related:\n  assumes \"cake_no_abs v\" \"is_cupcake_value v\"\n  shows \"related_v (cake_to_value v) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (cake_to_value v) v", "using assms"], ["proof (prove)\nusing this:\n  cake_no_abs v\n  is_cupcake_value v\n\ngoal (1 subgoal):\n 1. related_v (cake_to_value v) v", "proof (induction v)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>cake_no_abs (Litv x); is_cupcake_value (Litv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Litv x)) (Litv x)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; cake_no_abs x2a;\n                    is_cupcake_value x2a\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv x1a x2); is_cupcake_value (Conv x1a x2)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Conv x1a x2))\n                          (Conv x1a x2)\n 3. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Closure x1a x2 x3);\n        is_cupcake_value (Closure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Closure x1a x2 x3))\n                          (Closure x1a x2 x3)\n 4. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Recclosure x1a x2 x3);\n        is_cupcake_value (Recclosure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Recclosure x1a x2 x3))\n                          (Recclosure x1a x2 x3)\n 5. \\<And>x.\n       \\<lbrakk>cake_no_abs (Loc x); is_cupcake_value (Loc x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Loc x)) (Loc x)\n 6. \\<And>x.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set x; cake_no_abs xa;\n                    is_cupcake_value xa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value xa) xa;\n        cake_no_abs (Vectorv x); is_cupcake_value (Vectorv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Vectorv x)) (Vectorv x)", "case (Conv c vs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a4 \\<in> set vs; cake_no_abs ?x2a4;\n   is_cupcake_value ?x2a4\\<rbrakk>\n  \\<Longrightarrow> related_v (cake_to_value ?x2a4) ?x2a4\n  cake_no_abs (Conv c vs)\n  is_cupcake_value (Conv c vs)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>cake_no_abs (Litv x); is_cupcake_value (Litv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Litv x)) (Litv x)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; cake_no_abs x2a;\n                    is_cupcake_value x2a\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv x1a x2); is_cupcake_value (Conv x1a x2)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Conv x1a x2))\n                          (Conv x1a x2)\n 3. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Closure x1a x2 x3);\n        is_cupcake_value (Closure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Closure x1a x2 x3))\n                          (Closure x1a x2 x3)\n 4. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Recclosure x1a x2 x3);\n        is_cupcake_value (Recclosure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Recclosure x1a x2 x3))\n                          (Recclosure x1a x2 x3)\n 5. \\<And>x.\n       \\<lbrakk>cake_no_abs (Loc x); is_cupcake_value (Loc x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Loc x)) (Loc x)\n 6. \\<And>x.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set x; cake_no_abs xa;\n                    is_cupcake_value xa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value xa) xa;\n        cake_no_abs (Vectorv x); is_cupcake_value (Vectorv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Vectorv x)) (Vectorv x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a4 \\<in> set vs; cake_no_abs ?x2a4;\n   is_cupcake_value ?x2a4\\<rbrakk>\n  \\<Longrightarrow> related_v (cake_to_value ?x2a4) ?x2a4\n  cake_no_abs (Conv c vs)\n  is_cupcake_value (Conv c vs)", "obtain name tid where \"c = Some ((as_string name), TypeId (Short tid))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a4 \\<in> set vs; cake_no_abs ?x2a4;\n   is_cupcake_value ?x2a4\\<rbrakk>\n  \\<Longrightarrow> related_v (cake_to_value ?x2a4) ?x2a4\n  cake_no_abs (Conv c vs)\n  is_cupcake_value (Conv c vs)\n\ngoal (1 subgoal):\n 1. (\\<And>name tid.\n        c = Some (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (elim is_cupcake_value.elims)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ vsa.\n       \\<lbrakk>\\<And>name tid.\n                   c =\n                   Some\n                    (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                   thesis;\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n            is_cupcake_value x2a\\<rbrakk>\n           \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv c vs);\n        Conv c vs = Conv (Some (uu_, TypeId (Short uv_))) vsa;\n        list_all is_cupcake_value vsa\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>env uw_ e.\n       \\<lbrakk>\\<And>name tid.\n                   c =\n                   Some\n                    (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                   thesis;\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n            is_cupcake_value x2a\\<rbrakk>\n           \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv c vs); Conv c vs = Closure env uw_ e;\n        is_cupcake_exp e \\<and> is_cupcake_all_env env\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>env es ux_.\n       \\<lbrakk>\\<And>name tid.\n                   c =\n                   Some\n                    (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                   thesis;\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n            is_cupcake_value x2a\\<rbrakk>\n           \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv c vs); Conv c vs = Recclosure env es ux_;\n        list_all (\\<lambda>(_, uu_, y). is_cupcake_exp y) es \\<and>\n        is_cupcake_all_env env\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name tid.\n                c =\n                Some (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                thesis;\n     \\<And>x2a.\n        \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n         is_cupcake_value x2a\\<rbrakk>\n        \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n     cake_no_abs (Conv c vs);\n     Conv c vs = Conv (Some (uu_, TypeId (Short uv_))) vsa_;\n     list_all is_cupcake_value vsa_\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis name.sel v.simps(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>env uw_ e.\n       \\<lbrakk>\\<And>name tid.\n                   c =\n                   Some\n                    (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                   thesis;\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n            is_cupcake_value x2a\\<rbrakk>\n           \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv c vs); Conv c vs = Closure env uw_ e;\n        is_cupcake_exp e \\<and> is_cupcake_all_env env\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>env es ux_.\n       \\<lbrakk>\\<And>name tid.\n                   c =\n                   Some\n                    (as_string name, TypeId (Short tid)) \\<Longrightarrow>\n                   thesis;\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set vs; cake_no_abs x2a;\n            is_cupcake_value x2a\\<rbrakk>\n           \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv c vs); Conv c vs = Recclosure env es ux_;\n        list_all (\\<lambda>(_, uu_, y). is_cupcake_exp y) es \\<and>\n        is_cupcake_all_env env\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  c = Some (as_string name, TypeId (Short tid))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>cake_no_abs (Litv x); is_cupcake_value (Litv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Litv x)) (Litv x)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; cake_no_abs x2a;\n                    is_cupcake_value x2a\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x2a) x2a;\n        cake_no_abs (Conv x1a x2); is_cupcake_value (Conv x1a x2)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Conv x1a x2))\n                          (Conv x1a x2)\n 3. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Closure x1a x2 x3);\n        is_cupcake_value (Closure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Closure x1a x2 x3))\n                          (Closure x1a x2 x3)\n 4. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Recclosure x1a x2 x3);\n        is_cupcake_value (Recclosure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Recclosure x1a x2 x3))\n                          (Recclosure x1a x2 x3)\n 5. \\<And>x.\n       \\<lbrakk>cake_no_abs (Loc x); is_cupcake_value (Loc x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Loc x)) (Loc x)\n 6. \\<And>x.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set x; cake_no_abs xa;\n                    is_cupcake_value xa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value xa) xa;\n        cake_no_abs (Vectorv x); is_cupcake_value (Vectorv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Vectorv x)) (Vectorv x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (cake_to_value (Conv c vs)) (Conv c vs)", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v\n     (cake_to_value (Conv (Some (as_string name, TypeId (Short tid))) vs))\n     (Conv (Some (as_string name, TypeId (Short tid))) vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. related_v (Vconstr name (map cake_to_value vs))\n     (Conv (Some (as_string name, TypeId (Short tid))) vs)", "apply (rule related_v.conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 related_v (map cake_to_value vs) vs", "apply (simp add: list.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x. related_v (cake_to_value x)) vs vs", "apply (rule list.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set vs \\<Longrightarrow> related_v (cake_to_value z) z", "apply (rule Conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z. z \\<in> set vs \\<Longrightarrow> z \\<in> set vs\n 2. \\<And>z. z \\<in> set vs \\<Longrightarrow> cake_no_abs z\n 3. \\<And>z. z \\<in> set vs \\<Longrightarrow> is_cupcake_value z", "using Conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a4 \\<in> set vs; cake_no_abs ?x2a4;\n   is_cupcake_value ?x2a4\\<rbrakk>\n  \\<Longrightarrow> related_v (cake_to_value ?x2a4) ?x2a4\n  cake_no_abs (Conv c vs)\n  is_cupcake_value (Conv c vs)\n\ngoal (3 subgoals):\n 1. \\<And>z. z \\<in> set vs \\<Longrightarrow> z \\<in> set vs\n 2. \\<And>z. z \\<in> set vs \\<Longrightarrow> cake_no_abs z\n 3. \\<And>z. z \\<in> set vs \\<Longrightarrow> is_cupcake_value z", "unfolding \\<open>c = _\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a4 \\<in> set vs; cake_no_abs ?x2a4;\n   is_cupcake_value ?x2a4\\<rbrakk>\n  \\<Longrightarrow> related_v (cake_to_value ?x2a4) ?x2a4\n  cake_no_abs (Conv (Some (as_string name, TypeId (Short tid))) vs)\n  is_cupcake_value (Conv (Some (as_string name, TypeId (Short tid))) vs)\n\ngoal (3 subgoals):\n 1. \\<And>z. z \\<in> set vs \\<Longrightarrow> z \\<in> set vs\n 2. \\<And>z. z \\<in> set vs \\<Longrightarrow> cake_no_abs z\n 3. \\<And>z. z \\<in> set vs \\<Longrightarrow> is_cupcake_value z", "by (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  related_v (cake_to_value (Conv c vs)) (Conv c vs)\n\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>cake_no_abs (Litv x); is_cupcake_value (Litv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Litv x)) (Litv x)\n 2. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Closure x1a x2 x3);\n        is_cupcake_value (Closure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Closure x1a x2 x3))\n                          (Closure x1a x2 x3)\n 3. \\<And>x1a x2 x3.\n       \\<lbrakk>\\<And>x1aa.\n                   \\<lbrakk>x1aa \\<in> set_sem_env x1a; cake_no_abs x1aa;\n                    is_cupcake_value x1aa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value x1aa) x1aa;\n        cake_no_abs (Recclosure x1a x2 x3);\n        is_cupcake_value (Recclosure x1a x2 x3)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Recclosure x1a x2 x3))\n                          (Recclosure x1a x2 x3)\n 4. \\<And>x.\n       \\<lbrakk>cake_no_abs (Loc x); is_cupcake_value (Loc x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Loc x)) (Loc x)\n 5. \\<And>x.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set x; cake_no_abs xa;\n                    is_cupcake_value xa\\<rbrakk>\n                   \\<Longrightarrow> related_v (cake_to_value xa) xa;\n        cake_no_abs (Vectorv x); is_cupcake_value (Vectorv x)\\<rbrakk>\n       \\<Longrightarrow> related_v (cake_to_value (Vectorv x)) (Vectorv x)", "qed auto"], ["", "lemma related_v_abs_free_uniq:\n  assumes \"related_v v\\<^sub>1 ml_v\" \"related_v v\\<^sub>2 ml_v\" \"cake_no_abs ml_v\"\n  shows \"v\\<^sub>1 = v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>1 = v\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  related_v v\\<^sub>1 ml_v\n  related_v v\\<^sub>2 ml_v\n  cake_no_abs ml_v\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 = v\\<^sub>2", "proof (induction arbitrary: v\\<^sub>2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "case (conv vs\\<^sub>1 ml_vs name)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           related_v x x2 \\<longrightarrow>\n           cake_no_abs x2 \\<longrightarrow> x1 = x))\n   vs\\<^sub>1 ml_vs\n  related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) ml_vs)\n  cake_no_abs (Conv (Some (as_string name, uu_)) ml_vs)\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           related_v x x2 \\<longrightarrow>\n           cake_no_abs x2 \\<longrightarrow> x1 = x))\n   vs\\<^sub>1 ml_vs\n  related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) ml_vs)\n  cake_no_abs (Conv (Some (as_string name, uu_)) ml_vs)", "obtain vs\\<^sub>2 where \"v\\<^sub>2 = Vconstr name vs\\<^sub>2\" \"list_all2 related_v vs\\<^sub>2 ml_vs\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           related_v x x2 \\<longrightarrow>\n           cake_no_abs x2 \\<longrightarrow> x1 = x))\n   vs\\<^sub>1 ml_vs\n  related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) ml_vs)\n  cake_no_abs (Conv (Some (as_string name, uu_)) ml_vs)\n\ngoal (1 subgoal):\n 1. (\\<And>vs\\<^sub>2.\n        \\<lbrakk>v\\<^sub>2 = Vconstr name vs\\<^sub>2;\n         list_all2 related_v vs\\<^sub>2 ml_vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: related_v.cases simp: name.expand)"], ["proof (state)\nthis:\n  v\\<^sub>2 = Vconstr name vs\\<^sub>2\n  list_all2 related_v vs\\<^sub>2 ml_vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  v\\<^sub>2 = Vconstr name vs\\<^sub>2\n  list_all2 related_v vs\\<^sub>2 ml_vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "have \"list_all cake_no_abs ml_vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all cake_no_abs ml_vs", "using conv"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           related_v x x2 \\<longrightarrow>\n           cake_no_abs x2 \\<longrightarrow> x1 = x))\n   vs\\<^sub>1 ml_vs\n  related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) ml_vs)\n  cake_no_abs (Conv (Some (as_string name, uu_)) ml_vs)\n\ngoal (1 subgoal):\n 1. list_all cake_no_abs ml_vs", "by simp"], ["proof (state)\nthis:\n  list_all cake_no_abs ml_vs\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "have \"list_all2 (=) vs\\<^sub>1 vs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (=) vs\\<^sub>1 vs\\<^sub>2", "using \\<open>list_all2 _ vs\\<^sub>1 _\\<close>  \\<open>list_all2 _ vs\\<^sub>2 _\\<close> \\<open>list_all cake_no_abs ml_vs\\<close>"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>x1 x2.\n       related_v x1 x2 \\<and>\n       (\\<forall>x.\n           related_v x x2 \\<longrightarrow>\n           cake_no_abs x2 \\<longrightarrow> x1 = x))\n   vs\\<^sub>1 ml_vs\n  list_all2 related_v vs\\<^sub>2 ml_vs\n  list_all cake_no_abs ml_vs\n\ngoal (1 subgoal):\n 1. list_all2 (=) vs\\<^sub>1 vs\\<^sub>2", "by (induction arbitrary: vs\\<^sub>2 rule: list.rel_induct) (auto simp: list_all2_Cons2)"], ["proof (state)\nthis:\n  list_all2 (=) vs\\<^sub>1 vs\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>us vs name uu_ v\\<^sub>2.\n       \\<lbrakk>list_all2\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 us vs;\n        related_v v\\<^sub>2 (Conv (Some (as_string name, uu_)) vs);\n        cake_no_abs (Conv (Some (as_string name, uu_)) vs)\\<rbrakk>\n       \\<Longrightarrow> Vconstr name us = v\\<^sub>2\n 2. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 3. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2 (=) vs\\<^sub>1 vs\\<^sub>2\n\ngoal (1 subgoal):\n 1. Vconstr name vs\\<^sub>1 = v\\<^sub>2", "unfolding \\<open>v\\<^sub>2 = _\\<close>"], ["proof (prove)\nusing this:\n  list_all2 (=) vs\\<^sub>1 vs\\<^sub>2\n\ngoal (1 subgoal):\n 1. Vconstr name vs\\<^sub>1 = Vconstr name vs\\<^sub>2", "by (simp add: list.rel_eq)"], ["proof (state)\nthis:\n  Vconstr name vs\\<^sub>1 = v\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>cs n e \\<Gamma> env v\\<^sub>2.\n       \\<lbrakk>related_fun cs n e;\n        fmrel_on_fset (ids (Sabs cs))\n         (\\<lambda>x1 x2.\n             related_v x1 x2 \\<and>\n             (\\<forall>x.\n                 related_v x x2 \\<longrightarrow>\n                 cake_no_abs x2 \\<longrightarrow> x1 = x))\n         \\<Gamma> (fmap_of_ns (sem_env.v env));\n        related_v v\\<^sub>2 (Closure env (as_string n) e);\n        cake_no_abs (Closure env (as_string n) e)\\<rbrakk>\n       \\<Longrightarrow> Vabs cs \\<Gamma> = v\\<^sub>2\n 2. \\<And>css \\<Gamma> env exps name v\\<^sub>2.\n       \\<lbrakk>fmrel_on_fset (fbind (fmran css) (ids \\<circ> Sabs))\n                 (\\<lambda>x1 x2.\n                     related_v x1 x2 \\<and>\n                     (\\<forall>x.\n                         related_v x x2 \\<longrightarrow>\n                         cake_no_abs x2 \\<longrightarrow> x1 = x))\n                 \\<Gamma> (fmap_of_ns (sem_env.v env));\n        fmrel (\\<lambda>cs (n, e). related_fun cs n e) css\n         (fmap_of_list (map (map_prod Name (map_prod Name id)) exps));\n        related_v v\\<^sub>2 (Recclosure env exps (as_string name));\n        cake_no_abs (Recclosure env exps (as_string name))\\<rbrakk>\n       \\<Longrightarrow> Vrecabs css name \\<Gamma> = v\\<^sub>2", "qed auto"], ["", "corollary related_v_abs_free_cake_to_value:\n  assumes \"related_v v ml_v\" \"cake_no_abs ml_v\" \"is_cupcake_value ml_v\"\n  shows \"v = cake_to_value ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = cake_to_value ml_v", "using assms"], ["proof (prove)\nusing this:\n  related_v v ml_v\n  cake_no_abs ml_v\n  is_cupcake_value ml_v\n\ngoal (1 subgoal):\n 1. v = cake_to_value ml_v", "by (metis cake_to_value_related related_v_abs_free_uniq)"], ["", "end"], ["", "context srules begin"], ["", "lemma cupcake_sem_env_preserve:\n  assumes \"cupcake_evaluate_single sem_env (mk_con S t) (Rval ml_v)\" \"wellformed t\"\n  shows \"is_cupcake_value ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_value ml_v", "apply (rule cupcake_single_preserve[OF assms(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_cupcake_all_env sem_env\n 2. is_cupcake_exp (mk_con S t)", "apply (rule cupcake_sem_env)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp (mk_con S t)", "apply (rule mk_exp_cupcake)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed t", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma semantic_correctness'':\n  assumes \"cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  assumes \"cake_no_abs ml_v\"\n  shows \"fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single sem_env (mk_con all_consts t) (Rval ml_v)\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  pre_strong_term_class.wellformed t\n  cake_no_abs ml_v\n\ngoal (1 subgoal):\n 1. fmap_of_list as_vrules \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v", "by (metis cupcake_sem_env_preserve semantic_correctness' related_v_abs_free_cake_to_value)"], ["", "end"], ["", "subsection \\<open>Composition\\<close>"], ["", "context rules begin"], ["", "abbreviation term_to_nterm where\n\"term_to_nterm t \\<equiv> fresh_frun (Term_to_Nterm.term_to_nterm [] t) all_consts\""], ["", "abbreviation sterm_to_cake where\n\"sterm_to_cake \\<equiv> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_con all_consts\""], ["", "abbreviation \"term_to_cake t \\<equiv> sterm_to_cake (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["", "abbreviation \"cake_to_term t \\<equiv> (convert_term (value_to_sterm (cake_to_value t)) :: term)\""], ["", "abbreviation \"cake_sem_env \\<equiv> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.sem_env\""], ["", "definition \"compiled \\<equiv> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\""], ["", "lemma fmdom_compiled: \"fmdom (fmap_of_list compiled) = heads_of rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom (fmap_of_list compiled) = heads_of rs", "unfolding compiled_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom\n     (fmap_of_list\n       rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules) =\n    heads_of rs", "by (simp add:\n        rules_as_nrules.crules_as_irules'.irules'_as_prules.compile_heads\n        Rewriting_Pterm.compile_heads transform_irule_set_iter_heads\n        Rewriting_Pterm_Elim.compile_heads\n        compile_heads consts_of_heads)"], ["", "lemma cake_semantic_correctness:\n  assumes \"cupcake_evaluate_single cake_sem_env (sterm_to_cake t) (Rval ml_v)\"\n  assumes \"welldefined t\" \"closed t\" \"\\<not> shadows_consts t\" \"wellformed t\"\n  assumes \"cake_no_abs ml_v\"\n  shows \"fmap_of_list compiled \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list compiled \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v", "unfolding compiled_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n    \\<turnstile>\\<^sub>v t \\<down> cake_to_value ml_v", "apply (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.semantic_correctness'')"], ["proof (prove)\ngoal (6 subgoals):\n 1. cupcake_evaluate_single cake_sem_env\n     (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_con\n       rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n       t)\n     (Rval ml_v)\n 2. consts t |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n 3. pre_term_class.closed t\n 4. \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n            t\n 5. pre_strong_term_class.wellformed t\n 6. cake_no_abs ml_v", "using assms"], ["proof (prove)\nusing this:\n  cupcake_evaluate_single cake_sem_env (sterm_to_cake t) (Rval ml_v)\n  consts t |\\<subseteq>| all_consts\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  pre_strong_term_class.wellformed t\n  cake_no_abs ml_v\n\ngoal (6 subgoals):\n 1. cupcake_evaluate_single cake_sem_env\n     (rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.mk_con\n       rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n       t)\n     (Rval ml_v)\n 2. consts t |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n 3. pre_term_class.closed t\n 4. \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n            t\n 5. pre_strong_term_class.wellformed t\n 6. cake_no_abs ml_v", "by (simp_all add:\n      rules_as_nrules.crules_as_irules'.irules'_as_prules.compile_heads\n      Rewriting_Pterm.compile_heads transform_irule_set_iter_heads\n      Rewriting_Pterm_Elim.compile_heads\n      compile_heads consts_of_heads all_consts_def)"], ["", "text \\<open>Lo and behold, this is the final correctness theorem!\\<close>"], ["", "theorem compiled_correct:\n  \\<comment> \\<open>If CakeML evaluation of a term succeeds ...\\<close>\n  assumes \"\\<exists>k. Evaluate_Single.evaluate cake_sem_env (s \\<lparr> clock := k \\<rparr>) (term_to_cake t) = (s', Rval ml_v)\"\n  \\<comment> \\<open>... producing a constructor term without closures ...\\<close>\n  assumes \"cake_no_abs ml_v\"\n  \\<comment> \\<open>... and some syntactic properties of the involved terms hold ...\\<close>\n  assumes \"closed t\" \"\\<not> shadows_consts t\" \"welldefined t\" \"wellformed t\"\n  \\<comment> \\<open>... then this evaluation can be reproduced in the term-rewriting semantics\\<close>\n  shows \"rs \\<turnstile> t \\<longrightarrow>* cake_to_term ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "let ?heads = \"fst |`| fset_of_list rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\""], ["proof (state)\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"?heads = heads_of rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst |`|\n    fset_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n    heads_of rs", "using fmdom_compiled"], ["proof (prove)\nusing this:\n  fmdom (fmap_of_list compiled) = heads_of rs\n\ngoal (1 subgoal):\n 1. fst |`|\n    fset_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n    heads_of rs", "unfolding compiled_def"], ["proof (prove)\nusing this:\n  fmdom\n   (fmap_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules) =\n  heads_of rs\n\ngoal (1 subgoal):\n 1. fst |`|\n    fset_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n    heads_of rs", "by simp"], ["proof (state)\nthis:\n  fst |`|\n  fset_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n  heads_of rs\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"wellformed (nterm_to_pterm (term_to_nterm t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (nterm_to_pterm (local.term_to_nterm t))", "by auto"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed (nterm_to_pterm (local.term_to_nterm t))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"wellformed (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["proof (prove)\nusing this:\n  pre_strong_term_class.wellformed (nterm_to_pterm (local.term_to_nterm t))\n\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "by (auto intro: pterm_to_sterm_wellformed)"], ["proof (state)\nthis:\n  pre_strong_term_class.wellformed\n   (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"is_cupcake_all_env cake_sem_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_all_env cake_sem_env", "by (rule rules_as_nrules.nrules_as_crules.crules_as_irules'.irules'_as_prules.prules_as_srules.cupcake_sem_env)"], ["proof (state)\nthis:\n  is_cupcake_all_env cake_sem_env\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"is_cupcake_exp (term_to_cake t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cupcake_exp (term_to_cake t)", "by (rule rules_as_nrules.nrules_as_crules.crules_as_irules'.irules'_as_prules.prules_as_srules.srules_as_cake.mk_exp_cupcake) fact"], ["proof (state)\nthis:\n  is_cupcake_exp (term_to_cake t)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "obtain k where \"Evaluate_Single.evaluate cake_sem_env (s \\<lparr> clock := k \\<rparr>) (term_to_cake t) = (s', Rval ml_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        Evaluate_Single.evaluate cake_sem_env\n         (update_clock (\\<lambda>_. k) s) (term_to_cake t) =\n        (s', Rval ml_v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        Evaluate_Single.evaluate cake_sem_env\n         (update_clock (\\<lambda>_. k) s) (term_to_cake t) =\n        (s', Rval ml_v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n   (term_to_cake t) =\n  (s', Rval ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "then"], ["proof (chain)\npicking this:\n  Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n   (term_to_cake t) =\n  (s', Rval ml_v)", "have \"Big_Step_Unclocked_Single.evaluate cake_sem_env (s \\<lparr> clock := (clock s') \\<rparr>) (term_to_cake t) (s', Rval ml_v)\""], ["proof (prove)\nusing this:\n  Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n   (term_to_cake t) =\n  (s', Rval ml_v)\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate cake_sem_env\n     (update_clock (\\<lambda>_. clock s') s) (term_to_cake t)\n     (s', Rval ml_v)", "using unclocked_single_fun_eq"], ["proof (prove)\nusing this:\n  Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n   (term_to_cake t) =\n  (s', Rval ml_v)\n  ((\\<exists>k.\n       Evaluate_Single.evaluate ?env (update_clock (\\<lambda>_. k) ?s) ?e =\n       (?s', ?r)) \\<and>\n   ?r \\<noteq> Rerr (Rabort Rtimeout_error) \\<and> clock ?s = clock ?s') =\n  Big_Step_Unclocked_Single.evaluate ?env ?s ?e (?s', ?r)\n\ngoal (1 subgoal):\n 1. Big_Step_Unclocked_Single.evaluate cake_sem_env\n     (update_clock (\\<lambda>_. clock s') s) (term_to_cake t)\n     (s', Rval ml_v)", "by fastforce"], ["proof (state)\nthis:\n  Big_Step_Unclocked_Single.evaluate cake_sem_env\n   (update_clock (\\<lambda>_. clock s') s) (term_to_cake t) (s', Rval ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"cupcake_evaluate_single cake_sem_env (sterm_to_cake (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))) (Rval ml_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cupcake_evaluate_single cake_sem_env (term_to_cake t) (Rval ml_v)", "apply (rule cupcake_single_complete)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Big_Step_Unclocked_Single.evaluate cake_sem_env ?s (term_to_cake t)\n     (?s', Rval ml_v)\n 2. is_cupcake_all_env cake_sem_env\n 3. is_cupcake_exp (term_to_cake t)", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cupcake_evaluate_single cake_sem_env (term_to_cake t) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"is_cupcake_value ml_v\""], ["proof (prove)\nusing this:\n  cupcake_evaluate_single cake_sem_env (term_to_cake t) (Rval ml_v)\n\ngoal (1 subgoal):\n 1. is_cupcake_value ml_v", "apply (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.cupcake_sem_env_preserve)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "by (auto intro: pterm_to_sterm_wellformed)"], ["proof (state)\nthis:\n  is_cupcake_value ml_v\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"vno_abs (cake_to_value ml_v)\""], ["proof (prove)\nusing this:\n  is_cupcake_value ml_v\n\ngoal (1 subgoal):\n 1. vno_abs (cake_to_value ml_v)", "using \\<open>cake_no_abs _\\<close>"], ["proof (prove)\nusing this:\n  is_cupcake_value ml_v\n  cake_no_abs ml_v\n\ngoal (1 subgoal):\n 1. vno_abs (cake_to_value ml_v)", "by (metis rules_as_nrules.nrules_as_crules.crules_as_irules'.irules'_as_prules.prules_as_srules.srules_as_cake.cake_to_value_abs_free)"], ["proof (state)\nthis:\n  vno_abs (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"no_abs (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  vno_abs (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. no_abs (value_to_sterm (cake_to_value ml_v))", "by (metis vno_abs_value_to_sterm)"], ["proof (state)\nthis:\n  no_abs (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))\""], ["proof (prove)\nusing this:\n  no_abs (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))", "by (metis sterm_to_pterm convert_term_no_abs)"], ["proof (state)\nthis:\n  no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"welldefined (term_to_nterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (local.term_to_nterm t) |\\<subseteq>| all_consts", "unfolding term_to_nterm'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (local.term_to_nterm t) |\\<subseteq>| all_consts", "apply (subst fresh_frun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts\n     (frun_fresh (Term_to_Nterm.term_to_nterm [] t)\n       all_consts) |\\<subseteq>|\n    all_consts", "apply (subst pred_stateD[OF term_to_nterm_consts])"], ["proof (prove)\ngoal (2 subgoals):\n 1. run_state (Term_to_Nterm.term_to_nterm ?\\<Gamma> ?t) ?s =\n    (frun_fresh (Term_to_Nterm.term_to_nterm [] t) all_consts, ?s')\n 2. consts ?t |\\<subseteq>| all_consts", "apply (subst surjective_pairing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (fst (run_state (Term_to_Nterm.term_to_nterm ?\\<Gamma> ?t) ?s),\n     snd (run_state (Term_to_Nterm.term_to_nterm ?\\<Gamma> ?t) ?s)) =\n    (frun_fresh (Term_to_Nterm.term_to_nterm [] t) all_consts, ?s')\n 2. consts ?t |\\<subseteq>| all_consts", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts (local.term_to_nterm t) |\\<subseteq>| all_consts\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"welldefined (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    all_consts", "apply (subst pterm_to_sterm_consts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed\n     (nterm_to_pterm (local.term_to_nterm t))\n 2. consts (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| all_consts", "apply (subst consts_nterm_to_pterm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (local.term_to_nterm t) |\\<subseteq>| all_consts", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  consts\n   (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n  all_consts\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"\\<not> shadows_consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts t", "unfolding shadows_consts_def fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> all_consts |\\<inter>| all_frees t \\<noteq> {||}\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. \\<not> all_consts |\\<inter>| all_frees t \\<noteq> {||}", "by auto"], ["proof (state)\nthis:\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"\\<not> shadows_consts (term_to_nterm t)\""], ["proof (prove)\nusing this:\n  \\<not> shadows_consts t\n\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (local.term_to_nterm t)", "unfolding shadows_consts_def shadows_consts_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> fdisjnt all_consts (all_frees t)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> fdisjnt all_consts (all_frees (local.term_to_nterm t))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees t) \\<Longrightarrow>\n    fdisjnt all_consts (all_frees (local.term_to_nterm t))", "using term_to_nterm_all_vars[folded wellformed_term_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>pre_strong_term_class.wellformed ?t;\n   fdisjnt (frees ?t) ?S\\<rbrakk>\n  \\<Longrightarrow> fdisjnt\n                     (all_frees\n                       (fresh_frun (Term_to_Nterm.term_to_nterm [] ?t)\n                         (?T |\\<union>| ?S)))\n                     ?S\n\ngoal (1 subgoal):\n 1. fdisjnt all_consts (frees t) \\<Longrightarrow>\n    fdisjnt all_consts (all_frees (local.term_to_nterm t))", "by (metis assms(6) fdisjnt_swap sup_idem)"], ["proof (state)\nthis:\n  \\<not> shadows_consts (local.term_to_nterm t)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"\\<not> shadows_consts (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts\n            (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "apply (subst pterm_to_sterm_shadows[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed\n     (nterm_to_pterm (local.term_to_nterm t))\n 2. \\<not> shadows_consts (nterm_to_pterm (local.term_to_nterm t))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (nterm_to_pterm (local.term_to_nterm t))", "apply (subst shadows_nterm_to_pterm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> shadows_consts (local.term_to_nterm t)", "unfolding shadows_consts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> fdisjnt all_consts (all_frees (local.term_to_nterm t))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt all_consts (all_frees (local.term_to_nterm t))", "apply (rule term_to_nterm_all_vars[where T = \"fempty\", simplified, THEN fdisjnt_swap])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Term.wellformed t\n 2. fdisjnt (frees t) all_consts", "apply (fold wellformed_term_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. fdisjnt (frees t) all_consts", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees t) all_consts", "using \\<open>closed t\\<close>"], ["proof (prove)\nusing this:\n  pre_term_class.closed t\n\ngoal (1 subgoal):\n 1. fdisjnt (frees t) all_consts", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| {||}\n\ngoal (1 subgoal):\n 1. fdisjnt (frees t) all_consts", "by (auto simp: fdisjnt_alt_def)"], ["proof (state)\nthis:\n  \\<not> shadows_consts\n          (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"closed (term_to_nterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_term_class.closed (local.term_to_nterm t)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. pre_term_class.closed (local.term_to_nterm t)", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  frees t |\\<subseteq>| {||}\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. frees (local.term_to_nterm t) |\\<subseteq>| {||}", "using term_to_nterm_vars"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  frees t |\\<subseteq>| {||}\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n  Term.wellformed ?t \\<Longrightarrow>\n  frees (fresh_frun (Term_to_Nterm.term_to_nterm [] ?t) ?F) |\\<subseteq>|\n  frees ?t\n\ngoal (1 subgoal):\n 1. frees (local.term_to_nterm t) |\\<subseteq>| {||}", "unfolding wellformed_term_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  frees t |\\<subseteq>| {||}\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  Term.wellformed t\n  Term.wellformed ?t \\<Longrightarrow>\n  frees (fresh_frun (Term_to_Nterm.term_to_nterm [] ?t) ?F) |\\<subseteq>|\n  frees ?t\n\ngoal (1 subgoal):\n 1. frees (local.term_to_nterm t) |\\<subseteq>| {||}", "by blast"], ["proof (state)\nthis:\n  pre_term_class.closed (local.term_to_nterm t)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"closed (nterm_to_pterm (term_to_nterm t))\""], ["proof (prove)\nusing this:\n  pre_term_class.closed (local.term_to_nterm t)\n\ngoal (1 subgoal):\n 1. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))", "using closed_nterm_to_pterm"], ["proof (prove)\nusing this:\n  pre_term_class.closed (local.term_to_nterm t)\n  closed_except (nterm_to_pterm ?t) (frees ?t)\n\ngoal (1 subgoal):\n 1. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (local.term_to_nterm t) |\\<subseteq>| {||}\n  frees (nterm_to_pterm ?t) |\\<subseteq>| frees ?t\n\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| {||}", "by auto"], ["proof (state)\nthis:\n  pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"closed (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_term_class.closed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    {||}", "apply (subst pterm_to_sterm_frees)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_strong_term_class.wellformed\n     (nterm_to_pterm (local.term_to_nterm t))\n 2. frees (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| {||}", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| {||}", "using \\<open>closed (term_to_nterm t)\\<close> closed_nterm_to_pterm"], ["proof (prove)\nusing this:\n  pre_term_class.closed (local.term_to_nterm t)\n  closed_except (nterm_to_pterm ?t) (frees ?t)\n\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| {||}", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees (local.term_to_nterm t) |\\<subseteq>| {||}\n  frees (nterm_to_pterm ?t) |\\<subseteq>| frees ?t\n\ngoal (1 subgoal):\n 1. frees (nterm_to_pterm (local.term_to_nterm t)) |\\<subseteq>| {||}", "by auto"], ["proof (state)\nthis:\n  pre_term_class.closed\n   (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"fmap_of_list compiled \\<turnstile>\\<^sub>v pterm_to_sterm (nterm_to_pterm (term_to_nterm t)) \\<down> cake_to_value ml_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap_of_list compiled \\<turnstile>\\<^sub>v\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    cake_to_value ml_v", "by (rule cake_semantic_correctness) fact+"], ["proof (state)\nthis:\n  fmap_of_list compiled \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"fmap_of_list rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules \\<turnstile>\\<^sub>v pterm_to_sterm (nterm_to_pterm (term_to_nterm t)) \\<down> cake_to_value ml_v\""], ["proof (prove)\nusing this:\n  fmap_of_list compiled \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. fmap_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n    \\<turnstile>\\<^sub>v\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    cake_to_value ml_v", "using assms"], ["proof (prove)\nusing this:\n  fmap_of_list compiled \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. fmap_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n    \\<turnstile>\\<^sub>v\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    cake_to_value ml_v", "unfolding compiled_def"], ["proof (prove)\nusing this:\n  fmap_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n  \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (1 subgoal):\n 1. fmap_of_list\n     rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n    \\<turnstile>\\<^sub>v\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    cake_to_value ml_v", "by simp"], ["proof (state)\nthis:\n  fmap_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n  \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules, fmempty \\<turnstile>\\<^sub>v pterm_to_sterm (nterm_to_pterm (term_to_nterm t)) \\<down> cake_to_value ml_v\""], ["proof (prove)\nusing this:\n  fmap_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules\n  \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules, fmempty\n    \\<turnstile>\\<^sub>v\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    cake_to_value ml_v", "proof (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.veval'_correct'')"], ["proof (state)\ngoal (5 subgoals):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 2. \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n            (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 3. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n 4. pre_term_class.closed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 5. vno_abs (cake_to_value ml_v)", "show \"\\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts (pterm_to_sterm (nterm_to_pterm (term_to_nterm t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n            (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "using \\<open>\\<not> shadows_consts (_::sterm)\\<close> \\<open>?heads = heads_of rs\\<close>"], ["proof (prove)\nusing this:\n  \\<not> shadows_consts\n          (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n  fst |`|\n  fset_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n  heads_of rs\n\ngoal (1 subgoal):\n 1. \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n            (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))", "by auto"], ["proof (state)\nthis:\n  \\<not> rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.shadows_consts\n          (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 2. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n 3. pre_term_class.closed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 4. vno_abs (cake_to_value ml_v)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 2. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n 3. pre_term_class.closed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 4. vno_abs (cake_to_value ml_v)", "show \"consts (pterm_to_sterm (nterm_to_pterm (term_to_nterm t))) |\\<subseteq>| rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts", "using \\<open>welldefined (pterm_to_sterm _)\\<close> \\<open>?heads = _\\<close>"], ["proof (prove)\nusing this:\n  consts\n   (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n  all_consts\n  fst |`|\n  fset_of_list\n   rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules =\n  heads_of rs\n\ngoal (1 subgoal):\n 1. consts\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n    rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts", "by auto"], ["proof (state)\nthis:\n  consts\n   (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t))) |\\<subseteq>|\n  rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.all_consts\n\ngoal (3 subgoals):\n 1. pre_strong_term_class.wellformed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 2. pre_term_class.closed\n     (pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)))\n 3. vno_abs (cake_to_value ml_v)", "qed fact+"], ["proof (state)\nthis:\n  rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules, fmempty\n  \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"Rewriting_Sterm.compile (Rewriting_Pterm.compile (transform_irule_set_iter (Rewriting_Pterm_Elim.compile (consts_of compile)))), fmempty \\<turnstile>\\<^sub>s pterm_to_sterm (nterm_to_pterm (term_to_nterm t)) \\<down> value_to_sterm (cake_to_value ml_v)\""], ["proof (prove)\nusing this:\n  rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.as_vrules, fmempty\n  \\<turnstile>\\<^sub>v\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  cake_to_value ml_v\n\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile\n     (Rewriting_Pterm.compile\n       (transform_irule_set_iter\n         (Rewriting_Pterm_Elim.compile (consts_of local.compile)))), fmempty\n    \\<turnstile>\\<^sub>s\n    pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n    value_to_sterm (cake_to_value ml_v)", "by (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.veval_correct) fact+"], ["proof (state)\nthis:\n  Rewriting_Sterm.compile\n   (Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile)))), fmempty\n  \\<turnstile>\\<^sub>s\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  value_to_sterm (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"Rewriting_Sterm.compile (Rewriting_Pterm.compile (transform_irule_set_iter (Rewriting_Pterm_Elim.compile (consts_of compile)))) \\<turnstile>\\<^sub>s pterm_to_sterm (nterm_to_pterm (term_to_nterm t)) \\<longrightarrow>* value_to_sterm (cake_to_value ml_v)\""], ["proof (prove)\nusing this:\n  Rewriting_Sterm.compile\n   (Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile)))), fmempty\n  \\<turnstile>\\<^sub>s\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<down>\n  value_to_sterm (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. Rewriting_Sterm.compile\n     (Rewriting_Pterm.compile\n       (transform_irule_set_iter\n         (Rewriting_Pterm_Elim.compile (consts_of local.compile))))\n    \\<turnstile>\\<^sub>s\n    pterm_to_sterm\n     (nterm_to_pterm (local.term_to_nterm t)) \\<longrightarrow>*\n    value_to_sterm (cake_to_value ml_v)", "by (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.prules_as_srules.seval_correct) fact"], ["proof (state)\nthis:\n  Rewriting_Sterm.compile\n   (Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile))))\n  \\<turnstile>\\<^sub>s\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<longrightarrow>*\n  value_to_sterm (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"Rewriting_Pterm.compile (transform_irule_set_iter (Rewriting_Pterm_Elim.compile (consts_of compile))) \\<turnstile>\\<^sub>p sterm_to_pterm (pterm_to_sterm (nterm_to_pterm (term_to_nterm t))) \\<longrightarrow>* sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  Rewriting_Sterm.compile\n   (Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile))))\n  \\<turnstile>\\<^sub>s\n  pterm_to_sterm (nterm_to_pterm (local.term_to_nterm t)) \\<longrightarrow>*\n  value_to_sterm (cake_to_value ml_v)\n\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n    \\<turnstile>\\<^sub>p\n    sterm_to_pterm\n     (pterm_to_sterm\n       (nterm_to_pterm (local.term_to_nterm t))) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))", "by (rule rules_as_nrules.crules_as_irules'.irules'_as_prules.compile_correct_rt)"], ["proof (state)\nthis:\n  Rewriting_Pterm.compile\n   (transform_irule_set_iter\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n  \\<turnstile>\\<^sub>p\n  sterm_to_pterm\n   (pterm_to_sterm\n     (nterm_to_pterm (local.term_to_nterm t))) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"Rewriting_Pterm.compile (transform_irule_set_iter (Rewriting_Pterm_Elim.compile (consts_of compile))) \\<turnstile>\\<^sub>p nterm_to_pterm (term_to_nterm t) \\<longrightarrow>* sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile\n   (transform_irule_set_iter\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n  \\<turnstile>\\<^sub>p\n  sterm_to_pterm\n   (pterm_to_sterm\n     (nterm_to_pterm (local.term_to_nterm t))) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. Rewriting_Pterm.compile\n     (transform_irule_set_iter\n       (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n    \\<turnstile>\\<^sub>p\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))", "by (subst (asm) pterm_to_sterm_sterm_to_pterm) fact"], ["proof (state)\nthis:\n  Rewriting_Pterm.compile\n   (transform_irule_set_iter\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n  \\<turnstile>\\<^sub>p\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"transform_irule_set_iter (Rewriting_Pterm_Elim.compile (consts_of compile)) \\<turnstile>\\<^sub>i nterm_to_pterm (term_to_nterm t) \\<longrightarrow>* sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  Rewriting_Pterm.compile\n   (transform_irule_set_iter\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n  \\<turnstile>\\<^sub>p\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. transform_irule_set_iter\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n    \\<turnstile>\\<^sub>i\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))", "by (rule rules_as_nrules.crules_as_irules'.irules'_as_irules.compile_correct_rt)\n       (rule rules_as_nrules.crules_as_irules.transform_finished)"], ["proof (state)\nthis:\n  transform_irule_set_iter\n   (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"Rewriting_Pterm_Elim.compile (consts_of compile) \\<turnstile>\\<^sub>i nterm_to_pterm (term_to_nterm t) \\<longrightarrow>* sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rewriting_Pterm_Elim.compile (consts_of local.compile)\n    \\<turnstile>\\<^sub>i\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))", "apply (rule rules_as_nrules.crules_as_irules.transform_correct_rt_n_no_abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (transform_irule_set ^^ ?n)\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n    \\<turnstile>\\<^sub>i\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n 2. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))\n 3. no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))", "using \\<open>transform_irule_set_iter _ \\<turnstile>\\<^sub>i _ \\<longrightarrow>* _\\<close>"], ["proof (prove)\nusing this:\n  transform_irule_set_iter\n   (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (3 subgoals):\n 1. (transform_irule_set ^^ ?n)\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n    \\<turnstile>\\<^sub>i\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n 2. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))\n 3. no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))", "unfolding transform_irule_set_iter_def"], ["proof (prove)\nusing this:\n  (transform_irule_set ^^\n   max_arity (Rewriting_Pterm_Elim.compile (consts_of local.compile)))\n   (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (3 subgoals):\n 1. (transform_irule_set ^^ ?n)\n     (Rewriting_Pterm_Elim.compile (consts_of local.compile))\n    \\<turnstile>\\<^sub>i\n    nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n 2. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))\n 3. no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. pre_term_class.closed (nterm_to_pterm (local.term_to_nterm t))\n 2. no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Rewriting_Pterm_Elim.compile (consts_of local.compile)\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "then"], ["proof (chain)\npicking this:\n  Rewriting_Pterm_Elim.compile (consts_of local.compile)\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))", "obtain t' where \"compile \\<turnstile>\\<^sub>n term_to_nterm t \\<longrightarrow>* t'\" \"t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  Rewriting_Pterm_Elim.compile (consts_of local.compile)\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>local.compile \\<turnstile>\\<^sub>n\n                 local.term_to_nterm t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i sterm_to_pterm\n                               (value_to_sterm\n                                 (cake_to_value ml_v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>closed (term_to_nterm t)\\<close>"], ["proof (prove)\nusing this:\n  Rewriting_Pterm_Elim.compile (consts_of local.compile)\n  \\<turnstile>\\<^sub>i\n  nterm_to_pterm (local.term_to_nterm t) \\<longrightarrow>*\n  sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n  pre_term_class.closed (local.term_to_nterm t)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>local.compile \\<turnstile>\\<^sub>n\n                 local.term_to_nterm t \\<longrightarrow>* t';\n         t' \\<approx>\\<^sub>i sterm_to_pterm\n                               (value_to_sterm\n                                 (cake_to_value ml_v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis rules_as_nrules.compile_correct_rt)"], ["proof (state)\nthis:\n  local.compile \\<turnstile>\\<^sub>n\n  local.term_to_nterm t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"no_abs t'\""], ["proof (prove)\nusing this:\n  local.compile \\<turnstile>\\<^sub>n\n  local.term_to_nterm t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. no_abs t'", "using \\<open>no_abs (sterm_to_pterm _)\\<close>"], ["proof (prove)\nusing this:\n  local.compile \\<turnstile>\\<^sub>n\n  local.term_to_nterm t \\<longrightarrow>* t'\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n  no_abs (sterm_to_pterm (value_to_sterm (cake_to_value ml_v)))\n\ngoal (1 subgoal):\n 1. no_abs t'", "by (metis irelated_no_abs)"], ["proof (state)\nthis:\n  no_abs t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"rs \\<turnstile> nterm_to_term' (term_to_nterm t) \\<longrightarrow>* nterm_to_term' t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    nterm_to_term' (local.term_to_nterm t) \\<longrightarrow>*\n    nterm_to_term' t'", "by (rule compile_correct_rt) fact+"], ["proof (state)\nthis:\n  rs \\<turnstile> nterm_to_term' (local.term_to_nterm t) \\<longrightarrow>*\n  nterm_to_term' t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'\""], ["proof (prove)\nusing this:\n  rs \\<turnstile> nterm_to_term' (local.term_to_nterm t) \\<longrightarrow>*\n  nterm_to_term' t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "apply (subst (asm) fresh_frun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<turnstile>\n    nterm_to_term'\n     (frun_fresh (Term_to_Nterm.term_to_nterm [] t)\n       all_consts) \\<longrightarrow>*\n    nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "apply (subst (asm) term_to_nterm_nterm_to_term[where S = \"fempty\" and t = t, simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. Term.wellformed t\n 2. frees t = {||}\n 3. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "apply (fold wellformed_term_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pre_strong_term_class.wellformed t\n 2. frees t = {||}\n 3. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees t = {||}\n 2. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  pre_term_class.closed t\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (2 subgoals):\n 1. frees t = {||}\n 2. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     Evaluate_Single.evaluate cake_sem_env (update_clock (\\<lambda>_. k) s)\n      (term_to_cake t) =\n     (s', Rval ml_v)\n  cake_no_abs ml_v\n  frees t |\\<subseteq>| {||}\n  \\<not> shadows_consts t\n  consts t |\\<subseteq>| all_consts\n  pre_strong_term_class.wellformed t\n\ngoal (2 subgoals):\n 1. frees t = {||}\n 2. rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t' \\<Longrightarrow>\n    rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'", "by auto"], ["proof (state)\nthis:\n  rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "have \"nterm_to_pterm t' = sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>i sterm_to_pterm\n                          (value_to_sterm (cake_to_value ml_v))", "using \\<open>t' \\<approx>\\<^sub>i _\\<close>"], ["proof (prove)\nusing this:\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. t' \\<approx>\\<^sub>i sterm_to_pterm\n                          (value_to_sterm (cake_to_value ml_v))", "by auto"], ["proof (state)\nthis:\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"(convert_term t' :: pterm) = convert_term (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  t' \\<approx>\\<^sub>i sterm_to_pterm (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (subst (asm) nterm_to_pterm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_abs t'\n 2. convert_term t' =\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    sterm_to_pterm (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (subst (asm) sterm_to_pterm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_abs (value_to_sterm (cake_to_value ml_v))\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "hence \"nterm_to_term' t' = convert_term (value_to_sterm (cake_to_value ml_v))\""], ["proof (prove)\nusing this:\n  convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. nterm_to_term' t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (subst nterm_to_term')"], ["proof (prove)\ngoal (2 subgoals):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs t'\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (rule \\<open>no_abs t'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (rule convert_term_inj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs (convert_term t')\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs (convert_term (value_to_sterm (cake_to_value ml_v)))\n 3. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term (convert_term t') =\n    convert_term (convert_term (value_to_sterm (cake_to_value ml_v)))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs (convert_term t')", "apply (rule convert_term_no_abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs t'", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs (convert_term (value_to_sterm (cake_to_value ml_v)))\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term (convert_term t') =\n    convert_term (convert_term (value_to_sterm (cake_to_value ml_v)))", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs (convert_term (value_to_sterm (cake_to_value ml_v)))", "apply (rule convert_term_no_abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs (value_to_sterm (cake_to_value ml_v))", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term (convert_term t') =\n    convert_term (convert_term (value_to_sterm (cake_to_value ml_v)))", "apply (subst convert_term_idem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs t'\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' =\n    convert_term (convert_term (value_to_sterm (cake_to_value ml_v)))", "apply (rule \\<open>no_abs t'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' =\n    convert_term (convert_term (value_to_sterm (cake_to_value ml_v)))", "apply (subst convert_term_idem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    no_abs (value_to_sterm (cake_to_value ml_v))\n 2. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply (rule \\<open>no_abs (value_to_sterm (cake_to_value ml_v))\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t' =\n    convert_term (value_to_sterm (cake_to_value ml_v)) \\<Longrightarrow>\n    convert_term t' = convert_term (value_to_sterm (cake_to_value ml_v))", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nterm_to_term' t' = convert_term (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  nterm_to_term' t' = convert_term (value_to_sterm (cake_to_value ml_v))\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "using \\<open>rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'\\<close>"], ["proof (prove)\nusing this:\n  nterm_to_term' t' = convert_term (value_to_sterm (cake_to_value ml_v))\n  rs \\<turnstile> t \\<longrightarrow>* nterm_to_term' t'\n\ngoal (1 subgoal):\n 1. rs \\<turnstile> t \\<longrightarrow>*\n    convert_term (value_to_sterm (cake_to_value ml_v))", "by simp"], ["proof (state)\nthis:\n  rs \\<turnstile> t \\<longrightarrow>*\n  convert_term (value_to_sterm (cake_to_value ml_v))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}